{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/hcysun/source/css/mark.less","path":"css/mark.less","modified":0,"renderable":1},{"_id":"themes/hcysun/source/css/mixin.less","path":"css/mixin.less","modified":0,"renderable":1},{"_id":"themes/hcysun/source/css/reset.less","path":"css/reset.less","modified":0,"renderable":1},{"_id":"themes/hcysun/source/css/sidebar.less","path":"css/sidebar.less","modified":0,"renderable":1},{"_id":"themes/hcysun/source/css/style.less","path":"css/style.less","modified":0,"renderable":1},{"_id":"themes/hcysun/source/css/var.less","path":"css/var.less","modified":0,"renderable":1},{"_id":"themes/hcysun/source/img/search.png","path":"img/search.png","modified":0,"renderable":1},{"_id":"themes/hcysun/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/hcysun/source/img/hcysun.png","path":"img/hcysun.png","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"ba9cda575a0bba1218ccf2b18e741e9f26bb960e","modified":1502364547000},{"_id":"themes/hcysun/.DS_Store","hash":"9457f542cf2c3f2a50b9ecd64858fc6f50b0d0c4","modified":1502094513000},{"_id":"themes/hcysun/_config.yml","hash":"4c7644244c2529bfedca7db965372da336b17cc9","modified":1502356052000},{"_id":"source/_posts/.DS_Store","hash":"fde9b9d0f22569acfd2cf94ea6fa0099ca2a1661","modified":1502364547000},{"_id":"source/_posts/Vue源码学习.md","hash":"82c09f7d96b69e3eded3f9800162e4c272d9442c","modified":1502260393000},{"_id":"source/_posts/hello-world.md","hash":"433f481c4332b05fc88c8871cfdaddc16308e60f","modified":1442807106000},{"_id":"source/_posts/hello-world的副本 10.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1502075799000},{"_id":"source/_posts/hello-world的副本 11.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1502075799000},{"_id":"source/_posts/hello-world的副本 13.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1502075799000},{"_id":"source/_posts/hello-world的副本 12.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1502075799000},{"_id":"source/_posts/hello-world的副本 14.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1502075799000},{"_id":"source/_posts/hello-world的副本 15.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1502075799000},{"_id":"source/_posts/hello-world的副本 16.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1502075799000},{"_id":"source/_posts/hello-world的副本 17.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1502075799000},{"_id":"source/_posts/hello-world的副本 18.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1502075799000},{"_id":"source/_posts/hello-world的副本 19.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1502075799000},{"_id":"source/_posts/hello-world的副本 2.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1502075799000},{"_id":"source/_posts/hello-world的副本 20.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1502075799000},{"_id":"source/_posts/hello-world的副本 21.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1502075799000},{"_id":"source/_posts/hello-world的副本 22.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1502075799000},{"_id":"source/_posts/hello-world的副本 23.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1502075799000},{"_id":"source/_posts/hello-world的副本 24.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1502075799000},{"_id":"source/_posts/hello-world的副本 25.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1502075799000},{"_id":"source/_posts/hello-world的副本 3.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1502075799000},{"_id":"source/_posts/hello-world的副本 4.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1502075799000},{"_id":"source/_posts/hello-world的副本 5.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1502075799000},{"_id":"source/_posts/hello-world的副本 6.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1502075799000},{"_id":"source/_posts/hello-world的副本 7.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1502075799000},{"_id":"source/_posts/hello-world的副本 8.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1502075799000},{"_id":"source/_posts/hello-world的副本 9.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1502075799000},{"_id":"source/_posts/hello-world的副本.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1502075799000},{"_id":"source/about/index.md","hash":"d702da410592c4eef89f689d1a22fd32b28c7664","modified":1502357860000},{"_id":"source/donate/index.md","hash":"3d5609ae1399c1bfe78d3643cc25dc84e375052d","modified":1502356107000},{"_id":"themes/hcysun/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1502077464000},{"_id":"themes/hcysun/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1502077464000},{"_id":"themes/hcysun/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1502077464000},{"_id":"themes/hcysun/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1502077464000},{"_id":"themes/hcysun/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1502077464000},{"_id":"themes/hcysun/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1502077464000},{"_id":"themes/hcysun/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1502077464000},{"_id":"themes/hcysun/layout/about.ejs","hash":"82667b4079914d4aabed9c216620da5dedab630a","modified":1502354495000},{"_id":"themes/hcysun/layout/index.ejs","hash":"8447929fc4ba5d3de292d165cb3791f044430383","modified":1502337702000},{"_id":"themes/hcysun/layout/layout.ejs","hash":"ada1491984dc383bebd61378108da4fd5922c467","modified":1502337863000},{"_id":"themes/hcysun/layout/post.ejs","hash":"d54c67de94e425cd8c0969b0d9edb101cb0e5ea5","modified":1502357525000},{"_id":"themes/hcysun/source/.DS_Store","hash":"8983992a301632f377142eb0de9b7125c7a7c97a","modified":1502110439000},{"_id":"themes/hcysun/layout/_partial/after-footer.ejs","hash":"9f658fbcdd281811b07d7884fd5e07c49f80a252","modified":1502197946000},{"_id":"themes/hcysun/layout/_partial/footer.ejs","hash":"381a8615dffb521771214314a77bc8e9ad067d9e","modified":1502280266000},{"_id":"themes/hcysun/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1502090373000},{"_id":"themes/hcysun/layout/_partial/head.ejs","hash":"6e8d08b5bc5ce054f4bce41856ac320dd7ec749f","modified":1502338623000},{"_id":"themes/hcysun/layout/_partial/header.ejs","hash":"3f87f727b252e6207f8c43b4355975a59b216dea","modified":1502107015000},{"_id":"themes/hcysun/layout/_partial/marks.ejs","hash":"579d7a2265c232b9c059d2330693867c875b5b6f","modified":1502109459000},{"_id":"themes/hcysun/layout/_partial/sidebar.ejs","hash":"fe8b52688381cca5221ea8018dace054b1ccbd8a","modified":1502355383000},{"_id":"themes/hcysun/source/css/mark.less","hash":"302fd059b5f3a573355252b5abd54fb3bd339ac8","modified":1502183291000},{"_id":"themes/hcysun/source/css/mixin.less","hash":"9c7af9ae0389764034edafbf38a5ba842f67a2ab","modified":1502249377000},{"_id":"themes/hcysun/source/css/reset.less","hash":"7200dd4eff15c7d38d1303fb00f83514932d7105","modified":1502249330000},{"_id":"themes/hcysun/source/css/sidebar.less","hash":"a8b74795553d4a60a16096b7b7fb68c742877141","modified":1502361157000},{"_id":"themes/hcysun/source/css/style.less","hash":"b42765222a7a2ecf953680dc1746fb16c84a4c16","modified":1502361096000},{"_id":"themes/hcysun/source/css/var.less","hash":"9f2f08c13335ad652d30bfa8ddb25c1c860f99e6","modified":1502337585000},{"_id":"themes/hcysun/source/img/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1502347028000},{"_id":"themes/hcysun/source/img/search.png","hash":"390c074d6f875e9529e1ba0197a30148114c4946","modified":1502104719000},{"_id":"themes/hcysun/source/js/script.js","hash":"de05c83aeda0b6177062e11b875d4a36a1159a2e","modified":1502266028000},{"_id":"themes/hcysun/source/img/hcysun.png","hash":"34fbd037894e5d5e513195e9ebc48bfbe2ac5848","modified":1460816479000},{"_id":"public/about/index.html","hash":"708a912343cb0c4104d60747db77b833a7754db6","modified":1502357867792},{"_id":"public/2017/08/07/hello-world的副本-20/index.html","hash":"9dbc89553babd74b3444fad6909d3401e5904df0","modified":1502357545744},{"_id":"public/2017/08/07/hello-world的副本/index.html","hash":"6276eb8b6fc8197a49611979623749be57477678","modified":1502357545744},{"_id":"public/2017/08/07/hello-world的副本-10/index.html","hash":"15f34ed63ec27ba61c7febc2348568ce6ed8bc07","modified":1502357545744},{"_id":"public/2017/08/07/hello-world的副本-11/index.html","hash":"c6ed3800e1c8655364e2164b62bc12d059a6e245","modified":1502357545745},{"_id":"public/2017/08/07/hello-world的副本-13/index.html","hash":"46f61130d41c0da23e27833d2d282d93a6a6c13f","modified":1502357545745},{"_id":"public/2017/08/07/hello-world的副本-12/index.html","hash":"979aad69cb0bd47977b94d79c4eb663fb1a7770a","modified":1502357545745},{"_id":"public/2017/08/07/hello-world的副本-14/index.html","hash":"3b227539b139fd1f09a0a13e293e9c73716302b2","modified":1502357545745},{"_id":"public/2017/08/07/hello-world的副本-15/index.html","hash":"e29aa9fa212f349162226bfbbb2c8e0a7e03bc16","modified":1502357545745},{"_id":"public/2017/08/07/hello-world的副本-17/index.html","hash":"dc1bb72e3beeb34d50178ee0abd6cae6bc468cf9","modified":1502357545745},{"_id":"public/2017/08/07/hello-world的副本-16/index.html","hash":"4ee12acb27ac30dadd9bec684ce33a7b51cf7747","modified":1502357545745},{"_id":"public/2017/08/07/hello-world的副本-18/index.html","hash":"28e07b3b639c6a87aec57a216d990c2b7eec04e6","modified":1502357545745},{"_id":"public/2017/08/07/hello-world的副本-2/index.html","hash":"b66e10ceda7234fca3981cc9f4a6906b2b9395d8","modified":1502357545745},{"_id":"public/2017/08/07/hello-world的副本-19/index.html","hash":"a191d42a7588cff508d90336800db4be3c49f61d","modified":1502357545745},{"_id":"public/2017/08/07/hello-world/index.html","hash":"255a8258c0c3a9cba877de84117160e655996607","modified":1502357545745},{"_id":"public/2017/08/07/hello-world的副本-21/index.html","hash":"2b16987743fe8226c86d4cb9ccd676b4244d7978","modified":1502357545746},{"_id":"public/2017/08/07/hello-world的副本-22/index.html","hash":"60e5d63a7e0fe7f442ab8130d243a87a73460a06","modified":1502357545746},{"_id":"public/2017/08/07/hello-world的副本-23/index.html","hash":"152c6fc80f02b0e0202e602a438844a07082b7cd","modified":1502357545746},{"_id":"public/2017/08/07/hello-world的副本-24/index.html","hash":"ca5cc52232b8dd6a9db3448d058e96f9e8e5d3e3","modified":1502357545746},{"_id":"public/2017/08/07/hello-world的副本-25/index.html","hash":"97db14c52ce936935c8ac0804d0152e05cd74601","modified":1502357545746},{"_id":"public/2017/08/07/hello-world的副本-3/index.html","hash":"3a7c2f2169627799f03637c72d5ea8b8370b5a61","modified":1502357545746},{"_id":"public/2017/08/07/hello-world的副本-4/index.html","hash":"3dcb7f4c9fc4dceccc6b9b34de48d592de0fd682","modified":1502357545746},{"_id":"public/2017/08/07/hello-world的副本-5/index.html","hash":"ec9c823831ed8a96b3ff9defc7e178805d45d742","modified":1502357545746},{"_id":"public/2017/08/07/hello-world的副本-6/index.html","hash":"79cbc7ff8f4ea1dfb1a9f2cc3a9d326743b08921","modified":1502357545746},{"_id":"public/2017/08/07/hello-world的副本-7/index.html","hash":"9ea364b6a727f5b869cc58ef836628207ff9ad09","modified":1502357545746},{"_id":"public/2017/08/07/hello-world的副本-8/index.html","hash":"2d052a49228e794675fafbb84f0a4ee9d5963a15","modified":1502357545746},{"_id":"public/2017/08/07/hello-world的副本-9/index.html","hash":"28e351264d94a694577faca27aa3fdabb750edf0","modified":1502357545746},{"_id":"public/archives/index.html","hash":"1046d1f19c4e786aafd064268cf0d010589e0367","modified":1502356114958},{"_id":"public/archives/page/2/index.html","hash":"39ab5db89b73b12714a601337609addc98ad627f","modified":1502356114958},{"_id":"public/archives/2017/index.html","hash":"595d3011bec1392a3db223aab1209857febf1ace","modified":1502356114958},{"_id":"public/archives/2017/page/2/index.html","hash":"92241c9cd70de2689ab544d119323dc0f73166d6","modified":1502356114959},{"_id":"public/archives/2017/03/index.html","hash":"082ea673e30b45d97f1200e0cb5c239f8becad1f","modified":1502356114959},{"_id":"public/archives/2017/08/index.html","hash":"b9901b06e51a61f927fc1753d19fd623d0040599","modified":1502356114959},{"_id":"public/archives/2017/08/page/2/index.html","hash":"1c9ee1cae25be328b6a2d84241d0963605a2165b","modified":1502356114959},{"_id":"public/categories/WebFrontEnd/index.html","hash":"76445cb7cdd47aabe24af3f9b94923d719351315","modified":1502356114959},{"_id":"public/index.html","hash":"81a57fdf56a83e9aa3e8efb5008e61ea0985a24c","modified":1502356114959},{"_id":"public/page/2/index.html","hash":"025ed409169723b728b7b472b4671097dfec31fd","modified":1502356114959},{"_id":"public/tags/源码/index.html","hash":"ebb34b0d415f9c0ab4a2ce0616c42db1ae0536a6","modified":1502356114959},{"_id":"public/tags/Vue/index.html","hash":"7600928f5cf4954803df30e1aa1d8630ac685315","modified":1502356114959},{"_id":"public/2017/03/03/Vue源码学习/index.html","hash":"5f40061020a976339563b6bbac3582d4b9b62c0a","modified":1502357545747},{"_id":"public/donate/index.html","hash":"a05a973c07a66700a2c892c1a44c65f7b1a85aa1","modified":1502357545743},{"_id":"public/css/style.css","hash":"56dd2856bc9fbd93c8056d2d83294cdf33c2ae50","modified":1502357545837},{"_id":"source/_posts/2016/.DS_Store","hash":"ff5ae779b0146f813bb4392ddee86f3ac7fa6246","modified":1502364721000},{"_id":"source/_posts/2017/.DS_Store","hash":"77ebbbe49f38e89135f7990aca35ac2dd9cf9369","modified":1502364726000},{"_id":"source/_posts/2015/11/.DS_Store","hash":"93619ace422ed7b3f84eb173a92ac1305be3f981","modified":1502364649000},{"_id":"source/_posts/2017/03/.DS_Store","hash":"93cc2553054da69c150781ce604ac0ff19ac3576","modified":1502251547000},{"_id":"source/_posts/2015/09/17/hexo搭建博客并关联到github-page.md","hash":"f5a9df1deee8d180f7d0e04464216fb160a2333b","modified":1444702830000},{"_id":"source/_posts/2015/09/23/不用Express脚手架-自己搭建程序骨架.md","hash":"e40874a1c3050c12f01edea62cc149a5933a2899","modified":1448707524000},{"_id":"source/_posts/2015/09/25/移动端页面开发资源总结.md","hash":"46e3f87ef3a9ea20bcb9b40747a90fc34bd72628","modified":1488961481000},{"_id":"source/_posts/2015/10/10/javascript基础总结.md","hash":"a39ba8fb80200f7976bb8be7be658a0be187c8a7","modified":1444468874000},{"_id":"source/_posts/2015/10/16/一篇真正教会你开发移动端页面的文章(一).md","hash":"caac1c17c5fcb523fe83f06d4a2cbd351b6dcaa2","modified":1500296303000},{"_id":"source/_posts/2015/10/19/一篇真正教会你开发移动端页面的文章-二.md","hash":"5319a2682ad27c1f268424b489f216e029b04386","modified":1445313172000},{"_id":"source/_posts/2015/11/12/基于gulp-requirejs-rjs的前端自动化构建.md","hash":"7adb121a3c157c3d0740df16380145b999aa242b","modified":1447327239000},{"_id":"source/_posts/2015/11/14/基于gulp-requirejs-rjs的前端自动化构建系列文章-二.md","hash":"8c8753fe70f8750410d15b2001a11a7974463902","modified":1447745531000},{"_id":"source/_posts/2015/11/21/Mac下使用brew安装mongodb.md","hash":"d6a327a9aacedea385ca6f323e00d850f5b5a0b8","modified":1449137534000},{"_id":"source/_posts/2015/11/24/H5-admin-readme.md","hash":"7af5301baa96a752c77986d3203919e6772f3061","modified":1449056661000},{"_id":"source/_posts/2015/11/26/a标签的href属性与click事件的烦恼.md","hash":"b469a0e2fd4009a776e44149a28c060f6c5e016c","modified":1448593772000},{"_id":"source/_posts/2015/12/02/nodejs使用mongodb做数据持久化.md","hash":"af6b80ac0272d8d81707ec6d5c13601fdc793ce0","modified":1449046796000},{"_id":"source/_posts/2015/12/26/项目迁移问题总结.md","hash":"cbb9738f33019afd9024f309fda641ea5fd71b8e","modified":1451382155000},{"_id":"source/_posts/2016/01/14/Ubuntu连接的网络需要登陆认证后才能使用的解决办法.md","hash":"8666584effebcd2a8ccef1b6ad53537cf7ed660e","modified":1452769096000},{"_id":"source/_posts/2016/01/06/使用gulp实现项目模板化.md","hash":"1a6c2fe5c88cbfc3ef903cece627d1a0de3b7df4","modified":1452079481000},{"_id":"source/_posts/2016/01/30/使用npm和node开发命令行工具并使用npm管理你的包.md","hash":"da94914f17c33a11d6eeacdfee3dcd2d7af80f23","modified":1454139847000},{"_id":"source/_posts/2016/02/21/策略模式在表单验证中的应用.md","hash":"8af7cc933d2c471ca20b192c9949d40f64689e26","modified":1456107746000},{"_id":"source/_posts/2016/03/25/基于webpack和vue.js搭建的H5端框架(其实主要用于Hybrid开发H5端框架，但是依然能够作为纯web端使用).md","hash":"d9e175960767e3bf57fb18aed7142d0c7371e5b2","modified":1465184336000},{"_id":"source/_posts/2016/04/28/JavaScript实现MVVM之我就是想监测一个普通对象的变化.md","hash":"2f24f7c33451aa7b672f3389e6b15fcdee1c730e","modified":1463398279000},{"_id":"source/_posts/2016/07/11/js-Worker-API-在倒计时中的使用.md","hash":"bfb74c6782abc54d3bcb49c94d51b9097e4d793d","modified":1468235065000},{"_id":"source/_posts/2016/08/13/使用weinre调试移动端页面.md","hash":"cf9d00f6117e057c1f43b60ebcabaa25ee3d676f","modified":1471059708000},{"_id":"source/_posts/2017/03/03/Vue源码学习.md","hash":"9a904d6949b09e305cc78846a9925a05f0151e79","modified":1494327275000},{"_id":"source/_posts/2017/05/13/从矩阵与空间操作的关系理解CSS3的transform.md","hash":"87c52eee01c1250091ef8a29fefccd42dee5dc21","modified":1494647954000},{"_id":"source/_posts/2015/.DS_Store","hash":"8681c528dd65915fec982e3c40885f8de22be8c2","modified":1502364596000},{"_id":"source/_posts/2015/09/.DS_Store","hash":"768571e7d5b60d589152dd3b81cb1811526f8d2c","modified":1502364566000},{"_id":"source/_posts/2015/10/.DS_Store","hash":"5aa8590982d234c30c0b6cea3c9bf0ebef0f39f2","modified":1502364576000},{"_id":"source/_posts/2015/12/.DS_Store","hash":"b27bc7aac388b7e374ec2054b179d2ee049fe183","modified":1502364664000},{"_id":"source/_posts/2016/01/.DS_Store","hash":"346f093582c5c0a9c61f2e8ab465670a3b8bcdfe","modified":1502364704000},{"_id":"source/_posts/2016/02/.DS_Store","hash":"e7f7dd736c6f94c7a9126a6df7baaeee3943368d","modified":1502364704000},{"_id":"source/_posts/2016/03/.DS_Store","hash":"e1a1ab993e134df7117ab55414a89ce6d5156973","modified":1502364715000},{"_id":"source/_posts/2016/04/.DS_Store","hash":"fc0173738a776634b6a12c3b2c6ed3457693c14c","modified":1502364715000},{"_id":"source/_posts/2016/07/.DS_Store","hash":"0801397ebc2b1dd13075e6349ffdb624c0408bee","modified":1502364721000},{"_id":"source/_posts/2016/08/.DS_Store","hash":"8d2722cfde2913f9a0ed807a5ac96e3f4e5da5d7","modified":1502364726000},{"_id":"source/_posts/2017/05/.DS_Store","hash":"8d2722cfde2913f9a0ed807a5ac96e3f4e5da5d7","modified":1502364732000}],"Category":[{"name":"WebFrontEnd","_id":"cj6680ssh0004uffcc1tnqx0v"}],"Data":[],"Page":[{"title":"about","date":"2017-08-10T08:47:32.000Z","_content":"\nAbout\n\n<div id=\"disqus_thread\" style=\"margin-left: 0; margin-top: 50px;\"></div>\n<script>\n\n/**\n*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.\n*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/\n/*\nvar disqus_config = function () {\nthis.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable\nthis.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable\n};\n*/\n(function() { // DON'T EDIT BELOW THIS LINE\nvar d = document, s = d.createElement('script');\ns.src = 'https://hcysunyang.disqus.com/embed.js';\ns.setAttribute('data-timestamp', +new Date());\n(d.head || d.body).appendChild(s);\n})();\n</script>","source":"about/index.md","raw":"---\ntitle: about\ndate: 2017-08-10 16:47:32\n---\n\nAbout\n\n<div id=\"disqus_thread\" style=\"margin-left: 0; margin-top: 50px;\"></div>\n<script>\n\n/**\n*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.\n*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/\n/*\nvar disqus_config = function () {\nthis.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable\nthis.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable\n};\n*/\n(function() { // DON'T EDIT BELOW THIS LINE\nvar d = document, s = d.createElement('script');\ns.src = 'https://hcysunyang.disqus.com/embed.js';\ns.setAttribute('data-timestamp', +new Date());\n(d.head || d.body).appendChild(s);\n})();\n</script>","updated":"2017-08-10T09:37:40.000Z","path":"about/index.html","_id":"cj6680ss90001uffcntrduh12","comments":1,"layout":"page","content":"<p>About</p>\n<p><div id=\"disqus_thread\" style=\"margin-left: 0; margin-top: 50px;\"></div></p>\n<script>\n\n/**\n*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.\n*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/\n/*\nvar disqus_config = function () {\nthis.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable\nthis.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable\n};\n*/\n(function() { // DON'T EDIT BELOW THIS LINE\nvar d = document, s = d.createElement('script');\ns.src = 'https://hcysunyang.disqus.com/embed.js';\ns.setAttribute('data-timestamp', +new Date());\n(d.head || d.body).appendChild(s);\n})();\n</script>","site":{"data":{}},"excerpt":"","more":"<p>About</p>\n<p><div id=\"disqus_thread\" style=\"margin-left: 0; margin-top: 50px;\"></div></p>\n<script>\n\n/**\n*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.\n*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/\n/*\nvar disqus_config = function () {\nthis.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable\nthis.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable\n};\n*/\n(function() { // DON'T EDIT BELOW THIS LINE\nvar d = document, s = d.createElement('script');\ns.src = 'https://hcysunyang.disqus.com/embed.js';\ns.setAttribute('data-timestamp', +new Date());\n(d.head || d.body).appendChild(s);\n})();\n</script>"},{"title":"donate","date":"2017-08-10T09:06:55.000Z","_content":"\nDonate","source":"donate/index.md","raw":"---\ntitle: donate\ndate: 2017-08-10 17:06:55\n---\n\nDonate","updated":"2017-08-10T09:08:27.000Z","path":"donate/index.html","_id":"cj6680ssg0003uffcryiqsg2a","comments":1,"layout":"page","content":"<p>Donate</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Donate</p>\n"}],"Post":[{"title":"不用Express脚手架-自己搭建程序骨架","date":"2015-09-23T03:14:46.000Z","_content":"\n# 初识Express #\n\n[Express](http://expressjs.com/)的官网上是这样介绍的：“精简的、灵活的Node.js Web程序框架”。\nexpress的哲学是“少即是多”，express是可扩展的，他只充当你和服务器之间薄薄的一层，这并不是说它不健壮，而是尽量少干预你，让你能够充分表达自己的思想。\n\n<!-- more -->\n\n在开始之前，首先要确认你对node有一定的了解，以及你的电脑上已经安装了node，接下来我们就开始吧。\n既然是使用express从零搭建项目，那么第一步我们应该创建自己的项目文件夹也叫根目录或者项目目录（一下统称为项目目录）：\n\n```\nmkdir learnexpress\ncd learnexpress\n```\n\nnpm(包管理工具)是基于package.json文件管理项目的依赖以及项目的元数据的，所以我们要创建package.json这个文件，最简单的办法就是先项目目录中执行\n\n```\nnpm init\n```\n\n执行上面的命令后，终端会提出一些列问题，来帮助你完成这个文件：\n\n![npm init](http://7xlolm.com1.z0.glb.clouddn.com/20150923a.png) \n\n不过我们可以一路回车，不需要填写任何信息，这样就会生成一个包含默认信息的package.json文件，打开该文件，内容如下：\n\n```\n{\n  \"name\": \"learnexp\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"author\": \"\",\n  \"license\": \"ISC\"\n}\n```\n\npackage.json文件创建好了，我们就可以开始安装express了，执行：\n\n```\nnpm install --save express\n```\n\n运行npm install会把指定名称的包安装到node_modules目录下，如果你使用了 --save 选项，他还会更新package.json文件，将包的依赖写入package.json，打开项目目录，你会发现多了一个node_modules目录，此时再次打开package.json文件，会发现文件被更新了：\n\n```\n{\n  \"name\": \"learnexp\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"dependencies\": {\n    \"express\": \"^4.13.3\"\n  }\n}\n```\n\nexpress也安装好了，接下来，我们就可以开始写项目了，那么我们第一步需要做的事情是什么呢？不管任何一个项目都需要一个入口文件，所以我们接下来要做的就是写入口文件，在我们的项目目录下面创建一个js文件，文件名称自定义，但是最好以你的项目名称去命名，这里我们就叫app.js作为我们的项目入口文件，并写入以下代码\n\n```\n// 引入express模块\nvar express = require('express');\n\n// 调用express()方法创建一个对象\nvar app = express();\n\n// 设置端口\napp.set('port', process.env.PORT || 3000);\n\n// 中间件 定制404页面\napp.use(function(req, res){\n\tres.type('text/plain');\n\tres.status(404);\n\tres.send('404 - Not Found');\n});\n\n// 中间件 定制500页面\napp.use(function(req, res){\n\tres.type('text/plain');\n\tres.status(500);\n\tres.send('500 - Server Error');\n});\n\napp.listen(app.get('port'), function(){\n\tconsole.log('express启动并监听' + app.get('port') + '端口，按 Ctrl + C 终止');\n});\n```\n\n入口文件写好后，我们保存文件，在项目目录下执行：\n\n```\nnode app.js\n```\n\n这样，我们的程序就跑起来了，打开你的浏览器，输入 * localhost:3000 *，会看到如下界面：\n\n![404](http://7xlolm.com1.z0.glb.clouddn.com/20150923b.png)\n\n为什么是404界面呢？很简单我们并没有设置任何路由，我们的入口文件（app.js）中只设置了404、500的处理。\n在我们给应用程序加上路由之前我们来说一些问题，首先通过执行 * npm init * 创建的package.json中main属性的默认值是index.js，而我们的项目入口文件是app.js，所以我们要手动修改package.json文件的main属性为app.js：\n\n```\n{\n  \"name\": \"learnexp\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"app.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"dependencies\": {\n    \"express\": \"^4.13.3\"\n  }\n}\n```\n\n接下来，我们给首页和关于页面加上路由，注意：路由应该放在404和500处理器前面：\n\n```\n// 首页路由\napp.get('/' ,function(req, res){\n\tres.type('text/plain');\n\tres.send('home');\n})\n\n// 关于页面路由\napp.get('/about' ,function(req, res){\n\tres.type('text/plain');\n\tres.send('about');\n})\n\n// 中间件 定制404页面\napp.use(function(req, res){\n\tres.type('text/plain');\n\tres.status(404);\n\tres.send('404 - Not Found');\n});\n\n........\n\n```\n\napp.get 是我们添加的路由方法(常见的还有 app.post )，这个方法有两个参数：第一个参数是路径，第二个参数是一个回调函数\n重启我们的node服务\n\n```\nnode app.js\n```\n\n打开浏览器分别输入 * localhost:3000 * 和 * localhost:3000/about * 怎么样，是否如下图所示：\n\n![首页](http://7xlolm.com1.z0.glb.clouddn.com/20150923c.png) ![关于页面](http://7xlolm.com1.z0.glb.clouddn.com/20150923d.png)\n\n\n\n# 莫板引擎 #\n\n那么问题来了，我们的界面不可能总是一堆文字吧，是不是应该有漂亮的样式，开发过程中是不是应该有模板引擎，我相信很多同学对莫板引擎是不陌生的。express支持很多种莫板引擎，例如Jade，ejs等，而我们今天要介绍的是 Handlebars，为了支持handlebars，我们首先要安装 express3-handlebars 包：\n\n```\nnpm install --save express3-handlebars\n```\n\n然后在我们的项目入口文件中* 创建app的代码 *之后加入以下代码：\n\n```\nvar app = express();\n\n// 设置handlebars莫板引擎\nvar handlebars = require('express3-handlebars').create({defaultLayout : 'main'});\napp.engine('handlebars', handlebars.engine);\napp.set('view engine', 'handlebars');\n```\n\n以上代码中，我们执行了 * {defaultLayout : 'main'} * ，这就意味着除非我们特别声明，否则所有视图都将使用main.handlebars作为默认布局，布局文件默认在 * views/layouts/ * 目录下，接下来我们想项目目录下创建views目录，并在views目录中创建layouts目录，在layouts目录中创建main.handlebars文件：\n\n```\n<!dpcument html>\n<html>\n<head>\n\t<title>默认布局</title>\n</head>\n<body>\n\t<h1>默认布局哦哦哦哦</h1>\n\t{{{body}}}\n</body>\n</html>\n```\n\n编写好默认布局好，我们来分别创建首页页面，views/home.handlebars\n\n```\n<h1>这是首页</h1>\n```\n\n关于我们页面，views/about.handlebars\n\n```\n<h1>这是关于我们页面</h1>\n```\n\n404页面，views/404.handlebars\n\n```\n<h1>这是404页面</h1>\n```\n\n500页面，500.handlebars\n\n```\n<h1>这是500页面</h1>\n```\n\n现在视图也编写好了，接下来我们修改项目入口文件中的路由已经404和500处理器：\n\n```\n// 首页路由\napp.get('/' ,function(req, res){\n\tres.render('home');\n})\n\n// 关于页面路由\napp.get('/about' ,function(req, res){\n\tres.render('about');\n})\n\n// 中间件 定制404页面\napp.use(function(req, res){\n\tres.status(404);\n\tres.render('404');\n});\n\n// 中间件 定制500页面\napp.use(function(req, res){\n\tres.status(500);\n\tres.render('500');\n});\n```\n\n注意我们已经不用res.type指定内容类型了，视图引擎默认会返回 text/html 内容类型，也不用 res.status 指定状态码了，视图引擎会默认返回200状态码(对于404和500页面必须指定状态码)\n下面，我们再次重启服务器\n\n```\nnode app.js\n```\n\n怎么样，是不是如下图：\n\n![使用莫板引擎的首页](http://7xlolm.com1.z0.glb.clouddn.com/20150923e.png) ![使用莫板引擎的关于页面](http://7xlolm.com1.z0.glb.clouddn.com/20150923f.png)\n\n# 视图和静态资源 #\n\n我们在做视图的时候，总是会使用带静态资源，比如图片、css、javascript文件等，express是靠static中间件管理静态资源的，它可以把一个或多个目录指派成包含静态资源的目录，其中的资源不经过任何处理直接发给客户端。\n\n在项目目录下创建 * public * 目录，接下来，在所有路由以及中间件之前加入static中间件：\n\n```\napp.use(express.static(__dirname + '/public'));\n```\n\n接下来，在public目录下面创建一个img子目录，并照一张图片放入该目录下（如：logo.png），之后修改main.handlebars布局文件\n\n```\n<!DOCTYPE html>\n<html>\n<head>\n\t<title>默认布局</title>\n</head>\n<body>\n\t<img src=\"/img/logo.png\" alt=\"LOGO\" />\n\t<h1>默认布局哦哦哦哦</h1>\n\t{{{body}}}\n</body>\n</html>\n```\n\n重启node服务\n\n```\nnode app.js\n```\n\n访问主页面，是不是看到了静态资源图片：\n\n![静态资源图片](http://7xlolm.com1.z0.glb.clouddn.com/20150923g.png)\n\n好啦，这就是express搭建项目的基本使用，你还可以在public目录下面创建类似于css，js这样的子目录，存放对应的静态资源文件，更多有关于express的内容，可以继续关注我的博客，或者[express](http://expressjs.com/)官网","source":"_posts/2015/09/23/不用Express脚手架-自己搭建程序骨架.md","raw":"title: 不用Express脚手架-自己搭建程序骨架\ndate: 2015-09-23 11:14:46\ncategories:\n- WebFrontEnd\ntags:\n- express\n- nodejs\n---\n\n# 初识Express #\n\n[Express](http://expressjs.com/)的官网上是这样介绍的：“精简的、灵活的Node.js Web程序框架”。\nexpress的哲学是“少即是多”，express是可扩展的，他只充当你和服务器之间薄薄的一层，这并不是说它不健壮，而是尽量少干预你，让你能够充分表达自己的思想。\n\n<!-- more -->\n\n在开始之前，首先要确认你对node有一定的了解，以及你的电脑上已经安装了node，接下来我们就开始吧。\n既然是使用express从零搭建项目，那么第一步我们应该创建自己的项目文件夹也叫根目录或者项目目录（一下统称为项目目录）：\n\n```\nmkdir learnexpress\ncd learnexpress\n```\n\nnpm(包管理工具)是基于package.json文件管理项目的依赖以及项目的元数据的，所以我们要创建package.json这个文件，最简单的办法就是先项目目录中执行\n\n```\nnpm init\n```\n\n执行上面的命令后，终端会提出一些列问题，来帮助你完成这个文件：\n\n![npm init](http://7xlolm.com1.z0.glb.clouddn.com/20150923a.png) \n\n不过我们可以一路回车，不需要填写任何信息，这样就会生成一个包含默认信息的package.json文件，打开该文件，内容如下：\n\n```\n{\n  \"name\": \"learnexp\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"author\": \"\",\n  \"license\": \"ISC\"\n}\n```\n\npackage.json文件创建好了，我们就可以开始安装express了，执行：\n\n```\nnpm install --save express\n```\n\n运行npm install会把指定名称的包安装到node_modules目录下，如果你使用了 --save 选项，他还会更新package.json文件，将包的依赖写入package.json，打开项目目录，你会发现多了一个node_modules目录，此时再次打开package.json文件，会发现文件被更新了：\n\n```\n{\n  \"name\": \"learnexp\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"dependencies\": {\n    \"express\": \"^4.13.3\"\n  }\n}\n```\n\nexpress也安装好了，接下来，我们就可以开始写项目了，那么我们第一步需要做的事情是什么呢？不管任何一个项目都需要一个入口文件，所以我们接下来要做的就是写入口文件，在我们的项目目录下面创建一个js文件，文件名称自定义，但是最好以你的项目名称去命名，这里我们就叫app.js作为我们的项目入口文件，并写入以下代码\n\n```\n// 引入express模块\nvar express = require('express');\n\n// 调用express()方法创建一个对象\nvar app = express();\n\n// 设置端口\napp.set('port', process.env.PORT || 3000);\n\n// 中间件 定制404页面\napp.use(function(req, res){\n\tres.type('text/plain');\n\tres.status(404);\n\tres.send('404 - Not Found');\n});\n\n// 中间件 定制500页面\napp.use(function(req, res){\n\tres.type('text/plain');\n\tres.status(500);\n\tres.send('500 - Server Error');\n});\n\napp.listen(app.get('port'), function(){\n\tconsole.log('express启动并监听' + app.get('port') + '端口，按 Ctrl + C 终止');\n});\n```\n\n入口文件写好后，我们保存文件，在项目目录下执行：\n\n```\nnode app.js\n```\n\n这样，我们的程序就跑起来了，打开你的浏览器，输入 * localhost:3000 *，会看到如下界面：\n\n![404](http://7xlolm.com1.z0.glb.clouddn.com/20150923b.png)\n\n为什么是404界面呢？很简单我们并没有设置任何路由，我们的入口文件（app.js）中只设置了404、500的处理。\n在我们给应用程序加上路由之前我们来说一些问题，首先通过执行 * npm init * 创建的package.json中main属性的默认值是index.js，而我们的项目入口文件是app.js，所以我们要手动修改package.json文件的main属性为app.js：\n\n```\n{\n  \"name\": \"learnexp\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"app.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"dependencies\": {\n    \"express\": \"^4.13.3\"\n  }\n}\n```\n\n接下来，我们给首页和关于页面加上路由，注意：路由应该放在404和500处理器前面：\n\n```\n// 首页路由\napp.get('/' ,function(req, res){\n\tres.type('text/plain');\n\tres.send('home');\n})\n\n// 关于页面路由\napp.get('/about' ,function(req, res){\n\tres.type('text/plain');\n\tres.send('about');\n})\n\n// 中间件 定制404页面\napp.use(function(req, res){\n\tres.type('text/plain');\n\tres.status(404);\n\tres.send('404 - Not Found');\n});\n\n........\n\n```\n\napp.get 是我们添加的路由方法(常见的还有 app.post )，这个方法有两个参数：第一个参数是路径，第二个参数是一个回调函数\n重启我们的node服务\n\n```\nnode app.js\n```\n\n打开浏览器分别输入 * localhost:3000 * 和 * localhost:3000/about * 怎么样，是否如下图所示：\n\n![首页](http://7xlolm.com1.z0.glb.clouddn.com/20150923c.png) ![关于页面](http://7xlolm.com1.z0.glb.clouddn.com/20150923d.png)\n\n\n\n# 莫板引擎 #\n\n那么问题来了，我们的界面不可能总是一堆文字吧，是不是应该有漂亮的样式，开发过程中是不是应该有模板引擎，我相信很多同学对莫板引擎是不陌生的。express支持很多种莫板引擎，例如Jade，ejs等，而我们今天要介绍的是 Handlebars，为了支持handlebars，我们首先要安装 express3-handlebars 包：\n\n```\nnpm install --save express3-handlebars\n```\n\n然后在我们的项目入口文件中* 创建app的代码 *之后加入以下代码：\n\n```\nvar app = express();\n\n// 设置handlebars莫板引擎\nvar handlebars = require('express3-handlebars').create({defaultLayout : 'main'});\napp.engine('handlebars', handlebars.engine);\napp.set('view engine', 'handlebars');\n```\n\n以上代码中，我们执行了 * {defaultLayout : 'main'} * ，这就意味着除非我们特别声明，否则所有视图都将使用main.handlebars作为默认布局，布局文件默认在 * views/layouts/ * 目录下，接下来我们想项目目录下创建views目录，并在views目录中创建layouts目录，在layouts目录中创建main.handlebars文件：\n\n```\n<!dpcument html>\n<html>\n<head>\n\t<title>默认布局</title>\n</head>\n<body>\n\t<h1>默认布局哦哦哦哦</h1>\n\t{{{body}}}\n</body>\n</html>\n```\n\n编写好默认布局好，我们来分别创建首页页面，views/home.handlebars\n\n```\n<h1>这是首页</h1>\n```\n\n关于我们页面，views/about.handlebars\n\n```\n<h1>这是关于我们页面</h1>\n```\n\n404页面，views/404.handlebars\n\n```\n<h1>这是404页面</h1>\n```\n\n500页面，500.handlebars\n\n```\n<h1>这是500页面</h1>\n```\n\n现在视图也编写好了，接下来我们修改项目入口文件中的路由已经404和500处理器：\n\n```\n// 首页路由\napp.get('/' ,function(req, res){\n\tres.render('home');\n})\n\n// 关于页面路由\napp.get('/about' ,function(req, res){\n\tres.render('about');\n})\n\n// 中间件 定制404页面\napp.use(function(req, res){\n\tres.status(404);\n\tres.render('404');\n});\n\n// 中间件 定制500页面\napp.use(function(req, res){\n\tres.status(500);\n\tres.render('500');\n});\n```\n\n注意我们已经不用res.type指定内容类型了，视图引擎默认会返回 text/html 内容类型，也不用 res.status 指定状态码了，视图引擎会默认返回200状态码(对于404和500页面必须指定状态码)\n下面，我们再次重启服务器\n\n```\nnode app.js\n```\n\n怎么样，是不是如下图：\n\n![使用莫板引擎的首页](http://7xlolm.com1.z0.glb.clouddn.com/20150923e.png) ![使用莫板引擎的关于页面](http://7xlolm.com1.z0.glb.clouddn.com/20150923f.png)\n\n# 视图和静态资源 #\n\n我们在做视图的时候，总是会使用带静态资源，比如图片、css、javascript文件等，express是靠static中间件管理静态资源的，它可以把一个或多个目录指派成包含静态资源的目录，其中的资源不经过任何处理直接发给客户端。\n\n在项目目录下创建 * public * 目录，接下来，在所有路由以及中间件之前加入static中间件：\n\n```\napp.use(express.static(__dirname + '/public'));\n```\n\n接下来，在public目录下面创建一个img子目录，并照一张图片放入该目录下（如：logo.png），之后修改main.handlebars布局文件\n\n```\n<!DOCTYPE html>\n<html>\n<head>\n\t<title>默认布局</title>\n</head>\n<body>\n\t<img src=\"/img/logo.png\" alt=\"LOGO\" />\n\t<h1>默认布局哦哦哦哦</h1>\n\t{{{body}}}\n</body>\n</html>\n```\n\n重启node服务\n\n```\nnode app.js\n```\n\n访问主页面，是不是看到了静态资源图片：\n\n![静态资源图片](http://7xlolm.com1.z0.glb.clouddn.com/20150923g.png)\n\n好啦，这就是express搭建项目的基本使用，你还可以在public目录下面创建类似于css，js这样的子目录，存放对应的静态资源文件，更多有关于express的内容，可以继续关注我的博客，或者[express](http://expressjs.com/)官网","slug":"不用Express脚手架-自己搭建程序骨架","published":1,"updated":"2015-11-28T10:45:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj669fsjb000aewfcuahcvsdx","content":"<h1 id=\"初识Express\"><a href=\"#初识Express\" class=\"headerlink\" title=\"初识Express\"></a>初识Express</h1><p><a href=\"http://expressjs.com/\" target=\"_blank\" rel=\"external\">Express</a>的官网上是这样介绍的：“精简的、灵活的Node.js Web程序框架”。<br>express的哲学是“少即是多”，express是可扩展的，他只充当你和服务器之间薄薄的一层，这并不是说它不健壮，而是尽量少干预你，让你能够充分表达自己的思想。</p>\n<a id=\"more\"></a>\n<p>在开始之前，首先要确认你对node有一定的了解，以及你的电脑上已经安装了node，接下来我们就开始吧。<br>既然是使用express从零搭建项目，那么第一步我们应该创建自己的项目文件夹也叫根目录或者项目目录（一下统称为项目目录）：</p>\n<pre><code>mkdir learnexpress\ncd learnexpress\n</code></pre><p>npm(包管理工具)是基于package.json文件管理项目的依赖以及项目的元数据的，所以我们要创建package.json这个文件，最简单的办法就是先项目目录中执行</p>\n<pre><code>npm init\n</code></pre><p>执行上面的命令后，终端会提出一些列问题，来帮助你完成这个文件：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20150923a.png\" alt=\"npm init\"> </p>\n<p>不过我们可以一路回车，不需要填写任何信息，这样就会生成一个包含默认信息的package.json文件，打开该文件，内容如下：</p>\n<pre><code>{\n  &quot;name&quot;: &quot;learnexp&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;description&quot;: &quot;&quot;,\n  &quot;main&quot;: &quot;index.js&quot;,\n  &quot;scripts&quot;: {\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;\n  },\n  &quot;author&quot;: &quot;&quot;,\n  &quot;license&quot;: &quot;ISC&quot;\n}\n</code></pre><p>package.json文件创建好了，我们就可以开始安装express了，执行：</p>\n<pre><code>npm install --save express\n</code></pre><p>运行npm install会把指定名称的包安装到node_modules目录下，如果你使用了 –save 选项，他还会更新package.json文件，将包的依赖写入package.json，打开项目目录，你会发现多了一个node_modules目录，此时再次打开package.json文件，会发现文件被更新了：</p>\n<pre><code>{\n  &quot;name&quot;: &quot;learnexp&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;description&quot;: &quot;&quot;,\n  &quot;main&quot;: &quot;index.js&quot;,\n  &quot;scripts&quot;: {\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;\n  },\n  &quot;author&quot;: &quot;&quot;,\n  &quot;license&quot;: &quot;ISC&quot;,\n  &quot;dependencies&quot;: {\n    &quot;express&quot;: &quot;^4.13.3&quot;\n  }\n}\n</code></pre><p>express也安装好了，接下来，我们就可以开始写项目了，那么我们第一步需要做的事情是什么呢？不管任何一个项目都需要一个入口文件，所以我们接下来要做的就是写入口文件，在我们的项目目录下面创建一个js文件，文件名称自定义，但是最好以你的项目名称去命名，这里我们就叫app.js作为我们的项目入口文件，并写入以下代码</p>\n<pre><code>// 引入express模块\nvar express = require(&#39;express&#39;);\n\n// 调用express()方法创建一个对象\nvar app = express();\n\n// 设置端口\napp.set(&#39;port&#39;, process.env.PORT || 3000);\n\n// 中间件 定制404页面\napp.use(function(req, res){\n    res.type(&#39;text/plain&#39;);\n    res.status(404);\n    res.send(&#39;404 - Not Found&#39;);\n});\n\n// 中间件 定制500页面\napp.use(function(req, res){\n    res.type(&#39;text/plain&#39;);\n    res.status(500);\n    res.send(&#39;500 - Server Error&#39;);\n});\n\napp.listen(app.get(&#39;port&#39;), function(){\n    console.log(&#39;express启动并监听&#39; + app.get(&#39;port&#39;) + &#39;端口，按 Ctrl + C 终止&#39;);\n});\n</code></pre><p>入口文件写好后，我们保存文件，在项目目录下执行：</p>\n<pre><code>node app.js\n</code></pre><p>这样，我们的程序就跑起来了，打开你的浏览器，输入 <em> localhost:3000 </em>，会看到如下界面：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20150923b.png\" alt=\"404\"></p>\n<p>为什么是404界面呢？很简单我们并没有设置任何路由，我们的入口文件（app.js）中只设置了404、500的处理。<br>在我们给应用程序加上路由之前我们来说一些问题，首先通过执行 <em> npm init </em> 创建的package.json中main属性的默认值是index.js，而我们的项目入口文件是app.js，所以我们要手动修改package.json文件的main属性为app.js：</p>\n<pre><code>{\n  &quot;name&quot;: &quot;learnexp&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;description&quot;: &quot;&quot;,\n  &quot;main&quot;: &quot;app.js&quot;,\n  &quot;scripts&quot;: {\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;\n  },\n  &quot;author&quot;: &quot;&quot;,\n  &quot;license&quot;: &quot;ISC&quot;,\n  &quot;dependencies&quot;: {\n    &quot;express&quot;: &quot;^4.13.3&quot;\n  }\n}\n</code></pre><p>接下来，我们给首页和关于页面加上路由，注意：路由应该放在404和500处理器前面：</p>\n<pre><code>// 首页路由\napp.get(&#39;/&#39; ,function(req, res){\n    res.type(&#39;text/plain&#39;);\n    res.send(&#39;home&#39;);\n})\n\n// 关于页面路由\napp.get(&#39;/about&#39; ,function(req, res){\n    res.type(&#39;text/plain&#39;);\n    res.send(&#39;about&#39;);\n})\n\n// 中间件 定制404页面\napp.use(function(req, res){\n    res.type(&#39;text/plain&#39;);\n    res.status(404);\n    res.send(&#39;404 - Not Found&#39;);\n});\n\n........\n</code></pre><p>app.get 是我们添加的路由方法(常见的还有 app.post )，这个方法有两个参数：第一个参数是路径，第二个参数是一个回调函数<br>重启我们的node服务</p>\n<pre><code>node app.js\n</code></pre><p>打开浏览器分别输入 <em> localhost:3000 </em> 和 <em> localhost:3000/about </em> 怎么样，是否如下图所示：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20150923c.png\" alt=\"首页\"> <img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20150923d.png\" alt=\"关于页面\"></p>\n<h1 id=\"莫板引擎\"><a href=\"#莫板引擎\" class=\"headerlink\" title=\"莫板引擎\"></a>莫板引擎</h1><p>那么问题来了，我们的界面不可能总是一堆文字吧，是不是应该有漂亮的样式，开发过程中是不是应该有模板引擎，我相信很多同学对莫板引擎是不陌生的。express支持很多种莫板引擎，例如Jade，ejs等，而我们今天要介绍的是 Handlebars，为了支持handlebars，我们首先要安装 express3-handlebars 包：</p>\n<pre><code>npm install --save express3-handlebars\n</code></pre><p>然后在我们的项目入口文件中<em> 创建app的代码 </em>之后加入以下代码：</p>\n<pre><code>var app = express();\n\n// 设置handlebars莫板引擎\nvar handlebars = require(&#39;express3-handlebars&#39;).create({defaultLayout : &#39;main&#39;});\napp.engine(&#39;handlebars&#39;, handlebars.engine);\napp.set(&#39;view engine&#39;, &#39;handlebars&#39;);\n</code></pre><p>以上代码中，我们执行了 <em> {defaultLayout : ‘main’} </em> ，这就意味着除非我们特别声明，否则所有视图都将使用main.handlebars作为默认布局，布局文件默认在 <em> views/layouts/ </em> 目录下，接下来我们想项目目录下创建views目录，并在views目录中创建layouts目录，在layouts目录中创建main.handlebars文件：</p>\n<pre><code>&lt;!dpcument html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;默认布局&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;默认布局哦哦哦哦&lt;/h1&gt;\n    {{{body}}}\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>编写好默认布局好，我们来分别创建首页页面，views/home.handlebars</p>\n<pre><code>&lt;h1&gt;这是首页&lt;/h1&gt;\n</code></pre><p>关于我们页面，views/about.handlebars</p>\n<pre><code>&lt;h1&gt;这是关于我们页面&lt;/h1&gt;\n</code></pre><p>404页面，views/404.handlebars</p>\n<pre><code>&lt;h1&gt;这是404页面&lt;/h1&gt;\n</code></pre><p>500页面，500.handlebars</p>\n<pre><code>&lt;h1&gt;这是500页面&lt;/h1&gt;\n</code></pre><p>现在视图也编写好了，接下来我们修改项目入口文件中的路由已经404和500处理器：</p>\n<pre><code>// 首页路由\napp.get(&#39;/&#39; ,function(req, res){\n    res.render(&#39;home&#39;);\n})\n\n// 关于页面路由\napp.get(&#39;/about&#39; ,function(req, res){\n    res.render(&#39;about&#39;);\n})\n\n// 中间件 定制404页面\napp.use(function(req, res){\n    res.status(404);\n    res.render(&#39;404&#39;);\n});\n\n// 中间件 定制500页面\napp.use(function(req, res){\n    res.status(500);\n    res.render(&#39;500&#39;);\n});\n</code></pre><p>注意我们已经不用res.type指定内容类型了，视图引擎默认会返回 text/html 内容类型，也不用 res.status 指定状态码了，视图引擎会默认返回200状态码(对于404和500页面必须指定状态码)<br>下面，我们再次重启服务器</p>\n<pre><code>node app.js\n</code></pre><p>怎么样，是不是如下图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20150923e.png\" alt=\"使用莫板引擎的首页\"> <img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20150923f.png\" alt=\"使用莫板引擎的关于页面\"></p>\n<h1 id=\"视图和静态资源\"><a href=\"#视图和静态资源\" class=\"headerlink\" title=\"视图和静态资源\"></a>视图和静态资源</h1><p>我们在做视图的时候，总是会使用带静态资源，比如图片、css、javascript文件等，express是靠static中间件管理静态资源的，它可以把一个或多个目录指派成包含静态资源的目录，其中的资源不经过任何处理直接发给客户端。</p>\n<p>在项目目录下创建 <em> public </em> 目录，接下来，在所有路由以及中间件之前加入static中间件：</p>\n<pre><code>app.use(express.static(__dirname + &#39;/public&#39;));\n</code></pre><p>接下来，在public目录下面创建一个img子目录，并照一张图片放入该目录下（如：logo.png），之后修改main.handlebars布局文件</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;默认布局&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;img src=&quot;/img/logo.png&quot; alt=&quot;LOGO&quot; /&gt;\n    &lt;h1&gt;默认布局哦哦哦哦&lt;/h1&gt;\n    {{{body}}}\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>重启node服务</p>\n<pre><code>node app.js\n</code></pre><p>访问主页面，是不是看到了静态资源图片：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20150923g.png\" alt=\"静态资源图片\"></p>\n<p>好啦，这就是express搭建项目的基本使用，你还可以在public目录下面创建类似于css，js这样的子目录，存放对应的静态资源文件，更多有关于express的内容，可以继续关注我的博客，或者<a href=\"http://expressjs.com/\" target=\"_blank\" rel=\"external\">express</a>官网</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"初识Express\"><a href=\"#初识Express\" class=\"headerlink\" title=\"初识Express\"></a>初识Express</h1><p><a href=\"http://expressjs.com/\" target=\"_blank\" rel=\"external\">Express</a>的官网上是这样介绍的：“精简的、灵活的Node.js Web程序框架”。<br>express的哲学是“少即是多”，express是可扩展的，他只充当你和服务器之间薄薄的一层，这并不是说它不健壮，而是尽量少干预你，让你能够充分表达自己的思想。</p>","more":"<p>在开始之前，首先要确认你对node有一定的了解，以及你的电脑上已经安装了node，接下来我们就开始吧。<br>既然是使用express从零搭建项目，那么第一步我们应该创建自己的项目文件夹也叫根目录或者项目目录（一下统称为项目目录）：</p>\n<pre><code>mkdir learnexpress\ncd learnexpress\n</code></pre><p>npm(包管理工具)是基于package.json文件管理项目的依赖以及项目的元数据的，所以我们要创建package.json这个文件，最简单的办法就是先项目目录中执行</p>\n<pre><code>npm init\n</code></pre><p>执行上面的命令后，终端会提出一些列问题，来帮助你完成这个文件：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20150923a.png\" alt=\"npm init\"> </p>\n<p>不过我们可以一路回车，不需要填写任何信息，这样就会生成一个包含默认信息的package.json文件，打开该文件，内容如下：</p>\n<pre><code>{\n  &quot;name&quot;: &quot;learnexp&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;description&quot;: &quot;&quot;,\n  &quot;main&quot;: &quot;index.js&quot;,\n  &quot;scripts&quot;: {\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;\n  },\n  &quot;author&quot;: &quot;&quot;,\n  &quot;license&quot;: &quot;ISC&quot;\n}\n</code></pre><p>package.json文件创建好了，我们就可以开始安装express了，执行：</p>\n<pre><code>npm install --save express\n</code></pre><p>运行npm install会把指定名称的包安装到node_modules目录下，如果你使用了 –save 选项，他还会更新package.json文件，将包的依赖写入package.json，打开项目目录，你会发现多了一个node_modules目录，此时再次打开package.json文件，会发现文件被更新了：</p>\n<pre><code>{\n  &quot;name&quot;: &quot;learnexp&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;description&quot;: &quot;&quot;,\n  &quot;main&quot;: &quot;index.js&quot;,\n  &quot;scripts&quot;: {\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;\n  },\n  &quot;author&quot;: &quot;&quot;,\n  &quot;license&quot;: &quot;ISC&quot;,\n  &quot;dependencies&quot;: {\n    &quot;express&quot;: &quot;^4.13.3&quot;\n  }\n}\n</code></pre><p>express也安装好了，接下来，我们就可以开始写项目了，那么我们第一步需要做的事情是什么呢？不管任何一个项目都需要一个入口文件，所以我们接下来要做的就是写入口文件，在我们的项目目录下面创建一个js文件，文件名称自定义，但是最好以你的项目名称去命名，这里我们就叫app.js作为我们的项目入口文件，并写入以下代码</p>\n<pre><code>// 引入express模块\nvar express = require(&#39;express&#39;);\n\n// 调用express()方法创建一个对象\nvar app = express();\n\n// 设置端口\napp.set(&#39;port&#39;, process.env.PORT || 3000);\n\n// 中间件 定制404页面\napp.use(function(req, res){\n    res.type(&#39;text/plain&#39;);\n    res.status(404);\n    res.send(&#39;404 - Not Found&#39;);\n});\n\n// 中间件 定制500页面\napp.use(function(req, res){\n    res.type(&#39;text/plain&#39;);\n    res.status(500);\n    res.send(&#39;500 - Server Error&#39;);\n});\n\napp.listen(app.get(&#39;port&#39;), function(){\n    console.log(&#39;express启动并监听&#39; + app.get(&#39;port&#39;) + &#39;端口，按 Ctrl + C 终止&#39;);\n});\n</code></pre><p>入口文件写好后，我们保存文件，在项目目录下执行：</p>\n<pre><code>node app.js\n</code></pre><p>这样，我们的程序就跑起来了，打开你的浏览器，输入 <em> localhost:3000 </em>，会看到如下界面：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20150923b.png\" alt=\"404\"></p>\n<p>为什么是404界面呢？很简单我们并没有设置任何路由，我们的入口文件（app.js）中只设置了404、500的处理。<br>在我们给应用程序加上路由之前我们来说一些问题，首先通过执行 <em> npm init </em> 创建的package.json中main属性的默认值是index.js，而我们的项目入口文件是app.js，所以我们要手动修改package.json文件的main属性为app.js：</p>\n<pre><code>{\n  &quot;name&quot;: &quot;learnexp&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;description&quot;: &quot;&quot;,\n  &quot;main&quot;: &quot;app.js&quot;,\n  &quot;scripts&quot;: {\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;\n  },\n  &quot;author&quot;: &quot;&quot;,\n  &quot;license&quot;: &quot;ISC&quot;,\n  &quot;dependencies&quot;: {\n    &quot;express&quot;: &quot;^4.13.3&quot;\n  }\n}\n</code></pre><p>接下来，我们给首页和关于页面加上路由，注意：路由应该放在404和500处理器前面：</p>\n<pre><code>// 首页路由\napp.get(&#39;/&#39; ,function(req, res){\n    res.type(&#39;text/plain&#39;);\n    res.send(&#39;home&#39;);\n})\n\n// 关于页面路由\napp.get(&#39;/about&#39; ,function(req, res){\n    res.type(&#39;text/plain&#39;);\n    res.send(&#39;about&#39;);\n})\n\n// 中间件 定制404页面\napp.use(function(req, res){\n    res.type(&#39;text/plain&#39;);\n    res.status(404);\n    res.send(&#39;404 - Not Found&#39;);\n});\n\n........\n</code></pre><p>app.get 是我们添加的路由方法(常见的还有 app.post )，这个方法有两个参数：第一个参数是路径，第二个参数是一个回调函数<br>重启我们的node服务</p>\n<pre><code>node app.js\n</code></pre><p>打开浏览器分别输入 <em> localhost:3000 </em> 和 <em> localhost:3000/about </em> 怎么样，是否如下图所示：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20150923c.png\" alt=\"首页\"> <img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20150923d.png\" alt=\"关于页面\"></p>\n<h1 id=\"莫板引擎\"><a href=\"#莫板引擎\" class=\"headerlink\" title=\"莫板引擎\"></a>莫板引擎</h1><p>那么问题来了，我们的界面不可能总是一堆文字吧，是不是应该有漂亮的样式，开发过程中是不是应该有模板引擎，我相信很多同学对莫板引擎是不陌生的。express支持很多种莫板引擎，例如Jade，ejs等，而我们今天要介绍的是 Handlebars，为了支持handlebars，我们首先要安装 express3-handlebars 包：</p>\n<pre><code>npm install --save express3-handlebars\n</code></pre><p>然后在我们的项目入口文件中<em> 创建app的代码 </em>之后加入以下代码：</p>\n<pre><code>var app = express();\n\n// 设置handlebars莫板引擎\nvar handlebars = require(&#39;express3-handlebars&#39;).create({defaultLayout : &#39;main&#39;});\napp.engine(&#39;handlebars&#39;, handlebars.engine);\napp.set(&#39;view engine&#39;, &#39;handlebars&#39;);\n</code></pre><p>以上代码中，我们执行了 <em> {defaultLayout : ‘main’} </em> ，这就意味着除非我们特别声明，否则所有视图都将使用main.handlebars作为默认布局，布局文件默认在 <em> views/layouts/ </em> 目录下，接下来我们想项目目录下创建views目录，并在views目录中创建layouts目录，在layouts目录中创建main.handlebars文件：</p>\n<pre><code>&lt;!dpcument html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;默认布局&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;默认布局哦哦哦哦&lt;/h1&gt;\n    {{{body}}}\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>编写好默认布局好，我们来分别创建首页页面，views/home.handlebars</p>\n<pre><code>&lt;h1&gt;这是首页&lt;/h1&gt;\n</code></pre><p>关于我们页面，views/about.handlebars</p>\n<pre><code>&lt;h1&gt;这是关于我们页面&lt;/h1&gt;\n</code></pre><p>404页面，views/404.handlebars</p>\n<pre><code>&lt;h1&gt;这是404页面&lt;/h1&gt;\n</code></pre><p>500页面，500.handlebars</p>\n<pre><code>&lt;h1&gt;这是500页面&lt;/h1&gt;\n</code></pre><p>现在视图也编写好了，接下来我们修改项目入口文件中的路由已经404和500处理器：</p>\n<pre><code>// 首页路由\napp.get(&#39;/&#39; ,function(req, res){\n    res.render(&#39;home&#39;);\n})\n\n// 关于页面路由\napp.get(&#39;/about&#39; ,function(req, res){\n    res.render(&#39;about&#39;);\n})\n\n// 中间件 定制404页面\napp.use(function(req, res){\n    res.status(404);\n    res.render(&#39;404&#39;);\n});\n\n// 中间件 定制500页面\napp.use(function(req, res){\n    res.status(500);\n    res.render(&#39;500&#39;);\n});\n</code></pre><p>注意我们已经不用res.type指定内容类型了，视图引擎默认会返回 text/html 内容类型，也不用 res.status 指定状态码了，视图引擎会默认返回200状态码(对于404和500页面必须指定状态码)<br>下面，我们再次重启服务器</p>\n<pre><code>node app.js\n</code></pre><p>怎么样，是不是如下图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20150923e.png\" alt=\"使用莫板引擎的首页\"> <img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20150923f.png\" alt=\"使用莫板引擎的关于页面\"></p>\n<h1 id=\"视图和静态资源\"><a href=\"#视图和静态资源\" class=\"headerlink\" title=\"视图和静态资源\"></a>视图和静态资源</h1><p>我们在做视图的时候，总是会使用带静态资源，比如图片、css、javascript文件等，express是靠static中间件管理静态资源的，它可以把一个或多个目录指派成包含静态资源的目录，其中的资源不经过任何处理直接发给客户端。</p>\n<p>在项目目录下创建 <em> public </em> 目录，接下来，在所有路由以及中间件之前加入static中间件：</p>\n<pre><code>app.use(express.static(__dirname + &#39;/public&#39;));\n</code></pre><p>接下来，在public目录下面创建一个img子目录，并照一张图片放入该目录下（如：logo.png），之后修改main.handlebars布局文件</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;默认布局&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;img src=&quot;/img/logo.png&quot; alt=&quot;LOGO&quot; /&gt;\n    &lt;h1&gt;默认布局哦哦哦哦&lt;/h1&gt;\n    {{{body}}}\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>重启node服务</p>\n<pre><code>node app.js\n</code></pre><p>访问主页面，是不是看到了静态资源图片：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20150923g.png\" alt=\"静态资源图片\"></p>\n<p>好啦，这就是express搭建项目的基本使用，你还可以在public目录下面创建类似于css，js这样的子目录，存放对应的静态资源文件，更多有关于express的内容，可以继续关注我的博客，或者<a href=\"http://expressjs.com/\" target=\"_blank\" rel=\"external\">express</a>官网</p>"},{"title":"移动端页面开发资源总结","date":"2015-09-25T08:03:45.000Z","_content":"\n# 移动端页面开发资源总结及技巧 #\n\n工作了有一段时间，基本上都在搞移动端的前端开发，工作的过程中遇到过很多问题，bug的解决方案，记录下来，以便后用！！！内容并不是很全，以后每遇到一个问题都会总结在这里，分享给大家！\n\n<!-- more -->\n\n# 一、meta标签相关知识 #\n\n1、移动端页面设置视口宽度等于设备宽度，并禁止缩放。\n\n```\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no\" />\n```\n\n2、移动端页面设置视口宽度等于定宽（如640px），并禁止缩放，常用于微信浏览器页面。\n\n```\n<meta name=\"viewport\" content=\"width=640,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no\" />\n```\n\n3、禁止将页面中的数字识别为电话号码\n\n```\n<meta name=\"format-detection\" content=\"telephone=no\" />\n```\n\n4、忽略Android平台中对邮箱地址的识别\n\n```\n<meta name=\"format-detection\" content=\"email=no\" />\n```\n\n5、当网站添加到主屏幕快速启动方式，可隐藏地址栏，仅针对ios的safari\n\n```\n<meta name=\"apple-mobile-web-app-capable\" content=\"yes\" />\n<!-- ios7.0版本以后，safari上已看不到效果 -->\n```\n\n6、将网站添加到主屏幕快速启动方式，仅针对ios的safari顶端状态条的样式\n\n```\n<meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\" />\n<!-- 可选default、black、black-translucent -->\n```\n\n## viewport莫板 ##\n\n```\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no\" name=\"viewport\">\n<meta content=\"yes\" name=\"apple-mobile-web-app-capable\">\n<meta content=\"black\" name=\"apple-mobile-web-app-status-bar-style\">\n<meta content=\"telephone=no\" name=\"format-detection\">\n<meta content=\"email=no\" name=\"format-detection\">\n<title>title</title>\n<link rel=\"stylesheet\" href=\"index.css\">\n</head>\n\n<body>\n\tcontent...\n</body>\n\n</html>\n```\n\n# 二、CSS样式技巧 #\n\n1、禁止ios和android用户选中文字\n\n```\n.css{-webkit-user-select:none}\n```\n\n2、禁止ios长按时触发系统的菜单，禁止ios&android长按时下载图片\n\n```\n.css{-webkit-touch-callout: none}\n```\n\n3、webkit去除表单元素的默认样式\n\n```\n.css{-webkit-appearance:none;}\n```\n\n4、修改webkit表单输入框placeholder的样式\n\n```\ninput::-webkit-input-placeholder{color:#AAAAAA;}\ninput:focus::-webkit-input-placeholder{color:#EEEEEE;}\n```\n\n5、去除android a/button/input标签被点击时产生的边框 & 去除ios a标签被点击时产生的半透明灰色背景\n\n```\na,button,input{-webkit-tap-highlight-color:rgba(255,0,0,0);}\n```\n\n6、ios使用-webkit-text-size-adjust禁止调整字体大小\n\n```\nbody{-webkit-text-size-adjust: 100%!important;}\n```\n\n7、android 上去掉语音输入按钮\n\n```\ninput::-webkit-input-speech-button {display: none}\n```\n\n8、移动端定义字体，移动端没有微软雅黑字体\n\n```\n/* 移动端定义字体的代码 */\nbody{font-family:Helvetica;}\n```\n\n9、禁用Webkit内核浏览器的文字大小调整功能。\n\n```\n-webkit-text-size-adjust: none;\n```\n\n# 三、其他技巧 #\n\n1、手机拍照和上传图片\n\n```\n<!-- 选择照片 -->\n<input type=file accept=\"image/*\">\n<!-- 选择视频 -->\n<input type=file accept=\"video/*\">\n```\n\n2、取消input在ios下，输入的时候英文首字母的默认大写\n\n```\n<input autocapitalize=\"off\" autocorrect=\"off\" />\n```\n\n3、打电话和发短信\n\n```\n<a href=\"tel:0755-10086\">打电话给:0755-10086</a>\n<a href=\"sms:10086\">发短信给: 10086</a>\n```\n\n# 四、CSS reset #\n\n```\n/* hcysun  */\n@charset \"utf-8\";\n/* reset */\nhtml{\n\t-webkit-text-size-adjust:none;\n\t-webkit-user-select:none;\n\t-webkit-touch-callout: none\n\tfont-family: Helvetica;\n}\nbody{font-size:12px;}\nbody,h1,h2,h3,h4,h5,h6,p,dl,dd,ul,ol,pre,form,input,textarea,th,td,select{margin:0; padding:0; font-weight: normal;text-indent: 0;}\na,button,input,textarea,select{ background: none; -webkit-tap-highlight-color:rgba(255,0,0,0); outline:none; -webkit-appearance:none;}\nem{font-style:normal}\nli{list-style:none}\na{text-decoration:none;}\nimg{border:none; vertical-align:top;}\ntable{border-collapse:collapse;}\ntextarea{ resize:none; overflow:auto;}\n/* end reset */\n```\n\n# 五、常用公用CSS style #\n\n```\n/* public */\n\n/* 清除浮动 */\n.clear { zoom:1; }\n.clear:after { content:''; display:block; clear:both; }\n\n/* 定义盒模型为怪异和模型（宽高不受边框影响） */\n.boxSiz{\n\t-webkit-box-sizing: border-box;\n\t-moz-box-sizing: border-box;\n\t-ms-box-sizing: border-box;\n\t-o-box-sizing: border-box;\n\tbox-sizing: border-box;\n}\n\n/* 强制换行 */\n.toWrap{\n\tword-break: break-all;       /* 只对英文起作用，以字母作为换行依据。 */\n\tword-wrap: break-word;   \t/* 只对英文起作用，以单词作为换行依据。*/\n\twhite-space: pre-wrap;     /* 只对中文起作用，强制换行。*/\n}\n\n/* 禁止换行 */\n.noWrap{\n\twhite-space:nowrap;\n}\n\n/* 禁止换行,超出省略号 */\n.noWrapEllipsis{\n\t white-space:nowrap; overflow:hidden; text-overflow:ellipsis;\n}\n\n/* 多行显示省略号，less写法，@line是行数 */\n.ellipsisLn(@line) {\n    overflow: hidden;\n    text-overflow: ellipsis;\n    display: -webkit-box;\n    -webkit-box-orient: vertical;\n    -webkit-line-clamp: @line;\n}\n\n/* 1px 边框解决方案，示例中设置上边框，可以调整 top、right、bottom、left 的值分别设置上下左右边框 */\n#box2:after{\n\tcontent: \" \";\n    position: absolute;\n    left: 0;\n    top: 0;\n    right: 0;\n    height: 1px;\n    border-top: 1px solid #000;\n    color: #C7C7C7;\n    transform-origin: 0 0;\n    transform: scaleY(0.5);\n}\n\n/* 文字两端对齐 */\n.text-justify{\n\ttext-align:justify; \n\ttext-justify:inter-ideograph;\n}\n\n/* 定义盒模型为 flex布局兼容写法并让内容水平垂直居中 */\n.flex-center{\n\tdisplay: -webkit-box;\n\tdisplay: -moz-box;\n\tdisplay: -ms-flexbox;\n\tdisplay: -o-box;\n\tdisplay: box;\n\n\t-webkit-box-pack: center;\n    -moz-box-pack: center;\n    -ms-flex-pack: center;\n    -o-box-pack: center;\n    box-pack: center;\n\n    -webkit-box-align: center;\n    -moz-box-align: center;\n    -ms-flex-align: center;\n    -o-box-align: center;\n    box-align: center;\n}\n\n/* public end */\n```\n\n# 六、flex布局 #\n\n1、定义弹性盒模型兼容写法\n\n```\n\n/*\n\tbox\n\tinline-box\n*/\ndisplay: -webkit-box;\ndisplay: -moz-box;\ndisplay: -ms-flexbox;\ndisplay: -o-box;\ndisplay: box;\n```\n\n2、box-orient 定义盒模型内伸缩项目的布局方向\n\n```\n/**\n * vertical column\t垂直\n * horizontal row\t水平 默认值\n */\n-webkit-box-orient: horizontal;\n-moz-box-orient: horizontal;\n-ms-flex-direction: row;\n-o-box-orient: horizontal;\nbox-orient: horizontal;\n```\n\n3、box-direction 定义盒模型内伸缩项目的正序(normal默认值)、倒叙(reverse)\n\n```\n/* Firefox */\ndisplay:-moz-box;\n-moz-box-direction:reverse;\n/* Safari、Opera 以及 Chrome */\ndisplay:-webkit-box;\n-webkit-box-direction:reverse;\n```\n\n4、box-pack 对盒子水平富裕空间的管理\n\n```\n/*\n\tstart\n\tend\n\tcenter\n\tjustify\n*/\n-webkit-box-pack: center;\n-moz-box-pack: center;\n-ms-flex-pack: center;\n-o-box-pack: center;\nbox-pack: center;\n```\n\n5、box-pack 对盒子垂直方向富裕空间的管理\n\n```\n/*\n\tstart\n\tend\n\tcenter\n*/\n/* box-align */\n-webkit-box-align: center;\n-moz-box-align: center;\n-ms-flex-align: center;\n-o-box-align: center;\nbox-align: center;\n```\n\n6、定义伸缩项目的具体位置\n\n```\n/*-moz-box-ordinal-group:1;*/ /* Firefox */\n/*-webkit-box-ordinal-group:1;*/ /* Safari 和 Chrome */\n.box div:nth-of-type(1){-webkit-box-ordinal-group:1;}\n.box div:nth-of-type(2){-webkit-box-ordinal-group:2;}\n.box div:nth-of-type(3){-webkit-box-ordinal-group:3;}\n.box div:nth-of-type(4){-webkit-box-ordinal-group:4;}\n.box div:nth-of-type(5){-webkit-box-ordinal-group:5;}\n```\n\n7、定义伸缩项目占空间的份数\n\n```\n-moz-box-flex:2.0; /* Firefox */\n-webkit-box-flex:2.0; /* Safari 和 Chrome */\n\n.box div:nth-of-type(1){-webkit-box-flex:1;}\n.box div:nth-of-type(2){-webkit-box-flex:2;}\n.box div:nth-of-type(3){-webkit-box-flex:3;}\n.box div:nth-of-type(4){-webkit-box-flex:4;}\n.box div:nth-of-type(5){-webkit-box-flex:5;}\n```","source":"_posts/2015/09/25/移动端页面开发资源总结.md","raw":"title: 移动端页面开发资源总结\ndate: 2015-09-25 16:03:45\ncategories:\n- WebFrontEnd\ntags:\n- html\n- css\n- 移动页面\n---\n\n# 移动端页面开发资源总结及技巧 #\n\n工作了有一段时间，基本上都在搞移动端的前端开发，工作的过程中遇到过很多问题，bug的解决方案，记录下来，以便后用！！！内容并不是很全，以后每遇到一个问题都会总结在这里，分享给大家！\n\n<!-- more -->\n\n# 一、meta标签相关知识 #\n\n1、移动端页面设置视口宽度等于设备宽度，并禁止缩放。\n\n```\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no\" />\n```\n\n2、移动端页面设置视口宽度等于定宽（如640px），并禁止缩放，常用于微信浏览器页面。\n\n```\n<meta name=\"viewport\" content=\"width=640,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no\" />\n```\n\n3、禁止将页面中的数字识别为电话号码\n\n```\n<meta name=\"format-detection\" content=\"telephone=no\" />\n```\n\n4、忽略Android平台中对邮箱地址的识别\n\n```\n<meta name=\"format-detection\" content=\"email=no\" />\n```\n\n5、当网站添加到主屏幕快速启动方式，可隐藏地址栏，仅针对ios的safari\n\n```\n<meta name=\"apple-mobile-web-app-capable\" content=\"yes\" />\n<!-- ios7.0版本以后，safari上已看不到效果 -->\n```\n\n6、将网站添加到主屏幕快速启动方式，仅针对ios的safari顶端状态条的样式\n\n```\n<meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\" />\n<!-- 可选default、black、black-translucent -->\n```\n\n## viewport莫板 ##\n\n```\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no\" name=\"viewport\">\n<meta content=\"yes\" name=\"apple-mobile-web-app-capable\">\n<meta content=\"black\" name=\"apple-mobile-web-app-status-bar-style\">\n<meta content=\"telephone=no\" name=\"format-detection\">\n<meta content=\"email=no\" name=\"format-detection\">\n<title>title</title>\n<link rel=\"stylesheet\" href=\"index.css\">\n</head>\n\n<body>\n\tcontent...\n</body>\n\n</html>\n```\n\n# 二、CSS样式技巧 #\n\n1、禁止ios和android用户选中文字\n\n```\n.css{-webkit-user-select:none}\n```\n\n2、禁止ios长按时触发系统的菜单，禁止ios&android长按时下载图片\n\n```\n.css{-webkit-touch-callout: none}\n```\n\n3、webkit去除表单元素的默认样式\n\n```\n.css{-webkit-appearance:none;}\n```\n\n4、修改webkit表单输入框placeholder的样式\n\n```\ninput::-webkit-input-placeholder{color:#AAAAAA;}\ninput:focus::-webkit-input-placeholder{color:#EEEEEE;}\n```\n\n5、去除android a/button/input标签被点击时产生的边框 & 去除ios a标签被点击时产生的半透明灰色背景\n\n```\na,button,input{-webkit-tap-highlight-color:rgba(255,0,0,0);}\n```\n\n6、ios使用-webkit-text-size-adjust禁止调整字体大小\n\n```\nbody{-webkit-text-size-adjust: 100%!important;}\n```\n\n7、android 上去掉语音输入按钮\n\n```\ninput::-webkit-input-speech-button {display: none}\n```\n\n8、移动端定义字体，移动端没有微软雅黑字体\n\n```\n/* 移动端定义字体的代码 */\nbody{font-family:Helvetica;}\n```\n\n9、禁用Webkit内核浏览器的文字大小调整功能。\n\n```\n-webkit-text-size-adjust: none;\n```\n\n# 三、其他技巧 #\n\n1、手机拍照和上传图片\n\n```\n<!-- 选择照片 -->\n<input type=file accept=\"image/*\">\n<!-- 选择视频 -->\n<input type=file accept=\"video/*\">\n```\n\n2、取消input在ios下，输入的时候英文首字母的默认大写\n\n```\n<input autocapitalize=\"off\" autocorrect=\"off\" />\n```\n\n3、打电话和发短信\n\n```\n<a href=\"tel:0755-10086\">打电话给:0755-10086</a>\n<a href=\"sms:10086\">发短信给: 10086</a>\n```\n\n# 四、CSS reset #\n\n```\n/* hcysun  */\n@charset \"utf-8\";\n/* reset */\nhtml{\n\t-webkit-text-size-adjust:none;\n\t-webkit-user-select:none;\n\t-webkit-touch-callout: none\n\tfont-family: Helvetica;\n}\nbody{font-size:12px;}\nbody,h1,h2,h3,h4,h5,h6,p,dl,dd,ul,ol,pre,form,input,textarea,th,td,select{margin:0; padding:0; font-weight: normal;text-indent: 0;}\na,button,input,textarea,select{ background: none; -webkit-tap-highlight-color:rgba(255,0,0,0); outline:none; -webkit-appearance:none;}\nem{font-style:normal}\nli{list-style:none}\na{text-decoration:none;}\nimg{border:none; vertical-align:top;}\ntable{border-collapse:collapse;}\ntextarea{ resize:none; overflow:auto;}\n/* end reset */\n```\n\n# 五、常用公用CSS style #\n\n```\n/* public */\n\n/* 清除浮动 */\n.clear { zoom:1; }\n.clear:after { content:''; display:block; clear:both; }\n\n/* 定义盒模型为怪异和模型（宽高不受边框影响） */\n.boxSiz{\n\t-webkit-box-sizing: border-box;\n\t-moz-box-sizing: border-box;\n\t-ms-box-sizing: border-box;\n\t-o-box-sizing: border-box;\n\tbox-sizing: border-box;\n}\n\n/* 强制换行 */\n.toWrap{\n\tword-break: break-all;       /* 只对英文起作用，以字母作为换行依据。 */\n\tword-wrap: break-word;   \t/* 只对英文起作用，以单词作为换行依据。*/\n\twhite-space: pre-wrap;     /* 只对中文起作用，强制换行。*/\n}\n\n/* 禁止换行 */\n.noWrap{\n\twhite-space:nowrap;\n}\n\n/* 禁止换行,超出省略号 */\n.noWrapEllipsis{\n\t white-space:nowrap; overflow:hidden; text-overflow:ellipsis;\n}\n\n/* 多行显示省略号，less写法，@line是行数 */\n.ellipsisLn(@line) {\n    overflow: hidden;\n    text-overflow: ellipsis;\n    display: -webkit-box;\n    -webkit-box-orient: vertical;\n    -webkit-line-clamp: @line;\n}\n\n/* 1px 边框解决方案，示例中设置上边框，可以调整 top、right、bottom、left 的值分别设置上下左右边框 */\n#box2:after{\n\tcontent: \" \";\n    position: absolute;\n    left: 0;\n    top: 0;\n    right: 0;\n    height: 1px;\n    border-top: 1px solid #000;\n    color: #C7C7C7;\n    transform-origin: 0 0;\n    transform: scaleY(0.5);\n}\n\n/* 文字两端对齐 */\n.text-justify{\n\ttext-align:justify; \n\ttext-justify:inter-ideograph;\n}\n\n/* 定义盒模型为 flex布局兼容写法并让内容水平垂直居中 */\n.flex-center{\n\tdisplay: -webkit-box;\n\tdisplay: -moz-box;\n\tdisplay: -ms-flexbox;\n\tdisplay: -o-box;\n\tdisplay: box;\n\n\t-webkit-box-pack: center;\n    -moz-box-pack: center;\n    -ms-flex-pack: center;\n    -o-box-pack: center;\n    box-pack: center;\n\n    -webkit-box-align: center;\n    -moz-box-align: center;\n    -ms-flex-align: center;\n    -o-box-align: center;\n    box-align: center;\n}\n\n/* public end */\n```\n\n# 六、flex布局 #\n\n1、定义弹性盒模型兼容写法\n\n```\n\n/*\n\tbox\n\tinline-box\n*/\ndisplay: -webkit-box;\ndisplay: -moz-box;\ndisplay: -ms-flexbox;\ndisplay: -o-box;\ndisplay: box;\n```\n\n2、box-orient 定义盒模型内伸缩项目的布局方向\n\n```\n/**\n * vertical column\t垂直\n * horizontal row\t水平 默认值\n */\n-webkit-box-orient: horizontal;\n-moz-box-orient: horizontal;\n-ms-flex-direction: row;\n-o-box-orient: horizontal;\nbox-orient: horizontal;\n```\n\n3、box-direction 定义盒模型内伸缩项目的正序(normal默认值)、倒叙(reverse)\n\n```\n/* Firefox */\ndisplay:-moz-box;\n-moz-box-direction:reverse;\n/* Safari、Opera 以及 Chrome */\ndisplay:-webkit-box;\n-webkit-box-direction:reverse;\n```\n\n4、box-pack 对盒子水平富裕空间的管理\n\n```\n/*\n\tstart\n\tend\n\tcenter\n\tjustify\n*/\n-webkit-box-pack: center;\n-moz-box-pack: center;\n-ms-flex-pack: center;\n-o-box-pack: center;\nbox-pack: center;\n```\n\n5、box-pack 对盒子垂直方向富裕空间的管理\n\n```\n/*\n\tstart\n\tend\n\tcenter\n*/\n/* box-align */\n-webkit-box-align: center;\n-moz-box-align: center;\n-ms-flex-align: center;\n-o-box-align: center;\nbox-align: center;\n```\n\n6、定义伸缩项目的具体位置\n\n```\n/*-moz-box-ordinal-group:1;*/ /* Firefox */\n/*-webkit-box-ordinal-group:1;*/ /* Safari 和 Chrome */\n.box div:nth-of-type(1){-webkit-box-ordinal-group:1;}\n.box div:nth-of-type(2){-webkit-box-ordinal-group:2;}\n.box div:nth-of-type(3){-webkit-box-ordinal-group:3;}\n.box div:nth-of-type(4){-webkit-box-ordinal-group:4;}\n.box div:nth-of-type(5){-webkit-box-ordinal-group:5;}\n```\n\n7、定义伸缩项目占空间的份数\n\n```\n-moz-box-flex:2.0; /* Firefox */\n-webkit-box-flex:2.0; /* Safari 和 Chrome */\n\n.box div:nth-of-type(1){-webkit-box-flex:1;}\n.box div:nth-of-type(2){-webkit-box-flex:2;}\n.box div:nth-of-type(3){-webkit-box-flex:3;}\n.box div:nth-of-type(4){-webkit-box-flex:4;}\n.box div:nth-of-type(5){-webkit-box-flex:5;}\n```","slug":"移动端页面开发资源总结","published":1,"updated":"2017-03-08T08:24:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj669fsjg000cewfcloqpns9y","content":"<h1 id=\"移动端页面开发资源总结及技巧\"><a href=\"#移动端页面开发资源总结及技巧\" class=\"headerlink\" title=\"移动端页面开发资源总结及技巧\"></a>移动端页面开发资源总结及技巧</h1><p>工作了有一段时间，基本上都在搞移动端的前端开发，工作的过程中遇到过很多问题，bug的解决方案，记录下来，以便后用！！！内容并不是很全，以后每遇到一个问题都会总结在这里，分享给大家！</p>\n<a id=\"more\"></a>\n<h1 id=\"一、meta标签相关知识\"><a href=\"#一、meta标签相关知识\" class=\"headerlink\" title=\"一、meta标签相关知识\"></a>一、meta标签相关知识</h1><p>1、移动端页面设置视口宽度等于设备宽度，并禁止缩放。</p>\n<pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot; /&gt;\n</code></pre><p>2、移动端页面设置视口宽度等于定宽（如640px），并禁止缩放，常用于微信浏览器页面。</p>\n<pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=640,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot; /&gt;\n</code></pre><p>3、禁止将页面中的数字识别为电话号码</p>\n<pre><code>&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot; /&gt;\n</code></pre><p>4、忽略Android平台中对邮箱地址的识别</p>\n<pre><code>&lt;meta name=&quot;format-detection&quot; content=&quot;email=no&quot; /&gt;\n</code></pre><p>5、当网站添加到主屏幕快速启动方式，可隐藏地址栏，仅针对ios的safari</p>\n<pre><code>&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&gt;\n&lt;!-- ios7.0版本以后，safari上已看不到效果 --&gt;\n</code></pre><p>6、将网站添加到主屏幕快速启动方式，仅针对ios的safari顶端状态条的样式</p>\n<pre><code>&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot; /&gt;\n&lt;!-- 可选default、black、black-translucent --&gt;\n</code></pre><h2 id=\"viewport莫板\"><a href=\"#viewport莫板\" class=\"headerlink\" title=\"viewport莫板\"></a>viewport莫板</h2><pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=&quot;utf-8&quot;&gt;\n&lt;meta content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no&quot; name=&quot;viewport&quot;&gt;\n&lt;meta content=&quot;yes&quot; name=&quot;apple-mobile-web-app-capable&quot;&gt;\n&lt;meta content=&quot;black&quot; name=&quot;apple-mobile-web-app-status-bar-style&quot;&gt;\n&lt;meta content=&quot;telephone=no&quot; name=&quot;format-detection&quot;&gt;\n&lt;meta content=&quot;email=no&quot; name=&quot;format-detection&quot;&gt;\n&lt;title&gt;title&lt;/title&gt;\n&lt;link rel=&quot;stylesheet&quot; href=&quot;index.css&quot;&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    content...\n&lt;/body&gt;\n\n&lt;/html&gt;\n</code></pre><h1 id=\"二、CSS样式技巧\"><a href=\"#二、CSS样式技巧\" class=\"headerlink\" title=\"二、CSS样式技巧\"></a>二、CSS样式技巧</h1><p>1、禁止ios和android用户选中文字</p>\n<pre><code>.css{-webkit-user-select:none}\n</code></pre><p>2、禁止ios长按时触发系统的菜单，禁止ios&amp;android长按时下载图片</p>\n<pre><code>.css{-webkit-touch-callout: none}\n</code></pre><p>3、webkit去除表单元素的默认样式</p>\n<pre><code>.css{-webkit-appearance:none;}\n</code></pre><p>4、修改webkit表单输入框placeholder的样式</p>\n<pre><code>input::-webkit-input-placeholder{color:#AAAAAA;}\ninput:focus::-webkit-input-placeholder{color:#EEEEEE;}\n</code></pre><p>5、去除android a/button/input标签被点击时产生的边框 &amp; 去除ios a标签被点击时产生的半透明灰色背景</p>\n<pre><code>a,button,input{-webkit-tap-highlight-color:rgba(255,0,0,0);}\n</code></pre><p>6、ios使用-webkit-text-size-adjust禁止调整字体大小</p>\n<pre><code>body{-webkit-text-size-adjust: 100%!important;}\n</code></pre><p>7、android 上去掉语音输入按钮</p>\n<pre><code>input::-webkit-input-speech-button {display: none}\n</code></pre><p>8、移动端定义字体，移动端没有微软雅黑字体</p>\n<pre><code>/* 移动端定义字体的代码 */\nbody{font-family:Helvetica;}\n</code></pre><p>9、禁用Webkit内核浏览器的文字大小调整功能。</p>\n<pre><code>-webkit-text-size-adjust: none;\n</code></pre><h1 id=\"三、其他技巧\"><a href=\"#三、其他技巧\" class=\"headerlink\" title=\"三、其他技巧\"></a>三、其他技巧</h1><p>1、手机拍照和上传图片</p>\n<pre><code>&lt;!-- 选择照片 --&gt;\n&lt;input type=file accept=&quot;image/*&quot;&gt;\n&lt;!-- 选择视频 --&gt;\n&lt;input type=file accept=&quot;video/*&quot;&gt;\n</code></pre><p>2、取消input在ios下，输入的时候英文首字母的默认大写</p>\n<pre><code>&lt;input autocapitalize=&quot;off&quot; autocorrect=&quot;off&quot; /&gt;\n</code></pre><p>3、打电话和发短信</p>\n<pre><code>&lt;a href=&quot;tel:0755-10086&quot;&gt;打电话给:0755-10086&lt;/a&gt;\n&lt;a href=&quot;sms:10086&quot;&gt;发短信给: 10086&lt;/a&gt;\n</code></pre><h1 id=\"四、CSS-reset\"><a href=\"#四、CSS-reset\" class=\"headerlink\" title=\"四、CSS reset\"></a>四、CSS reset</h1><pre><code>/* hcysun  */\n@charset &quot;utf-8&quot;;\n/* reset */\nhtml{\n    -webkit-text-size-adjust:none;\n    -webkit-user-select:none;\n    -webkit-touch-callout: none\n    font-family: Helvetica;\n}\nbody{font-size:12px;}\nbody,h1,h2,h3,h4,h5,h6,p,dl,dd,ul,ol,pre,form,input,textarea,th,td,select{margin:0; padding:0; font-weight: normal;text-indent: 0;}\na,button,input,textarea,select{ background: none; -webkit-tap-highlight-color:rgba(255,0,0,0); outline:none; -webkit-appearance:none;}\nem{font-style:normal}\nli{list-style:none}\na{text-decoration:none;}\nimg{border:none; vertical-align:top;}\ntable{border-collapse:collapse;}\ntextarea{ resize:none; overflow:auto;}\n/* end reset */\n</code></pre><h1 id=\"五、常用公用CSS-style\"><a href=\"#五、常用公用CSS-style\" class=\"headerlink\" title=\"五、常用公用CSS style\"></a>五、常用公用CSS style</h1><pre><code>/* public */\n\n/* 清除浮动 */\n.clear { zoom:1; }\n.clear:after { content:&#39;&#39;; display:block; clear:both; }\n\n/* 定义盒模型为怪异和模型（宽高不受边框影响） */\n.boxSiz{\n    -webkit-box-sizing: border-box;\n    -moz-box-sizing: border-box;\n    -ms-box-sizing: border-box;\n    -o-box-sizing: border-box;\n    box-sizing: border-box;\n}\n\n/* 强制换行 */\n.toWrap{\n    word-break: break-all;       /* 只对英文起作用，以字母作为换行依据。 */\n    word-wrap: break-word;       /* 只对英文起作用，以单词作为换行依据。*/\n    white-space: pre-wrap;     /* 只对中文起作用，强制换行。*/\n}\n\n/* 禁止换行 */\n.noWrap{\n    white-space:nowrap;\n}\n\n/* 禁止换行,超出省略号 */\n.noWrapEllipsis{\n     white-space:nowrap; overflow:hidden; text-overflow:ellipsis;\n}\n\n/* 多行显示省略号，less写法，@line是行数 */\n.ellipsisLn(@line) {\n    overflow: hidden;\n    text-overflow: ellipsis;\n    display: -webkit-box;\n    -webkit-box-orient: vertical;\n    -webkit-line-clamp: @line;\n}\n\n/* 1px 边框解决方案，示例中设置上边框，可以调整 top、right、bottom、left 的值分别设置上下左右边框 */\n#box2:after{\n    content: &quot; &quot;;\n    position: absolute;\n    left: 0;\n    top: 0;\n    right: 0;\n    height: 1px;\n    border-top: 1px solid #000;\n    color: #C7C7C7;\n    transform-origin: 0 0;\n    transform: scaleY(0.5);\n}\n\n/* 文字两端对齐 */\n.text-justify{\n    text-align:justify; \n    text-justify:inter-ideograph;\n}\n\n/* 定义盒模型为 flex布局兼容写法并让内容水平垂直居中 */\n.flex-center{\n    display: -webkit-box;\n    display: -moz-box;\n    display: -ms-flexbox;\n    display: -o-box;\n    display: box;\n\n    -webkit-box-pack: center;\n    -moz-box-pack: center;\n    -ms-flex-pack: center;\n    -o-box-pack: center;\n    box-pack: center;\n\n    -webkit-box-align: center;\n    -moz-box-align: center;\n    -ms-flex-align: center;\n    -o-box-align: center;\n    box-align: center;\n}\n\n/* public end */\n</code></pre><h1 id=\"六、flex布局\"><a href=\"#六、flex布局\" class=\"headerlink\" title=\"六、flex布局\"></a>六、flex布局</h1><p>1、定义弹性盒模型兼容写法</p>\n<pre><code>\n/*\n    box\n    inline-box\n*/\ndisplay: -webkit-box;\ndisplay: -moz-box;\ndisplay: -ms-flexbox;\ndisplay: -o-box;\ndisplay: box;\n</code></pre><p>2、box-orient 定义盒模型内伸缩项目的布局方向</p>\n<pre><code>/**\n * vertical column    垂直\n * horizontal row    水平 默认值\n */\n-webkit-box-orient: horizontal;\n-moz-box-orient: horizontal;\n-ms-flex-direction: row;\n-o-box-orient: horizontal;\nbox-orient: horizontal;\n</code></pre><p>3、box-direction 定义盒模型内伸缩项目的正序(normal默认值)、倒叙(reverse)</p>\n<pre><code>/* Firefox */\ndisplay:-moz-box;\n-moz-box-direction:reverse;\n/* Safari、Opera 以及 Chrome */\ndisplay:-webkit-box;\n-webkit-box-direction:reverse;\n</code></pre><p>4、box-pack 对盒子水平富裕空间的管理</p>\n<pre><code>/*\n    start\n    end\n    center\n    justify\n*/\n-webkit-box-pack: center;\n-moz-box-pack: center;\n-ms-flex-pack: center;\n-o-box-pack: center;\nbox-pack: center;\n</code></pre><p>5、box-pack 对盒子垂直方向富裕空间的管理</p>\n<pre><code>/*\n    start\n    end\n    center\n*/\n/* box-align */\n-webkit-box-align: center;\n-moz-box-align: center;\n-ms-flex-align: center;\n-o-box-align: center;\nbox-align: center;\n</code></pre><p>6、定义伸缩项目的具体位置</p>\n<pre><code>/*-moz-box-ordinal-group:1;*/ /* Firefox */\n/*-webkit-box-ordinal-group:1;*/ /* Safari 和 Chrome */\n.box div:nth-of-type(1){-webkit-box-ordinal-group:1;}\n.box div:nth-of-type(2){-webkit-box-ordinal-group:2;}\n.box div:nth-of-type(3){-webkit-box-ordinal-group:3;}\n.box div:nth-of-type(4){-webkit-box-ordinal-group:4;}\n.box div:nth-of-type(5){-webkit-box-ordinal-group:5;}\n</code></pre><p>7、定义伸缩项目占空间的份数</p>\n<pre><code>-moz-box-flex:2.0; /* Firefox */\n-webkit-box-flex:2.0; /* Safari 和 Chrome */\n\n.box div:nth-of-type(1){-webkit-box-flex:1;}\n.box div:nth-of-type(2){-webkit-box-flex:2;}\n.box div:nth-of-type(3){-webkit-box-flex:3;}\n.box div:nth-of-type(4){-webkit-box-flex:4;}\n.box div:nth-of-type(5){-webkit-box-flex:5;}\n</code></pre>","site":{"data":{}},"excerpt":"<h1 id=\"移动端页面开发资源总结及技巧\"><a href=\"#移动端页面开发资源总结及技巧\" class=\"headerlink\" title=\"移动端页面开发资源总结及技巧\"></a>移动端页面开发资源总结及技巧</h1><p>工作了有一段时间，基本上都在搞移动端的前端开发，工作的过程中遇到过很多问题，bug的解决方案，记录下来，以便后用！！！内容并不是很全，以后每遇到一个问题都会总结在这里，分享给大家！</p>","more":"<h1 id=\"一、meta标签相关知识\"><a href=\"#一、meta标签相关知识\" class=\"headerlink\" title=\"一、meta标签相关知识\"></a>一、meta标签相关知识</h1><p>1、移动端页面设置视口宽度等于设备宽度，并禁止缩放。</p>\n<pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot; /&gt;\n</code></pre><p>2、移动端页面设置视口宽度等于定宽（如640px），并禁止缩放，常用于微信浏览器页面。</p>\n<pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=640,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot; /&gt;\n</code></pre><p>3、禁止将页面中的数字识别为电话号码</p>\n<pre><code>&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot; /&gt;\n</code></pre><p>4、忽略Android平台中对邮箱地址的识别</p>\n<pre><code>&lt;meta name=&quot;format-detection&quot; content=&quot;email=no&quot; /&gt;\n</code></pre><p>5、当网站添加到主屏幕快速启动方式，可隐藏地址栏，仅针对ios的safari</p>\n<pre><code>&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&gt;\n&lt;!-- ios7.0版本以后，safari上已看不到效果 --&gt;\n</code></pre><p>6、将网站添加到主屏幕快速启动方式，仅针对ios的safari顶端状态条的样式</p>\n<pre><code>&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot; /&gt;\n&lt;!-- 可选default、black、black-translucent --&gt;\n</code></pre><h2 id=\"viewport莫板\"><a href=\"#viewport莫板\" class=\"headerlink\" title=\"viewport莫板\"></a>viewport莫板</h2><pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=&quot;utf-8&quot;&gt;\n&lt;meta content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no&quot; name=&quot;viewport&quot;&gt;\n&lt;meta content=&quot;yes&quot; name=&quot;apple-mobile-web-app-capable&quot;&gt;\n&lt;meta content=&quot;black&quot; name=&quot;apple-mobile-web-app-status-bar-style&quot;&gt;\n&lt;meta content=&quot;telephone=no&quot; name=&quot;format-detection&quot;&gt;\n&lt;meta content=&quot;email=no&quot; name=&quot;format-detection&quot;&gt;\n&lt;title&gt;title&lt;/title&gt;\n&lt;link rel=&quot;stylesheet&quot; href=&quot;index.css&quot;&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    content...\n&lt;/body&gt;\n\n&lt;/html&gt;\n</code></pre><h1 id=\"二、CSS样式技巧\"><a href=\"#二、CSS样式技巧\" class=\"headerlink\" title=\"二、CSS样式技巧\"></a>二、CSS样式技巧</h1><p>1、禁止ios和android用户选中文字</p>\n<pre><code>.css{-webkit-user-select:none}\n</code></pre><p>2、禁止ios长按时触发系统的菜单，禁止ios&amp;android长按时下载图片</p>\n<pre><code>.css{-webkit-touch-callout: none}\n</code></pre><p>3、webkit去除表单元素的默认样式</p>\n<pre><code>.css{-webkit-appearance:none;}\n</code></pre><p>4、修改webkit表单输入框placeholder的样式</p>\n<pre><code>input::-webkit-input-placeholder{color:#AAAAAA;}\ninput:focus::-webkit-input-placeholder{color:#EEEEEE;}\n</code></pre><p>5、去除android a/button/input标签被点击时产生的边框 &amp; 去除ios a标签被点击时产生的半透明灰色背景</p>\n<pre><code>a,button,input{-webkit-tap-highlight-color:rgba(255,0,0,0);}\n</code></pre><p>6、ios使用-webkit-text-size-adjust禁止调整字体大小</p>\n<pre><code>body{-webkit-text-size-adjust: 100%!important;}\n</code></pre><p>7、android 上去掉语音输入按钮</p>\n<pre><code>input::-webkit-input-speech-button {display: none}\n</code></pre><p>8、移动端定义字体，移动端没有微软雅黑字体</p>\n<pre><code>/* 移动端定义字体的代码 */\nbody{font-family:Helvetica;}\n</code></pre><p>9、禁用Webkit内核浏览器的文字大小调整功能。</p>\n<pre><code>-webkit-text-size-adjust: none;\n</code></pre><h1 id=\"三、其他技巧\"><a href=\"#三、其他技巧\" class=\"headerlink\" title=\"三、其他技巧\"></a>三、其他技巧</h1><p>1、手机拍照和上传图片</p>\n<pre><code>&lt;!-- 选择照片 --&gt;\n&lt;input type=file accept=&quot;image/*&quot;&gt;\n&lt;!-- 选择视频 --&gt;\n&lt;input type=file accept=&quot;video/*&quot;&gt;\n</code></pre><p>2、取消input在ios下，输入的时候英文首字母的默认大写</p>\n<pre><code>&lt;input autocapitalize=&quot;off&quot; autocorrect=&quot;off&quot; /&gt;\n</code></pre><p>3、打电话和发短信</p>\n<pre><code>&lt;a href=&quot;tel:0755-10086&quot;&gt;打电话给:0755-10086&lt;/a&gt;\n&lt;a href=&quot;sms:10086&quot;&gt;发短信给: 10086&lt;/a&gt;\n</code></pre><h1 id=\"四、CSS-reset\"><a href=\"#四、CSS-reset\" class=\"headerlink\" title=\"四、CSS reset\"></a>四、CSS reset</h1><pre><code>/* hcysun  */\n@charset &quot;utf-8&quot;;\n/* reset */\nhtml{\n    -webkit-text-size-adjust:none;\n    -webkit-user-select:none;\n    -webkit-touch-callout: none\n    font-family: Helvetica;\n}\nbody{font-size:12px;}\nbody,h1,h2,h3,h4,h5,h6,p,dl,dd,ul,ol,pre,form,input,textarea,th,td,select{margin:0; padding:0; font-weight: normal;text-indent: 0;}\na,button,input,textarea,select{ background: none; -webkit-tap-highlight-color:rgba(255,0,0,0); outline:none; -webkit-appearance:none;}\nem{font-style:normal}\nli{list-style:none}\na{text-decoration:none;}\nimg{border:none; vertical-align:top;}\ntable{border-collapse:collapse;}\ntextarea{ resize:none; overflow:auto;}\n/* end reset */\n</code></pre><h1 id=\"五、常用公用CSS-style\"><a href=\"#五、常用公用CSS-style\" class=\"headerlink\" title=\"五、常用公用CSS style\"></a>五、常用公用CSS style</h1><pre><code>/* public */\n\n/* 清除浮动 */\n.clear { zoom:1; }\n.clear:after { content:&#39;&#39;; display:block; clear:both; }\n\n/* 定义盒模型为怪异和模型（宽高不受边框影响） */\n.boxSiz{\n    -webkit-box-sizing: border-box;\n    -moz-box-sizing: border-box;\n    -ms-box-sizing: border-box;\n    -o-box-sizing: border-box;\n    box-sizing: border-box;\n}\n\n/* 强制换行 */\n.toWrap{\n    word-break: break-all;       /* 只对英文起作用，以字母作为换行依据。 */\n    word-wrap: break-word;       /* 只对英文起作用，以单词作为换行依据。*/\n    white-space: pre-wrap;     /* 只对中文起作用，强制换行。*/\n}\n\n/* 禁止换行 */\n.noWrap{\n    white-space:nowrap;\n}\n\n/* 禁止换行,超出省略号 */\n.noWrapEllipsis{\n     white-space:nowrap; overflow:hidden; text-overflow:ellipsis;\n}\n\n/* 多行显示省略号，less写法，@line是行数 */\n.ellipsisLn(@line) {\n    overflow: hidden;\n    text-overflow: ellipsis;\n    display: -webkit-box;\n    -webkit-box-orient: vertical;\n    -webkit-line-clamp: @line;\n}\n\n/* 1px 边框解决方案，示例中设置上边框，可以调整 top、right、bottom、left 的值分别设置上下左右边框 */\n#box2:after{\n    content: &quot; &quot;;\n    position: absolute;\n    left: 0;\n    top: 0;\n    right: 0;\n    height: 1px;\n    border-top: 1px solid #000;\n    color: #C7C7C7;\n    transform-origin: 0 0;\n    transform: scaleY(0.5);\n}\n\n/* 文字两端对齐 */\n.text-justify{\n    text-align:justify; \n    text-justify:inter-ideograph;\n}\n\n/* 定义盒模型为 flex布局兼容写法并让内容水平垂直居中 */\n.flex-center{\n    display: -webkit-box;\n    display: -moz-box;\n    display: -ms-flexbox;\n    display: -o-box;\n    display: box;\n\n    -webkit-box-pack: center;\n    -moz-box-pack: center;\n    -ms-flex-pack: center;\n    -o-box-pack: center;\n    box-pack: center;\n\n    -webkit-box-align: center;\n    -moz-box-align: center;\n    -ms-flex-align: center;\n    -o-box-align: center;\n    box-align: center;\n}\n\n/* public end */\n</code></pre><h1 id=\"六、flex布局\"><a href=\"#六、flex布局\" class=\"headerlink\" title=\"六、flex布局\"></a>六、flex布局</h1><p>1、定义弹性盒模型兼容写法</p>\n<pre><code>\n/*\n    box\n    inline-box\n*/\ndisplay: -webkit-box;\ndisplay: -moz-box;\ndisplay: -ms-flexbox;\ndisplay: -o-box;\ndisplay: box;\n</code></pre><p>2、box-orient 定义盒模型内伸缩项目的布局方向</p>\n<pre><code>/**\n * vertical column    垂直\n * horizontal row    水平 默认值\n */\n-webkit-box-orient: horizontal;\n-moz-box-orient: horizontal;\n-ms-flex-direction: row;\n-o-box-orient: horizontal;\nbox-orient: horizontal;\n</code></pre><p>3、box-direction 定义盒模型内伸缩项目的正序(normal默认值)、倒叙(reverse)</p>\n<pre><code>/* Firefox */\ndisplay:-moz-box;\n-moz-box-direction:reverse;\n/* Safari、Opera 以及 Chrome */\ndisplay:-webkit-box;\n-webkit-box-direction:reverse;\n</code></pre><p>4、box-pack 对盒子水平富裕空间的管理</p>\n<pre><code>/*\n    start\n    end\n    center\n    justify\n*/\n-webkit-box-pack: center;\n-moz-box-pack: center;\n-ms-flex-pack: center;\n-o-box-pack: center;\nbox-pack: center;\n</code></pre><p>5、box-pack 对盒子垂直方向富裕空间的管理</p>\n<pre><code>/*\n    start\n    end\n    center\n*/\n/* box-align */\n-webkit-box-align: center;\n-moz-box-align: center;\n-ms-flex-align: center;\n-o-box-align: center;\nbox-align: center;\n</code></pre><p>6、定义伸缩项目的具体位置</p>\n<pre><code>/*-moz-box-ordinal-group:1;*/ /* Firefox */\n/*-webkit-box-ordinal-group:1;*/ /* Safari 和 Chrome */\n.box div:nth-of-type(1){-webkit-box-ordinal-group:1;}\n.box div:nth-of-type(2){-webkit-box-ordinal-group:2;}\n.box div:nth-of-type(3){-webkit-box-ordinal-group:3;}\n.box div:nth-of-type(4){-webkit-box-ordinal-group:4;}\n.box div:nth-of-type(5){-webkit-box-ordinal-group:5;}\n</code></pre><p>7、定义伸缩项目占空间的份数</p>\n<pre><code>-moz-box-flex:2.0; /* Firefox */\n-webkit-box-flex:2.0; /* Safari 和 Chrome */\n\n.box div:nth-of-type(1){-webkit-box-flex:1;}\n.box div:nth-of-type(2){-webkit-box-flex:2;}\n.box div:nth-of-type(3){-webkit-box-flex:3;}\n.box div:nth-of-type(4){-webkit-box-flex:4;}\n.box div:nth-of-type(5){-webkit-box-flex:5;}\n</code></pre>"},{"title":"一篇真正教会你开发移动端页面的文章(一)","date":"2015-10-16T02:22:14.000Z","_content":"\n# 一个移动端的时代 #\n\n> 从我工作以来，开发的一直都是移动端的页面，只有偶尔去开发几个PC端的页面，现在是一个移动端的时代，移动先行已经深入骨髓，作为一个web前端开发，如果你还在为如何开发移动端页面而迷茫，或者你还在为开发出了一个在你手机上“完美”的移动页面而沾沾自喜却不知移动的世界有多“残酷”的时候，那你应该看看这篇文章了。希望这能给你帮助，同时也能给我帮助，有不合理的地方，欢迎评论支持，必将改正。\n\n![移动端](http://7xlolm.com1.z0.glb.clouddn.com/20150923mobile.jpg)\n\n<!-- more -->\n\n# 这里是基础，你了解否？ #\n\n## 一、像素 - 什么是像素 ##\n\n像素是web页面布局的基础，那么到底什么才是一个像素呢？\n像素：<b>一个像素就是计算机屏幕所能显示一种特定颜色的最小区域。</b> 这是像素的概念，实际上，在web前端开发领域，像素有以下两层含义：\n1、<b>设备像素：</b>设备屏幕的物理像素，对于任何设备来讲物理像素的数量是固定的。\n2、<b>CSS像素：</b>这是一个抽象的像素概念，它是为web开发者创造的。\n\n如下图，是在缩放比例为1，即scale = 1的情况下，设备像素和CSS像素示意图\n\n![设备像素和CSS像素](http://7xlolm.com1.z0.glb.clouddn.com/20150923px1.jpg)\n\n现在你已经了解了，原来像素对于web前端开发来讲有这样的两层含义，那么你有没有再深入的考虑这样一个问题，当我给一个元素设置了 <b>width: 200px;</b> 这条样式的时候，到底放生了什么事情？\n你可能会说：“废话！元素的宽度是200px呗。”；对，并没有什么问题，但是这个200px指的是什么呢？因为我们知道，对于web前端来讲像素有两层含义，那么到底是设备像素还是CSS像素？实际上我们控制的是CSS像素，因为前面提到了，CSS像素是给我们web前端开发者创造的抽象概念。所以你要记住：<b>当你给元素设置了 width: 200px 时，这个元素的宽度跨越了200个CSS像素</b>。但是它并不一定跨越200个设备像素，至于会跨越多少个设备像素，就取决于<b>手机屏幕的特性</b>和<b>用户的缩放</b>了,举个栗子：\n\n苹果手机的视网膜屏幕，是一个高密度屏幕，它的像素密度是普通屏幕的2倍，所以当我们设置 <b>width: 200px;</b> 时，200个CSS像素跨越了400个设备像素，如下图：\n\n![苹果视网膜屏幕的设备像素与CSS像素的关系](http://7xlolm.com1.z0.glb.clouddn.com/20150923px2.jpg)\n\n如果用户缩小页面，那么一个CSS像素会明显小于一个设备像素，这个时候 <b>width: 200px;</b> 这条样式中所设置的200个CSS像素跨越不了200个设备像素，如下图：\n\n![用户缩页面时设备像素与CSS像素的关系](http://7xlolm.com1.z0.glb.clouddn.com/20150923px3.jpg)\n\n让我们来做一个总结\n\n> 1、web前端领域，像素分为<b>设备像素</b>和<b>CSS像素</b>\n  3、一个CSS像素的大小是可变的，比如用后缩放页面的时候，实际上就是在缩小或放大CSS像素，而设备像素无论大小还是数量都是不变的。\n\n## 二、移动端的三个视口 ##\n\n一看标题，你是不是蒙了？三个视口？什么三个视口？先别急，让我们慢慢来讲。\n你一定写过这样一条样式：<b>width: 25%;</b> 但是你有想过给一个元素加上这样一条样式之后发生了什么吗？25%是基于谁的25%？明白的同学可能知道了：一个块元素默认的宽度是其父元素的100%，是基于起父元素的，所以25%指的是父元素宽度的25%，所以，<b>body</b>元素的默认宽度是<b>html</b>元素宽度的100%，那么你有没有想过<b>html</b>元素的宽度是基于谁的呢？这个时候，就要引出一个概念：<b style=\"color: red;\">初始包含块和视口了</b>\n\n记住一句话：<b>视口是html的父元素，所以我们称视口为初始包含块。</b> 这样你就明白了，html元素的百分比是基于视口的。\n\n### 第一个视口：布局视口 ###\n\n首先你需要了解一个原因：浏览器厂商是希望满足用户的要求的，即在手机也能浏览为PC端设计的网站，所以浏览器厂商必须想办法来在满足~\n在PC浏览器中，视口只有一个，并且 <b>视口的宽度</b> = <b>浏览器窗口的宽度</b>，但是在移动端也要根据这个来设计的话，那么PC端设计的网站在移动端看起来会很丑，因为PC端的网页宽度在800 ~ 1024个CSS像素，而手机屏幕要窄的多，这个时候再PC端25%的宽度在移动端看起来会很窄。所以，布局视口的概念产生了。\n\n布局是口：移动端CSS布局的依据视口，即CSS布局会根据布局视口来计算。\n也就是说，在移动端，视口和浏览器窗口将不在关联，实际上，布局视口要比浏览器窗口大的多(在手机和平板中浏览器布局视口的宽度在768~1024像素之间)，如下图（布局视口和窗口的关系）：\n\n![布局是口和浏览器窗口的关系](http://7xlolm.com1.z0.glb.clouddn.com/20150923px4.jpg)\n\n可以通过以下JavaScript代码获取布局视口的宽度和高度：\n\n```\ndocument.documentElement.clientWidth\ndocument.documentElement.clientHeight\n```\n\n### 第二个视口：视觉视口 ###\n\n视觉视口可能要更好理解一些，他就是用户正在看到网站的区域，如下图：\n\n![视觉视口](http://7xlolm.com1.z0.glb.clouddn.com/20150923px5.jpg)\n\n### 第三个视口：理想视口 ###\n\n理想视口，这是我们最需要关注的视口，现在我们来回顾一下我们知道了哪些视口，有两个，分别是：布局视口，视觉视口。\n我们前面提到过，布局视口的宽度一般在 680~1024像素之间，这样可以使得PC网站在手机中不被压扁，但是这并不理想，因为手机更适合窄的网站，换句话说，布局视口并不是最理想的宽度，所以，就引入了理想视口。\n\n理想视口，定义了理想视口的宽度，比如对于iphone5来讲，理想视口是320*568。但是最终作用的还是布局视口，因为我们的css是依据布局视口计算的，所以你可以这样理解理想视口：<b>理想的布局视口</b>。下面这段代码可以告诉手机浏览器要把布局视口设为理想视口：\n\n```\n<meta name=\"viewport\" content=\"width=device-width\" />\n```\n\n上面那段代码告诉浏览器：<b>将布局视口的宽度设为理想视口。</b>所以，上面代码中的width指的是布局视口的宽 device-width 实际上就是理想视口的宽度。\n\n好了，移动端的三个视口介绍完了，让我们总结一下：\n\n> 1、在PC端，布局视口就是浏览器窗口\n  2、在移动端，视口被分为两个：布局视口、视觉视口。\n  3、移动端还有一个理想视口，它是布局视口的理想尺寸，即理想的布局视口。（注：理想视口的尺寸因设备和浏览器的不同而不同，但这对于我们来说无所谓）\n  4、可以将布局视口的宽度设为理想视口\n\n## 三、设备像素比(DPR) ##\n\n下面你还需要了解一个概念，设备像素比(Device Pixel Ratio 简称：DPR)。\n下面是设备像素比的计算公式\n\n公式成立的大前提：<b style=\"color: red;\">（缩放比例为1）</b>\n<b>设备像素比(DPR) = 设备像素个数 / 理想视口CSS像素个数(device-width)</b>\n\n与理想视口一样，设备像素比对于不同的设备是不同的，但是他们都是合理的，比如早起iphone的设备像素是320px，理想视口也是320px，所以早起iphone的DPR=1，而后来iphone的设备像素为640px，理想视口还是320px，所以后来iphone的DPR=2。在开发中，打开浏览器的调试工具可以看到设备像素比，如下图：\n\n![chrome浏览器调试工具](http://7xlolm.com1.z0.glb.clouddn.com/20150923dpr.png)\n\n如上图，我们可以获得以下信息：\niPhone5的理想视口是：320\\*568 <==> device-width = 320，device-height = 568\niPhone5的设备像素比：2\n根据公式：<b>设备像素比(DPR) = 设备像素个数 / 理想视口CSS像素个数(device-width)</b>\n可知iPhone5的设备像素为 640\\*1136\n\n## 缩放 ##\n\n在讲设备像素比公式的时候讲到了：\n\n> 公式成立的大前提：<b style=\"color: red;\">（缩放比例为1）</b>\n  <b>设备像素比(DPR) = 设备像素个数 / 理想视口CSS像素个数(device-width)</b>\n\n那么缩放到底是什么呢？也许这个问题让你很疑惑，如果你自己阅读了前面的内容，你会注意到CSS像素的大小是可变得，而缩放从技术实现的角度来讲，就是放大或缩小CSS像素的过程，怎么样？明白了吧，当你用双指缩放页面的时候，实际上是在放大或缩小CSS像素，至于什么是CSS像素，晕，回去从头好好看~~~~~\n\n也学你会觉得缩放没什么，但是你了解这个概念至关重要，因为在《一篇真正教会你开发移动端页面的文章(二)》中，会用到这里的概念。即\n\n> 缩放：缩小放大的是 CSS像素。\n\n## meta标签 ##\n\nmeta视口标签存在的主要目的是为了让布局视口和理想视口的宽度匹配，meta视口标签应该放在HTML文档的head标签内，语法如下：\n\n```\n<meta name=\"viewport\" content=\"name=value,name=value\" />\n```\n\n其中 content 属性是一个字符串值，字符串是由逗号“，”分隔的 名/值 对组成，共有5个：\n\n> 1、width：设置布局视口的宽\n  2、init-scale：设置页面的初始缩放程度\n  3、minimum-scale：设置了页面最小缩放程度\n  4、maximum-scale：设置了页面最大缩放程度\n  5、user-scalable：是否允许用户对页面进行缩放操作\n\n下面是一个常用的meta标签实例\n\n```\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\">\n```\n\n上面代码的意思是，让布局视口的宽度等于理想视口的宽度，页面的初始缩放比例以及最大缩放比例都为1，且不允许用户对页面进行缩放操作。\n\n## 媒体查询 ##\n\n媒体查询是响应式设计的基础，他有以下三点作用：\n\n> 1、检测媒体的类型，比如 screen，tv等\n  2、检测布局视口的特性，比如视口的宽高分辨率等\n  3、特性相关查询，比如检测浏览器是否支持某某特性（这一点不讨论，因为它被目前浏览器支持的功能对于web开发来讲很无用）\n\ncss中使用媒体查询的语法：\n\n```\n@media 媒体类型 and (视口特性阀值){\n\t// 满足条件的css样式代码\n  \n}\n```\n\n下面是一段在css中使用媒体查询的示例:\n\n```\n@media all and (min-width: 321px) and (max-width: 400px){\n\t.box{\n\t\tbackground: red;\n\t}\n}\n```\n\n上面代码中，媒体类型为all，代表任何设备，并且设备的布局视口宽度大于等于321px且小于等于400px时，让拥有box类的元素背景变红。\n这里只是简单介绍了css3的媒体查询，但是用于本系列文章（我也呵呵了，其实就两篇文章这是第一篇，第二篇会尽快更新）已经足够用了，感兴趣或者希望获得更多css3 媒体查询知识的同学可以在网上查阅相关资料。\n\n经过6个小时的奋战，好吧，终于整理好了 《一篇真正教会你开发移动端页面的文章》系列文章的第一篇，这篇文章主要是为<a href=\"http://hcysun.me/2015/10/19/%E4%B8%80%E7%AF%87%E7%9C%9F%E6%AD%A3%E6%95%99%E4%BC%9A%E4%BD%A0%E5%BC%80%E5%8F%91%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%96%87%E7%AB%A0-%E4%BA%8C/\">第二篇</a>文章要将到的内容打基础，同学们如果不了解可以多阅读即便，如果有问题欢迎评论，我会及时回复的，另外，下一篇文章将会带来干货，真真正正的让大家掌握移动端页面的开发。如果你已经阅读到了这里，我对你表示感谢，你的坚持一定会得到回报，共勉。","source":"_posts/2015/10/16/一篇真正教会你开发移动端页面的文章(一).md","raw":"title: 一篇真正教会你开发移动端页面的文章(一)\ndate: 2015-10-16 10:22:14\ncategories:\n- WebFrontEnd\ntags:\n- css\n- html\n- 移动页面\n---\n\n# 一个移动端的时代 #\n\n> 从我工作以来，开发的一直都是移动端的页面，只有偶尔去开发几个PC端的页面，现在是一个移动端的时代，移动先行已经深入骨髓，作为一个web前端开发，如果你还在为如何开发移动端页面而迷茫，或者你还在为开发出了一个在你手机上“完美”的移动页面而沾沾自喜却不知移动的世界有多“残酷”的时候，那你应该看看这篇文章了。希望这能给你帮助，同时也能给我帮助，有不合理的地方，欢迎评论支持，必将改正。\n\n![移动端](http://7xlolm.com1.z0.glb.clouddn.com/20150923mobile.jpg)\n\n<!-- more -->\n\n# 这里是基础，你了解否？ #\n\n## 一、像素 - 什么是像素 ##\n\n像素是web页面布局的基础，那么到底什么才是一个像素呢？\n像素：<b>一个像素就是计算机屏幕所能显示一种特定颜色的最小区域。</b> 这是像素的概念，实际上，在web前端开发领域，像素有以下两层含义：\n1、<b>设备像素：</b>设备屏幕的物理像素，对于任何设备来讲物理像素的数量是固定的。\n2、<b>CSS像素：</b>这是一个抽象的像素概念，它是为web开发者创造的。\n\n如下图，是在缩放比例为1，即scale = 1的情况下，设备像素和CSS像素示意图\n\n![设备像素和CSS像素](http://7xlolm.com1.z0.glb.clouddn.com/20150923px1.jpg)\n\n现在你已经了解了，原来像素对于web前端开发来讲有这样的两层含义，那么你有没有再深入的考虑这样一个问题，当我给一个元素设置了 <b>width: 200px;</b> 这条样式的时候，到底放生了什么事情？\n你可能会说：“废话！元素的宽度是200px呗。”；对，并没有什么问题，但是这个200px指的是什么呢？因为我们知道，对于web前端来讲像素有两层含义，那么到底是设备像素还是CSS像素？实际上我们控制的是CSS像素，因为前面提到了，CSS像素是给我们web前端开发者创造的抽象概念。所以你要记住：<b>当你给元素设置了 width: 200px 时，这个元素的宽度跨越了200个CSS像素</b>。但是它并不一定跨越200个设备像素，至于会跨越多少个设备像素，就取决于<b>手机屏幕的特性</b>和<b>用户的缩放</b>了,举个栗子：\n\n苹果手机的视网膜屏幕，是一个高密度屏幕，它的像素密度是普通屏幕的2倍，所以当我们设置 <b>width: 200px;</b> 时，200个CSS像素跨越了400个设备像素，如下图：\n\n![苹果视网膜屏幕的设备像素与CSS像素的关系](http://7xlolm.com1.z0.glb.clouddn.com/20150923px2.jpg)\n\n如果用户缩小页面，那么一个CSS像素会明显小于一个设备像素，这个时候 <b>width: 200px;</b> 这条样式中所设置的200个CSS像素跨越不了200个设备像素，如下图：\n\n![用户缩页面时设备像素与CSS像素的关系](http://7xlolm.com1.z0.glb.clouddn.com/20150923px3.jpg)\n\n让我们来做一个总结\n\n> 1、web前端领域，像素分为<b>设备像素</b>和<b>CSS像素</b>\n  3、一个CSS像素的大小是可变的，比如用后缩放页面的时候，实际上就是在缩小或放大CSS像素，而设备像素无论大小还是数量都是不变的。\n\n## 二、移动端的三个视口 ##\n\n一看标题，你是不是蒙了？三个视口？什么三个视口？先别急，让我们慢慢来讲。\n你一定写过这样一条样式：<b>width: 25%;</b> 但是你有想过给一个元素加上这样一条样式之后发生了什么吗？25%是基于谁的25%？明白的同学可能知道了：一个块元素默认的宽度是其父元素的100%，是基于起父元素的，所以25%指的是父元素宽度的25%，所以，<b>body</b>元素的默认宽度是<b>html</b>元素宽度的100%，那么你有没有想过<b>html</b>元素的宽度是基于谁的呢？这个时候，就要引出一个概念：<b style=\"color: red;\">初始包含块和视口了</b>\n\n记住一句话：<b>视口是html的父元素，所以我们称视口为初始包含块。</b> 这样你就明白了，html元素的百分比是基于视口的。\n\n### 第一个视口：布局视口 ###\n\n首先你需要了解一个原因：浏览器厂商是希望满足用户的要求的，即在手机也能浏览为PC端设计的网站，所以浏览器厂商必须想办法来在满足~\n在PC浏览器中，视口只有一个，并且 <b>视口的宽度</b> = <b>浏览器窗口的宽度</b>，但是在移动端也要根据这个来设计的话，那么PC端设计的网站在移动端看起来会很丑，因为PC端的网页宽度在800 ~ 1024个CSS像素，而手机屏幕要窄的多，这个时候再PC端25%的宽度在移动端看起来会很窄。所以，布局视口的概念产生了。\n\n布局是口：移动端CSS布局的依据视口，即CSS布局会根据布局视口来计算。\n也就是说，在移动端，视口和浏览器窗口将不在关联，实际上，布局视口要比浏览器窗口大的多(在手机和平板中浏览器布局视口的宽度在768~1024像素之间)，如下图（布局视口和窗口的关系）：\n\n![布局是口和浏览器窗口的关系](http://7xlolm.com1.z0.glb.clouddn.com/20150923px4.jpg)\n\n可以通过以下JavaScript代码获取布局视口的宽度和高度：\n\n```\ndocument.documentElement.clientWidth\ndocument.documentElement.clientHeight\n```\n\n### 第二个视口：视觉视口 ###\n\n视觉视口可能要更好理解一些，他就是用户正在看到网站的区域，如下图：\n\n![视觉视口](http://7xlolm.com1.z0.glb.clouddn.com/20150923px5.jpg)\n\n### 第三个视口：理想视口 ###\n\n理想视口，这是我们最需要关注的视口，现在我们来回顾一下我们知道了哪些视口，有两个，分别是：布局视口，视觉视口。\n我们前面提到过，布局视口的宽度一般在 680~1024像素之间，这样可以使得PC网站在手机中不被压扁，但是这并不理想，因为手机更适合窄的网站，换句话说，布局视口并不是最理想的宽度，所以，就引入了理想视口。\n\n理想视口，定义了理想视口的宽度，比如对于iphone5来讲，理想视口是320*568。但是最终作用的还是布局视口，因为我们的css是依据布局视口计算的，所以你可以这样理解理想视口：<b>理想的布局视口</b>。下面这段代码可以告诉手机浏览器要把布局视口设为理想视口：\n\n```\n<meta name=\"viewport\" content=\"width=device-width\" />\n```\n\n上面那段代码告诉浏览器：<b>将布局视口的宽度设为理想视口。</b>所以，上面代码中的width指的是布局视口的宽 device-width 实际上就是理想视口的宽度。\n\n好了，移动端的三个视口介绍完了，让我们总结一下：\n\n> 1、在PC端，布局视口就是浏览器窗口\n  2、在移动端，视口被分为两个：布局视口、视觉视口。\n  3、移动端还有一个理想视口，它是布局视口的理想尺寸，即理想的布局视口。（注：理想视口的尺寸因设备和浏览器的不同而不同，但这对于我们来说无所谓）\n  4、可以将布局视口的宽度设为理想视口\n\n## 三、设备像素比(DPR) ##\n\n下面你还需要了解一个概念，设备像素比(Device Pixel Ratio 简称：DPR)。\n下面是设备像素比的计算公式\n\n公式成立的大前提：<b style=\"color: red;\">（缩放比例为1）</b>\n<b>设备像素比(DPR) = 设备像素个数 / 理想视口CSS像素个数(device-width)</b>\n\n与理想视口一样，设备像素比对于不同的设备是不同的，但是他们都是合理的，比如早起iphone的设备像素是320px，理想视口也是320px，所以早起iphone的DPR=1，而后来iphone的设备像素为640px，理想视口还是320px，所以后来iphone的DPR=2。在开发中，打开浏览器的调试工具可以看到设备像素比，如下图：\n\n![chrome浏览器调试工具](http://7xlolm.com1.z0.glb.clouddn.com/20150923dpr.png)\n\n如上图，我们可以获得以下信息：\niPhone5的理想视口是：320\\*568 <==> device-width = 320，device-height = 568\niPhone5的设备像素比：2\n根据公式：<b>设备像素比(DPR) = 设备像素个数 / 理想视口CSS像素个数(device-width)</b>\n可知iPhone5的设备像素为 640\\*1136\n\n## 缩放 ##\n\n在讲设备像素比公式的时候讲到了：\n\n> 公式成立的大前提：<b style=\"color: red;\">（缩放比例为1）</b>\n  <b>设备像素比(DPR) = 设备像素个数 / 理想视口CSS像素个数(device-width)</b>\n\n那么缩放到底是什么呢？也许这个问题让你很疑惑，如果你自己阅读了前面的内容，你会注意到CSS像素的大小是可变得，而缩放从技术实现的角度来讲，就是放大或缩小CSS像素的过程，怎么样？明白了吧，当你用双指缩放页面的时候，实际上是在放大或缩小CSS像素，至于什么是CSS像素，晕，回去从头好好看~~~~~\n\n也学你会觉得缩放没什么，但是你了解这个概念至关重要，因为在《一篇真正教会你开发移动端页面的文章(二)》中，会用到这里的概念。即\n\n> 缩放：缩小放大的是 CSS像素。\n\n## meta标签 ##\n\nmeta视口标签存在的主要目的是为了让布局视口和理想视口的宽度匹配，meta视口标签应该放在HTML文档的head标签内，语法如下：\n\n```\n<meta name=\"viewport\" content=\"name=value,name=value\" />\n```\n\n其中 content 属性是一个字符串值，字符串是由逗号“，”分隔的 名/值 对组成，共有5个：\n\n> 1、width：设置布局视口的宽\n  2、init-scale：设置页面的初始缩放程度\n  3、minimum-scale：设置了页面最小缩放程度\n  4、maximum-scale：设置了页面最大缩放程度\n  5、user-scalable：是否允许用户对页面进行缩放操作\n\n下面是一个常用的meta标签实例\n\n```\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\">\n```\n\n上面代码的意思是，让布局视口的宽度等于理想视口的宽度，页面的初始缩放比例以及最大缩放比例都为1，且不允许用户对页面进行缩放操作。\n\n## 媒体查询 ##\n\n媒体查询是响应式设计的基础，他有以下三点作用：\n\n> 1、检测媒体的类型，比如 screen，tv等\n  2、检测布局视口的特性，比如视口的宽高分辨率等\n  3、特性相关查询，比如检测浏览器是否支持某某特性（这一点不讨论，因为它被目前浏览器支持的功能对于web开发来讲很无用）\n\ncss中使用媒体查询的语法：\n\n```\n@media 媒体类型 and (视口特性阀值){\n\t// 满足条件的css样式代码\n  \n}\n```\n\n下面是一段在css中使用媒体查询的示例:\n\n```\n@media all and (min-width: 321px) and (max-width: 400px){\n\t.box{\n\t\tbackground: red;\n\t}\n}\n```\n\n上面代码中，媒体类型为all，代表任何设备，并且设备的布局视口宽度大于等于321px且小于等于400px时，让拥有box类的元素背景变红。\n这里只是简单介绍了css3的媒体查询，但是用于本系列文章（我也呵呵了，其实就两篇文章这是第一篇，第二篇会尽快更新）已经足够用了，感兴趣或者希望获得更多css3 媒体查询知识的同学可以在网上查阅相关资料。\n\n经过6个小时的奋战，好吧，终于整理好了 《一篇真正教会你开发移动端页面的文章》系列文章的第一篇，这篇文章主要是为<a href=\"http://hcysun.me/2015/10/19/%E4%B8%80%E7%AF%87%E7%9C%9F%E6%AD%A3%E6%95%99%E4%BC%9A%E4%BD%A0%E5%BC%80%E5%8F%91%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%96%87%E7%AB%A0-%E4%BA%8C/\">第二篇</a>文章要将到的内容打基础，同学们如果不了解可以多阅读即便，如果有问题欢迎评论，我会及时回复的，另外，下一篇文章将会带来干货，真真正正的让大家掌握移动端页面的开发。如果你已经阅读到了这里，我对你表示感谢，你的坚持一定会得到回报，共勉。","slug":"一篇真正教会你开发移动端页面的文章(一)","published":1,"updated":"2017-07-17T12:58:23.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj669fsjk000fewfcsk545e0m","content":"<h1 id=\"一个移动端的时代\"><a href=\"#一个移动端的时代\" class=\"headerlink\" title=\"一个移动端的时代\"></a>一个移动端的时代</h1><blockquote>\n<p>从我工作以来，开发的一直都是移动端的页面，只有偶尔去开发几个PC端的页面，现在是一个移动端的时代，移动先行已经深入骨髓，作为一个web前端开发，如果你还在为如何开发移动端页面而迷茫，或者你还在为开发出了一个在你手机上“完美”的移动页面而沾沾自喜却不知移动的世界有多“残酷”的时候，那你应该看看这篇文章了。希望这能给你帮助，同时也能给我帮助，有不合理的地方，欢迎评论支持，必将改正。</p>\n</blockquote>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20150923mobile.jpg\" alt=\"移动端\"></p>\n<a id=\"more\"></a>\n<h1 id=\"这里是基础，你了解否？\"><a href=\"#这里是基础，你了解否？\" class=\"headerlink\" title=\"这里是基础，你了解否？\"></a>这里是基础，你了解否？</h1><h2 id=\"一、像素-什么是像素\"><a href=\"#一、像素-什么是像素\" class=\"headerlink\" title=\"一、像素 - 什么是像素\"></a>一、像素 - 什么是像素</h2><p>像素是web页面布局的基础，那么到底什么才是一个像素呢？<br>像素：<b>一个像素就是计算机屏幕所能显示一种特定颜色的最小区域。</b> 这是像素的概念，实际上，在web前端开发领域，像素有以下两层含义：<br>1、<b>设备像素：</b>设备屏幕的物理像素，对于任何设备来讲物理像素的数量是固定的。<br>2、<b>CSS像素：</b>这是一个抽象的像素概念，它是为web开发者创造的。</p>\n<p>如下图，是在缩放比例为1，即scale = 1的情况下，设备像素和CSS像素示意图</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20150923px1.jpg\" alt=\"设备像素和CSS像素\"></p>\n<p>现在你已经了解了，原来像素对于web前端开发来讲有这样的两层含义，那么你有没有再深入的考虑这样一个问题，当我给一个元素设置了 <b>width: 200px;</b> 这条样式的时候，到底放生了什么事情？<br>你可能会说：“废话！元素的宽度是200px呗。”；对，并没有什么问题，但是这个200px指的是什么呢？因为我们知道，对于web前端来讲像素有两层含义，那么到底是设备像素还是CSS像素？实际上我们控制的是CSS像素，因为前面提到了，CSS像素是给我们web前端开发者创造的抽象概念。所以你要记住：<b>当你给元素设置了 width: 200px 时，这个元素的宽度跨越了200个CSS像素</b>。但是它并不一定跨越200个设备像素，至于会跨越多少个设备像素，就取决于<b>手机屏幕的特性</b>和<b>用户的缩放</b>了,举个栗子：</p>\n<p>苹果手机的视网膜屏幕，是一个高密度屏幕，它的像素密度是普通屏幕的2倍，所以当我们设置 <b>width: 200px;</b> 时，200个CSS像素跨越了400个设备像素，如下图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20150923px2.jpg\" alt=\"苹果视网膜屏幕的设备像素与CSS像素的关系\"></p>\n<p>如果用户缩小页面，那么一个CSS像素会明显小于一个设备像素，这个时候 <b>width: 200px;</b> 这条样式中所设置的200个CSS像素跨越不了200个设备像素，如下图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20150923px3.jpg\" alt=\"用户缩页面时设备像素与CSS像素的关系\"></p>\n<p>让我们来做一个总结</p>\n<blockquote>\n<p>1、web前端领域，像素分为<b>设备像素</b>和<b>CSS像素</b><br>  3、一个CSS像素的大小是可变的，比如用后缩放页面的时候，实际上就是在缩小或放大CSS像素，而设备像素无论大小还是数量都是不变的。</p>\n</blockquote>\n<h2 id=\"二、移动端的三个视口\"><a href=\"#二、移动端的三个视口\" class=\"headerlink\" title=\"二、移动端的三个视口\"></a>二、移动端的三个视口</h2><p>一看标题，你是不是蒙了？三个视口？什么三个视口？先别急，让我们慢慢来讲。<br>你一定写过这样一条样式：<b>width: 25%;</b> 但是你有想过给一个元素加上这样一条样式之后发生了什么吗？25%是基于谁的25%？明白的同学可能知道了：一个块元素默认的宽度是其父元素的100%，是基于起父元素的，所以25%指的是父元素宽度的25%，所以，<b>body</b>元素的默认宽度是<b>html</b>元素宽度的100%，那么你有没有想过<b>html</b>元素的宽度是基于谁的呢？这个时候，就要引出一个概念：<b style=\"color: red;\">初始包含块和视口了</b></p>\n<p>记住一句话：<b>视口是html的父元素，所以我们称视口为初始包含块。</b> 这样你就明白了，html元素的百分比是基于视口的。</p>\n<h3 id=\"第一个视口：布局视口\"><a href=\"#第一个视口：布局视口\" class=\"headerlink\" title=\"第一个视口：布局视口\"></a>第一个视口：布局视口</h3><p>首先你需要了解一个原因：浏览器厂商是希望满足用户的要求的，即在手机也能浏览为PC端设计的网站，所以浏览器厂商必须想办法来在满足~<br>在PC浏览器中，视口只有一个，并且 <b>视口的宽度</b> = <b>浏览器窗口的宽度</b>，但是在移动端也要根据这个来设计的话，那么PC端设计的网站在移动端看起来会很丑，因为PC端的网页宽度在800 ~ 1024个CSS像素，而手机屏幕要窄的多，这个时候再PC端25%的宽度在移动端看起来会很窄。所以，布局视口的概念产生了。</p>\n<p>布局是口：移动端CSS布局的依据视口，即CSS布局会根据布局视口来计算。<br>也就是说，在移动端，视口和浏览器窗口将不在关联，实际上，布局视口要比浏览器窗口大的多(在手机和平板中浏览器布局视口的宽度在768~1024像素之间)，如下图（布局视口和窗口的关系）：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20150923px4.jpg\" alt=\"布局是口和浏览器窗口的关系\"></p>\n<p>可以通过以下JavaScript代码获取布局视口的宽度和高度：</p>\n<pre><code>document.documentElement.clientWidth\ndocument.documentElement.clientHeight\n</code></pre><h3 id=\"第二个视口：视觉视口\"><a href=\"#第二个视口：视觉视口\" class=\"headerlink\" title=\"第二个视口：视觉视口\"></a>第二个视口：视觉视口</h3><p>视觉视口可能要更好理解一些，他就是用户正在看到网站的区域，如下图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20150923px5.jpg\" alt=\"视觉视口\"></p>\n<h3 id=\"第三个视口：理想视口\"><a href=\"#第三个视口：理想视口\" class=\"headerlink\" title=\"第三个视口：理想视口\"></a>第三个视口：理想视口</h3><p>理想视口，这是我们最需要关注的视口，现在我们来回顾一下我们知道了哪些视口，有两个，分别是：布局视口，视觉视口。<br>我们前面提到过，布局视口的宽度一般在 680~1024像素之间，这样可以使得PC网站在手机中不被压扁，但是这并不理想，因为手机更适合窄的网站，换句话说，布局视口并不是最理想的宽度，所以，就引入了理想视口。</p>\n<p>理想视口，定义了理想视口的宽度，比如对于iphone5来讲，理想视口是320*568。但是最终作用的还是布局视口，因为我们的css是依据布局视口计算的，所以你可以这样理解理想视口：<b>理想的布局视口</b>。下面这段代码可以告诉手机浏览器要把布局视口设为理想视口：</p>\n<pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot; /&gt;\n</code></pre><p>上面那段代码告诉浏览器：<b>将布局视口的宽度设为理想视口。</b>所以，上面代码中的width指的是布局视口的宽 device-width 实际上就是理想视口的宽度。</p>\n<p>好了，移动端的三个视口介绍完了，让我们总结一下：</p>\n<blockquote>\n<p>1、在PC端，布局视口就是浏览器窗口<br>  2、在移动端，视口被分为两个：布局视口、视觉视口。<br>  3、移动端还有一个理想视口，它是布局视口的理想尺寸，即理想的布局视口。（注：理想视口的尺寸因设备和浏览器的不同而不同，但这对于我们来说无所谓）<br>  4、可以将布局视口的宽度设为理想视口</p>\n</blockquote>\n<h2 id=\"三、设备像素比-DPR\"><a href=\"#三、设备像素比-DPR\" class=\"headerlink\" title=\"三、设备像素比(DPR)\"></a>三、设备像素比(DPR)</h2><p>下面你还需要了解一个概念，设备像素比(Device Pixel Ratio 简称：DPR)。<br>下面是设备像素比的计算公式</p>\n<p>公式成立的大前提：<b style=\"color: red;\">（缩放比例为1）</b><br><b>设备像素比(DPR) = 设备像素个数 / 理想视口CSS像素个数(device-width)</b></p>\n<p>与理想视口一样，设备像素比对于不同的设备是不同的，但是他们都是合理的，比如早起iphone的设备像素是320px，理想视口也是320px，所以早起iphone的DPR=1，而后来iphone的设备像素为640px，理想视口还是320px，所以后来iphone的DPR=2。在开发中，打开浏览器的调试工具可以看到设备像素比，如下图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20150923dpr.png\" alt=\"chrome浏览器调试工具\"></p>\n<p>如上图，我们可以获得以下信息：<br>iPhone5的理想视口是：320*568 &lt;==&gt; device-width = 320，device-height = 568<br>iPhone5的设备像素比：2<br>根据公式：<b>设备像素比(DPR) = 设备像素个数 / 理想视口CSS像素个数(device-width)</b><br>可知iPhone5的设备像素为 640*1136</p>\n<h2 id=\"缩放\"><a href=\"#缩放\" class=\"headerlink\" title=\"缩放\"></a>缩放</h2><p>在讲设备像素比公式的时候讲到了：</p>\n<blockquote>\n<p>公式成立的大前提：<b style=\"color: red;\">（缩放比例为1）</b><br>  <b>设备像素比(DPR) = 设备像素个数 / 理想视口CSS像素个数(device-width)</b></p>\n</blockquote>\n<p>那么缩放到底是什么呢？也许这个问题让你很疑惑，如果你自己阅读了前面的内容，你会注意到CSS像素的大小是可变得，而缩放从技术实现的角度来讲，就是放大或缩小CSS像素的过程，怎么样？明白了吧，当你用双指缩放页面的时候，实际上是在放大或缩小CSS像素，至于什么是CSS像素，晕，回去从头好好看<del>~</del></p>\n<p>也学你会觉得缩放没什么，但是你了解这个概念至关重要，因为在《一篇真正教会你开发移动端页面的文章(二)》中，会用到这里的概念。即</p>\n<blockquote>\n<p>缩放：缩小放大的是 CSS像素。</p>\n</blockquote>\n<h2 id=\"meta标签\"><a href=\"#meta标签\" class=\"headerlink\" title=\"meta标签\"></a>meta标签</h2><p>meta视口标签存在的主要目的是为了让布局视口和理想视口的宽度匹配，meta视口标签应该放在HTML文档的head标签内，语法如下：</p>\n<pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;name=value,name=value&quot; /&gt;\n</code></pre><p>其中 content 属性是一个字符串值，字符串是由逗号“，”分隔的 名/值 对组成，共有5个：</p>\n<blockquote>\n<p>1、width：设置布局视口的宽<br>  2、init-scale：设置页面的初始缩放程度<br>  3、minimum-scale：设置了页面最小缩放程度<br>  4、maximum-scale：设置了页面最大缩放程度<br>  5、user-scalable：是否允许用户对页面进行缩放操作</p>\n</blockquote>\n<p>下面是一个常用的meta标签实例</p>\n<pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&gt;\n</code></pre><p>上面代码的意思是，让布局视口的宽度等于理想视口的宽度，页面的初始缩放比例以及最大缩放比例都为1，且不允许用户对页面进行缩放操作。</p>\n<h2 id=\"媒体查询\"><a href=\"#媒体查询\" class=\"headerlink\" title=\"媒体查询\"></a>媒体查询</h2><p>媒体查询是响应式设计的基础，他有以下三点作用：</p>\n<blockquote>\n<p>1、检测媒体的类型，比如 screen，tv等<br>  2、检测布局视口的特性，比如视口的宽高分辨率等<br>  3、特性相关查询，比如检测浏览器是否支持某某特性（这一点不讨论，因为它被目前浏览器支持的功能对于web开发来讲很无用）</p>\n</blockquote>\n<p>css中使用媒体查询的语法：</p>\n<pre><code>@media 媒体类型 and (视口特性阀值){\n    // 满足条件的css样式代码\n\n}\n</code></pre><p>下面是一段在css中使用媒体查询的示例:</p>\n<pre><code>@media all and (min-width: 321px) and (max-width: 400px){\n    .box{\n        background: red;\n    }\n}\n</code></pre><p>上面代码中，媒体类型为all，代表任何设备，并且设备的布局视口宽度大于等于321px且小于等于400px时，让拥有box类的元素背景变红。<br>这里只是简单介绍了css3的媒体查询，但是用于本系列文章（我也呵呵了，其实就两篇文章这是第一篇，第二篇会尽快更新）已经足够用了，感兴趣或者希望获得更多css3 媒体查询知识的同学可以在网上查阅相关资料。</p>\n<p>经过6个小时的奋战，好吧，终于整理好了 《一篇真正教会你开发移动端页面的文章》系列文章的第一篇，这篇文章主要是为<a href=\"http://hcysun.me/2015/10/19/%E4%B8%80%E7%AF%87%E7%9C%9F%E6%AD%A3%E6%95%99%E4%BC%9A%E4%BD%A0%E5%BC%80%E5%8F%91%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%96%87%E7%AB%A0-%E4%BA%8C/\">第二篇</a>文章要将到的内容打基础，同学们如果不了解可以多阅读即便，如果有问题欢迎评论，我会及时回复的，另外，下一篇文章将会带来干货，真真正正的让大家掌握移动端页面的开发。如果你已经阅读到了这里，我对你表示感谢，你的坚持一定会得到回报，共勉。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"一个移动端的时代\"><a href=\"#一个移动端的时代\" class=\"headerlink\" title=\"一个移动端的时代\"></a>一个移动端的时代</h1><blockquote>\n<p>从我工作以来，开发的一直都是移动端的页面，只有偶尔去开发几个PC端的页面，现在是一个移动端的时代，移动先行已经深入骨髓，作为一个web前端开发，如果你还在为如何开发移动端页面而迷茫，或者你还在为开发出了一个在你手机上“完美”的移动页面而沾沾自喜却不知移动的世界有多“残酷”的时候，那你应该看看这篇文章了。希望这能给你帮助，同时也能给我帮助，有不合理的地方，欢迎评论支持，必将改正。</p>\n</blockquote>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20150923mobile.jpg\" alt=\"移动端\"></p>","more":"<h1 id=\"这里是基础，你了解否？\"><a href=\"#这里是基础，你了解否？\" class=\"headerlink\" title=\"这里是基础，你了解否？\"></a>这里是基础，你了解否？</h1><h2 id=\"一、像素-什么是像素\"><a href=\"#一、像素-什么是像素\" class=\"headerlink\" title=\"一、像素 - 什么是像素\"></a>一、像素 - 什么是像素</h2><p>像素是web页面布局的基础，那么到底什么才是一个像素呢？<br>像素：<b>一个像素就是计算机屏幕所能显示一种特定颜色的最小区域。</b> 这是像素的概念，实际上，在web前端开发领域，像素有以下两层含义：<br>1、<b>设备像素：</b>设备屏幕的物理像素，对于任何设备来讲物理像素的数量是固定的。<br>2、<b>CSS像素：</b>这是一个抽象的像素概念，它是为web开发者创造的。</p>\n<p>如下图，是在缩放比例为1，即scale = 1的情况下，设备像素和CSS像素示意图</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20150923px1.jpg\" alt=\"设备像素和CSS像素\"></p>\n<p>现在你已经了解了，原来像素对于web前端开发来讲有这样的两层含义，那么你有没有再深入的考虑这样一个问题，当我给一个元素设置了 <b>width: 200px;</b> 这条样式的时候，到底放生了什么事情？<br>你可能会说：“废话！元素的宽度是200px呗。”；对，并没有什么问题，但是这个200px指的是什么呢？因为我们知道，对于web前端来讲像素有两层含义，那么到底是设备像素还是CSS像素？实际上我们控制的是CSS像素，因为前面提到了，CSS像素是给我们web前端开发者创造的抽象概念。所以你要记住：<b>当你给元素设置了 width: 200px 时，这个元素的宽度跨越了200个CSS像素</b>。但是它并不一定跨越200个设备像素，至于会跨越多少个设备像素，就取决于<b>手机屏幕的特性</b>和<b>用户的缩放</b>了,举个栗子：</p>\n<p>苹果手机的视网膜屏幕，是一个高密度屏幕，它的像素密度是普通屏幕的2倍，所以当我们设置 <b>width: 200px;</b> 时，200个CSS像素跨越了400个设备像素，如下图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20150923px2.jpg\" alt=\"苹果视网膜屏幕的设备像素与CSS像素的关系\"></p>\n<p>如果用户缩小页面，那么一个CSS像素会明显小于一个设备像素，这个时候 <b>width: 200px;</b> 这条样式中所设置的200个CSS像素跨越不了200个设备像素，如下图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20150923px3.jpg\" alt=\"用户缩页面时设备像素与CSS像素的关系\"></p>\n<p>让我们来做一个总结</p>\n<blockquote>\n<p>1、web前端领域，像素分为<b>设备像素</b>和<b>CSS像素</b><br>  3、一个CSS像素的大小是可变的，比如用后缩放页面的时候，实际上就是在缩小或放大CSS像素，而设备像素无论大小还是数量都是不变的。</p>\n</blockquote>\n<h2 id=\"二、移动端的三个视口\"><a href=\"#二、移动端的三个视口\" class=\"headerlink\" title=\"二、移动端的三个视口\"></a>二、移动端的三个视口</h2><p>一看标题，你是不是蒙了？三个视口？什么三个视口？先别急，让我们慢慢来讲。<br>你一定写过这样一条样式：<b>width: 25%;</b> 但是你有想过给一个元素加上这样一条样式之后发生了什么吗？25%是基于谁的25%？明白的同学可能知道了：一个块元素默认的宽度是其父元素的100%，是基于起父元素的，所以25%指的是父元素宽度的25%，所以，<b>body</b>元素的默认宽度是<b>html</b>元素宽度的100%，那么你有没有想过<b>html</b>元素的宽度是基于谁的呢？这个时候，就要引出一个概念：<b style=\"color: red;\">初始包含块和视口了</b></p>\n<p>记住一句话：<b>视口是html的父元素，所以我们称视口为初始包含块。</b> 这样你就明白了，html元素的百分比是基于视口的。</p>\n<h3 id=\"第一个视口：布局视口\"><a href=\"#第一个视口：布局视口\" class=\"headerlink\" title=\"第一个视口：布局视口\"></a>第一个视口：布局视口</h3><p>首先你需要了解一个原因：浏览器厂商是希望满足用户的要求的，即在手机也能浏览为PC端设计的网站，所以浏览器厂商必须想办法来在满足~<br>在PC浏览器中，视口只有一个，并且 <b>视口的宽度</b> = <b>浏览器窗口的宽度</b>，但是在移动端也要根据这个来设计的话，那么PC端设计的网站在移动端看起来会很丑，因为PC端的网页宽度在800 ~ 1024个CSS像素，而手机屏幕要窄的多，这个时候再PC端25%的宽度在移动端看起来会很窄。所以，布局视口的概念产生了。</p>\n<p>布局是口：移动端CSS布局的依据视口，即CSS布局会根据布局视口来计算。<br>也就是说，在移动端，视口和浏览器窗口将不在关联，实际上，布局视口要比浏览器窗口大的多(在手机和平板中浏览器布局视口的宽度在768~1024像素之间)，如下图（布局视口和窗口的关系）：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20150923px4.jpg\" alt=\"布局是口和浏览器窗口的关系\"></p>\n<p>可以通过以下JavaScript代码获取布局视口的宽度和高度：</p>\n<pre><code>document.documentElement.clientWidth\ndocument.documentElement.clientHeight\n</code></pre><h3 id=\"第二个视口：视觉视口\"><a href=\"#第二个视口：视觉视口\" class=\"headerlink\" title=\"第二个视口：视觉视口\"></a>第二个视口：视觉视口</h3><p>视觉视口可能要更好理解一些，他就是用户正在看到网站的区域，如下图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20150923px5.jpg\" alt=\"视觉视口\"></p>\n<h3 id=\"第三个视口：理想视口\"><a href=\"#第三个视口：理想视口\" class=\"headerlink\" title=\"第三个视口：理想视口\"></a>第三个视口：理想视口</h3><p>理想视口，这是我们最需要关注的视口，现在我们来回顾一下我们知道了哪些视口，有两个，分别是：布局视口，视觉视口。<br>我们前面提到过，布局视口的宽度一般在 680~1024像素之间，这样可以使得PC网站在手机中不被压扁，但是这并不理想，因为手机更适合窄的网站，换句话说，布局视口并不是最理想的宽度，所以，就引入了理想视口。</p>\n<p>理想视口，定义了理想视口的宽度，比如对于iphone5来讲，理想视口是320*568。但是最终作用的还是布局视口，因为我们的css是依据布局视口计算的，所以你可以这样理解理想视口：<b>理想的布局视口</b>。下面这段代码可以告诉手机浏览器要把布局视口设为理想视口：</p>\n<pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot; /&gt;\n</code></pre><p>上面那段代码告诉浏览器：<b>将布局视口的宽度设为理想视口。</b>所以，上面代码中的width指的是布局视口的宽 device-width 实际上就是理想视口的宽度。</p>\n<p>好了，移动端的三个视口介绍完了，让我们总结一下：</p>\n<blockquote>\n<p>1、在PC端，布局视口就是浏览器窗口<br>  2、在移动端，视口被分为两个：布局视口、视觉视口。<br>  3、移动端还有一个理想视口，它是布局视口的理想尺寸，即理想的布局视口。（注：理想视口的尺寸因设备和浏览器的不同而不同，但这对于我们来说无所谓）<br>  4、可以将布局视口的宽度设为理想视口</p>\n</blockquote>\n<h2 id=\"三、设备像素比-DPR\"><a href=\"#三、设备像素比-DPR\" class=\"headerlink\" title=\"三、设备像素比(DPR)\"></a>三、设备像素比(DPR)</h2><p>下面你还需要了解一个概念，设备像素比(Device Pixel Ratio 简称：DPR)。<br>下面是设备像素比的计算公式</p>\n<p>公式成立的大前提：<b style=\"color: red;\">（缩放比例为1）</b><br><b>设备像素比(DPR) = 设备像素个数 / 理想视口CSS像素个数(device-width)</b></p>\n<p>与理想视口一样，设备像素比对于不同的设备是不同的，但是他们都是合理的，比如早起iphone的设备像素是320px，理想视口也是320px，所以早起iphone的DPR=1，而后来iphone的设备像素为640px，理想视口还是320px，所以后来iphone的DPR=2。在开发中，打开浏览器的调试工具可以看到设备像素比，如下图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20150923dpr.png\" alt=\"chrome浏览器调试工具\"></p>\n<p>如上图，我们可以获得以下信息：<br>iPhone5的理想视口是：320*568 &lt;==&gt; device-width = 320，device-height = 568<br>iPhone5的设备像素比：2<br>根据公式：<b>设备像素比(DPR) = 设备像素个数 / 理想视口CSS像素个数(device-width)</b><br>可知iPhone5的设备像素为 640*1136</p>\n<h2 id=\"缩放\"><a href=\"#缩放\" class=\"headerlink\" title=\"缩放\"></a>缩放</h2><p>在讲设备像素比公式的时候讲到了：</p>\n<blockquote>\n<p>公式成立的大前提：<b style=\"color: red;\">（缩放比例为1）</b><br>  <b>设备像素比(DPR) = 设备像素个数 / 理想视口CSS像素个数(device-width)</b></p>\n</blockquote>\n<p>那么缩放到底是什么呢？也许这个问题让你很疑惑，如果你自己阅读了前面的内容，你会注意到CSS像素的大小是可变得，而缩放从技术实现的角度来讲，就是放大或缩小CSS像素的过程，怎么样？明白了吧，当你用双指缩放页面的时候，实际上是在放大或缩小CSS像素，至于什么是CSS像素，晕，回去从头好好看<del>~</del></p>\n<p>也学你会觉得缩放没什么，但是你了解这个概念至关重要，因为在《一篇真正教会你开发移动端页面的文章(二)》中，会用到这里的概念。即</p>\n<blockquote>\n<p>缩放：缩小放大的是 CSS像素。</p>\n</blockquote>\n<h2 id=\"meta标签\"><a href=\"#meta标签\" class=\"headerlink\" title=\"meta标签\"></a>meta标签</h2><p>meta视口标签存在的主要目的是为了让布局视口和理想视口的宽度匹配，meta视口标签应该放在HTML文档的head标签内，语法如下：</p>\n<pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;name=value,name=value&quot; /&gt;\n</code></pre><p>其中 content 属性是一个字符串值，字符串是由逗号“，”分隔的 名/值 对组成，共有5个：</p>\n<blockquote>\n<p>1、width：设置布局视口的宽<br>  2、init-scale：设置页面的初始缩放程度<br>  3、minimum-scale：设置了页面最小缩放程度<br>  4、maximum-scale：设置了页面最大缩放程度<br>  5、user-scalable：是否允许用户对页面进行缩放操作</p>\n</blockquote>\n<p>下面是一个常用的meta标签实例</p>\n<pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&gt;\n</code></pre><p>上面代码的意思是，让布局视口的宽度等于理想视口的宽度，页面的初始缩放比例以及最大缩放比例都为1，且不允许用户对页面进行缩放操作。</p>\n<h2 id=\"媒体查询\"><a href=\"#媒体查询\" class=\"headerlink\" title=\"媒体查询\"></a>媒体查询</h2><p>媒体查询是响应式设计的基础，他有以下三点作用：</p>\n<blockquote>\n<p>1、检测媒体的类型，比如 screen，tv等<br>  2、检测布局视口的特性，比如视口的宽高分辨率等<br>  3、特性相关查询，比如检测浏览器是否支持某某特性（这一点不讨论，因为它被目前浏览器支持的功能对于web开发来讲很无用）</p>\n</blockquote>\n<p>css中使用媒体查询的语法：</p>\n<pre><code>@media 媒体类型 and (视口特性阀值){\n    // 满足条件的css样式代码\n\n}\n</code></pre><p>下面是一段在css中使用媒体查询的示例:</p>\n<pre><code>@media all and (min-width: 321px) and (max-width: 400px){\n    .box{\n        background: red;\n    }\n}\n</code></pre><p>上面代码中，媒体类型为all，代表任何设备，并且设备的布局视口宽度大于等于321px且小于等于400px时，让拥有box类的元素背景变红。<br>这里只是简单介绍了css3的媒体查询，但是用于本系列文章（我也呵呵了，其实就两篇文章这是第一篇，第二篇会尽快更新）已经足够用了，感兴趣或者希望获得更多css3 媒体查询知识的同学可以在网上查阅相关资料。</p>\n<p>经过6个小时的奋战，好吧，终于整理好了 《一篇真正教会你开发移动端页面的文章》系列文章的第一篇，这篇文章主要是为<a href=\"http://hcysun.me/2015/10/19/%E4%B8%80%E7%AF%87%E7%9C%9F%E6%AD%A3%E6%95%99%E4%BC%9A%E4%BD%A0%E5%BC%80%E5%8F%91%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%96%87%E7%AB%A0-%E4%BA%8C/\">第二篇</a>文章要将到的内容打基础，同学们如果不了解可以多阅读即便，如果有问题欢迎评论，我会及时回复的，另外，下一篇文章将会带来干货，真真正正的让大家掌握移动端页面的开发。如果你已经阅读到了这里，我对你表示感谢，你的坚持一定会得到回报，共勉。</p>"},{"title":"一篇真正教会你开发移动端页面的文章(二)","date":"2015-10-19T06:56:12.000Z","_content":"\n# 移动端开发的干货篇 #\n\n> 之前写了一篇文章<a href=\"http://hcysun.me/2015/10/16/%E4%B8%80%E7%AF%87%E7%9C%9F%E6%AD%A3%E6%95%99%E4%BC%9A%E4%BD%A0%E5%BC%80%E5%8F%91%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%96%87%E7%AB%A0(%E4%B8%80)/\">《一篇真正教会你开发移动端一面的文章(一)》</a>。那是本篇文章的基础，如果没有阅读过的同学可以去看看，今天就给大家带来干货，真真正正的讲到如何很好的开发一个移动端的页面\n\n![移动端](http://7xlolm.com1.z0.glb.clouddn.com/20150923mobile.jpg)\n\n<!-- more -->\n\n好了，让我们开始吧，从哪里开始呢？从设计图开始，即PSD稿件：\n移动端PSD稿件的尺寸肯定较之PC端的PSD稿件不同，具体体现在设计图的尺寸上，现在移动端的设计图尺寸大多以iPhone5和iPhone6的设备像素尺寸作为依据，比如拿到一张PSD设计图，它的总宽度为640px(iPhone5)或者750px(iPhone6)。本例就拿iPhone6的设计图尺寸为标准进行讲解，其它设计图尺寸道理是一样的，这并不影响我们的开发。\n\n首先我们要有一张设计图才行，看下图，假设我们有一张设计图，它很简单，只有一个红色的方块：\n\n![psd稿](http://7xlolm.com1.z0.glb.clouddn.com/20150923psd1.jpg)\n\n拿到了设计图，于是你开开心心的开始写代码了，你打开了编辑器，并写下了如下HTML代码：\n\n```\n<!DOCTYPE html>\n<html>\n<head>\n\t<title></title>\n\t<meta charset=\"utf-8\" />\n\t<meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no\" />\n</head>\n<body>\n\n\t<div class=\"box\"></div>\n\n</body>\n</html>\n```\n\nHTML代码写好了，你用了一个带有box类的div标签作为ps稿中的红色块，经过尺寸测量，你为上面代码添加了CSS样式，最后你的代码是这样的：\n\n```\n<!DOCTYPE html>\n<html>\n<head>\n\t<title></title>\n\t<meta charset=\"utf-8\" />\n\t<meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no\" />\n\t<style>\n\tbody{\n\t\tmargin: 0;\n\t\tpadding: 0;\n\t}\n\t.box{\n\t\twidth: 200px;\n\t\theight: 200px;\n\t\tbackground: red;\n\t}\n\t</style>\n</head>\n<body>\n\n\t<div class=\"box\"></div>\n\n</body>\n</html>\n```\n\n上面的代码中，你只是在原来的基础上增加了CSS样式，首先你清除了body标签上的默认样式，这个没什么好说的，然后你根据设计图中测量的尺寸来给box编写样式，宽200px;高200px;背景红色。看上去并没有什么问题，于是你开开心心的打开浏览器，刷新页面，你的脸色沉了下来，因为你看到了你不想看到的结果，如下图，上图为设计稿的样式，下图为你编写的html文件的样式：\n\n![psd原稿](http://7xlolm.com1.z0.glb.clouddn.com/20150923psd2.jpg)\n\n![html页面](http://7xlolm.com1.z0.glb.clouddn.com/20150923ht1.jpg)\n\n通过对比psd原稿和我们目前所写的html页面，可以看出我们html页面的问题，红色方块与整个页面的比例和psd原稿不一样啊，那么为什么我们明明是按照原稿测量的尺寸写出来的代码却和psd原稿显示的效果不一样呢？别忘了，psd原稿的尺寸是按照设备像素设计的，由于我们所用的设计稿是基于iPhone6设计的，所以我们设计稿的尺寸就是iPhone6的设备像素的尺寸，也就是750px，而我们CSS中的样式是基于布局视口的尺寸计算的，由于我们html页面中由于写入了以下meta标签：\n\n```\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no\" />\n```\n\n在上一篇我们讲过，* width=device-width * 这段代码是让布局视口的尺寸等于理想视口。\n根据公式(缩放比例为1)：\n<b>设备像素比（DPR） = 设备像素个数 / 理想视口像素个数（device-width）</b>\n因为iPhone6的DPR（设备像素比）为2，设备像素为750，所以iPhone6的理想视口尺寸为375px。所以上面代码最终导致的是：使我们布局视口的宽度变成了375px。而我们CSS中编写的样式尺寸又是基于布局视口计算的，所以我们得到的页面看上去比例不对，如下图：\n\n![布局视口宽度和元素宽度](http://7xlolm.com1.z0.glb.clouddn.com/20150923ht2.jpg)\n![psd设计稿宽度和元素宽度](http://7xlolm.com1.z0.glb.clouddn.com/20150923psd3.jpg)\n\n如上面两幅图片，我们知道，psd稿的总宽是750px，元素宽200px，而我们真正做页面的时候，布局视口的宽度是375px，正好是设计稿的一半。所以我们不能直接使用设计稿上面测量所得的像素尺寸，根据比例，我们应该将测量所得的尺寸除以2，才是我们CSS中布局所用的尺寸，据此，我们将200px除以2得到100px，于是我们修改代码，将红色方块的宽高都设为100px，刷新页面，看看比例是不是和设计图一样了？答案是肯定的，如下图为修改后的html页面：\n\n![修改后的html页面](http://7xlolm.com1.z0.glb.clouddn.com/20150923ht3.jpg)\n\n这样，我们就得到了正确的数据，并且正确的写出了页面，你很高兴，可是问题来了，如果你在做页面的时候，测量了一个元素的宽度，宽度是一个奇数，比如111像素，按照我们之前的做法是，将测量到的数据除以2，得到我们真正使用的数据，所以111除以2等于55.5px，我们知道，计算机(手机)没办法显示不到一个像素的像素值，计算机(手机)会自动将其补全为一个像素进行显示，所以最终会将元素显示为56像素，这并不是我们想要的结果。\n另外，我们的设计稿是基于iphone6设计的，我们调试页面也是在iphone6下调试的。又因为iphone6的设备像素比试2，所以我们才能由设计稿测量的数据除以2后直接使用，并且在iphone6下没有问题，但是你要知道，并不是所有手机的设备像素比都是2，有的手机的设备像素比试2.5或者3。并且不同设备的设备像素又不同，这样就导致理想视口的尺寸不同，从而导致布局视口的尺寸不同，那么我们直接根据iphone6的设计稿尺寸除以2得到的尺寸用来编写CSS是不能在所有设备下完好显示的。\n\n所以，我们要换一个方法。\n于是我们想到：如果我们能将布局视口的尺寸设置为和设备像素尺寸相等的话，这样我们就保证了设计图与页面的1:1关系，那么我们就可以直接使用psd中测量的尺寸了，然后在其他尺寸的手机中，我们进行等比缩放就ok了。那么如何才能让布局视口的尺寸等于设备像素尺寸呢？\n\n我们注意到meta标签中的 width=device-width 这段代码，首先你要明白这句话的意思，前面讲过，这句话最终导致的结果是：让布局视口的尺寸等于理想视口的尺寸。言外之意就是,在代码 width=device-width 中：\n\nwidth：是布局视口的width\ndevice-width：是理想视口的宽度\n\n根据公式(缩放比例为1)：\n\n<b>设备像素比（DPR） = 设备像素个数 / 理想视口像素个数（device-width）</b>\n\n以iphone6为例：\n设备像素比（DPR）：2\n设备像素个数：750\n所以在缩放比例为1的情况下，iphone6理想视口的像素个数为 750 / 2 = 375，也就是说，对于iphone6来讲 device-width的值为375\n\n所以我们通过width=device-width这句话，间接的将布局视口的尺寸设为了375，也就是说，如果我们能改变理想视口的尺寸，也就改变了布局适口的尺寸，如何改变理想视口的尺寸呢？这就要讲到缩放了，上一篇我们讲到过缩放，缩放是缩小或放大CSS像素的过程，以iphone6为例，当我们缩放比例为1:1的时候，由于iphone6的设备像素比为2，所以iphone6的设备像素与CSS像素的关系看起来就像下图这样：\n\n![iphone6下缩放比例为1时，设备像素与CSS像素的关系](http://7xlolm.com1.z0.glb.clouddn.com/2015092319a.jpg)\n\n一个CSS像素宽度等于两个设备像素宽度，所以750px的设备宽度的布局视口为357CSS像素。这是在缩放比例为1的情况下，既然缩放可以放大或缩小CSS像素，所以如果我们将CSS像素的宽度缩放至与设备像素宽度相等了，那么750个设备像素也就能显示750个CSS像素，缩放后的设备像素与CSS像素看起来应该像下图这样：\n\n![iphone6缩小0.5倍后，设备像素与CSS像素的关系](http://7xlolm.com1.z0.glb.clouddn.com/20150923px1.jpg)\n\n但是，我们的缩放倍数是多少呢？在缩放比例为1的时候，一个CSS像素的宽度 = 两个设备像素的宽度，如果我们想让 一个CSS像素的宽度 = 一个设备像素的宽度，我们就要将CSS像素缩小为原来的0.5倍，实际上，我们缩小的倍数 = 设备像素比的倒数。\n于是，我们修改上面的HTML代码(修改了meta标签)：\n\n```\n<html>\n<head>\n\t<title></title>\n\t<meta charset=\"utf-8\" />\n\t<meta name=\"viewport\" content=\"width=device-width,initial-scale=0.5,maximum-scale=0.5,user-scalable=no\" />\n\t<style>\n\tbody{\n\t\tmargin: 0;\n\t\tpadding: 0;\n\t}\n\t.box{\n\t\twidth: 200px;\n\t\theight: 200px;\n\t\tbackground: red;\n\t}\n\t</style>\n</head>\n<body>\n\n\t<div class=\"box\"></div>\n\n</body>\n</html>\n```\n\n注意，上面代码中我们给红色方块使用的CSS尺寸直接使用的是psd稿中测量的尺寸，我们刷新页面，怎么样？满意吧：\n\n![修改后的新页面正确输出](http://7xlolm.com1.z0.glb.clouddn.com/2015092316b.jpg)\n\n但是我们这是有个前提的，那就是缩放0.5倍只适用于设备像素比为2的设备（因为缩放值 = 1 / 设备像素比）。所以，为了适应所有的设备，我们应该用javascript代码动态生成meta标签：\n\n```\nvar scale = 1 / window.devicePixelRatio;\ndocument.querySelector('meta[name=\"viewport\"]').setAttribute('content','width=device-width,initial-scale=' + scale + ', maximum-scale=' + scale + ', minimum-scale=' + scale + ', user-scalable=no');\n```\n\n其中 <b>window.devicePixelRatio</b> 的值为设备像素比。\n于是我们的代码变成了这样：\n\n```\n<html>\n<head>\n\t<title></title>\n\t<meta charset=\"utf-8\" />\n\t<meta name=\"viewport\" content=\"\" />\n\t<style>\n\tbody{\n\t\tmargin: 0;\n\t\tpadding: 0;\n\t}\n\t.box{\n\t\twidth: 200px;\n\t\theight: 200px;\n\t\tbackground: red;\n\t}\n\t</style>\n</head>\n<body>\n\n\t<div class=\"box\"></div>\n\n\t<script>\n\tvar scale = 1 / window.devicePixelRatio;\n\tdocument.querySelector('meta[name=\"viewport\"]').setAttribute('content','width=device-width,initial-scale=' + scale + ', maximum-scale=' + scale + ', minimum-scale=' + scale + ', user-scalable=no');\n\t</script>\n</body>\n</html>\n```\n\n上面的代码最终能保证一个问题，那就是无论任何设备，布局视口的宽度总是等于设备像素。\n这样，我们在设计图中测量为200px的宽度就能直接用在CSS中了，并且在iphone6中显示完好，可是别忘了，我们的设计图就是根据iphone6设计的，如果换做其他设备，还能显示完好么？我们不妨试一下，如下图，是上面代码在iphone5和iphone6下的对比：\n\n![iphone5中的效果](http://7xlolm.com1.z0.glb.clouddn.com/20150923p5.jpg)\n\n![iphone6中的效果](http://7xlolm.com1.z0.glb.clouddn.com/20150923p6.jpg)\n\n我们发现，无论是五还是6，即使设备像素变了，即屏幕宽度变了，可是红色方块的宽度并没有变，这并不是一个好的现象，因为这样页面的元素就不成比例了，会影响到布局，所以我们要想办法让我们页面的元素跟着设备变化而等比缩放，这就是我们要解决的第二个问题，怎么实现呢？这就要讲到rem的知识点了。\n\n## rem ##\n\n什么是rem？\nrem是相对尺寸单位，相对于html标签字体大小的单位，举个例子：\n如果html的font-size = 18px;\n那么1rem = 18px，需要记住的是，rem是基于html标签的字体大小的。\n\n相信你已经明白了，对没错，我们要把之前用px做元素尺寸的单位换成rem，所以，现在的问题就是如果转换，因为rem是根据html标签的font-size值确定的，所以我们只要确定html标签的font-size值就行了，我们首先自己定一个标准，就是让font-size的值等于设备像素的十分之一，即：\n\n```\ndocument.documentElement.style.fontSize = document.documentElement.clientWidth / 10 + 'px';\n```\n\n以iphone6为例，html标签的font-size的值就等于 750 / 10 = 75px 了，这样 1rem = 75px，所以红色方块200px换算为rem单位就是 200 / 75 = 2.6666667rem。\n那么在iphone5中呢？因为iphone5的设备像素为640，所以iphone的html标签的font-size的值为 640 / 10 = 64px，所以 1rem = 64px，所以在iphone6中显示为200px的元素在iphone5中会显示为 2.6666667 * 64 像素，这样，在不同设备中就实现了让元素等比缩放从而不影响布局。而上面的方法也是手机淘宝所用的方法。所以，现在你只需要将你测量的尺寸数据除以75就转换成了rem单位，如果是iPhone5就要除以64，即除以你动态设置的font-size的值。\n\n另外需要注意的是：做页面的时候文字字体大小不要用rem换算，还是使用px做单位。后面会讲到。\n\n让我们来总结一下我们现在了解的方法：\n\n1、将布局视口大小设为设备像素尺寸：\n\n```\nvar scale = 1 / window.devicePixelRatio;\ndocument.querySelector('meta[name=\"viewport\"]').setAttribute('content','width=device-width,initial-scale=' + scale + ', maximum-scale=' + scale + ', minimum-scale=' + scale + ', user-scalable=no');\n```\n\n2、动态设置html字体大小：\n\n```\ndocument.documentElement.style.fontSize = document.documentElement.clientWidth / 10 + 'px';\n```\n\n3、将设计图中的尺寸换算成rem\n\n元素的rem尺寸 = 元素的psd稿测量的像素尺寸 / 动态设置的html标签的font-size值\n\n说了一大堆，其实我们使用下面的html莫板就可以写页面了，唯一需要你做的就是计算元素的rem尺寸，所以即使你没看懂上面的讲述也不重要，你只要将莫板拿过去用就好了：\n\n```\n<html>\n<head>\n\t<title></title>\n\t<meta charset=\"utf-8\" />\n\t<meta name=\"viewport\" content=\"\" />\n</head>\n<body>\n\n\t\n\n\t<script>\n\tvar scale = 1 / window.devicePixelRatio;\n\tdocument.querySelector('meta[name=\"viewport\"]').setAttribute('content','width=device-width,initial-scale=' + scale + ', maximum-scale=' + scale + ', minimum-scale=' + scale + ', user-scalable=no');\n\n\tdocument.documentElement.style.fontSize = document.documentElement.clientWidth / 10 + 'px';\n\t</script>\n</body>\n</html>\n```\n\n现在我们使用上面的方法修改我们的代码如下：\n\n```\n<html>\n<head>\n\t<title></title>\n\t<meta charset=\"utf-8\" />\n\t<meta name=\"viewport\" content=\"\" />\n\t<style>\n\tbody{\n\t\tmargin: 0;\n\t\tpadding: 0;\n\t}\n\t.box{\n\t\twidth: 2.66666667rem;\n\t\theight: 2.66666667rem;\n\t\tbackground: red;\n\t}\n\t</style>\n</head>\n<body>\n\n\t<div class=\"box\"></div>\n\n\t<script>\n\tvar scale = 1 / window.devicePixelRatio;\n\tdocument.querySelector('meta[name=\"viewport\"]').setAttribute('content','width=device-width,initial-scale=' + scale + ', maximum-scale=' + scale + ', minimum-scale=' + scale + ', user-scalable=no');\n\n\tdocument.documentElement.style.fontSize = document.documentElement.clientWidth / 10 + 'px';\n\t</script>\n</body>\n</html>\n```\n\n打开浏览器，分别在iPhone6和iPhone5下查看页面，我们会发现，现在的元素可以根据手机的尺寸不同而等比缩放了。\n\n上面的方法是手机淘宝的方法，有一个缺点，就是转化rem单位的时候，需要除以font-size的值，淘宝用的是iPhone6的设计图，所以淘宝转换尺寸的时候要除以75，这个值可不好算，所以还要借用计算器来完成，影响开发效率，另外，在转还rem单位时遇到除不尽的数时我们会采用很长的近似值比如上面的2.6666667rem，这样可能会使页面元素的尺寸有偏差。\n\n除了上面的方法比较通用之外，还有一种方式，我们来重新思考一下：\n\n上面做页面的思路是：拿到设计图，比如iPhone6的设计图，我们就将浏览器设置到iPhone6设备调试，然后使用js动态修改meta标签，使布局视口的尺寸等于设计图尺寸，也就是设备像素尺寸，然后使用rem替代px做尺寸代为，使得页面在不同设备中等比缩放。\n\n现在假如我们不去修改meta标签，正常使用缩放为1:1的meta标签，即使用如下meta标签：\n\n```\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no\" />\n```\n\n还以iPhone6为例，我们知道，在缩放为1:1的情况下，根据公式：\n\n<b>设备像素比（DPR） = 设备像素个数 / 理想视口像素个数（device-width）</b>\n\n我们知道：\n设备像素 = 设计图尺寸 = 750px\n布局视口 = 375px\n\n假设我们以iPhone6设计图尺寸为标准，在设计图的尺寸下设置一个font-size值为100px。\n也就是说：750px宽的页面，我们设置100px的font-size值，那么页面的宽度换算为rem就等于 750 / 100 = 7.5rem。\n\n我们就以页面总宽为7.5rem为标准，那么在布局视口中，也就是页面总宽为375px下，font-size值应该是多少？很简单：\n\nfont-size = 375 / 7.5 = 50px\n\n那么在iPhone5下呢？因为iPhone5的布局视口宽为320px，所以如果页面总宽以7.5为标准，那么iPhone5下我们设置的font-size值应该是：\n\nfont-size = 320 / 7.5 =42.666666667px\n\n也就是说，不管在什么设备下，我们都可以把页面的总宽度设为一个以rem为单位的定值，比如本例就是7.5rem，只不过，我们需要根据布局视口的尺寸动态设置font-size的值：\n\n```\ndocument.documentElement.style.fontSize = document.documentElement.clientWidth / 7.5 + 'px';\n```\n\n这样，无论在什么设备下，我们页面的总宽度都是7.5rem，所以我们直接在设计图上测量px单位的尺寸，然后除以100转换成rem单位后直接使用就可以了，比如，在iPhone6设计图中测量一个元素的尺寸为200px，那么转换成rem单位就是 200 / 100 = 2rem，因为在不同设备下我们动态设置了html标签的font-size值，所以不同设备下相同的rem值对应的像素值是不同的，这样就实现了在不同设备下等比缩放。我们修改html代码如下：\n\n```\n<html>\n<head>\n\t<title></title>\n\t<meta charset=\"utf-8\" />\n\t<meta name=\"viewport\" content=\"width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no\" />\n\t<style>\n\tbody{\n\t\tmargin: 0;\n\t\tpadding: 0;\n\t}\n\t.box{\n\t\twidth: 2rem;\n\t\theight: 2rem;\n\t\tbackground: red;\n\t}\n\t</style>\n</head>\n<body>\n\n\t<div class=\"box\"></div>\n\n\t<script>\n\tdocument.documentElement.style.fontSize = document.documentElement.clientWidth / 7.5 + 'px';\n\t</script>\n</body>\n</html>\n```\n\n刷新页面，分别在iPhone6和iPhone5下调试查看结果，会发现如下图，使我们想要的效果，等比缩放，ok，实际上这种做法也是网易的做法：\n\n![iPhone6下显示效果](http://7xlolm.com1.z0.glb.clouddn.com/2015092320a.jpg)\n\n![iPhone5下显示效果](http://7xlolm.com1.z0.glb.clouddn.com/2015092320b.jpg)\n\n下面，我们来总结一下第二种做法：\n\n1、拿到设计图，计算出页面的总宽，为了好计算，取100px的font-size，如果设计图是iPhone6的那么计算出的就是7.5rem，如果页面是iPhone5的那么计算出的结果就是6.4rem。\n2、动态设置html标签的font-size值：\n  ```\n  document.documentElement.style.fontSize = document.documentElement.clientWidth / 以rem为单位的页面总宽 + 'px';\n  ```\n  如iPhone6的设计图就是：\n  ```\n  document.documentElement.style.fontSize = document.documentElement.clientWidth / 7.5 + 'px';\n  ```\n  iPhone5的设计图就是：\n  ```\n  document.documentElement.style.fontSize = document.documentElement.clientWidth / 6.4 + 'px';\n  ```\n3、做页面是测量设计图的px尺寸除以100得到rem尺寸。\n4、和淘宝的做法一样，文字字体大小不要使用rem换算。\n\n下面是这种做法的html莫板：\n\n```\n<html>\n<head>\n\t<title></title>\n\t<meta charset=\"utf-8\" />\n\t<meta name=\"viewport\" content=\"width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no\" />\n</head>\n<body>\n\n\t\n\n\t<script>\n\tdocument.documentElement.style.fontSize = document.documentElement.clientWidth / 7.5 + 'px';\n\t</script>\n</body>\n</html>\n```\n\n由于这种做法在开发中换算rem单位的时候只需要将测量的尺寸除以100即可，所以不需要使用计算器我们就可以很快的完成计算转换，所以这也会提升开发效率，本人也比较青睐这种做法。\n\n另外，无论是第一种做法还是第二种做法，我们都提到了，文字字体大小是不要换算成rem做单位的，而是使用媒体查询来进行动态设置，比如下面的代码就是网易的代码：\n\n代码片段一：\n\n```\n@media screen and (max-width: 321px) {\n    body {\n        font-size:16px\n    }\n}\n\n@media screen and (min-width: 321px) and (max-width:400px) {\n    body {\n        font-size:17px\n    }\n}\n\n@media screen and (min-width: 400px) {\n    body {\n        font-size:19px\n    }\n}\n```\n\n代码片段二：\n\n```\n@media screen and (max-width: 321px) {\n    header,footer {\n        font-size:16px\n    }\n}\n\n@media screen and (min-width: 321px) and (max-width:400px) {\n    header,footer {\n        font-size:17px\n    }\n}\n\n@media screen and (min-width: 400px) {\n    header,footer {\n        font-size:19px\n    }\n}\n```\n\n我们总结一下网易在文字字体大小上的做法，在媒体查询阶段，分为三个等级分别是：\n321px以下\n321px - 400px之间\n400px以上\n\n具体文字大小要多少个像素这个以设计图为准，但是这三个等级之间是有规律的，仔细观察发现，321px以下的屏幕字体大小比321px - 400px之间的屏幕字体大小要小一个像素，而321px - 400px之间的屏幕字体大小要比400以上屏幕字体大小要小2个像素。依照这个规律，我们根据设计图所在的像素区段先写好该区段的字体大小，然后分别写出另外两个区段的字体大小媒体查询代码就可以了。\n\n终于码完了这第二篇文章，无力再多说其他的话，望对大家有帮助，有些细节地方没有细说，另外作者水平有限，希望大家指正共同进步，谢谢。","source":"_posts/2015/10/19/一篇真正教会你开发移动端页面的文章-二.md","raw":"title: 一篇真正教会你开发移动端页面的文章(二)\ndate: 2015-10-19 14:56:12\ncategories:\n- WebFrontEnd\ntags:\n- css\n- html\n- 移动页面\n---\n\n# 移动端开发的干货篇 #\n\n> 之前写了一篇文章<a href=\"http://hcysun.me/2015/10/16/%E4%B8%80%E7%AF%87%E7%9C%9F%E6%AD%A3%E6%95%99%E4%BC%9A%E4%BD%A0%E5%BC%80%E5%8F%91%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%96%87%E7%AB%A0(%E4%B8%80)/\">《一篇真正教会你开发移动端一面的文章(一)》</a>。那是本篇文章的基础，如果没有阅读过的同学可以去看看，今天就给大家带来干货，真真正正的讲到如何很好的开发一个移动端的页面\n\n![移动端](http://7xlolm.com1.z0.glb.clouddn.com/20150923mobile.jpg)\n\n<!-- more -->\n\n好了，让我们开始吧，从哪里开始呢？从设计图开始，即PSD稿件：\n移动端PSD稿件的尺寸肯定较之PC端的PSD稿件不同，具体体现在设计图的尺寸上，现在移动端的设计图尺寸大多以iPhone5和iPhone6的设备像素尺寸作为依据，比如拿到一张PSD设计图，它的总宽度为640px(iPhone5)或者750px(iPhone6)。本例就拿iPhone6的设计图尺寸为标准进行讲解，其它设计图尺寸道理是一样的，这并不影响我们的开发。\n\n首先我们要有一张设计图才行，看下图，假设我们有一张设计图，它很简单，只有一个红色的方块：\n\n![psd稿](http://7xlolm.com1.z0.glb.clouddn.com/20150923psd1.jpg)\n\n拿到了设计图，于是你开开心心的开始写代码了，你打开了编辑器，并写下了如下HTML代码：\n\n```\n<!DOCTYPE html>\n<html>\n<head>\n\t<title></title>\n\t<meta charset=\"utf-8\" />\n\t<meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no\" />\n</head>\n<body>\n\n\t<div class=\"box\"></div>\n\n</body>\n</html>\n```\n\nHTML代码写好了，你用了一个带有box类的div标签作为ps稿中的红色块，经过尺寸测量，你为上面代码添加了CSS样式，最后你的代码是这样的：\n\n```\n<!DOCTYPE html>\n<html>\n<head>\n\t<title></title>\n\t<meta charset=\"utf-8\" />\n\t<meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no\" />\n\t<style>\n\tbody{\n\t\tmargin: 0;\n\t\tpadding: 0;\n\t}\n\t.box{\n\t\twidth: 200px;\n\t\theight: 200px;\n\t\tbackground: red;\n\t}\n\t</style>\n</head>\n<body>\n\n\t<div class=\"box\"></div>\n\n</body>\n</html>\n```\n\n上面的代码中，你只是在原来的基础上增加了CSS样式，首先你清除了body标签上的默认样式，这个没什么好说的，然后你根据设计图中测量的尺寸来给box编写样式，宽200px;高200px;背景红色。看上去并没有什么问题，于是你开开心心的打开浏览器，刷新页面，你的脸色沉了下来，因为你看到了你不想看到的结果，如下图，上图为设计稿的样式，下图为你编写的html文件的样式：\n\n![psd原稿](http://7xlolm.com1.z0.glb.clouddn.com/20150923psd2.jpg)\n\n![html页面](http://7xlolm.com1.z0.glb.clouddn.com/20150923ht1.jpg)\n\n通过对比psd原稿和我们目前所写的html页面，可以看出我们html页面的问题，红色方块与整个页面的比例和psd原稿不一样啊，那么为什么我们明明是按照原稿测量的尺寸写出来的代码却和psd原稿显示的效果不一样呢？别忘了，psd原稿的尺寸是按照设备像素设计的，由于我们所用的设计稿是基于iPhone6设计的，所以我们设计稿的尺寸就是iPhone6的设备像素的尺寸，也就是750px，而我们CSS中的样式是基于布局视口的尺寸计算的，由于我们html页面中由于写入了以下meta标签：\n\n```\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no\" />\n```\n\n在上一篇我们讲过，* width=device-width * 这段代码是让布局视口的尺寸等于理想视口。\n根据公式(缩放比例为1)：\n<b>设备像素比（DPR） = 设备像素个数 / 理想视口像素个数（device-width）</b>\n因为iPhone6的DPR（设备像素比）为2，设备像素为750，所以iPhone6的理想视口尺寸为375px。所以上面代码最终导致的是：使我们布局视口的宽度变成了375px。而我们CSS中编写的样式尺寸又是基于布局视口计算的，所以我们得到的页面看上去比例不对，如下图：\n\n![布局视口宽度和元素宽度](http://7xlolm.com1.z0.glb.clouddn.com/20150923ht2.jpg)\n![psd设计稿宽度和元素宽度](http://7xlolm.com1.z0.glb.clouddn.com/20150923psd3.jpg)\n\n如上面两幅图片，我们知道，psd稿的总宽是750px，元素宽200px，而我们真正做页面的时候，布局视口的宽度是375px，正好是设计稿的一半。所以我们不能直接使用设计稿上面测量所得的像素尺寸，根据比例，我们应该将测量所得的尺寸除以2，才是我们CSS中布局所用的尺寸，据此，我们将200px除以2得到100px，于是我们修改代码，将红色方块的宽高都设为100px，刷新页面，看看比例是不是和设计图一样了？答案是肯定的，如下图为修改后的html页面：\n\n![修改后的html页面](http://7xlolm.com1.z0.glb.clouddn.com/20150923ht3.jpg)\n\n这样，我们就得到了正确的数据，并且正确的写出了页面，你很高兴，可是问题来了，如果你在做页面的时候，测量了一个元素的宽度，宽度是一个奇数，比如111像素，按照我们之前的做法是，将测量到的数据除以2，得到我们真正使用的数据，所以111除以2等于55.5px，我们知道，计算机(手机)没办法显示不到一个像素的像素值，计算机(手机)会自动将其补全为一个像素进行显示，所以最终会将元素显示为56像素，这并不是我们想要的结果。\n另外，我们的设计稿是基于iphone6设计的，我们调试页面也是在iphone6下调试的。又因为iphone6的设备像素比试2，所以我们才能由设计稿测量的数据除以2后直接使用，并且在iphone6下没有问题，但是你要知道，并不是所有手机的设备像素比都是2，有的手机的设备像素比试2.5或者3。并且不同设备的设备像素又不同，这样就导致理想视口的尺寸不同，从而导致布局视口的尺寸不同，那么我们直接根据iphone6的设计稿尺寸除以2得到的尺寸用来编写CSS是不能在所有设备下完好显示的。\n\n所以，我们要换一个方法。\n于是我们想到：如果我们能将布局视口的尺寸设置为和设备像素尺寸相等的话，这样我们就保证了设计图与页面的1:1关系，那么我们就可以直接使用psd中测量的尺寸了，然后在其他尺寸的手机中，我们进行等比缩放就ok了。那么如何才能让布局视口的尺寸等于设备像素尺寸呢？\n\n我们注意到meta标签中的 width=device-width 这段代码，首先你要明白这句话的意思，前面讲过，这句话最终导致的结果是：让布局视口的尺寸等于理想视口的尺寸。言外之意就是,在代码 width=device-width 中：\n\nwidth：是布局视口的width\ndevice-width：是理想视口的宽度\n\n根据公式(缩放比例为1)：\n\n<b>设备像素比（DPR） = 设备像素个数 / 理想视口像素个数（device-width）</b>\n\n以iphone6为例：\n设备像素比（DPR）：2\n设备像素个数：750\n所以在缩放比例为1的情况下，iphone6理想视口的像素个数为 750 / 2 = 375，也就是说，对于iphone6来讲 device-width的值为375\n\n所以我们通过width=device-width这句话，间接的将布局视口的尺寸设为了375，也就是说，如果我们能改变理想视口的尺寸，也就改变了布局适口的尺寸，如何改变理想视口的尺寸呢？这就要讲到缩放了，上一篇我们讲到过缩放，缩放是缩小或放大CSS像素的过程，以iphone6为例，当我们缩放比例为1:1的时候，由于iphone6的设备像素比为2，所以iphone6的设备像素与CSS像素的关系看起来就像下图这样：\n\n![iphone6下缩放比例为1时，设备像素与CSS像素的关系](http://7xlolm.com1.z0.glb.clouddn.com/2015092319a.jpg)\n\n一个CSS像素宽度等于两个设备像素宽度，所以750px的设备宽度的布局视口为357CSS像素。这是在缩放比例为1的情况下，既然缩放可以放大或缩小CSS像素，所以如果我们将CSS像素的宽度缩放至与设备像素宽度相等了，那么750个设备像素也就能显示750个CSS像素，缩放后的设备像素与CSS像素看起来应该像下图这样：\n\n![iphone6缩小0.5倍后，设备像素与CSS像素的关系](http://7xlolm.com1.z0.glb.clouddn.com/20150923px1.jpg)\n\n但是，我们的缩放倍数是多少呢？在缩放比例为1的时候，一个CSS像素的宽度 = 两个设备像素的宽度，如果我们想让 一个CSS像素的宽度 = 一个设备像素的宽度，我们就要将CSS像素缩小为原来的0.5倍，实际上，我们缩小的倍数 = 设备像素比的倒数。\n于是，我们修改上面的HTML代码(修改了meta标签)：\n\n```\n<html>\n<head>\n\t<title></title>\n\t<meta charset=\"utf-8\" />\n\t<meta name=\"viewport\" content=\"width=device-width,initial-scale=0.5,maximum-scale=0.5,user-scalable=no\" />\n\t<style>\n\tbody{\n\t\tmargin: 0;\n\t\tpadding: 0;\n\t}\n\t.box{\n\t\twidth: 200px;\n\t\theight: 200px;\n\t\tbackground: red;\n\t}\n\t</style>\n</head>\n<body>\n\n\t<div class=\"box\"></div>\n\n</body>\n</html>\n```\n\n注意，上面代码中我们给红色方块使用的CSS尺寸直接使用的是psd稿中测量的尺寸，我们刷新页面，怎么样？满意吧：\n\n![修改后的新页面正确输出](http://7xlolm.com1.z0.glb.clouddn.com/2015092316b.jpg)\n\n但是我们这是有个前提的，那就是缩放0.5倍只适用于设备像素比为2的设备（因为缩放值 = 1 / 设备像素比）。所以，为了适应所有的设备，我们应该用javascript代码动态生成meta标签：\n\n```\nvar scale = 1 / window.devicePixelRatio;\ndocument.querySelector('meta[name=\"viewport\"]').setAttribute('content','width=device-width,initial-scale=' + scale + ', maximum-scale=' + scale + ', minimum-scale=' + scale + ', user-scalable=no');\n```\n\n其中 <b>window.devicePixelRatio</b> 的值为设备像素比。\n于是我们的代码变成了这样：\n\n```\n<html>\n<head>\n\t<title></title>\n\t<meta charset=\"utf-8\" />\n\t<meta name=\"viewport\" content=\"\" />\n\t<style>\n\tbody{\n\t\tmargin: 0;\n\t\tpadding: 0;\n\t}\n\t.box{\n\t\twidth: 200px;\n\t\theight: 200px;\n\t\tbackground: red;\n\t}\n\t</style>\n</head>\n<body>\n\n\t<div class=\"box\"></div>\n\n\t<script>\n\tvar scale = 1 / window.devicePixelRatio;\n\tdocument.querySelector('meta[name=\"viewport\"]').setAttribute('content','width=device-width,initial-scale=' + scale + ', maximum-scale=' + scale + ', minimum-scale=' + scale + ', user-scalable=no');\n\t</script>\n</body>\n</html>\n```\n\n上面的代码最终能保证一个问题，那就是无论任何设备，布局视口的宽度总是等于设备像素。\n这样，我们在设计图中测量为200px的宽度就能直接用在CSS中了，并且在iphone6中显示完好，可是别忘了，我们的设计图就是根据iphone6设计的，如果换做其他设备，还能显示完好么？我们不妨试一下，如下图，是上面代码在iphone5和iphone6下的对比：\n\n![iphone5中的效果](http://7xlolm.com1.z0.glb.clouddn.com/20150923p5.jpg)\n\n![iphone6中的效果](http://7xlolm.com1.z0.glb.clouddn.com/20150923p6.jpg)\n\n我们发现，无论是五还是6，即使设备像素变了，即屏幕宽度变了，可是红色方块的宽度并没有变，这并不是一个好的现象，因为这样页面的元素就不成比例了，会影响到布局，所以我们要想办法让我们页面的元素跟着设备变化而等比缩放，这就是我们要解决的第二个问题，怎么实现呢？这就要讲到rem的知识点了。\n\n## rem ##\n\n什么是rem？\nrem是相对尺寸单位，相对于html标签字体大小的单位，举个例子：\n如果html的font-size = 18px;\n那么1rem = 18px，需要记住的是，rem是基于html标签的字体大小的。\n\n相信你已经明白了，对没错，我们要把之前用px做元素尺寸的单位换成rem，所以，现在的问题就是如果转换，因为rem是根据html标签的font-size值确定的，所以我们只要确定html标签的font-size值就行了，我们首先自己定一个标准，就是让font-size的值等于设备像素的十分之一，即：\n\n```\ndocument.documentElement.style.fontSize = document.documentElement.clientWidth / 10 + 'px';\n```\n\n以iphone6为例，html标签的font-size的值就等于 750 / 10 = 75px 了，这样 1rem = 75px，所以红色方块200px换算为rem单位就是 200 / 75 = 2.6666667rem。\n那么在iphone5中呢？因为iphone5的设备像素为640，所以iphone的html标签的font-size的值为 640 / 10 = 64px，所以 1rem = 64px，所以在iphone6中显示为200px的元素在iphone5中会显示为 2.6666667 * 64 像素，这样，在不同设备中就实现了让元素等比缩放从而不影响布局。而上面的方法也是手机淘宝所用的方法。所以，现在你只需要将你测量的尺寸数据除以75就转换成了rem单位，如果是iPhone5就要除以64，即除以你动态设置的font-size的值。\n\n另外需要注意的是：做页面的时候文字字体大小不要用rem换算，还是使用px做单位。后面会讲到。\n\n让我们来总结一下我们现在了解的方法：\n\n1、将布局视口大小设为设备像素尺寸：\n\n```\nvar scale = 1 / window.devicePixelRatio;\ndocument.querySelector('meta[name=\"viewport\"]').setAttribute('content','width=device-width,initial-scale=' + scale + ', maximum-scale=' + scale + ', minimum-scale=' + scale + ', user-scalable=no');\n```\n\n2、动态设置html字体大小：\n\n```\ndocument.documentElement.style.fontSize = document.documentElement.clientWidth / 10 + 'px';\n```\n\n3、将设计图中的尺寸换算成rem\n\n元素的rem尺寸 = 元素的psd稿测量的像素尺寸 / 动态设置的html标签的font-size值\n\n说了一大堆，其实我们使用下面的html莫板就可以写页面了，唯一需要你做的就是计算元素的rem尺寸，所以即使你没看懂上面的讲述也不重要，你只要将莫板拿过去用就好了：\n\n```\n<html>\n<head>\n\t<title></title>\n\t<meta charset=\"utf-8\" />\n\t<meta name=\"viewport\" content=\"\" />\n</head>\n<body>\n\n\t\n\n\t<script>\n\tvar scale = 1 / window.devicePixelRatio;\n\tdocument.querySelector('meta[name=\"viewport\"]').setAttribute('content','width=device-width,initial-scale=' + scale + ', maximum-scale=' + scale + ', minimum-scale=' + scale + ', user-scalable=no');\n\n\tdocument.documentElement.style.fontSize = document.documentElement.clientWidth / 10 + 'px';\n\t</script>\n</body>\n</html>\n```\n\n现在我们使用上面的方法修改我们的代码如下：\n\n```\n<html>\n<head>\n\t<title></title>\n\t<meta charset=\"utf-8\" />\n\t<meta name=\"viewport\" content=\"\" />\n\t<style>\n\tbody{\n\t\tmargin: 0;\n\t\tpadding: 0;\n\t}\n\t.box{\n\t\twidth: 2.66666667rem;\n\t\theight: 2.66666667rem;\n\t\tbackground: red;\n\t}\n\t</style>\n</head>\n<body>\n\n\t<div class=\"box\"></div>\n\n\t<script>\n\tvar scale = 1 / window.devicePixelRatio;\n\tdocument.querySelector('meta[name=\"viewport\"]').setAttribute('content','width=device-width,initial-scale=' + scale + ', maximum-scale=' + scale + ', minimum-scale=' + scale + ', user-scalable=no');\n\n\tdocument.documentElement.style.fontSize = document.documentElement.clientWidth / 10 + 'px';\n\t</script>\n</body>\n</html>\n```\n\n打开浏览器，分别在iPhone6和iPhone5下查看页面，我们会发现，现在的元素可以根据手机的尺寸不同而等比缩放了。\n\n上面的方法是手机淘宝的方法，有一个缺点，就是转化rem单位的时候，需要除以font-size的值，淘宝用的是iPhone6的设计图，所以淘宝转换尺寸的时候要除以75，这个值可不好算，所以还要借用计算器来完成，影响开发效率，另外，在转还rem单位时遇到除不尽的数时我们会采用很长的近似值比如上面的2.6666667rem，这样可能会使页面元素的尺寸有偏差。\n\n除了上面的方法比较通用之外，还有一种方式，我们来重新思考一下：\n\n上面做页面的思路是：拿到设计图，比如iPhone6的设计图，我们就将浏览器设置到iPhone6设备调试，然后使用js动态修改meta标签，使布局视口的尺寸等于设计图尺寸，也就是设备像素尺寸，然后使用rem替代px做尺寸代为，使得页面在不同设备中等比缩放。\n\n现在假如我们不去修改meta标签，正常使用缩放为1:1的meta标签，即使用如下meta标签：\n\n```\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no\" />\n```\n\n还以iPhone6为例，我们知道，在缩放为1:1的情况下，根据公式：\n\n<b>设备像素比（DPR） = 设备像素个数 / 理想视口像素个数（device-width）</b>\n\n我们知道：\n设备像素 = 设计图尺寸 = 750px\n布局视口 = 375px\n\n假设我们以iPhone6设计图尺寸为标准，在设计图的尺寸下设置一个font-size值为100px。\n也就是说：750px宽的页面，我们设置100px的font-size值，那么页面的宽度换算为rem就等于 750 / 100 = 7.5rem。\n\n我们就以页面总宽为7.5rem为标准，那么在布局视口中，也就是页面总宽为375px下，font-size值应该是多少？很简单：\n\nfont-size = 375 / 7.5 = 50px\n\n那么在iPhone5下呢？因为iPhone5的布局视口宽为320px，所以如果页面总宽以7.5为标准，那么iPhone5下我们设置的font-size值应该是：\n\nfont-size = 320 / 7.5 =42.666666667px\n\n也就是说，不管在什么设备下，我们都可以把页面的总宽度设为一个以rem为单位的定值，比如本例就是7.5rem，只不过，我们需要根据布局视口的尺寸动态设置font-size的值：\n\n```\ndocument.documentElement.style.fontSize = document.documentElement.clientWidth / 7.5 + 'px';\n```\n\n这样，无论在什么设备下，我们页面的总宽度都是7.5rem，所以我们直接在设计图上测量px单位的尺寸，然后除以100转换成rem单位后直接使用就可以了，比如，在iPhone6设计图中测量一个元素的尺寸为200px，那么转换成rem单位就是 200 / 100 = 2rem，因为在不同设备下我们动态设置了html标签的font-size值，所以不同设备下相同的rem值对应的像素值是不同的，这样就实现了在不同设备下等比缩放。我们修改html代码如下：\n\n```\n<html>\n<head>\n\t<title></title>\n\t<meta charset=\"utf-8\" />\n\t<meta name=\"viewport\" content=\"width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no\" />\n\t<style>\n\tbody{\n\t\tmargin: 0;\n\t\tpadding: 0;\n\t}\n\t.box{\n\t\twidth: 2rem;\n\t\theight: 2rem;\n\t\tbackground: red;\n\t}\n\t</style>\n</head>\n<body>\n\n\t<div class=\"box\"></div>\n\n\t<script>\n\tdocument.documentElement.style.fontSize = document.documentElement.clientWidth / 7.5 + 'px';\n\t</script>\n</body>\n</html>\n```\n\n刷新页面，分别在iPhone6和iPhone5下调试查看结果，会发现如下图，使我们想要的效果，等比缩放，ok，实际上这种做法也是网易的做法：\n\n![iPhone6下显示效果](http://7xlolm.com1.z0.glb.clouddn.com/2015092320a.jpg)\n\n![iPhone5下显示效果](http://7xlolm.com1.z0.glb.clouddn.com/2015092320b.jpg)\n\n下面，我们来总结一下第二种做法：\n\n1、拿到设计图，计算出页面的总宽，为了好计算，取100px的font-size，如果设计图是iPhone6的那么计算出的就是7.5rem，如果页面是iPhone5的那么计算出的结果就是6.4rem。\n2、动态设置html标签的font-size值：\n  ```\n  document.documentElement.style.fontSize = document.documentElement.clientWidth / 以rem为单位的页面总宽 + 'px';\n  ```\n  如iPhone6的设计图就是：\n  ```\n  document.documentElement.style.fontSize = document.documentElement.clientWidth / 7.5 + 'px';\n  ```\n  iPhone5的设计图就是：\n  ```\n  document.documentElement.style.fontSize = document.documentElement.clientWidth / 6.4 + 'px';\n  ```\n3、做页面是测量设计图的px尺寸除以100得到rem尺寸。\n4、和淘宝的做法一样，文字字体大小不要使用rem换算。\n\n下面是这种做法的html莫板：\n\n```\n<html>\n<head>\n\t<title></title>\n\t<meta charset=\"utf-8\" />\n\t<meta name=\"viewport\" content=\"width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no\" />\n</head>\n<body>\n\n\t\n\n\t<script>\n\tdocument.documentElement.style.fontSize = document.documentElement.clientWidth / 7.5 + 'px';\n\t</script>\n</body>\n</html>\n```\n\n由于这种做法在开发中换算rem单位的时候只需要将测量的尺寸除以100即可，所以不需要使用计算器我们就可以很快的完成计算转换，所以这也会提升开发效率，本人也比较青睐这种做法。\n\n另外，无论是第一种做法还是第二种做法，我们都提到了，文字字体大小是不要换算成rem做单位的，而是使用媒体查询来进行动态设置，比如下面的代码就是网易的代码：\n\n代码片段一：\n\n```\n@media screen and (max-width: 321px) {\n    body {\n        font-size:16px\n    }\n}\n\n@media screen and (min-width: 321px) and (max-width:400px) {\n    body {\n        font-size:17px\n    }\n}\n\n@media screen and (min-width: 400px) {\n    body {\n        font-size:19px\n    }\n}\n```\n\n代码片段二：\n\n```\n@media screen and (max-width: 321px) {\n    header,footer {\n        font-size:16px\n    }\n}\n\n@media screen and (min-width: 321px) and (max-width:400px) {\n    header,footer {\n        font-size:17px\n    }\n}\n\n@media screen and (min-width: 400px) {\n    header,footer {\n        font-size:19px\n    }\n}\n```\n\n我们总结一下网易在文字字体大小上的做法，在媒体查询阶段，分为三个等级分别是：\n321px以下\n321px - 400px之间\n400px以上\n\n具体文字大小要多少个像素这个以设计图为准，但是这三个等级之间是有规律的，仔细观察发现，321px以下的屏幕字体大小比321px - 400px之间的屏幕字体大小要小一个像素，而321px - 400px之间的屏幕字体大小要比400以上屏幕字体大小要小2个像素。依照这个规律，我们根据设计图所在的像素区段先写好该区段的字体大小，然后分别写出另外两个区段的字体大小媒体查询代码就可以了。\n\n终于码完了这第二篇文章，无力再多说其他的话，望对大家有帮助，有些细节地方没有细说，另外作者水平有限，希望大家指正共同进步，谢谢。","slug":"一篇真正教会你开发移动端页面的文章-二","published":1,"updated":"2015-10-20T03:52:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj669fsjm000jewfcjvvao0u1","content":"<h1 id=\"移动端开发的干货篇\"><a href=\"#移动端开发的干货篇\" class=\"headerlink\" title=\"移动端开发的干货篇\"></a>移动端开发的干货篇</h1><blockquote>\n<p>之前写了一篇文章<a href=\"http://hcysun.me/2015/10/16/%E4%B8%80%E7%AF%87%E7%9C%9F%E6%AD%A3%E6%95%99%E4%BC%9A%E4%BD%A0%E5%BC%80%E5%8F%91%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%96%87%E7%AB%A0(%E4%B8%80)/\">《一篇真正教会你开发移动端一面的文章(一)》</a>。那是本篇文章的基础，如果没有阅读过的同学可以去看看，今天就给大家带来干货，真真正正的讲到如何很好的开发一个移动端的页面</p>\n</blockquote>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20150923mobile.jpg\" alt=\"移动端\"></p>\n<a id=\"more\"></a>\n<p>好了，让我们开始吧，从哪里开始呢？从设计图开始，即PSD稿件：<br>移动端PSD稿件的尺寸肯定较之PC端的PSD稿件不同，具体体现在设计图的尺寸上，现在移动端的设计图尺寸大多以iPhone5和iPhone6的设备像素尺寸作为依据，比如拿到一张PSD设计图，它的总宽度为640px(iPhone5)或者750px(iPhone6)。本例就拿iPhone6的设计图尺寸为标准进行讲解，其它设计图尺寸道理是一样的，这并不影响我们的开发。</p>\n<p>首先我们要有一张设计图才行，看下图，假设我们有一张设计图，它很简单，只有一个红色的方块：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20150923psd1.jpg\" alt=\"psd稿\"></p>\n<p>拿到了设计图，于是你开开心心的开始写代码了，你打开了编辑器，并写下了如下HTML代码：</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;&lt;/title&gt;\n    &lt;meta charset=&quot;utf-8&quot; /&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no&quot; /&gt;\n&lt;/head&gt;\n&lt;body&gt;\n\n    &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>HTML代码写好了，你用了一个带有box类的div标签作为ps稿中的红色块，经过尺寸测量，你为上面代码添加了CSS样式，最后你的代码是这样的：</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;&lt;/title&gt;\n    &lt;meta charset=&quot;utf-8&quot; /&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no&quot; /&gt;\n    &lt;style&gt;\n    body{\n        margin: 0;\n        padding: 0;\n    }\n    .box{\n        width: 200px;\n        height: 200px;\n        background: red;\n    }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n\n    &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>上面的代码中，你只是在原来的基础上增加了CSS样式，首先你清除了body标签上的默认样式，这个没什么好说的，然后你根据设计图中测量的尺寸来给box编写样式，宽200px;高200px;背景红色。看上去并没有什么问题，于是你开开心心的打开浏览器，刷新页面，你的脸色沉了下来，因为你看到了你不想看到的结果，如下图，上图为设计稿的样式，下图为你编写的html文件的样式：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20150923psd2.jpg\" alt=\"psd原稿\"></p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20150923ht1.jpg\" alt=\"html页面\"></p>\n<p>通过对比psd原稿和我们目前所写的html页面，可以看出我们html页面的问题，红色方块与整个页面的比例和psd原稿不一样啊，那么为什么我们明明是按照原稿测量的尺寸写出来的代码却和psd原稿显示的效果不一样呢？别忘了，psd原稿的尺寸是按照设备像素设计的，由于我们所用的设计稿是基于iPhone6设计的，所以我们设计稿的尺寸就是iPhone6的设备像素的尺寸，也就是750px，而我们CSS中的样式是基于布局视口的尺寸计算的，由于我们html页面中由于写入了以下meta标签：</p>\n<pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no&quot; /&gt;\n</code></pre><p>在上一篇我们讲过，<em> width=device-width </em> 这段代码是让布局视口的尺寸等于理想视口。<br>根据公式(缩放比例为1)：<br><b>设备像素比（DPR） = 设备像素个数 / 理想视口像素个数（device-width）</b><br>因为iPhone6的DPR（设备像素比）为2，设备像素为750，所以iPhone6的理想视口尺寸为375px。所以上面代码最终导致的是：使我们布局视口的宽度变成了375px。而我们CSS中编写的样式尺寸又是基于布局视口计算的，所以我们得到的页面看上去比例不对，如下图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20150923ht2.jpg\" alt=\"布局视口宽度和元素宽度\"><br><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20150923psd3.jpg\" alt=\"psd设计稿宽度和元素宽度\"></p>\n<p>如上面两幅图片，我们知道，psd稿的总宽是750px，元素宽200px，而我们真正做页面的时候，布局视口的宽度是375px，正好是设计稿的一半。所以我们不能直接使用设计稿上面测量所得的像素尺寸，根据比例，我们应该将测量所得的尺寸除以2，才是我们CSS中布局所用的尺寸，据此，我们将200px除以2得到100px，于是我们修改代码，将红色方块的宽高都设为100px，刷新页面，看看比例是不是和设计图一样了？答案是肯定的，如下图为修改后的html页面：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20150923ht3.jpg\" alt=\"修改后的html页面\"></p>\n<p>这样，我们就得到了正确的数据，并且正确的写出了页面，你很高兴，可是问题来了，如果你在做页面的时候，测量了一个元素的宽度，宽度是一个奇数，比如111像素，按照我们之前的做法是，将测量到的数据除以2，得到我们真正使用的数据，所以111除以2等于55.5px，我们知道，计算机(手机)没办法显示不到一个像素的像素值，计算机(手机)会自动将其补全为一个像素进行显示，所以最终会将元素显示为56像素，这并不是我们想要的结果。<br>另外，我们的设计稿是基于iphone6设计的，我们调试页面也是在iphone6下调试的。又因为iphone6的设备像素比试2，所以我们才能由设计稿测量的数据除以2后直接使用，并且在iphone6下没有问题，但是你要知道，并不是所有手机的设备像素比都是2，有的手机的设备像素比试2.5或者3。并且不同设备的设备像素又不同，这样就导致理想视口的尺寸不同，从而导致布局视口的尺寸不同，那么我们直接根据iphone6的设计稿尺寸除以2得到的尺寸用来编写CSS是不能在所有设备下完好显示的。</p>\n<p>所以，我们要换一个方法。<br>于是我们想到：如果我们能将布局视口的尺寸设置为和设备像素尺寸相等的话，这样我们就保证了设计图与页面的1:1关系，那么我们就可以直接使用psd中测量的尺寸了，然后在其他尺寸的手机中，我们进行等比缩放就ok了。那么如何才能让布局视口的尺寸等于设备像素尺寸呢？</p>\n<p>我们注意到meta标签中的 width=device-width 这段代码，首先你要明白这句话的意思，前面讲过，这句话最终导致的结果是：让布局视口的尺寸等于理想视口的尺寸。言外之意就是,在代码 width=device-width 中：</p>\n<p>width：是布局视口的width<br>device-width：是理想视口的宽度</p>\n<p>根据公式(缩放比例为1)：</p>\n<p><b>设备像素比（DPR） = 设备像素个数 / 理想视口像素个数（device-width）</b></p>\n<p>以iphone6为例：<br>设备像素比（DPR）：2<br>设备像素个数：750<br>所以在缩放比例为1的情况下，iphone6理想视口的像素个数为 750 / 2 = 375，也就是说，对于iphone6来讲 device-width的值为375</p>\n<p>所以我们通过width=device-width这句话，间接的将布局视口的尺寸设为了375，也就是说，如果我们能改变理想视口的尺寸，也就改变了布局适口的尺寸，如何改变理想视口的尺寸呢？这就要讲到缩放了，上一篇我们讲到过缩放，缩放是缩小或放大CSS像素的过程，以iphone6为例，当我们缩放比例为1:1的时候，由于iphone6的设备像素比为2，所以iphone6的设备像素与CSS像素的关系看起来就像下图这样：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/2015092319a.jpg\" alt=\"iphone6下缩放比例为1时，设备像素与CSS像素的关系\"></p>\n<p>一个CSS像素宽度等于两个设备像素宽度，所以750px的设备宽度的布局视口为357CSS像素。这是在缩放比例为1的情况下，既然缩放可以放大或缩小CSS像素，所以如果我们将CSS像素的宽度缩放至与设备像素宽度相等了，那么750个设备像素也就能显示750个CSS像素，缩放后的设备像素与CSS像素看起来应该像下图这样：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20150923px1.jpg\" alt=\"iphone6缩小0.5倍后，设备像素与CSS像素的关系\"></p>\n<p>但是，我们的缩放倍数是多少呢？在缩放比例为1的时候，一个CSS像素的宽度 = 两个设备像素的宽度，如果我们想让 一个CSS像素的宽度 = 一个设备像素的宽度，我们就要将CSS像素缩小为原来的0.5倍，实际上，我们缩小的倍数 = 设备像素比的倒数。<br>于是，我们修改上面的HTML代码(修改了meta标签)：</p>\n<pre><code>&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;&lt;/title&gt;\n    &lt;meta charset=&quot;utf-8&quot; /&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=0.5,maximum-scale=0.5,user-scalable=no&quot; /&gt;\n    &lt;style&gt;\n    body{\n        margin: 0;\n        padding: 0;\n    }\n    .box{\n        width: 200px;\n        height: 200px;\n        background: red;\n    }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n\n    &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>注意，上面代码中我们给红色方块使用的CSS尺寸直接使用的是psd稿中测量的尺寸，我们刷新页面，怎么样？满意吧：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/2015092316b.jpg\" alt=\"修改后的新页面正确输出\"></p>\n<p>但是我们这是有个前提的，那就是缩放0.5倍只适用于设备像素比为2的设备（因为缩放值 = 1 / 设备像素比）。所以，为了适应所有的设备，我们应该用javascript代码动态生成meta标签：</p>\n<pre><code>var scale = 1 / window.devicePixelRatio;\ndocument.querySelector(&#39;meta[name=&quot;viewport&quot;]&#39;).setAttribute(&#39;content&#39;,&#39;width=device-width,initial-scale=&#39; + scale + &#39;, maximum-scale=&#39; + scale + &#39;, minimum-scale=&#39; + scale + &#39;, user-scalable=no&#39;);\n</code></pre><p>其中 <b>window.devicePixelRatio</b> 的值为设备像素比。<br>于是我们的代码变成了这样：</p>\n<pre><code>&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;&lt;/title&gt;\n    &lt;meta charset=&quot;utf-8&quot; /&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;&quot; /&gt;\n    &lt;style&gt;\n    body{\n        margin: 0;\n        padding: 0;\n    }\n    .box{\n        width: 200px;\n        height: 200px;\n        background: red;\n    }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n\n    &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n\n    &lt;script&gt;\n    var scale = 1 / window.devicePixelRatio;\n    document.querySelector(&#39;meta[name=&quot;viewport&quot;]&#39;).setAttribute(&#39;content&#39;,&#39;width=device-width,initial-scale=&#39; + scale + &#39;, maximum-scale=&#39; + scale + &#39;, minimum-scale=&#39; + scale + &#39;, user-scalable=no&#39;);\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>上面的代码最终能保证一个问题，那就是无论任何设备，布局视口的宽度总是等于设备像素。<br>这样，我们在设计图中测量为200px的宽度就能直接用在CSS中了，并且在iphone6中显示完好，可是别忘了，我们的设计图就是根据iphone6设计的，如果换做其他设备，还能显示完好么？我们不妨试一下，如下图，是上面代码在iphone5和iphone6下的对比：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20150923p5.jpg\" alt=\"iphone5中的效果\"></p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20150923p6.jpg\" alt=\"iphone6中的效果\"></p>\n<p>我们发现，无论是五还是6，即使设备像素变了，即屏幕宽度变了，可是红色方块的宽度并没有变，这并不是一个好的现象，因为这样页面的元素就不成比例了，会影响到布局，所以我们要想办法让我们页面的元素跟着设备变化而等比缩放，这就是我们要解决的第二个问题，怎么实现呢？这就要讲到rem的知识点了。</p>\n<h2 id=\"rem\"><a href=\"#rem\" class=\"headerlink\" title=\"rem\"></a>rem</h2><p>什么是rem？<br>rem是相对尺寸单位，相对于html标签字体大小的单位，举个例子：<br>如果html的font-size = 18px;<br>那么1rem = 18px，需要记住的是，rem是基于html标签的字体大小的。</p>\n<p>相信你已经明白了，对没错，我们要把之前用px做元素尺寸的单位换成rem，所以，现在的问题就是如果转换，因为rem是根据html标签的font-size值确定的，所以我们只要确定html标签的font-size值就行了，我们首先自己定一个标准，就是让font-size的值等于设备像素的十分之一，即：</p>\n<pre><code>document.documentElement.style.fontSize = document.documentElement.clientWidth / 10 + &#39;px&#39;;\n</code></pre><p>以iphone6为例，html标签的font-size的值就等于 750 / 10 = 75px 了，这样 1rem = 75px，所以红色方块200px换算为rem单位就是 200 / 75 = 2.6666667rem。<br>那么在iphone5中呢？因为iphone5的设备像素为640，所以iphone的html标签的font-size的值为 640 / 10 = 64px，所以 1rem = 64px，所以在iphone6中显示为200px的元素在iphone5中会显示为 2.6666667 * 64 像素，这样，在不同设备中就实现了让元素等比缩放从而不影响布局。而上面的方法也是手机淘宝所用的方法。所以，现在你只需要将你测量的尺寸数据除以75就转换成了rem单位，如果是iPhone5就要除以64，即除以你动态设置的font-size的值。</p>\n<p>另外需要注意的是：做页面的时候文字字体大小不要用rem换算，还是使用px做单位。后面会讲到。</p>\n<p>让我们来总结一下我们现在了解的方法：</p>\n<p>1、将布局视口大小设为设备像素尺寸：</p>\n<pre><code>var scale = 1 / window.devicePixelRatio;\ndocument.querySelector(&#39;meta[name=&quot;viewport&quot;]&#39;).setAttribute(&#39;content&#39;,&#39;width=device-width,initial-scale=&#39; + scale + &#39;, maximum-scale=&#39; + scale + &#39;, minimum-scale=&#39; + scale + &#39;, user-scalable=no&#39;);\n</code></pre><p>2、动态设置html字体大小：</p>\n<pre><code>document.documentElement.style.fontSize = document.documentElement.clientWidth / 10 + &#39;px&#39;;\n</code></pre><p>3、将设计图中的尺寸换算成rem</p>\n<p>元素的rem尺寸 = 元素的psd稿测量的像素尺寸 / 动态设置的html标签的font-size值</p>\n<p>说了一大堆，其实我们使用下面的html莫板就可以写页面了，唯一需要你做的就是计算元素的rem尺寸，所以即使你没看懂上面的讲述也不重要，你只要将莫板拿过去用就好了：</p>\n<pre><code>&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;&lt;/title&gt;\n    &lt;meta charset=&quot;utf-8&quot; /&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;&quot; /&gt;\n&lt;/head&gt;\n&lt;body&gt;\n\n\n\n    &lt;script&gt;\n    var scale = 1 / window.devicePixelRatio;\n    document.querySelector(&#39;meta[name=&quot;viewport&quot;]&#39;).setAttribute(&#39;content&#39;,&#39;width=device-width,initial-scale=&#39; + scale + &#39;, maximum-scale=&#39; + scale + &#39;, minimum-scale=&#39; + scale + &#39;, user-scalable=no&#39;);\n\n    document.documentElement.style.fontSize = document.documentElement.clientWidth / 10 + &#39;px&#39;;\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>现在我们使用上面的方法修改我们的代码如下：</p>\n<pre><code>&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;&lt;/title&gt;\n    &lt;meta charset=&quot;utf-8&quot; /&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;&quot; /&gt;\n    &lt;style&gt;\n    body{\n        margin: 0;\n        padding: 0;\n    }\n    .box{\n        width: 2.66666667rem;\n        height: 2.66666667rem;\n        background: red;\n    }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n\n    &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n\n    &lt;script&gt;\n    var scale = 1 / window.devicePixelRatio;\n    document.querySelector(&#39;meta[name=&quot;viewport&quot;]&#39;).setAttribute(&#39;content&#39;,&#39;width=device-width,initial-scale=&#39; + scale + &#39;, maximum-scale=&#39; + scale + &#39;, minimum-scale=&#39; + scale + &#39;, user-scalable=no&#39;);\n\n    document.documentElement.style.fontSize = document.documentElement.clientWidth / 10 + &#39;px&#39;;\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>打开浏览器，分别在iPhone6和iPhone5下查看页面，我们会发现，现在的元素可以根据手机的尺寸不同而等比缩放了。</p>\n<p>上面的方法是手机淘宝的方法，有一个缺点，就是转化rem单位的时候，需要除以font-size的值，淘宝用的是iPhone6的设计图，所以淘宝转换尺寸的时候要除以75，这个值可不好算，所以还要借用计算器来完成，影响开发效率，另外，在转还rem单位时遇到除不尽的数时我们会采用很长的近似值比如上面的2.6666667rem，这样可能会使页面元素的尺寸有偏差。</p>\n<p>除了上面的方法比较通用之外，还有一种方式，我们来重新思考一下：</p>\n<p>上面做页面的思路是：拿到设计图，比如iPhone6的设计图，我们就将浏览器设置到iPhone6设备调试，然后使用js动态修改meta标签，使布局视口的尺寸等于设计图尺寸，也就是设备像素尺寸，然后使用rem替代px做尺寸代为，使得页面在不同设备中等比缩放。</p>\n<p>现在假如我们不去修改meta标签，正常使用缩放为1:1的meta标签，即使用如下meta标签：</p>\n<pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no&quot; /&gt;\n</code></pre><p>还以iPhone6为例，我们知道，在缩放为1:1的情况下，根据公式：</p>\n<p><b>设备像素比（DPR） = 设备像素个数 / 理想视口像素个数（device-width）</b></p>\n<p>我们知道：<br>设备像素 = 设计图尺寸 = 750px<br>布局视口 = 375px</p>\n<p>假设我们以iPhone6设计图尺寸为标准，在设计图的尺寸下设置一个font-size值为100px。<br>也就是说：750px宽的页面，我们设置100px的font-size值，那么页面的宽度换算为rem就等于 750 / 100 = 7.5rem。</p>\n<p>我们就以页面总宽为7.5rem为标准，那么在布局视口中，也就是页面总宽为375px下，font-size值应该是多少？很简单：</p>\n<p>font-size = 375 / 7.5 = 50px</p>\n<p>那么在iPhone5下呢？因为iPhone5的布局视口宽为320px，所以如果页面总宽以7.5为标准，那么iPhone5下我们设置的font-size值应该是：</p>\n<p>font-size = 320 / 7.5 =42.666666667px</p>\n<p>也就是说，不管在什么设备下，我们都可以把页面的总宽度设为一个以rem为单位的定值，比如本例就是7.5rem，只不过，我们需要根据布局视口的尺寸动态设置font-size的值：</p>\n<pre><code>document.documentElement.style.fontSize = document.documentElement.clientWidth / 7.5 + &#39;px&#39;;\n</code></pre><p>这样，无论在什么设备下，我们页面的总宽度都是7.5rem，所以我们直接在设计图上测量px单位的尺寸，然后除以100转换成rem单位后直接使用就可以了，比如，在iPhone6设计图中测量一个元素的尺寸为200px，那么转换成rem单位就是 200 / 100 = 2rem，因为在不同设备下我们动态设置了html标签的font-size值，所以不同设备下相同的rem值对应的像素值是不同的，这样就实现了在不同设备下等比缩放。我们修改html代码如下：</p>\n<pre><code>&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;&lt;/title&gt;\n    &lt;meta charset=&quot;utf-8&quot; /&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no&quot; /&gt;\n    &lt;style&gt;\n    body{\n        margin: 0;\n        padding: 0;\n    }\n    .box{\n        width: 2rem;\n        height: 2rem;\n        background: red;\n    }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n\n    &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n\n    &lt;script&gt;\n    document.documentElement.style.fontSize = document.documentElement.clientWidth / 7.5 + &#39;px&#39;;\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>刷新页面，分别在iPhone6和iPhone5下调试查看结果，会发现如下图，使我们想要的效果，等比缩放，ok，实际上这种做法也是网易的做法：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/2015092320a.jpg\" alt=\"iPhone6下显示效果\"></p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/2015092320b.jpg\" alt=\"iPhone5下显示效果\"></p>\n<p>下面，我们来总结一下第二种做法：</p>\n<p>1、拿到设计图，计算出页面的总宽，为了好计算，取100px的font-size，如果设计图是iPhone6的那么计算出的就是7.5rem，如果页面是iPhone5的那么计算出的结果就是6.4rem。<br>2、动态设置html标签的font-size值：</p>\n<pre><code>  document.documentElement.style.fontSize = document.documentElement.clientWidth / 以rem为单位的页面总宽 + &#39;px&#39;;\n</code></pre><p>  如iPhone6的设计图就是：</p>\n<pre><code>  document.documentElement.style.fontSize = document.documentElement.clientWidth / 7.5 + &#39;px&#39;;\n</code></pre><p>  iPhone5的设计图就是：</p>\n<pre><code>  document.documentElement.style.fontSize = document.documentElement.clientWidth / 6.4 + &#39;px&#39;;\n</code></pre><p>3、做页面是测量设计图的px尺寸除以100得到rem尺寸。<br>4、和淘宝的做法一样，文字字体大小不要使用rem换算。</p>\n<p>下面是这种做法的html莫板：</p>\n<pre><code>&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;&lt;/title&gt;\n    &lt;meta charset=&quot;utf-8&quot; /&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no&quot; /&gt;\n&lt;/head&gt;\n&lt;body&gt;\n\n\n\n    &lt;script&gt;\n    document.documentElement.style.fontSize = document.documentElement.clientWidth / 7.5 + &#39;px&#39;;\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>由于这种做法在开发中换算rem单位的时候只需要将测量的尺寸除以100即可，所以不需要使用计算器我们就可以很快的完成计算转换，所以这也会提升开发效率，本人也比较青睐这种做法。</p>\n<p>另外，无论是第一种做法还是第二种做法，我们都提到了，文字字体大小是不要换算成rem做单位的，而是使用媒体查询来进行动态设置，比如下面的代码就是网易的代码：</p>\n<p>代码片段一：</p>\n<pre><code>@media screen and (max-width: 321px) {\n    body {\n        font-size:16px\n    }\n}\n\n@media screen and (min-width: 321px) and (max-width:400px) {\n    body {\n        font-size:17px\n    }\n}\n\n@media screen and (min-width: 400px) {\n    body {\n        font-size:19px\n    }\n}\n</code></pre><p>代码片段二：</p>\n<pre><code>@media screen and (max-width: 321px) {\n    header,footer {\n        font-size:16px\n    }\n}\n\n@media screen and (min-width: 321px) and (max-width:400px) {\n    header,footer {\n        font-size:17px\n    }\n}\n\n@media screen and (min-width: 400px) {\n    header,footer {\n        font-size:19px\n    }\n}\n</code></pre><p>我们总结一下网易在文字字体大小上的做法，在媒体查询阶段，分为三个等级分别是：<br>321px以下<br>321px - 400px之间<br>400px以上</p>\n<p>具体文字大小要多少个像素这个以设计图为准，但是这三个等级之间是有规律的，仔细观察发现，321px以下的屏幕字体大小比321px - 400px之间的屏幕字体大小要小一个像素，而321px - 400px之间的屏幕字体大小要比400以上屏幕字体大小要小2个像素。依照这个规律，我们根据设计图所在的像素区段先写好该区段的字体大小，然后分别写出另外两个区段的字体大小媒体查询代码就可以了。</p>\n<p>终于码完了这第二篇文章，无力再多说其他的话，望对大家有帮助，有些细节地方没有细说，另外作者水平有限，希望大家指正共同进步，谢谢。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"移动端开发的干货篇\"><a href=\"#移动端开发的干货篇\" class=\"headerlink\" title=\"移动端开发的干货篇\"></a>移动端开发的干货篇</h1><blockquote>\n<p>之前写了一篇文章<a href=\"http://hcysun.me/2015/10/16/%E4%B8%80%E7%AF%87%E7%9C%9F%E6%AD%A3%E6%95%99%E4%BC%9A%E4%BD%A0%E5%BC%80%E5%8F%91%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%96%87%E7%AB%A0(%E4%B8%80)/\">《一篇真正教会你开发移动端一面的文章(一)》</a>。那是本篇文章的基础，如果没有阅读过的同学可以去看看，今天就给大家带来干货，真真正正的讲到如何很好的开发一个移动端的页面</p>\n</blockquote>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20150923mobile.jpg\" alt=\"移动端\"></p>","more":"<p>好了，让我们开始吧，从哪里开始呢？从设计图开始，即PSD稿件：<br>移动端PSD稿件的尺寸肯定较之PC端的PSD稿件不同，具体体现在设计图的尺寸上，现在移动端的设计图尺寸大多以iPhone5和iPhone6的设备像素尺寸作为依据，比如拿到一张PSD设计图，它的总宽度为640px(iPhone5)或者750px(iPhone6)。本例就拿iPhone6的设计图尺寸为标准进行讲解，其它设计图尺寸道理是一样的，这并不影响我们的开发。</p>\n<p>首先我们要有一张设计图才行，看下图，假设我们有一张设计图，它很简单，只有一个红色的方块：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20150923psd1.jpg\" alt=\"psd稿\"></p>\n<p>拿到了设计图，于是你开开心心的开始写代码了，你打开了编辑器，并写下了如下HTML代码：</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;&lt;/title&gt;\n    &lt;meta charset=&quot;utf-8&quot; /&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no&quot; /&gt;\n&lt;/head&gt;\n&lt;body&gt;\n\n    &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>HTML代码写好了，你用了一个带有box类的div标签作为ps稿中的红色块，经过尺寸测量，你为上面代码添加了CSS样式，最后你的代码是这样的：</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;&lt;/title&gt;\n    &lt;meta charset=&quot;utf-8&quot; /&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no&quot; /&gt;\n    &lt;style&gt;\n    body{\n        margin: 0;\n        padding: 0;\n    }\n    .box{\n        width: 200px;\n        height: 200px;\n        background: red;\n    }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n\n    &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>上面的代码中，你只是在原来的基础上增加了CSS样式，首先你清除了body标签上的默认样式，这个没什么好说的，然后你根据设计图中测量的尺寸来给box编写样式，宽200px;高200px;背景红色。看上去并没有什么问题，于是你开开心心的打开浏览器，刷新页面，你的脸色沉了下来，因为你看到了你不想看到的结果，如下图，上图为设计稿的样式，下图为你编写的html文件的样式：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20150923psd2.jpg\" alt=\"psd原稿\"></p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20150923ht1.jpg\" alt=\"html页面\"></p>\n<p>通过对比psd原稿和我们目前所写的html页面，可以看出我们html页面的问题，红色方块与整个页面的比例和psd原稿不一样啊，那么为什么我们明明是按照原稿测量的尺寸写出来的代码却和psd原稿显示的效果不一样呢？别忘了，psd原稿的尺寸是按照设备像素设计的，由于我们所用的设计稿是基于iPhone6设计的，所以我们设计稿的尺寸就是iPhone6的设备像素的尺寸，也就是750px，而我们CSS中的样式是基于布局视口的尺寸计算的，由于我们html页面中由于写入了以下meta标签：</p>\n<pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no&quot; /&gt;\n</code></pre><p>在上一篇我们讲过，<em> width=device-width </em> 这段代码是让布局视口的尺寸等于理想视口。<br>根据公式(缩放比例为1)：<br><b>设备像素比（DPR） = 设备像素个数 / 理想视口像素个数（device-width）</b><br>因为iPhone6的DPR（设备像素比）为2，设备像素为750，所以iPhone6的理想视口尺寸为375px。所以上面代码最终导致的是：使我们布局视口的宽度变成了375px。而我们CSS中编写的样式尺寸又是基于布局视口计算的，所以我们得到的页面看上去比例不对，如下图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20150923ht2.jpg\" alt=\"布局视口宽度和元素宽度\"><br><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20150923psd3.jpg\" alt=\"psd设计稿宽度和元素宽度\"></p>\n<p>如上面两幅图片，我们知道，psd稿的总宽是750px，元素宽200px，而我们真正做页面的时候，布局视口的宽度是375px，正好是设计稿的一半。所以我们不能直接使用设计稿上面测量所得的像素尺寸，根据比例，我们应该将测量所得的尺寸除以2，才是我们CSS中布局所用的尺寸，据此，我们将200px除以2得到100px，于是我们修改代码，将红色方块的宽高都设为100px，刷新页面，看看比例是不是和设计图一样了？答案是肯定的，如下图为修改后的html页面：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20150923ht3.jpg\" alt=\"修改后的html页面\"></p>\n<p>这样，我们就得到了正确的数据，并且正确的写出了页面，你很高兴，可是问题来了，如果你在做页面的时候，测量了一个元素的宽度，宽度是一个奇数，比如111像素，按照我们之前的做法是，将测量到的数据除以2，得到我们真正使用的数据，所以111除以2等于55.5px，我们知道，计算机(手机)没办法显示不到一个像素的像素值，计算机(手机)会自动将其补全为一个像素进行显示，所以最终会将元素显示为56像素，这并不是我们想要的结果。<br>另外，我们的设计稿是基于iphone6设计的，我们调试页面也是在iphone6下调试的。又因为iphone6的设备像素比试2，所以我们才能由设计稿测量的数据除以2后直接使用，并且在iphone6下没有问题，但是你要知道，并不是所有手机的设备像素比都是2，有的手机的设备像素比试2.5或者3。并且不同设备的设备像素又不同，这样就导致理想视口的尺寸不同，从而导致布局视口的尺寸不同，那么我们直接根据iphone6的设计稿尺寸除以2得到的尺寸用来编写CSS是不能在所有设备下完好显示的。</p>\n<p>所以，我们要换一个方法。<br>于是我们想到：如果我们能将布局视口的尺寸设置为和设备像素尺寸相等的话，这样我们就保证了设计图与页面的1:1关系，那么我们就可以直接使用psd中测量的尺寸了，然后在其他尺寸的手机中，我们进行等比缩放就ok了。那么如何才能让布局视口的尺寸等于设备像素尺寸呢？</p>\n<p>我们注意到meta标签中的 width=device-width 这段代码，首先你要明白这句话的意思，前面讲过，这句话最终导致的结果是：让布局视口的尺寸等于理想视口的尺寸。言外之意就是,在代码 width=device-width 中：</p>\n<p>width：是布局视口的width<br>device-width：是理想视口的宽度</p>\n<p>根据公式(缩放比例为1)：</p>\n<p><b>设备像素比（DPR） = 设备像素个数 / 理想视口像素个数（device-width）</b></p>\n<p>以iphone6为例：<br>设备像素比（DPR）：2<br>设备像素个数：750<br>所以在缩放比例为1的情况下，iphone6理想视口的像素个数为 750 / 2 = 375，也就是说，对于iphone6来讲 device-width的值为375</p>\n<p>所以我们通过width=device-width这句话，间接的将布局视口的尺寸设为了375，也就是说，如果我们能改变理想视口的尺寸，也就改变了布局适口的尺寸，如何改变理想视口的尺寸呢？这就要讲到缩放了，上一篇我们讲到过缩放，缩放是缩小或放大CSS像素的过程，以iphone6为例，当我们缩放比例为1:1的时候，由于iphone6的设备像素比为2，所以iphone6的设备像素与CSS像素的关系看起来就像下图这样：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/2015092319a.jpg\" alt=\"iphone6下缩放比例为1时，设备像素与CSS像素的关系\"></p>\n<p>一个CSS像素宽度等于两个设备像素宽度，所以750px的设备宽度的布局视口为357CSS像素。这是在缩放比例为1的情况下，既然缩放可以放大或缩小CSS像素，所以如果我们将CSS像素的宽度缩放至与设备像素宽度相等了，那么750个设备像素也就能显示750个CSS像素，缩放后的设备像素与CSS像素看起来应该像下图这样：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20150923px1.jpg\" alt=\"iphone6缩小0.5倍后，设备像素与CSS像素的关系\"></p>\n<p>但是，我们的缩放倍数是多少呢？在缩放比例为1的时候，一个CSS像素的宽度 = 两个设备像素的宽度，如果我们想让 一个CSS像素的宽度 = 一个设备像素的宽度，我们就要将CSS像素缩小为原来的0.5倍，实际上，我们缩小的倍数 = 设备像素比的倒数。<br>于是，我们修改上面的HTML代码(修改了meta标签)：</p>\n<pre><code>&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;&lt;/title&gt;\n    &lt;meta charset=&quot;utf-8&quot; /&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=0.5,maximum-scale=0.5,user-scalable=no&quot; /&gt;\n    &lt;style&gt;\n    body{\n        margin: 0;\n        padding: 0;\n    }\n    .box{\n        width: 200px;\n        height: 200px;\n        background: red;\n    }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n\n    &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>注意，上面代码中我们给红色方块使用的CSS尺寸直接使用的是psd稿中测量的尺寸，我们刷新页面，怎么样？满意吧：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/2015092316b.jpg\" alt=\"修改后的新页面正确输出\"></p>\n<p>但是我们这是有个前提的，那就是缩放0.5倍只适用于设备像素比为2的设备（因为缩放值 = 1 / 设备像素比）。所以，为了适应所有的设备，我们应该用javascript代码动态生成meta标签：</p>\n<pre><code>var scale = 1 / window.devicePixelRatio;\ndocument.querySelector(&#39;meta[name=&quot;viewport&quot;]&#39;).setAttribute(&#39;content&#39;,&#39;width=device-width,initial-scale=&#39; + scale + &#39;, maximum-scale=&#39; + scale + &#39;, minimum-scale=&#39; + scale + &#39;, user-scalable=no&#39;);\n</code></pre><p>其中 <b>window.devicePixelRatio</b> 的值为设备像素比。<br>于是我们的代码变成了这样：</p>\n<pre><code>&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;&lt;/title&gt;\n    &lt;meta charset=&quot;utf-8&quot; /&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;&quot; /&gt;\n    &lt;style&gt;\n    body{\n        margin: 0;\n        padding: 0;\n    }\n    .box{\n        width: 200px;\n        height: 200px;\n        background: red;\n    }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n\n    &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n\n    &lt;script&gt;\n    var scale = 1 / window.devicePixelRatio;\n    document.querySelector(&#39;meta[name=&quot;viewport&quot;]&#39;).setAttribute(&#39;content&#39;,&#39;width=device-width,initial-scale=&#39; + scale + &#39;, maximum-scale=&#39; + scale + &#39;, minimum-scale=&#39; + scale + &#39;, user-scalable=no&#39;);\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>上面的代码最终能保证一个问题，那就是无论任何设备，布局视口的宽度总是等于设备像素。<br>这样，我们在设计图中测量为200px的宽度就能直接用在CSS中了，并且在iphone6中显示完好，可是别忘了，我们的设计图就是根据iphone6设计的，如果换做其他设备，还能显示完好么？我们不妨试一下，如下图，是上面代码在iphone5和iphone6下的对比：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20150923p5.jpg\" alt=\"iphone5中的效果\"></p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20150923p6.jpg\" alt=\"iphone6中的效果\"></p>\n<p>我们发现，无论是五还是6，即使设备像素变了，即屏幕宽度变了，可是红色方块的宽度并没有变，这并不是一个好的现象，因为这样页面的元素就不成比例了，会影响到布局，所以我们要想办法让我们页面的元素跟着设备变化而等比缩放，这就是我们要解决的第二个问题，怎么实现呢？这就要讲到rem的知识点了。</p>\n<h2 id=\"rem\"><a href=\"#rem\" class=\"headerlink\" title=\"rem\"></a>rem</h2><p>什么是rem？<br>rem是相对尺寸单位，相对于html标签字体大小的单位，举个例子：<br>如果html的font-size = 18px;<br>那么1rem = 18px，需要记住的是，rem是基于html标签的字体大小的。</p>\n<p>相信你已经明白了，对没错，我们要把之前用px做元素尺寸的单位换成rem，所以，现在的问题就是如果转换，因为rem是根据html标签的font-size值确定的，所以我们只要确定html标签的font-size值就行了，我们首先自己定一个标准，就是让font-size的值等于设备像素的十分之一，即：</p>\n<pre><code>document.documentElement.style.fontSize = document.documentElement.clientWidth / 10 + &#39;px&#39;;\n</code></pre><p>以iphone6为例，html标签的font-size的值就等于 750 / 10 = 75px 了，这样 1rem = 75px，所以红色方块200px换算为rem单位就是 200 / 75 = 2.6666667rem。<br>那么在iphone5中呢？因为iphone5的设备像素为640，所以iphone的html标签的font-size的值为 640 / 10 = 64px，所以 1rem = 64px，所以在iphone6中显示为200px的元素在iphone5中会显示为 2.6666667 * 64 像素，这样，在不同设备中就实现了让元素等比缩放从而不影响布局。而上面的方法也是手机淘宝所用的方法。所以，现在你只需要将你测量的尺寸数据除以75就转换成了rem单位，如果是iPhone5就要除以64，即除以你动态设置的font-size的值。</p>\n<p>另外需要注意的是：做页面的时候文字字体大小不要用rem换算，还是使用px做单位。后面会讲到。</p>\n<p>让我们来总结一下我们现在了解的方法：</p>\n<p>1、将布局视口大小设为设备像素尺寸：</p>\n<pre><code>var scale = 1 / window.devicePixelRatio;\ndocument.querySelector(&#39;meta[name=&quot;viewport&quot;]&#39;).setAttribute(&#39;content&#39;,&#39;width=device-width,initial-scale=&#39; + scale + &#39;, maximum-scale=&#39; + scale + &#39;, minimum-scale=&#39; + scale + &#39;, user-scalable=no&#39;);\n</code></pre><p>2、动态设置html字体大小：</p>\n<pre><code>document.documentElement.style.fontSize = document.documentElement.clientWidth / 10 + &#39;px&#39;;\n</code></pre><p>3、将设计图中的尺寸换算成rem</p>\n<p>元素的rem尺寸 = 元素的psd稿测量的像素尺寸 / 动态设置的html标签的font-size值</p>\n<p>说了一大堆，其实我们使用下面的html莫板就可以写页面了，唯一需要你做的就是计算元素的rem尺寸，所以即使你没看懂上面的讲述也不重要，你只要将莫板拿过去用就好了：</p>\n<pre><code>&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;&lt;/title&gt;\n    &lt;meta charset=&quot;utf-8&quot; /&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;&quot; /&gt;\n&lt;/head&gt;\n&lt;body&gt;\n\n\n\n    &lt;script&gt;\n    var scale = 1 / window.devicePixelRatio;\n    document.querySelector(&#39;meta[name=&quot;viewport&quot;]&#39;).setAttribute(&#39;content&#39;,&#39;width=device-width,initial-scale=&#39; + scale + &#39;, maximum-scale=&#39; + scale + &#39;, minimum-scale=&#39; + scale + &#39;, user-scalable=no&#39;);\n\n    document.documentElement.style.fontSize = document.documentElement.clientWidth / 10 + &#39;px&#39;;\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>现在我们使用上面的方法修改我们的代码如下：</p>\n<pre><code>&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;&lt;/title&gt;\n    &lt;meta charset=&quot;utf-8&quot; /&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;&quot; /&gt;\n    &lt;style&gt;\n    body{\n        margin: 0;\n        padding: 0;\n    }\n    .box{\n        width: 2.66666667rem;\n        height: 2.66666667rem;\n        background: red;\n    }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n\n    &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n\n    &lt;script&gt;\n    var scale = 1 / window.devicePixelRatio;\n    document.querySelector(&#39;meta[name=&quot;viewport&quot;]&#39;).setAttribute(&#39;content&#39;,&#39;width=device-width,initial-scale=&#39; + scale + &#39;, maximum-scale=&#39; + scale + &#39;, minimum-scale=&#39; + scale + &#39;, user-scalable=no&#39;);\n\n    document.documentElement.style.fontSize = document.documentElement.clientWidth / 10 + &#39;px&#39;;\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>打开浏览器，分别在iPhone6和iPhone5下查看页面，我们会发现，现在的元素可以根据手机的尺寸不同而等比缩放了。</p>\n<p>上面的方法是手机淘宝的方法，有一个缺点，就是转化rem单位的时候，需要除以font-size的值，淘宝用的是iPhone6的设计图，所以淘宝转换尺寸的时候要除以75，这个值可不好算，所以还要借用计算器来完成，影响开发效率，另外，在转还rem单位时遇到除不尽的数时我们会采用很长的近似值比如上面的2.6666667rem，这样可能会使页面元素的尺寸有偏差。</p>\n<p>除了上面的方法比较通用之外，还有一种方式，我们来重新思考一下：</p>\n<p>上面做页面的思路是：拿到设计图，比如iPhone6的设计图，我们就将浏览器设置到iPhone6设备调试，然后使用js动态修改meta标签，使布局视口的尺寸等于设计图尺寸，也就是设备像素尺寸，然后使用rem替代px做尺寸代为，使得页面在不同设备中等比缩放。</p>\n<p>现在假如我们不去修改meta标签，正常使用缩放为1:1的meta标签，即使用如下meta标签：</p>\n<pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no&quot; /&gt;\n</code></pre><p>还以iPhone6为例，我们知道，在缩放为1:1的情况下，根据公式：</p>\n<p><b>设备像素比（DPR） = 设备像素个数 / 理想视口像素个数（device-width）</b></p>\n<p>我们知道：<br>设备像素 = 设计图尺寸 = 750px<br>布局视口 = 375px</p>\n<p>假设我们以iPhone6设计图尺寸为标准，在设计图的尺寸下设置一个font-size值为100px。<br>也就是说：750px宽的页面，我们设置100px的font-size值，那么页面的宽度换算为rem就等于 750 / 100 = 7.5rem。</p>\n<p>我们就以页面总宽为7.5rem为标准，那么在布局视口中，也就是页面总宽为375px下，font-size值应该是多少？很简单：</p>\n<p>font-size = 375 / 7.5 = 50px</p>\n<p>那么在iPhone5下呢？因为iPhone5的布局视口宽为320px，所以如果页面总宽以7.5为标准，那么iPhone5下我们设置的font-size值应该是：</p>\n<p>font-size = 320 / 7.5 =42.666666667px</p>\n<p>也就是说，不管在什么设备下，我们都可以把页面的总宽度设为一个以rem为单位的定值，比如本例就是7.5rem，只不过，我们需要根据布局视口的尺寸动态设置font-size的值：</p>\n<pre><code>document.documentElement.style.fontSize = document.documentElement.clientWidth / 7.5 + &#39;px&#39;;\n</code></pre><p>这样，无论在什么设备下，我们页面的总宽度都是7.5rem，所以我们直接在设计图上测量px单位的尺寸，然后除以100转换成rem单位后直接使用就可以了，比如，在iPhone6设计图中测量一个元素的尺寸为200px，那么转换成rem单位就是 200 / 100 = 2rem，因为在不同设备下我们动态设置了html标签的font-size值，所以不同设备下相同的rem值对应的像素值是不同的，这样就实现了在不同设备下等比缩放。我们修改html代码如下：</p>\n<pre><code>&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;&lt;/title&gt;\n    &lt;meta charset=&quot;utf-8&quot; /&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no&quot; /&gt;\n    &lt;style&gt;\n    body{\n        margin: 0;\n        padding: 0;\n    }\n    .box{\n        width: 2rem;\n        height: 2rem;\n        background: red;\n    }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n\n    &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n\n    &lt;script&gt;\n    document.documentElement.style.fontSize = document.documentElement.clientWidth / 7.5 + &#39;px&#39;;\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>刷新页面，分别在iPhone6和iPhone5下调试查看结果，会发现如下图，使我们想要的效果，等比缩放，ok，实际上这种做法也是网易的做法：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/2015092320a.jpg\" alt=\"iPhone6下显示效果\"></p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/2015092320b.jpg\" alt=\"iPhone5下显示效果\"></p>\n<p>下面，我们来总结一下第二种做法：</p>\n<p>1、拿到设计图，计算出页面的总宽，为了好计算，取100px的font-size，如果设计图是iPhone6的那么计算出的就是7.5rem，如果页面是iPhone5的那么计算出的结果就是6.4rem。<br>2、动态设置html标签的font-size值：</p>\n<pre><code>  document.documentElement.style.fontSize = document.documentElement.clientWidth / 以rem为单位的页面总宽 + &#39;px&#39;;\n</code></pre><p>  如iPhone6的设计图就是：</p>\n<pre><code>  document.documentElement.style.fontSize = document.documentElement.clientWidth / 7.5 + &#39;px&#39;;\n</code></pre><p>  iPhone5的设计图就是：</p>\n<pre><code>  document.documentElement.style.fontSize = document.documentElement.clientWidth / 6.4 + &#39;px&#39;;\n</code></pre><p>3、做页面是测量设计图的px尺寸除以100得到rem尺寸。<br>4、和淘宝的做法一样，文字字体大小不要使用rem换算。</p>\n<p>下面是这种做法的html莫板：</p>\n<pre><code>&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;&lt;/title&gt;\n    &lt;meta charset=&quot;utf-8&quot; /&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no&quot; /&gt;\n&lt;/head&gt;\n&lt;body&gt;\n\n\n\n    &lt;script&gt;\n    document.documentElement.style.fontSize = document.documentElement.clientWidth / 7.5 + &#39;px&#39;;\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>由于这种做法在开发中换算rem单位的时候只需要将测量的尺寸除以100即可，所以不需要使用计算器我们就可以很快的完成计算转换，所以这也会提升开发效率，本人也比较青睐这种做法。</p>\n<p>另外，无论是第一种做法还是第二种做法，我们都提到了，文字字体大小是不要换算成rem做单位的，而是使用媒体查询来进行动态设置，比如下面的代码就是网易的代码：</p>\n<p>代码片段一：</p>\n<pre><code>@media screen and (max-width: 321px) {\n    body {\n        font-size:16px\n    }\n}\n\n@media screen and (min-width: 321px) and (max-width:400px) {\n    body {\n        font-size:17px\n    }\n}\n\n@media screen and (min-width: 400px) {\n    body {\n        font-size:19px\n    }\n}\n</code></pre><p>代码片段二：</p>\n<pre><code>@media screen and (max-width: 321px) {\n    header,footer {\n        font-size:16px\n    }\n}\n\n@media screen and (min-width: 321px) and (max-width:400px) {\n    header,footer {\n        font-size:17px\n    }\n}\n\n@media screen and (min-width: 400px) {\n    header,footer {\n        font-size:19px\n    }\n}\n</code></pre><p>我们总结一下网易在文字字体大小上的做法，在媒体查询阶段，分为三个等级分别是：<br>321px以下<br>321px - 400px之间<br>400px以上</p>\n<p>具体文字大小要多少个像素这个以设计图为准，但是这三个等级之间是有规律的，仔细观察发现，321px以下的屏幕字体大小比321px - 400px之间的屏幕字体大小要小一个像素，而321px - 400px之间的屏幕字体大小要比400以上屏幕字体大小要小2个像素。依照这个规律，我们根据设计图所在的像素区段先写好该区段的字体大小，然后分别写出另外两个区段的字体大小媒体查询代码就可以了。</p>\n<p>终于码完了这第二篇文章，无力再多说其他的话，望对大家有帮助，有些细节地方没有细说，另外作者水平有限，希望大家指正共同进步，谢谢。</p>"},{"title":"基于gulp requirejs rjs的前端自动化构建系列文章(一)","date":"2015-11-12T02:40:43.000Z","_content":"\n> 前端的自动化，顾名思义，就是让一件事能够在我们的一条命令下就能够自动去执行并很好的完成，而不再需要我们手动去重复这些工作，这个系列文章不仅仅去单一的讲述每一块知识点或者工具的使用方法，因为网上的文章已经很多了，而是在清晰的给读者讲述这些“工具”用法的同时，真正的把他们组合在一起并且搭建一个项目框架雏形来，本系列文章涉及到的知识点有：\n\n* js的模块化（重点在AMD规范）\n* requirejs的介绍及使用\n* rjs的使用\n* 新一代构建工具gulp的介绍及使用\n* 组合以上工具搭建前端自动化开发框架\n\n<!-- more -->\n\n# 写在前面 #\n\n其实上面的每一个知识点都可以单独成文，但是我又不喜欢把本应该是“一件事”的东西拆分的七零八碎，网上很多文章都是其中某一个知识点的总结、介绍或者使用，这样的弊端就是，读者能够看的明白你在说什么，也知道这些工具是干什么的，但是偏偏不会把他们放在一块组合去使用，而且读者可能在搜索引擎中搜索知识点的时候都是单独去搜索，这样学习不同的知识点需要阅读的文章并不是同一个人得文章，这样在思路上和例子代码上很难联系到一块，因为本人当时大概就经历过这样的过程，所以趋于这样的原因，我决定来写此系列文章，由于作者水平有限，并且多是抱着积累学习和分享的态度，所以特别希望大家能够给与指正和建议。\n\n好啦，接下来开始我的系列文章第一篇。\n\n# 一、js模块化与AMD #\n\n### 元某人时期，我国最早的人类，距今约170万年 ###\n\n简介：javascript这门语言很灵活，但是在最初阶段模块化并没有受到重视，是后来nodejs的出现，使得js在浏览器端的模块化迅速崛起，那么到底什么是模块化，我们从头来。\n\n在元某人时期，人类写js代码都是这样的，在head标签中或者body结束标签的上面通过script标签引入一个js脚本文件：\n\n```\n\t<script src=\"a.js\"></script>\n```\n\n于是所有的代码都写在了 a.js 这个文件中，后来，代码越来越多，如果全部写在a.js文件中会使得代码非常不好维护，至于为什么不好维护（自己脑补），你可以想象一下2000行的js文件，然后你忘记一个函数的名称，于是在写代码的时候上下拉来拉去。。。。。。。。这样，人们自然的就想到分出几个js文件，于是，聪明的元某人就把一些类似于获取元素，添加class等等等等功能封装成一个个的函数，单独的写在一个js文件里，取名叫做util.js，意思是工具文件的意思，以后需要用到这些函数的话就直接引入这个文件就可以了，如下：\n\n```\n\t<script src=\"util.js\"></script>\n\t<script src=\"a.js\"></script>\n```\n\n后来元某人发现，工具文件util.js的内容也变的越来越多，于是又把不同功能的函数区分开来，写在不同的文件里，比如把ajax操作函数都分装在了ajax.js文件中，把操作DOM元素的函数封装在了dom.js文件中等等，于是，html页面引入的js文件看上去就成了这样：\n\n```\n\t<script src=\"ajax.js\"></script>\n\t<script src=\"dom.js\"></script>\n\t...\n\t...\n\t<script src=\"a.js\"></script>\n```\n\n那么这样做的坏处是显而易见的：\n1 html文件中引入了过多的js脚本文件，这不会使得浏览器发出很多次http请求，这是影响页面性能的最糟糕因素。\n2 所有变量及函数都是全局变量，极易冲突，比如a.js中有个变量obj，b.js中也有个变量obj。\n3 依赖顺序不易管理，比如我们上面的代码，dom.js依赖ajax.js中的一个函数，那么你必须先引入ajax.js文件再引入dom.js文件。\n\n### 北京人时期，距今约20 ~ 70万年 ###\n\n此北京人非彼北京人，有点历史常识的都应该明白 = =。\n北京人很聪明的，他们发现了上面的问题后，提出，如果每一个文件里面的内容（变量和函数），都用一个对象存储，这样就能打打减小冲突的可能，假如我们将dom.js中的函数都放在一个对象下面，于是dom.js就变成了这样：\n\n```\nvar Dom = {\n\t// 获取元素\n\tgetEle : function(){...},\n\t// 克隆元素\n\tcloneEle : function(){...},\t\n\t// 其他dom方法\n\t...\n};\n```\n\n北京人的确缓解了变量冲突的问题，注意，我用的是“缓解”并不是“解决”，因为这样做只能减少冲突，不能保证一定不会冲突，这样，我们在使用这些函数的时候，就会像这样：\n\n```\nDom.getEle();\n```\n\n如果层级深得话还可能类似于这样：\n\n```\nDom.XXX.getEle();\n```\n\n这并不是读者在杜撰，在为了暴露缺点而乱写的，来看看Yahoo! 的 YUI2 项目，下面是一段真实的代码：\n\n```\nif (org.cometd.Utils.isString(response)) {\n  return org.cometd.JSON.fromJSON(response);\n}\n```\n\n这样是很让人恼火的，我为了使用一个函数，要记住一大串的调用关系，写起来也特别麻烦，假如我记不住调用关系我还要去查询，及其影响开发效率，并且这种做法也仅仅是缓解了命名冲突的问题并没有真正解决，包括文件依赖关系的处理，和页面需要发送的http请求数量等问题依旧没有得到处理。\n\n后来的 山顶洞人、半坡人、河姆渡人通通没有解决这类问题（谁知道有没有解决呢~ ~，也是醉了）\n\n但是再苦难的问题都难不倒我们“新人类”的智慧，什么叫新人类？ 新人类 == ‘贿赂，走关系，乱用职权，公品私用......’ ，咳咳，回到正题，那么新人类到底是怎么解决这个问题的呢？在经历了山顶洞人、半坡人、河姆渡人之后，人们已经深深的被这种问题所痛恶，认识到了模块化的必要性，所以说，模块化目的在于解决以下问题：\n\n* 文件的依赖关系\n* 避免污染全局环境，导致命名冲突\n* 使编码过程变得优雅\n* 性能得到提升\n\n但是人们的确是认识到了模块化的重要行，可真正普及还要归功于nodejs的出现，nodejs是服务器端javascript的实现，如果你使用nodejs你会发现可以使用require()方法加载模块，使用define()定义模块等，实际上nodejs遵循的是Commonjs规范，之所以要有规范是为了统一编码的方式，因为js是一门很灵活的语言，实现模块变成的方式有很多，你写一种我写一种这岂不是就乱套了，目前在javascript中有三种规范，分别是Commonjs规范、AMD规范、CMD规范。三者之间的区别说实话，的确有，但是不大，我们接下来要介绍的就是AMD规范，并且requirejs是AMD规范的一个实现。\n\n### AMD规范 ###\n\nAMD(Asynchronous Module Definition) 译为“异步模块定义”，为什么是异步模块定义呢？我们知道，nodejs中使用require去加载模块的时候，模块多在内存或磁盘中，而且在浏览器环境中，需要通过网络请求去加载模块，这与从内存或磁盘中加载模块根本就不在一个量级上，假如我们同步加载模块的话，浏览器会停滞在这里出现假死的状态，要等到所有模块全部加载完之后才会继续执行其他操作。所以我们需要一个适用于浏览器端实现模块化的规范，而这也是AMD规范的成因。\n\n下面我们来看看，AMD规范中我们如何去写代码，其中我们只需要关注如何定义一个模块，和如何使用模块。\n\n#### 如何定义一个模块 ####\n\nAMD规范规定使用define()方法定义一个模块，define方法如下：\n\ndefine(id?, dependencies?, factory);\n\n参数说明：\n\tid {String} 模块标识，可以省略。\n\tdependencies {Array} 所依赖的模块数组，可以省略。\n\tfactory {Object} | {Function} 模块的实现。\n\n看下面的代码，定义了一个模块，该模块没有依赖任何其他模块，也没有名字（即没有id这个参数）：\n\n```\ndefine(function(){\n\treturn {\n\t\ta : '1',\n\t\tb : '2'\n\t}\n});\n```\n\n像上面的代码，如果只是简单的返回一个对象，也可以这样写：\n\n```\ndefine({\n\ta : '1',\n\tb : '2'\n});\n```\n\n上面定义的模块返回了一个对象，AMD规定，返回的对象，即为该模块对象。也可以返回一个函数，如下：\n\n```\ndefine(function(){\n\tvar m = function(){\n\n\t};\n\n\treturn m;\n\n});\n```\n\n如果你编写的模块需要使用其他模块中的方法，那么你就需要依赖那个模块，这个时候你就可以传递第二个参数，第二个参数是一个数组，数组中的每一个元素为你依赖模块的名称：\n\n```\ndefine(['A', 'B'], function(A, B){\n\t\n\tA.add();\n\n\treturn {\n\t\ta : '1',\n\t\tb : '2'\n\t}\n});\n```\n\n上面的代码定义了一个模块，该模块依赖两个模块，分别是模块A和模块B，注意我们在函数中传递了与依赖数组中一一对应的形式参数，以便在模块中使用依赖的模块，而我们也在模块中调用了模块A的add()方法。\n\n上面我们定义的模块都没有传递id这个参数，我们也可以传递这个参数，这样就像我们给模块去了一个名字，所以带有id这个参数的模块叫做具名模块：\n\n```\ndefine('index', ['A'], function(A){\n\t...\n});\n```\n\n但是我们一般不会手动的去写，一般我们在使用构建工具优化项目的时候，如我们使用gulp配合rjs合并模块的时候，自动去帮我们填充模块id。\n\n最后，介绍一下AMD规范兼容Commonjs规范的一个模块定义写法：\n\n```\ndefine(function(require, exports, module){\n\tvar m = require('m1');\n\n\texports.A = function(){\n\t\treturn m.add();\n\t}\n});\n```\n\n我们在函数中显示的传递了三个参数，分别是require，exports和module，这三个变量是全局的，其中require是用来加载其他模块的，exports是用来导出模块接口的，module是模块对象本身。\n\n接下来我们讲解一下requrie，require是用来引用模块的，及加载模块，上面我们已经看到了require()方法，我们传递了一个字符串，及模块的名称，去加载模块，实际上我们还可以传递依赖数组，如下：\n\n```\nrequire(['A', 'B'], function(A, B){\n\t// ...\n});\n```\n\n这样，js大概的模块化历史和AMD规范我们就简单介绍完了，由于我们这篇文章综合性比较强，如果想深入了解AMD，点击这里：[AMD](https://github.com/amdjs/amdjs-api/blob/master/require.md)\n\n这篇文章就到这里，下一章我们结合实际的案例仔细讨论一下requirejs，并相信我，一定有你能学到的东西。\n\n如果对你有用，感谢捐助。\n\n![支付宝二维码](http://7xlolm.com1.z0.glb.clouddn.com/201511122.pic.jpg)\n","source":"_posts/2015/11/12/基于gulp-requirejs-rjs的前端自动化构建.md","raw":"title: 基于gulp requirejs rjs的前端自动化构建系列文章(一)\ndate: 2015-11-12 10:40:43\ncategories:\n- WebFrontEnd\ntags:\n- js\n- 自动化\n- gulp\n- requirejs\n- rjs\n- 构建\n---\n\n> 前端的自动化，顾名思义，就是让一件事能够在我们的一条命令下就能够自动去执行并很好的完成，而不再需要我们手动去重复这些工作，这个系列文章不仅仅去单一的讲述每一块知识点或者工具的使用方法，因为网上的文章已经很多了，而是在清晰的给读者讲述这些“工具”用法的同时，真正的把他们组合在一起并且搭建一个项目框架雏形来，本系列文章涉及到的知识点有：\n\n* js的模块化（重点在AMD规范）\n* requirejs的介绍及使用\n* rjs的使用\n* 新一代构建工具gulp的介绍及使用\n* 组合以上工具搭建前端自动化开发框架\n\n<!-- more -->\n\n# 写在前面 #\n\n其实上面的每一个知识点都可以单独成文，但是我又不喜欢把本应该是“一件事”的东西拆分的七零八碎，网上很多文章都是其中某一个知识点的总结、介绍或者使用，这样的弊端就是，读者能够看的明白你在说什么，也知道这些工具是干什么的，但是偏偏不会把他们放在一块组合去使用，而且读者可能在搜索引擎中搜索知识点的时候都是单独去搜索，这样学习不同的知识点需要阅读的文章并不是同一个人得文章，这样在思路上和例子代码上很难联系到一块，因为本人当时大概就经历过这样的过程，所以趋于这样的原因，我决定来写此系列文章，由于作者水平有限，并且多是抱着积累学习和分享的态度，所以特别希望大家能够给与指正和建议。\n\n好啦，接下来开始我的系列文章第一篇。\n\n# 一、js模块化与AMD #\n\n### 元某人时期，我国最早的人类，距今约170万年 ###\n\n简介：javascript这门语言很灵活，但是在最初阶段模块化并没有受到重视，是后来nodejs的出现，使得js在浏览器端的模块化迅速崛起，那么到底什么是模块化，我们从头来。\n\n在元某人时期，人类写js代码都是这样的，在head标签中或者body结束标签的上面通过script标签引入一个js脚本文件：\n\n```\n\t<script src=\"a.js\"></script>\n```\n\n于是所有的代码都写在了 a.js 这个文件中，后来，代码越来越多，如果全部写在a.js文件中会使得代码非常不好维护，至于为什么不好维护（自己脑补），你可以想象一下2000行的js文件，然后你忘记一个函数的名称，于是在写代码的时候上下拉来拉去。。。。。。。。这样，人们自然的就想到分出几个js文件，于是，聪明的元某人就把一些类似于获取元素，添加class等等等等功能封装成一个个的函数，单独的写在一个js文件里，取名叫做util.js，意思是工具文件的意思，以后需要用到这些函数的话就直接引入这个文件就可以了，如下：\n\n```\n\t<script src=\"util.js\"></script>\n\t<script src=\"a.js\"></script>\n```\n\n后来元某人发现，工具文件util.js的内容也变的越来越多，于是又把不同功能的函数区分开来，写在不同的文件里，比如把ajax操作函数都分装在了ajax.js文件中，把操作DOM元素的函数封装在了dom.js文件中等等，于是，html页面引入的js文件看上去就成了这样：\n\n```\n\t<script src=\"ajax.js\"></script>\n\t<script src=\"dom.js\"></script>\n\t...\n\t...\n\t<script src=\"a.js\"></script>\n```\n\n那么这样做的坏处是显而易见的：\n1 html文件中引入了过多的js脚本文件，这不会使得浏览器发出很多次http请求，这是影响页面性能的最糟糕因素。\n2 所有变量及函数都是全局变量，极易冲突，比如a.js中有个变量obj，b.js中也有个变量obj。\n3 依赖顺序不易管理，比如我们上面的代码，dom.js依赖ajax.js中的一个函数，那么你必须先引入ajax.js文件再引入dom.js文件。\n\n### 北京人时期，距今约20 ~ 70万年 ###\n\n此北京人非彼北京人，有点历史常识的都应该明白 = =。\n北京人很聪明的，他们发现了上面的问题后，提出，如果每一个文件里面的内容（变量和函数），都用一个对象存储，这样就能打打减小冲突的可能，假如我们将dom.js中的函数都放在一个对象下面，于是dom.js就变成了这样：\n\n```\nvar Dom = {\n\t// 获取元素\n\tgetEle : function(){...},\n\t// 克隆元素\n\tcloneEle : function(){...},\t\n\t// 其他dom方法\n\t...\n};\n```\n\n北京人的确缓解了变量冲突的问题，注意，我用的是“缓解”并不是“解决”，因为这样做只能减少冲突，不能保证一定不会冲突，这样，我们在使用这些函数的时候，就会像这样：\n\n```\nDom.getEle();\n```\n\n如果层级深得话还可能类似于这样：\n\n```\nDom.XXX.getEle();\n```\n\n这并不是读者在杜撰，在为了暴露缺点而乱写的，来看看Yahoo! 的 YUI2 项目，下面是一段真实的代码：\n\n```\nif (org.cometd.Utils.isString(response)) {\n  return org.cometd.JSON.fromJSON(response);\n}\n```\n\n这样是很让人恼火的，我为了使用一个函数，要记住一大串的调用关系，写起来也特别麻烦，假如我记不住调用关系我还要去查询，及其影响开发效率，并且这种做法也仅仅是缓解了命名冲突的问题并没有真正解决，包括文件依赖关系的处理，和页面需要发送的http请求数量等问题依旧没有得到处理。\n\n后来的 山顶洞人、半坡人、河姆渡人通通没有解决这类问题（谁知道有没有解决呢~ ~，也是醉了）\n\n但是再苦难的问题都难不倒我们“新人类”的智慧，什么叫新人类？ 新人类 == ‘贿赂，走关系，乱用职权，公品私用......’ ，咳咳，回到正题，那么新人类到底是怎么解决这个问题的呢？在经历了山顶洞人、半坡人、河姆渡人之后，人们已经深深的被这种问题所痛恶，认识到了模块化的必要性，所以说，模块化目的在于解决以下问题：\n\n* 文件的依赖关系\n* 避免污染全局环境，导致命名冲突\n* 使编码过程变得优雅\n* 性能得到提升\n\n但是人们的确是认识到了模块化的重要行，可真正普及还要归功于nodejs的出现，nodejs是服务器端javascript的实现，如果你使用nodejs你会发现可以使用require()方法加载模块，使用define()定义模块等，实际上nodejs遵循的是Commonjs规范，之所以要有规范是为了统一编码的方式，因为js是一门很灵活的语言，实现模块变成的方式有很多，你写一种我写一种这岂不是就乱套了，目前在javascript中有三种规范，分别是Commonjs规范、AMD规范、CMD规范。三者之间的区别说实话，的确有，但是不大，我们接下来要介绍的就是AMD规范，并且requirejs是AMD规范的一个实现。\n\n### AMD规范 ###\n\nAMD(Asynchronous Module Definition) 译为“异步模块定义”，为什么是异步模块定义呢？我们知道，nodejs中使用require去加载模块的时候，模块多在内存或磁盘中，而且在浏览器环境中，需要通过网络请求去加载模块，这与从内存或磁盘中加载模块根本就不在一个量级上，假如我们同步加载模块的话，浏览器会停滞在这里出现假死的状态，要等到所有模块全部加载完之后才会继续执行其他操作。所以我们需要一个适用于浏览器端实现模块化的规范，而这也是AMD规范的成因。\n\n下面我们来看看，AMD规范中我们如何去写代码，其中我们只需要关注如何定义一个模块，和如何使用模块。\n\n#### 如何定义一个模块 ####\n\nAMD规范规定使用define()方法定义一个模块，define方法如下：\n\ndefine(id?, dependencies?, factory);\n\n参数说明：\n\tid {String} 模块标识，可以省略。\n\tdependencies {Array} 所依赖的模块数组，可以省略。\n\tfactory {Object} | {Function} 模块的实现。\n\n看下面的代码，定义了一个模块，该模块没有依赖任何其他模块，也没有名字（即没有id这个参数）：\n\n```\ndefine(function(){\n\treturn {\n\t\ta : '1',\n\t\tb : '2'\n\t}\n});\n```\n\n像上面的代码，如果只是简单的返回一个对象，也可以这样写：\n\n```\ndefine({\n\ta : '1',\n\tb : '2'\n});\n```\n\n上面定义的模块返回了一个对象，AMD规定，返回的对象，即为该模块对象。也可以返回一个函数，如下：\n\n```\ndefine(function(){\n\tvar m = function(){\n\n\t};\n\n\treturn m;\n\n});\n```\n\n如果你编写的模块需要使用其他模块中的方法，那么你就需要依赖那个模块，这个时候你就可以传递第二个参数，第二个参数是一个数组，数组中的每一个元素为你依赖模块的名称：\n\n```\ndefine(['A', 'B'], function(A, B){\n\t\n\tA.add();\n\n\treturn {\n\t\ta : '1',\n\t\tb : '2'\n\t}\n});\n```\n\n上面的代码定义了一个模块，该模块依赖两个模块，分别是模块A和模块B，注意我们在函数中传递了与依赖数组中一一对应的形式参数，以便在模块中使用依赖的模块，而我们也在模块中调用了模块A的add()方法。\n\n上面我们定义的模块都没有传递id这个参数，我们也可以传递这个参数，这样就像我们给模块去了一个名字，所以带有id这个参数的模块叫做具名模块：\n\n```\ndefine('index', ['A'], function(A){\n\t...\n});\n```\n\n但是我们一般不会手动的去写，一般我们在使用构建工具优化项目的时候，如我们使用gulp配合rjs合并模块的时候，自动去帮我们填充模块id。\n\n最后，介绍一下AMD规范兼容Commonjs规范的一个模块定义写法：\n\n```\ndefine(function(require, exports, module){\n\tvar m = require('m1');\n\n\texports.A = function(){\n\t\treturn m.add();\n\t}\n});\n```\n\n我们在函数中显示的传递了三个参数，分别是require，exports和module，这三个变量是全局的，其中require是用来加载其他模块的，exports是用来导出模块接口的，module是模块对象本身。\n\n接下来我们讲解一下requrie，require是用来引用模块的，及加载模块，上面我们已经看到了require()方法，我们传递了一个字符串，及模块的名称，去加载模块，实际上我们还可以传递依赖数组，如下：\n\n```\nrequire(['A', 'B'], function(A, B){\n\t// ...\n});\n```\n\n这样，js大概的模块化历史和AMD规范我们就简单介绍完了，由于我们这篇文章综合性比较强，如果想深入了解AMD，点击这里：[AMD](https://github.com/amdjs/amdjs-api/blob/master/require.md)\n\n这篇文章就到这里，下一章我们结合实际的案例仔细讨论一下requirejs，并相信我，一定有你能学到的东西。\n\n如果对你有用，感谢捐助。\n\n![支付宝二维码](http://7xlolm.com1.z0.glb.clouddn.com/201511122.pic.jpg)\n","slug":"基于gulp-requirejs-rjs的前端自动化构建","published":1,"updated":"2015-11-12T11:20:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj669fsjn000mewfcno4zqmca","content":"<blockquote>\n<p>前端的自动化，顾名思义，就是让一件事能够在我们的一条命令下就能够自动去执行并很好的完成，而不再需要我们手动去重复这些工作，这个系列文章不仅仅去单一的讲述每一块知识点或者工具的使用方法，因为网上的文章已经很多了，而是在清晰的给读者讲述这些“工具”用法的同时，真正的把他们组合在一起并且搭建一个项目框架雏形来，本系列文章涉及到的知识点有：</p>\n</blockquote>\n<ul>\n<li>js的模块化（重点在AMD规范）</li>\n<li>requirejs的介绍及使用</li>\n<li>rjs的使用</li>\n<li>新一代构建工具gulp的介绍及使用</li>\n<li>组合以上工具搭建前端自动化开发框架</li>\n</ul>\n<a id=\"more\"></a>\n<h1 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h1><p>其实上面的每一个知识点都可以单独成文，但是我又不喜欢把本应该是“一件事”的东西拆分的七零八碎，网上很多文章都是其中某一个知识点的总结、介绍或者使用，这样的弊端就是，读者能够看的明白你在说什么，也知道这些工具是干什么的，但是偏偏不会把他们放在一块组合去使用，而且读者可能在搜索引擎中搜索知识点的时候都是单独去搜索，这样学习不同的知识点需要阅读的文章并不是同一个人得文章，这样在思路上和例子代码上很难联系到一块，因为本人当时大概就经历过这样的过程，所以趋于这样的原因，我决定来写此系列文章，由于作者水平有限，并且多是抱着积累学习和分享的态度，所以特别希望大家能够给与指正和建议。</p>\n<p>好啦，接下来开始我的系列文章第一篇。</p>\n<h1 id=\"一、js模块化与AMD\"><a href=\"#一、js模块化与AMD\" class=\"headerlink\" title=\"一、js模块化与AMD\"></a>一、js模块化与AMD</h1><h3 id=\"元某人时期，我国最早的人类，距今约170万年\"><a href=\"#元某人时期，我国最早的人类，距今约170万年\" class=\"headerlink\" title=\"元某人时期，我国最早的人类，距今约170万年\"></a>元某人时期，我国最早的人类，距今约170万年</h3><p>简介：javascript这门语言很灵活，但是在最初阶段模块化并没有受到重视，是后来nodejs的出现，使得js在浏览器端的模块化迅速崛起，那么到底什么是模块化，我们从头来。</p>\n<p>在元某人时期，人类写js代码都是这样的，在head标签中或者body结束标签的上面通过script标签引入一个js脚本文件：</p>\n<pre><code>    &lt;script src=&quot;a.js&quot;&gt;&lt;/script&gt;\n</code></pre><p>于是所有的代码都写在了 a.js 这个文件中，后来，代码越来越多，如果全部写在a.js文件中会使得代码非常不好维护，至于为什么不好维护（自己脑补），你可以想象一下2000行的js文件，然后你忘记一个函数的名称，于是在写代码的时候上下拉来拉去。。。。。。。。这样，人们自然的就想到分出几个js文件，于是，聪明的元某人就把一些类似于获取元素，添加class等等等等功能封装成一个个的函数，单独的写在一个js文件里，取名叫做util.js，意思是工具文件的意思，以后需要用到这些函数的话就直接引入这个文件就可以了，如下：</p>\n<pre><code>    &lt;script src=&quot;util.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;a.js&quot;&gt;&lt;/script&gt;\n</code></pre><p>后来元某人发现，工具文件util.js的内容也变的越来越多，于是又把不同功能的函数区分开来，写在不同的文件里，比如把ajax操作函数都分装在了ajax.js文件中，把操作DOM元素的函数封装在了dom.js文件中等等，于是，html页面引入的js文件看上去就成了这样：</p>\n<pre><code>    &lt;script src=&quot;ajax.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;dom.js&quot;&gt;&lt;/script&gt;\n    ...\n    ...\n    &lt;script src=&quot;a.js&quot;&gt;&lt;/script&gt;\n</code></pre><p>那么这样做的坏处是显而易见的：<br>1 html文件中引入了过多的js脚本文件，这不会使得浏览器发出很多次http请求，这是影响页面性能的最糟糕因素。<br>2 所有变量及函数都是全局变量，极易冲突，比如a.js中有个变量obj，b.js中也有个变量obj。<br>3 依赖顺序不易管理，比如我们上面的代码，dom.js依赖ajax.js中的一个函数，那么你必须先引入ajax.js文件再引入dom.js文件。</p>\n<h3 id=\"北京人时期，距今约20-70万年\"><a href=\"#北京人时期，距今约20-70万年\" class=\"headerlink\" title=\"北京人时期，距今约20 ~ 70万年\"></a>北京人时期，距今约20 ~ 70万年</h3><p>此北京人非彼北京人，有点历史常识的都应该明白 = =。<br>北京人很聪明的，他们发现了上面的问题后，提出，如果每一个文件里面的内容（变量和函数），都用一个对象存储，这样就能打打减小冲突的可能，假如我们将dom.js中的函数都放在一个对象下面，于是dom.js就变成了这样：</p>\n<pre><code>var Dom = {\n    // 获取元素\n    getEle : function(){...},\n    // 克隆元素\n    cloneEle : function(){...},    \n    // 其他dom方法\n    ...\n};\n</code></pre><p>北京人的确缓解了变量冲突的问题，注意，我用的是“缓解”并不是“解决”，因为这样做只能减少冲突，不能保证一定不会冲突，这样，我们在使用这些函数的时候，就会像这样：</p>\n<pre><code>Dom.getEle();\n</code></pre><p>如果层级深得话还可能类似于这样：</p>\n<pre><code>Dom.XXX.getEle();\n</code></pre><p>这并不是读者在杜撰，在为了暴露缺点而乱写的，来看看Yahoo! 的 YUI2 项目，下面是一段真实的代码：</p>\n<pre><code>if (org.cometd.Utils.isString(response)) {\n  return org.cometd.JSON.fromJSON(response);\n}\n</code></pre><p>这样是很让人恼火的，我为了使用一个函数，要记住一大串的调用关系，写起来也特别麻烦，假如我记不住调用关系我还要去查询，及其影响开发效率，并且这种做法也仅仅是缓解了命名冲突的问题并没有真正解决，包括文件依赖关系的处理，和页面需要发送的http请求数量等问题依旧没有得到处理。</p>\n<p>后来的 山顶洞人、半坡人、河姆渡人通通没有解决这类问题（谁知道有没有解决呢~ ~，也是醉了）</p>\n<p>但是再苦难的问题都难不倒我们“新人类”的智慧，什么叫新人类？ 新人类 == ‘贿赂，走关系，乱用职权，公品私用……’ ，咳咳，回到正题，那么新人类到底是怎么解决这个问题的呢？在经历了山顶洞人、半坡人、河姆渡人之后，人们已经深深的被这种问题所痛恶，认识到了模块化的必要性，所以说，模块化目的在于解决以下问题：</p>\n<ul>\n<li>文件的依赖关系</li>\n<li>避免污染全局环境，导致命名冲突</li>\n<li>使编码过程变得优雅</li>\n<li>性能得到提升</li>\n</ul>\n<p>但是人们的确是认识到了模块化的重要行，可真正普及还要归功于nodejs的出现，nodejs是服务器端javascript的实现，如果你使用nodejs你会发现可以使用require()方法加载模块，使用define()定义模块等，实际上nodejs遵循的是Commonjs规范，之所以要有规范是为了统一编码的方式，因为js是一门很灵活的语言，实现模块变成的方式有很多，你写一种我写一种这岂不是就乱套了，目前在javascript中有三种规范，分别是Commonjs规范、AMD规范、CMD规范。三者之间的区别说实话，的确有，但是不大，我们接下来要介绍的就是AMD规范，并且requirejs是AMD规范的一个实现。</p>\n<h3 id=\"AMD规范\"><a href=\"#AMD规范\" class=\"headerlink\" title=\"AMD规范\"></a>AMD规范</h3><p>AMD(Asynchronous Module Definition) 译为“异步模块定义”，为什么是异步模块定义呢？我们知道，nodejs中使用require去加载模块的时候，模块多在内存或磁盘中，而且在浏览器环境中，需要通过网络请求去加载模块，这与从内存或磁盘中加载模块根本就不在一个量级上，假如我们同步加载模块的话，浏览器会停滞在这里出现假死的状态，要等到所有模块全部加载完之后才会继续执行其他操作。所以我们需要一个适用于浏览器端实现模块化的规范，而这也是AMD规范的成因。</p>\n<p>下面我们来看看，AMD规范中我们如何去写代码，其中我们只需要关注如何定义一个模块，和如何使用模块。</p>\n<h4 id=\"如何定义一个模块\"><a href=\"#如何定义一个模块\" class=\"headerlink\" title=\"如何定义一个模块\"></a>如何定义一个模块</h4><p>AMD规范规定使用define()方法定义一个模块，define方法如下：</p>\n<p>define(id?, dependencies?, factory);</p>\n<p>参数说明：<br>    id {String} 模块标识，可以省略。<br>    dependencies {Array} 所依赖的模块数组，可以省略。<br>    factory {Object} | {Function} 模块的实现。</p>\n<p>看下面的代码，定义了一个模块，该模块没有依赖任何其他模块，也没有名字（即没有id这个参数）：</p>\n<pre><code>define(function(){\n    return {\n        a : &#39;1&#39;,\n        b : &#39;2&#39;\n    }\n});\n</code></pre><p>像上面的代码，如果只是简单的返回一个对象，也可以这样写：</p>\n<pre><code>define({\n    a : &#39;1&#39;,\n    b : &#39;2&#39;\n});\n</code></pre><p>上面定义的模块返回了一个对象，AMD规定，返回的对象，即为该模块对象。也可以返回一个函数，如下：</p>\n<pre><code>define(function(){\n    var m = function(){\n\n    };\n\n    return m;\n\n});\n</code></pre><p>如果你编写的模块需要使用其他模块中的方法，那么你就需要依赖那个模块，这个时候你就可以传递第二个参数，第二个参数是一个数组，数组中的每一个元素为你依赖模块的名称：</p>\n<pre><code>define([&#39;A&#39;, &#39;B&#39;], function(A, B){\n\n    A.add();\n\n    return {\n        a : &#39;1&#39;,\n        b : &#39;2&#39;\n    }\n});\n</code></pre><p>上面的代码定义了一个模块，该模块依赖两个模块，分别是模块A和模块B，注意我们在函数中传递了与依赖数组中一一对应的形式参数，以便在模块中使用依赖的模块，而我们也在模块中调用了模块A的add()方法。</p>\n<p>上面我们定义的模块都没有传递id这个参数，我们也可以传递这个参数，这样就像我们给模块去了一个名字，所以带有id这个参数的模块叫做具名模块：</p>\n<pre><code>define(&#39;index&#39;, [&#39;A&#39;], function(A){\n    ...\n});\n</code></pre><p>但是我们一般不会手动的去写，一般我们在使用构建工具优化项目的时候，如我们使用gulp配合rjs合并模块的时候，自动去帮我们填充模块id。</p>\n<p>最后，介绍一下AMD规范兼容Commonjs规范的一个模块定义写法：</p>\n<pre><code>define(function(require, exports, module){\n    var m = require(&#39;m1&#39;);\n\n    exports.A = function(){\n        return m.add();\n    }\n});\n</code></pre><p>我们在函数中显示的传递了三个参数，分别是require，exports和module，这三个变量是全局的，其中require是用来加载其他模块的，exports是用来导出模块接口的，module是模块对象本身。</p>\n<p>接下来我们讲解一下requrie，require是用来引用模块的，及加载模块，上面我们已经看到了require()方法，我们传递了一个字符串，及模块的名称，去加载模块，实际上我们还可以传递依赖数组，如下：</p>\n<pre><code>require([&#39;A&#39;, &#39;B&#39;], function(A, B){\n    // ...\n});\n</code></pre><p>这样，js大概的模块化历史和AMD规范我们就简单介绍完了，由于我们这篇文章综合性比较强，如果想深入了解AMD，点击这里：<a href=\"https://github.com/amdjs/amdjs-api/blob/master/require.md\" target=\"_blank\" rel=\"external\">AMD</a></p>\n<p>这篇文章就到这里，下一章我们结合实际的案例仔细讨论一下requirejs，并相信我，一定有你能学到的东西。</p>\n<p>如果对你有用，感谢捐助。</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201511122.pic.jpg\" alt=\"支付宝二维码\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>前端的自动化，顾名思义，就是让一件事能够在我们的一条命令下就能够自动去执行并很好的完成，而不再需要我们手动去重复这些工作，这个系列文章不仅仅去单一的讲述每一块知识点或者工具的使用方法，因为网上的文章已经很多了，而是在清晰的给读者讲述这些“工具”用法的同时，真正的把他们组合在一起并且搭建一个项目框架雏形来，本系列文章涉及到的知识点有：</p>\n</blockquote>\n<ul>\n<li>js的模块化（重点在AMD规范）</li>\n<li>requirejs的介绍及使用</li>\n<li>rjs的使用</li>\n<li>新一代构建工具gulp的介绍及使用</li>\n<li>组合以上工具搭建前端自动化开发框架</li>\n</ul>","more":"<h1 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h1><p>其实上面的每一个知识点都可以单独成文，但是我又不喜欢把本应该是“一件事”的东西拆分的七零八碎，网上很多文章都是其中某一个知识点的总结、介绍或者使用，这样的弊端就是，读者能够看的明白你在说什么，也知道这些工具是干什么的，但是偏偏不会把他们放在一块组合去使用，而且读者可能在搜索引擎中搜索知识点的时候都是单独去搜索，这样学习不同的知识点需要阅读的文章并不是同一个人得文章，这样在思路上和例子代码上很难联系到一块，因为本人当时大概就经历过这样的过程，所以趋于这样的原因，我决定来写此系列文章，由于作者水平有限，并且多是抱着积累学习和分享的态度，所以特别希望大家能够给与指正和建议。</p>\n<p>好啦，接下来开始我的系列文章第一篇。</p>\n<h1 id=\"一、js模块化与AMD\"><a href=\"#一、js模块化与AMD\" class=\"headerlink\" title=\"一、js模块化与AMD\"></a>一、js模块化与AMD</h1><h3 id=\"元某人时期，我国最早的人类，距今约170万年\"><a href=\"#元某人时期，我国最早的人类，距今约170万年\" class=\"headerlink\" title=\"元某人时期，我国最早的人类，距今约170万年\"></a>元某人时期，我国最早的人类，距今约170万年</h3><p>简介：javascript这门语言很灵活，但是在最初阶段模块化并没有受到重视，是后来nodejs的出现，使得js在浏览器端的模块化迅速崛起，那么到底什么是模块化，我们从头来。</p>\n<p>在元某人时期，人类写js代码都是这样的，在head标签中或者body结束标签的上面通过script标签引入一个js脚本文件：</p>\n<pre><code>    &lt;script src=&quot;a.js&quot;&gt;&lt;/script&gt;\n</code></pre><p>于是所有的代码都写在了 a.js 这个文件中，后来，代码越来越多，如果全部写在a.js文件中会使得代码非常不好维护，至于为什么不好维护（自己脑补），你可以想象一下2000行的js文件，然后你忘记一个函数的名称，于是在写代码的时候上下拉来拉去。。。。。。。。这样，人们自然的就想到分出几个js文件，于是，聪明的元某人就把一些类似于获取元素，添加class等等等等功能封装成一个个的函数，单独的写在一个js文件里，取名叫做util.js，意思是工具文件的意思，以后需要用到这些函数的话就直接引入这个文件就可以了，如下：</p>\n<pre><code>    &lt;script src=&quot;util.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;a.js&quot;&gt;&lt;/script&gt;\n</code></pre><p>后来元某人发现，工具文件util.js的内容也变的越来越多，于是又把不同功能的函数区分开来，写在不同的文件里，比如把ajax操作函数都分装在了ajax.js文件中，把操作DOM元素的函数封装在了dom.js文件中等等，于是，html页面引入的js文件看上去就成了这样：</p>\n<pre><code>    &lt;script src=&quot;ajax.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;dom.js&quot;&gt;&lt;/script&gt;\n    ...\n    ...\n    &lt;script src=&quot;a.js&quot;&gt;&lt;/script&gt;\n</code></pre><p>那么这样做的坏处是显而易见的：<br>1 html文件中引入了过多的js脚本文件，这不会使得浏览器发出很多次http请求，这是影响页面性能的最糟糕因素。<br>2 所有变量及函数都是全局变量，极易冲突，比如a.js中有个变量obj，b.js中也有个变量obj。<br>3 依赖顺序不易管理，比如我们上面的代码，dom.js依赖ajax.js中的一个函数，那么你必须先引入ajax.js文件再引入dom.js文件。</p>\n<h3 id=\"北京人时期，距今约20-70万年\"><a href=\"#北京人时期，距今约20-70万年\" class=\"headerlink\" title=\"北京人时期，距今约20 ~ 70万年\"></a>北京人时期，距今约20 ~ 70万年</h3><p>此北京人非彼北京人，有点历史常识的都应该明白 = =。<br>北京人很聪明的，他们发现了上面的问题后，提出，如果每一个文件里面的内容（变量和函数），都用一个对象存储，这样就能打打减小冲突的可能，假如我们将dom.js中的函数都放在一个对象下面，于是dom.js就变成了这样：</p>\n<pre><code>var Dom = {\n    // 获取元素\n    getEle : function(){...},\n    // 克隆元素\n    cloneEle : function(){...},    \n    // 其他dom方法\n    ...\n};\n</code></pre><p>北京人的确缓解了变量冲突的问题，注意，我用的是“缓解”并不是“解决”，因为这样做只能减少冲突，不能保证一定不会冲突，这样，我们在使用这些函数的时候，就会像这样：</p>\n<pre><code>Dom.getEle();\n</code></pre><p>如果层级深得话还可能类似于这样：</p>\n<pre><code>Dom.XXX.getEle();\n</code></pre><p>这并不是读者在杜撰，在为了暴露缺点而乱写的，来看看Yahoo! 的 YUI2 项目，下面是一段真实的代码：</p>\n<pre><code>if (org.cometd.Utils.isString(response)) {\n  return org.cometd.JSON.fromJSON(response);\n}\n</code></pre><p>这样是很让人恼火的，我为了使用一个函数，要记住一大串的调用关系，写起来也特别麻烦，假如我记不住调用关系我还要去查询，及其影响开发效率，并且这种做法也仅仅是缓解了命名冲突的问题并没有真正解决，包括文件依赖关系的处理，和页面需要发送的http请求数量等问题依旧没有得到处理。</p>\n<p>后来的 山顶洞人、半坡人、河姆渡人通通没有解决这类问题（谁知道有没有解决呢~ ~，也是醉了）</p>\n<p>但是再苦难的问题都难不倒我们“新人类”的智慧，什么叫新人类？ 新人类 == ‘贿赂，走关系，乱用职权，公品私用……’ ，咳咳，回到正题，那么新人类到底是怎么解决这个问题的呢？在经历了山顶洞人、半坡人、河姆渡人之后，人们已经深深的被这种问题所痛恶，认识到了模块化的必要性，所以说，模块化目的在于解决以下问题：</p>\n<ul>\n<li>文件的依赖关系</li>\n<li>避免污染全局环境，导致命名冲突</li>\n<li>使编码过程变得优雅</li>\n<li>性能得到提升</li>\n</ul>\n<p>但是人们的确是认识到了模块化的重要行，可真正普及还要归功于nodejs的出现，nodejs是服务器端javascript的实现，如果你使用nodejs你会发现可以使用require()方法加载模块，使用define()定义模块等，实际上nodejs遵循的是Commonjs规范，之所以要有规范是为了统一编码的方式，因为js是一门很灵活的语言，实现模块变成的方式有很多，你写一种我写一种这岂不是就乱套了，目前在javascript中有三种规范，分别是Commonjs规范、AMD规范、CMD规范。三者之间的区别说实话，的确有，但是不大，我们接下来要介绍的就是AMD规范，并且requirejs是AMD规范的一个实现。</p>\n<h3 id=\"AMD规范\"><a href=\"#AMD规范\" class=\"headerlink\" title=\"AMD规范\"></a>AMD规范</h3><p>AMD(Asynchronous Module Definition) 译为“异步模块定义”，为什么是异步模块定义呢？我们知道，nodejs中使用require去加载模块的时候，模块多在内存或磁盘中，而且在浏览器环境中，需要通过网络请求去加载模块，这与从内存或磁盘中加载模块根本就不在一个量级上，假如我们同步加载模块的话，浏览器会停滞在这里出现假死的状态，要等到所有模块全部加载完之后才会继续执行其他操作。所以我们需要一个适用于浏览器端实现模块化的规范，而这也是AMD规范的成因。</p>\n<p>下面我们来看看，AMD规范中我们如何去写代码，其中我们只需要关注如何定义一个模块，和如何使用模块。</p>\n<h4 id=\"如何定义一个模块\"><a href=\"#如何定义一个模块\" class=\"headerlink\" title=\"如何定义一个模块\"></a>如何定义一个模块</h4><p>AMD规范规定使用define()方法定义一个模块，define方法如下：</p>\n<p>define(id?, dependencies?, factory);</p>\n<p>参数说明：<br>    id {String} 模块标识，可以省略。<br>    dependencies {Array} 所依赖的模块数组，可以省略。<br>    factory {Object} | {Function} 模块的实现。</p>\n<p>看下面的代码，定义了一个模块，该模块没有依赖任何其他模块，也没有名字（即没有id这个参数）：</p>\n<pre><code>define(function(){\n    return {\n        a : &#39;1&#39;,\n        b : &#39;2&#39;\n    }\n});\n</code></pre><p>像上面的代码，如果只是简单的返回一个对象，也可以这样写：</p>\n<pre><code>define({\n    a : &#39;1&#39;,\n    b : &#39;2&#39;\n});\n</code></pre><p>上面定义的模块返回了一个对象，AMD规定，返回的对象，即为该模块对象。也可以返回一个函数，如下：</p>\n<pre><code>define(function(){\n    var m = function(){\n\n    };\n\n    return m;\n\n});\n</code></pre><p>如果你编写的模块需要使用其他模块中的方法，那么你就需要依赖那个模块，这个时候你就可以传递第二个参数，第二个参数是一个数组，数组中的每一个元素为你依赖模块的名称：</p>\n<pre><code>define([&#39;A&#39;, &#39;B&#39;], function(A, B){\n\n    A.add();\n\n    return {\n        a : &#39;1&#39;,\n        b : &#39;2&#39;\n    }\n});\n</code></pre><p>上面的代码定义了一个模块，该模块依赖两个模块，分别是模块A和模块B，注意我们在函数中传递了与依赖数组中一一对应的形式参数，以便在模块中使用依赖的模块，而我们也在模块中调用了模块A的add()方法。</p>\n<p>上面我们定义的模块都没有传递id这个参数，我们也可以传递这个参数，这样就像我们给模块去了一个名字，所以带有id这个参数的模块叫做具名模块：</p>\n<pre><code>define(&#39;index&#39;, [&#39;A&#39;], function(A){\n    ...\n});\n</code></pre><p>但是我们一般不会手动的去写，一般我们在使用构建工具优化项目的时候，如我们使用gulp配合rjs合并模块的时候，自动去帮我们填充模块id。</p>\n<p>最后，介绍一下AMD规范兼容Commonjs规范的一个模块定义写法：</p>\n<pre><code>define(function(require, exports, module){\n    var m = require(&#39;m1&#39;);\n\n    exports.A = function(){\n        return m.add();\n    }\n});\n</code></pre><p>我们在函数中显示的传递了三个参数，分别是require，exports和module，这三个变量是全局的，其中require是用来加载其他模块的，exports是用来导出模块接口的，module是模块对象本身。</p>\n<p>接下来我们讲解一下requrie，require是用来引用模块的，及加载模块，上面我们已经看到了require()方法，我们传递了一个字符串，及模块的名称，去加载模块，实际上我们还可以传递依赖数组，如下：</p>\n<pre><code>require([&#39;A&#39;, &#39;B&#39;], function(A, B){\n    // ...\n});\n</code></pre><p>这样，js大概的模块化历史和AMD规范我们就简单介绍完了，由于我们这篇文章综合性比较强，如果想深入了解AMD，点击这里：<a href=\"https://github.com/amdjs/amdjs-api/blob/master/require.md\" target=\"_blank\" rel=\"external\">AMD</a></p>\n<p>这篇文章就到这里，下一章我们结合实际的案例仔细讨论一下requirejs，并相信我，一定有你能学到的东西。</p>\n<p>如果对你有用，感谢捐助。</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201511122.pic.jpg\" alt=\"支付宝二维码\"></p>"},{"title":"基于gulp requirejs rjs的前端自动化构建系列文章(二)","date":"2015-11-14T02:12:25.000Z","_content":"\n> 上一篇介绍了js模块化的历程和AMD规范中规定模块的定义和引用，这篇文章就以requirejs这个AMD规范的实现来讲解js中的模块化开发\n\n![requirejs](http://7xlolm.com1.z0.glb.clouddn.com/20151109amd.jpg)\n\n<!-- more -->\n\n如果你知道了AMD规范中规定的js模块的定义方法和如何引用一个模块，那么requirejs的使用几乎是零成本的，因为requirejs就是AMD规范的实现，你唯一需要学习的可能就是一些便于我们使用模块的配置，和requirejs的一些特性，接下来，我们就用一个完整的例子，来学习如何使用requirejs。\n\n我们在项目中很可能会引用第三方库，比如jQuery等，还要引用我们自己写的一些js文件，在最初，我们的目录结构看上去是这样的，如下图：\n\n![原始目录结构](http://7xlolm.com1.z0.glb.clouddn.com/201511141.pic.jpg)\n\n我们有一个index.html文件，然后再建立一个名为js的文件夹，把jQuery库和我们自己写的js文件都放在里面，或者可能你还会为jQuery等第三方库单独建立一个文件夹，但最终在html页面中引用的效果是一样的，即需要几个js文件，就需要几个script标签，如下是index.html的内容：\n\n```\n<!DOCTYPE html>\n<html>\n<head>\n\t<title></title>\n\t<meta charset=\"utf-8\" />\n</head>\n<body>\n\n\t<script src=\"js/jquery.min.js\"></script>\n\t<script src=\"js/a.js\"></script>\n\t<script src=\"js/b.js\"></script>\n</body>\n</html>\n```\n\n我们已经了解了上面代码的缺点：\n* 污染了全局变量，不同文件之间可能会命名冲突\n* 文件依赖关系难以维护\n* 发出更多的http请求，影响性能\n\n再来看看我们的a.js和b.js文件：\n\na.js\n```\nvar a = {\n\tcontent : 'a.js'\n}\n```\n\nb.js\n```\nvar b = {\n\tcontent : 'b.js'\n}\n```\n\n这两个文件很简单，分别定义了两个污染全局的变量a和b。\n\n那我们通过requirejs来解决这些问题呢？首先，你得有个女朋友，哦不对，你得先有requirejs库，所以，下载连接 [requirejs下载](http://www.requirejs.cn/docs/download.html#requirejs)\n\n下载下来之后，我们把requirejs放在与我们index.html同级的目录下，如下图：\n\n![requirejs与html同级](http://7xlolm.com1.z0.glb.clouddn.com/201511142.pic.jpg)\n\n修改我们的index.html，只需引入我们刚刚下载下来的requirejs：\n\n```\n<!DOCTYPE html>\n<html>\n<head>\n\t<title></title>\n\t<meta charset=\"utf-8\" />\n</head>\n<body>\n\n\t<script src=\"require.js\" data-main=\"config\"></script>\n</body>\n</html>\n```\n\n你可能会疑惑，script标签中data-main是什么？是这样的，requirejs需要一个入口模块，也就是一上来就去执行的模块，类似于C语言中的main函数。上面的代码中，我们告诉requirejs我们的入口模块是config.js，由于requirejs默认模块都是以.js为后缀的，所以这里我们可以省略，只需要写config就可以了，然后我们在index.html同级目录下创建config.js文件如下：\n\n![config.js文件与index.html同级目录](http://7xlolm.com1.z0.glb.clouddn.com/201511143.pic.jpg)\n\n这个config.js可以看做是我们的入口模块，或者主模块，当requirejs加载完成后，会自动执行config.js文件，我们可以在config.js文件中写下如下代码：\n\n```\nalert('这是config.js文件');\n```\n\n双击打开requirejs文件在浏览器中打开，如下图，如我们所愿，config.js被执行了：\n\n![config.js文件被执行了](http://7xlolm.com1.z0.glb.clouddn.com/20151114c.png)\n\n如果config模块只是简单的alert一句话，那么我们就没有必要用requirejs了，一般来讲，我们在主模块中去引用其他模块，开发我们的业务逻辑，在之前的代码中，我们引入了jQuery库，a.js和b.js，现在我们只引入了requirejs并且告诉它我们的主模块是config.js，那么我们如何使用requirejs去加载a.js、b.js和jQuery库呢？我们知道config.js符合AMD模块编写规范，上一篇文章我们已经讲过了AMD规范中如何编写和引用模块，下面我们需要做的就是把我们的文件都编写成一个个模块就好了，由于我们多在主模块即config.js中去引用其他模块，所以我们修改config.js如下：\n\n```\nrequire(['a', 'b'], function(A, B){\n\tconsole.log(A);\n\tconsole.log(B);\n});\n```\n\n我们在config.js中使用require函数去加载模块a和模块b，注意，requirejs默认模块是.js后缀结尾的，所以我们只需要写a和b即可，它会自动去加载a.js和b.js，但是这样写就可以了嘛？我们刷新浏览器：\n\n![报错](http://7xlolm.com1.z0.glb.clouddn.com/2015111422.pic.jpg)\n\n我们仔细看报错信息，“net::ERR_FILE_NOT_FOUND”，再看模块加载的路径 “file:///Users/huochunyang/hcyObj/temp/a.js”，为什么会这样呢？我们知道，我们刚刚在config.js中加载模块a和b的时候，我们仅仅写了a和b到依赖数组中，可是requirejs怎么知道你这两个模块在哪里？所以默认情况下，requirejs默认会在引用requirejs的html文件所在目录下查找，注意，是html同级目录下查找，不是requirejs同级目录下查找，当然，由于我们这个例子中index.html和requirejs是在同一个目录下，所以怕大家混淆。既然这样，问题就好说了，我们index.html同级目录下并没有a.js和b.js这两个模块，我们把这两个模块放到了js目录下，所以，当然会报错啦，既然找到了问题的原因，我们修改config.js文件：\n\n```\nrequire(['js/a', 'js/b'], function(A, B){\n\tconsole.log(A);\n\tconsole.log(B);\n});\n```\n\n再刷新浏览器，如下图：\n\n![不报错，但输出undefined](http://7xlolm.com1.z0.glb.clouddn.com/201511144.pic.jpg)\n\n怎么样？不报错了吧？那是因为我们家在模块的时候路径写的正确，requirejs能够正确加载模块，所以就不会报错了，但是细心的同学会发现，怎么输出两个undefined？在config.js中我们加载了a、b两个模块后，分别在log中输出了A、B模块对象，也就是说我们使用requirejs加载过来的两个模块竟然是undefined。为什么会这样呢？很简单，因为我们a.js和b.js中，并没有暗中AMD规范去编写模块代码，上一篇文章中我们介绍了如果编写一个模块，下面我们就改写a.js和b.js为模块的写法，如下：\n\na.js\n```\ndefine(function(){\n\tvar a = {\n\t\tcontent : 'a.js'\n\t}\n\n\treturn a;\n});\n```\n\nb.js\n```\ndefine(function(){\n\n\tvar b = {\n\t\tcontent : 'b.js'\n\t}\n\n\treturn b;\n\n});\n```\n\n这两个模块很简单，我们使用return语句返回两个对象，被返回的对象就是模块对象，代表了这个模块，我们刷新浏览器：\n\n![输出模块A和B](http://7xlolm.com1.z0.glb.clouddn.com/201511145.pic.jpg)\n\n如何我们的模块B需要依赖模块A，我们可以改写模块B为如下代码，在依赖数组中依赖模块A：\n\n```\ndefine(['js/a'], function(A){\n\n\tvar b = {\n\t\tcontent : 'b.js'\n\t}\n\n\treturn b;\n\n});\n```\n\n不知道大家有没有发现，我们每次去加载模块的时候，都要写对模块所在路径，比如加载模块a，我们就要这样去加载 “js/a.js” ，假如我们的项目做的比较大，模块分的比较深，及目录层级深，如果我们还这样去加载的话，可能会写成下面这样：\n\n* \"modules/dom/XXX/aaa.js\" *\n\n如果每次为了加载一个模块都要这样去写的话，第一我们还要记住模块所在路径，如果记不住的话还要去查看，很影响开发效率，第二写起来总是感觉很不爽，代码看着很恶心，那么我们如何解决这个问题呢？这就要讲到requirejs的配置了，requirejs有一个config函数，接受一个json对象，设置一些配置选项，我们修改config.js如下：\n\n```\nrequirejs.config({\n\tpaths : {\n\t\ta : 'js/a',\n\t\tb : 'js/b'\n\t}\n});\n\n\nrequire(['a', 'b'], function(A, B){\n\tconsole.log(A);\n\tconsole.log(B);\n});\n```\n\n首先我们在使用require()函数去加载模块之前，我们使用requirejs.config()方法去对requirejs进行配置，requirejs.config方法接收一个对象，对象中有一个paths配置项，顾名思义，这是一项路径配置，再看下面使用require()函数去加载模块时，我们直接去加载a和b，这样是可以正常加载模块的，因为在加载a模块的时候，requirejs发现在paths中配置的路径中a对应“js/a”，所以，require会自动去加载js/a模块，而不是在index.html同级目录下去找，所以paths配置就像一个路由，刷新页面，查看控制台中的输出，我们等待片刻会发现，如下图：\n\n![加载超时](http://7xlolm.com1.z0.glb.clouddn.com/201511146.pic.jpg)\n\n什么？加载超时？什么情况？别紧张，还记我们的b.js中吗？我们在b.js中依赖了a.js，可是我们的代码是怎么依赖的呢？打开b.js：\n\n```\ndefine(['js/a'], function(A){\n\n\tvar b = {\n\t\tcontent : 'b.js'\n\t}\n\n\treturn b;\n\n});\n```\n\n我们发现，我们依赖a，模块的时候依然使用'js/a'进行依赖，而当requirejs在解析'js/a'的时候，发现有一个'a'，然后又再paths配置中发现'a'对应'js/a',于是，requirejs就把'a'换成了'js/a'，所以整体的'js/a'最终被换成了'js/js/a'，然后又再路径中发现了a，于是加载路径又被替换成了'js/js/js/a'，如此下去，最终成了死循环，而超过一定的时间之后，就会报错加载超时，明白了吧，所以，我们把b.js中依赖a.js的字符创直接写成'a'就可以了，如下：\n\n```\ndefine(['a'], function(A){\n\n\tvar b = {\n\t\tcontent : 'b.js'\n\t}\n\n\treturn b;\n\n});\n```\n\n再次刷新浏览器，怎么样？正常加载了吧？这样以后我们只要需要依赖a模块，我们就直接写'a'就可以了：\n\n![正常加载](http://7xlolm.com1.z0.glb.clouddn.com/201511147.pic.jpg)\n\n那么好，a.js和b.js我们都改成了模块的编写方式，并且也做了paths配置，最终也成功加载了，但是我们还遗漏了一个东西，就是jQuery这个第三方库，那么requirejs能够加载第三方库吗？答案是：只要第三方库提供了AMD接口，那么requirejs就可以加载，而jQuery本身也提供了这个接口，所以我们直接加载就好了，为了方便，我们依然在paths中配置一下：\n\n```\nrequirejs.config({\n\tpaths : {\n\t\ta : 'js/a',\n\t\tb : 'js/b',\n\t\t$ : 'js/jquery.min'\n\t}\n});\n```\n\n然后在config中去加载jQuery并试着使用jQuery，看看能不能正常使用，修改我们的config.js如下：\n\n```\nrequirejs.config({\n\tpaths : {\n\t\ta : 'js/a',\n\t\tb : 'js/b',\n\t\tjquery : 'js/jquery.min'\n\t}\n});\n\nrequire(['a', 'b', 'jquery'], function(A, B, $){\n\talert($('html').html());\n\tconsole.log(A);\n\tconsole.log(B);\n});\n```\n\n刷新页面：\n\n![第三方库加载成功](http://7xlolm.com1.z0.glb.clouddn.com/201511148.pic.jpg)\n\n弹出弹窗，证明我们加载jQuery成功并成功使用。\n\n下面我们再来思考一个问题，我们为什么能够直接通过requirejs加载jQuery？是因为jQuery这个第三方库提供了AMD支持，可是并不是所有第三方库都提供了AMD支持，那么require就不能加载那些第三方库了吗？答案是：依然能够加载。不过，这就涉及到如何加载非AMD模块写法的模块了，假设我们有一个模块c，但是c.js并没有按照AMD规范封装为一个模块，我们在js文件加下创建c.js，并写下如下代码：\n\n```\nvar show = function(){\n\talert('调用了c');\n}\n```\n\n我们的c.js很简单。只是单纯的定义了一个c函数，并弹出一个提示框，显示“调用了c”，所以这个c.js并不是一个AMD模块，那么如果我们想使用requirejs加载这个c，该如何加载呢？这就要讲到requirejs.config()中的另一个配置项 shim 了，我们已经知道了paths是用来配置加载模块路径的，shim则是用来加载非AMD模块规范的“模块”的，所以，为了加载c.js，我们可以修改config.js并添加shim配置，如下：\n\n```\nrequirejs.config({\n\tpaths : {\n\t\ta : 'js/a',\n\t\tb : 'js/b',\n\t\tc : 'js/c',\n\t\tjquery : 'js/jquery.min'\n\t},\n\n\tshim : {\n\t\tc : {\n\t\t\texports : 'show'\n\t\t}\n\t}\n});\n\n\nrequire(['a', 'b', 'jquery', 'c'], function(A, B, $, c){\n\tconsole.log(c);\n});\n```\n\n我们添加了shim配置，配置中，c 代表我们在require中引入模块时的名字，即我们可以通过require(['c'])去引用c模块，c对应一个json对象，对象中有一个exports属性，exports属性的值就是我们要到处的接口，注意，我们依然要在paths中添加模块c的配置，这样才能正常加载模块，最后，我们在控制台中输出了模块c，打开浏览器，刷新：\n\n![输出模块c](http://7xlolm.com1.z0.glb.clouddn.com/201511149.pic.jpg)\n\n我们看到，打印出来的就是我们的函数show，也就是说我们到处的接口就是show函数，我们可以调用一下试试，修改config.js：\n\n```\nrequire(['a', 'b', 'jquery', 'c'], function(A, B, $, c){\n\tc();\n});\n```\n\n刷新页面：\n\n![调用了show函数](http://7xlolm.com1.z0.glb.clouddn.com/2015111410.pic.jpg)\n\n怎么样，弹出弹窗了吧，实际上，经过shim配置后，requirejs会自动修改c.js为一个AMD模块，为其添加封装代码，如下：\n\n```\ndefine(function(){\n\tvar show = function(){\n\t\talert('调用了c');\n\t}\t\n\n\treturn show;\n});\n```\n\n我们看到，return返回的是show函数，是因为我们在shim中为c模块配置的导出接口为show，即exports的值是show，所以加入我们修改exports的值为其他值，是没有办法导出成功的，比如我们修改config.js中c模块的shim配置，如下，我们导出的接口不是show而是随意的aaa:\n\n```\nshim : {\n\tc : {\n\t\texports : 'aaa'\n\t}\n}\n```\n\n刷新页面：\n\n![报错](http://7xlolm.com1.z0.glb.clouddn.com/2015111411.pic.jpg)\n\n报错，c不是一个函数，为什么呢？因为我们导出的接口是aaa，鬼知道你这个aaa是什么啊。所以最后调用的时候当然会报错。\n\n我们还可以导出多个接口，比如我们的c.js中有两个函数，分别是show函数和hide函数，修改我们的c.js如下：\n\n```\nvar show = function(){\n\talert('show函数');\n}\t\n\nvar hide = function(){\n\talert('hide函数');\n}\n```\n\n如果我们继续使用上面的shim配置，那么我们将只能导出show函数，没有办法导出hide，如何才能将两个接口都导出来呢？这个时候我们就不能使用exports属性了，我们要用init属性，分别将两个接口导出，修改config.js如下：\n\n```\nshim : {\n\tc : {\n\t\tinit : function(){\n\t\t\treturn {\n\t\t\t\taaa : show,\n\t\t\t\tbbb : hide\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\ninit属性对应一个函数，函数返回一个对象，对象里面对应我们要导出的接口，这样，我们就把两个接口都导出了，我们可以通过模块的aaa调用show函数，模块的bbb调用hide函数，修改config.js去尝试调用一下：\n\n```\nrequire(['a', 'b', 'jquery', 'c'], function(A, B, $, c){\n\tc.aaa();\n\tc.bbb();\n});\n```\n\n打开浏览器刷新，怎么样，两个函数正常调用了吧，不过这里有一个需要注意的地方，init属性对应的函数中，返回的对象里面，show和hide不能用引号引起来，下面的写法是错误的：\n\n```\nshim : {\n\tc : {\n\t\tinit : function(){\n\t\t\treturn {\n\t\t\t\taaa : 'show',\n\t\t\t\tbbb : 'hide'\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n刷新浏览器会报错，如下图：\n\n![加引号后报错](http://7xlolm.com1.z0.glb.clouddn.com/2015111412.pic.jpg)\n\n那么为什么会这样呢？实际上，当我们设置了init属性后，requirejs相当于自动为我们封装了c.js如下面这样：\n\n```\ndefine(function(){\n\tvar show = function(){\n\t\talert('show函数');\n\t}\t\n\n\tvar hide = function(){\n\t\talert('hide函数');\n\t}\n\n\treturn {\n\t\taaa : show,\n\t\tbbb : hide\n\t}\n});\n```\n\n上面代码中show和hide没有加引号，所以是变量，分别引用上面的show函数和hide函数，如果我们加了引号，requirejs封装之后就会想这样：\n\n```\ndefine(function(){\n\tvar show = function(){\n\t\talert('show函数');\n\t}\t\n\n\tvar hide = function(){\n\t\talert('hide函数');\n\t}\n\n\treturn {\n\t\taaa : 'show',\n\t\tbbb : 'hide'\n\t}\n});\n```\n\n我们看上面的代码，'show'和'hide'都加了引号，所以他们是字符串，并没有引用上面的show函数和hide函数，只是导出一个字符串而已，所以当我们把字符串当做函数来调用的时候，当然会报错。我们也可以验证这一点，我们就使用带引号的配置，然后打印出c.aaa的类型，如下：\n\n```\nrequirejs.config({\n\tpaths : {\n\t\ta : 'js/a',\n\t\tb : 'js/b',\n\t\tc : 'js/c',\n\t\tjquery : 'js/jquery.min'\n\t},\n\n\tshim : {\n\t\tc : {\n\t\t\tinit : function(){\n\t\t\t\treturn {\n\t\t\t\t\taaa : 'show',\n\t\t\t\t\tbbb : 'hide'\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n});\n\n\nrequire(['a', 'b', 'jquery', 'c'], function(A, B, $, c){\n\tconsole.log(typeof c.aaa);\n});\n```\n\n刷新浏览器，我们看到，c.aaa的确是一个字符串：\n\n![打印出来的是字符串](http://7xlolm.com1.z0.glb.clouddn.com/2015111413.pic.jpg)\n\n另外，我们注意一点，paths里面的配置，路径中都带有'js/'，如下：\n\n```\npaths : {\n\ta : 'js/a',\n\tb : 'js/b',\n\tc : 'js/c',\n\tjquery : 'js/jquery.min'\n}\n```\n\n也就是说我们的模块都放在js目录下，既然这样，我们可不可以通过一个配置，来告诉我们的requirejs，每次查找模块的时候都基于js目录查找呢？这样我们就不用每次编写paths配置的时候都要写上'js/'了，实际上是可以的，requirejs.config()的配置对象中还有一个 baseUrl 属性，用来制定模块的查找目录，修改配置如下：\n\n```\nrequirejs.config({\n\tbaseUrl : './js',\n\tpaths : {\n\t\ta : 'a',\n\t\tb : 'b',\n\t\tc : 'c',\n\t\tjquery : 'jquery.min'\n\t},\n\n\tshim : {\n\t\tc : {\n\t\t\tinit : function(){\n\t\t\t\treturn {\n\t\t\t\t\taaa : show,\n\t\t\t\t\tbbb : hide\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n});\n```\n\n当然，baseUrl本省是基于引入requirejs的html文件所在目录的，在本例中即index.html所在目录的。\n\n另外，我们发现，当我们配置完baseUrl之后，paths中a、b、c三个模块可以不用配置，因为已经没有什么意义了，但是jquery需要保留，如下：\n\n```\nrequirejs.config({\n\tbaseUrl : './js',\n\tpaths : {\n\t\tjquery : 'jquery.min'\n\t},\n\n\tshim : {\n\t\tc : {\n\t\t\tinit : function(){\n\t\t\t\treturn {\n\t\t\t\t\taaa : show,\n\t\t\t\t\tbbb : hide\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n});\n```\n\n这样，当requirejs去加载的a、b、c模块的时候，就自动会根据baseUrl中的配置去查找模块，而我们的三个模块也恰好在js目录下，所以可以不用配置了，总而言之，这是一个很灵好好用的配置，具体根据你的项目来。\n\n下面，我们在考虑一种情景，假如你的项目很大，在最初阶段，你的项目里引用了jQuery1.x版本，后来随着项目的发展，项目需要引入jQuery2.x的版本，但是又不能删除掉原来的1.x版本，因为项目中有很多模块都在使用1.x的版本，这个时候，我们就希望在某些文件中引入jQuery时使用的1.x版本，而在另外一些文件中使用的是2.x的版本，怎么办呢？有的同学可能会这样想，如下配置：\n\n```\nrequirejs.config({\n\tbaseUrl : './js',\n\tpaths : {\n\t\tjquery1 : 'jquery-1.11.3'\n\t\tjquery2 : 'jquery-2.1.4'\n\t},\n\n\tshim : {\n\t\tc : {\n\t\t\tinit : function(){\n\t\t\t\treturn {\n\t\t\t\t\taaa : show,\n\t\t\t\t\tbbb : hide\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n});\n```\n\n配置两个jquery，一个jquery1，一个jquery2，分别对应不同的版本，当我们使用1.x版本的时候，就引用'jquery1'，当我们想使用2.x版本的时候就引用'jquery2'，这样看上去好像很合理，试着使用一下，修改config.js中require中的代码如下：\n\n```requirejs.config({\n\tbaseUrl : './js',\n\tpaths : {\n\t\tjquery1 : 'jquery-1.11.3',\n\t\tjquery2 : 'jquery-2.1.4'\n\t},\n\n\tshim : {\n\t\tc : {\n\t\t\tinit : function(){\n\t\t\t\treturn {\n\t\t\t\t\taaa : show,\n\t\t\t\t\tbbb : hide\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n});\n\n\nrequire(['jquery1'], function($){\n\talert($('html').html());\n});\n\n```\n\n我们刷新页面，报错了：\n\n![报错](http://7xlolm.com1.z0.glb.clouddn.com/2015111414.pic.jpg)\n\n查看报错信息，他说$没有定义，言外之意就是说我们jQuery模块根本没有引入进来，怎么会这样呢？实际上，当我们在paths中配置jquery时，我们不能使用别名，也就是说我们只能使用 jquery 而不能使用 jquery1和jquery2，不信你将requirejs.config()中的paths修改如下：\n\n```\npaths : {\n\tjquery : 'jquery-1.11.3'\n}\n```\n\n刷新页面可以正常使用，但是修改成下面这样就不能正常使用：\n\n```\npaths : {\n\tjq : 'jquery-1.11.3'\n}\n```\n\n因为你只能用jquery而不能用任何其他别名，为什么这样呢？我们打开jquery的源码，开其中有这么一段代码，如下图：\n\n![jQuery源码中对AMD兼容做法](http://7xlolm.com1.z0.glb.clouddn.com/2015111415.pic.jpg)\n\n这段代码其实就是jQuery库对AMD模块的兼容做法，我们发现，jQuery去使用define定义模块的时候，他显示的传递了第一个参数，是一个字符串 'jquery'，这个参数在我们自己编写的模块中一般是不去手动写死得，一般由构建工具在优化模块时自动填充的，以免模块冲突，因为这个参数代表了模块id，那么jquery为什么要写死呢？\n\n网上有种说法是出于性能考虑，因为像jQuery这种库我们在项目中使用是很频繁的，很多模块都要依赖这个模块，如果id这个参数不写死得话，意味着我们在依赖jQuery的时候可以随意起名字，而非必须使用 'jquery' ，这样其他模块就可以给jQuery起不同的模块名，这就会导致多次引入jQuery。\n\n现在，我们知道了为什么我们在paths配置中配置jQuery的时候为什么只能使用 'jquery' 了，我们回到之前的问题，即在不同的模块引入不同版本的jQuery，想一想我们还能这样去配置了嘛：\n\n```\npaths : {\n\tjquery1 : 'jquery-1.11.3',\n\tjquery2 : 'jquery-2.1.4'\n}\n```\n\n答案是否定的，因为我们只能用 jquery 而不能用 jquery1 或 jquery2，那难道我们这样配置吗？如下：\n\n```\npaths : {\n\tjquery : 'jquery-1.11.3',\n\tjquery : 'jquery-2.1.4'\n}\n```\n\n简直就是笑话，这样第二个jquery属性会覆盖第一个jquery属性，那怎么办？这就涉及requirejs的另一个配置了，map配置项，map配置项的作用是，在不同的模块中，即js文件中，依赖相同的模块名，缺加载不同的模块。\n\n我们先在config.js中增加map配置如下：\n\n```\nrequirejs.config({\n\tbaseUrl : './js',\n\tpaths : {\n\t\tjquery : 'jquery-1.11.3'\n\t},\n\n\tshim : {\n\t\tc : {\n\t\t\tinit : function(){\n\t\t\t\treturn {\n\t\t\t\t\taaa : show,\n\t\t\t\t\tbbb : hide\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tmap : {\n\t\t'a' : {\n\t\t\tjquery : 'jquery-1.11.3'\n\t\t},\n\t\t\n\t\t'b' : {\n\t\t\tjquery : 'jquery-2.1.4'\n\t\t}\n\t}\n});\n```\n\n我们在map中可以对每一个模块进行配置，上面代码中，我们配置了当在 a 模块中依赖 'jquery' 时，我们加载的是 1.11.3 版本，当我们在 b 模块中依赖 'jquery' 时，我们加载的是 2.1.4 版本。我们可以尝试一下，分别修改a.js和b.js这两个模块，让他们都去依赖jquery，然后分别返回所依赖jquery的版本，如下：\n\na.js\n```\ndefine(['jquery'], function(jquery){\n\tvar a = {\n\t\tcontent : $().jquery\n\t}\n\n\treturn a;\n});\n```\n\nb.js\n```\ndefine(['jquery'], function(jquery){\n\tvar b = {\n\t\tcontent : $().jquery\n\t}\n\n\treturn b;\n\n});\n```\n\n然后我们在config.js中打印模块a和b，如下：\n\n```\nrequire(['a', 'b'], function(A, B){\n\tconsole.log('模块a引用的jQuery版本是' + A.content);\n\tconsole.log('模块b引用的jQuery版本是' + B.content);\n});\n```\n\n刷新浏览器，我们看到如下，的确在不同的文件中依赖了不同版本的jQuery：\n\n![不同文件中依赖了不同版本的jQuery](http://7xlolm.com1.z0.glb.clouddn.com/2015111416.pic.jpg)\n\n但是有一点请读者看清楚，在a.js和b.js中我都依赖了jquery，在形式参数中我使用的是jquery，但是在下面我用到的却是(美元符号)，因为笔者在调试过程中，如果形式参数也写成(美元符号)，那么使用(美元符号)参数打印出来的始终都是undefined，但是经过分析的确正常导入模块并且没有报错，我不知道这是什么原因，或者requirejs的BUG，如果读者有知道是什么原因的欢迎在下面评论指针，共同进步。\n\n这样，requirejs中一些必备且不易理解的配置以及一些遇到的问题和解决方案就讲解的差不多了，其实requirejs中的配置不只这些，读者可以查阅[官方文档](http://www.requirejs.cn/) 查看其他配置，都比较简单，掌握笔者讲得这些基本够用了。\n\n下一篇文章我们就来讲一讲如何优化项目的事，包括使用rjs配合gulp构建工具等，如果你觉得对你有帮助，就看看我的话联网祈祷思维的运用吧，如下：\n\n![支付宝二维码](http://7xlolm.com1.z0.glb.clouddn.com/201511122.pic.jpg)\n\n\n","source":"_posts/2015/11/14/基于gulp-requirejs-rjs的前端自动化构建系列文章-二.md","raw":"title: 基于gulp requirejs rjs的前端自动化构建系列文章(二)\ndate: 2015-11-14 10:12:25\ncategories:\n- WebFrontEnd\ntags:\n- js\n- 自动化\n- gulp\n- requirejs\n- rjs\n- 构建\n---\n\n> 上一篇介绍了js模块化的历程和AMD规范中规定模块的定义和引用，这篇文章就以requirejs这个AMD规范的实现来讲解js中的模块化开发\n\n![requirejs](http://7xlolm.com1.z0.glb.clouddn.com/20151109amd.jpg)\n\n<!-- more -->\n\n如果你知道了AMD规范中规定的js模块的定义方法和如何引用一个模块，那么requirejs的使用几乎是零成本的，因为requirejs就是AMD规范的实现，你唯一需要学习的可能就是一些便于我们使用模块的配置，和requirejs的一些特性，接下来，我们就用一个完整的例子，来学习如何使用requirejs。\n\n我们在项目中很可能会引用第三方库，比如jQuery等，还要引用我们自己写的一些js文件，在最初，我们的目录结构看上去是这样的，如下图：\n\n![原始目录结构](http://7xlolm.com1.z0.glb.clouddn.com/201511141.pic.jpg)\n\n我们有一个index.html文件，然后再建立一个名为js的文件夹，把jQuery库和我们自己写的js文件都放在里面，或者可能你还会为jQuery等第三方库单独建立一个文件夹，但最终在html页面中引用的效果是一样的，即需要几个js文件，就需要几个script标签，如下是index.html的内容：\n\n```\n<!DOCTYPE html>\n<html>\n<head>\n\t<title></title>\n\t<meta charset=\"utf-8\" />\n</head>\n<body>\n\n\t<script src=\"js/jquery.min.js\"></script>\n\t<script src=\"js/a.js\"></script>\n\t<script src=\"js/b.js\"></script>\n</body>\n</html>\n```\n\n我们已经了解了上面代码的缺点：\n* 污染了全局变量，不同文件之间可能会命名冲突\n* 文件依赖关系难以维护\n* 发出更多的http请求，影响性能\n\n再来看看我们的a.js和b.js文件：\n\na.js\n```\nvar a = {\n\tcontent : 'a.js'\n}\n```\n\nb.js\n```\nvar b = {\n\tcontent : 'b.js'\n}\n```\n\n这两个文件很简单，分别定义了两个污染全局的变量a和b。\n\n那我们通过requirejs来解决这些问题呢？首先，你得有个女朋友，哦不对，你得先有requirejs库，所以，下载连接 [requirejs下载](http://www.requirejs.cn/docs/download.html#requirejs)\n\n下载下来之后，我们把requirejs放在与我们index.html同级的目录下，如下图：\n\n![requirejs与html同级](http://7xlolm.com1.z0.glb.clouddn.com/201511142.pic.jpg)\n\n修改我们的index.html，只需引入我们刚刚下载下来的requirejs：\n\n```\n<!DOCTYPE html>\n<html>\n<head>\n\t<title></title>\n\t<meta charset=\"utf-8\" />\n</head>\n<body>\n\n\t<script src=\"require.js\" data-main=\"config\"></script>\n</body>\n</html>\n```\n\n你可能会疑惑，script标签中data-main是什么？是这样的，requirejs需要一个入口模块，也就是一上来就去执行的模块，类似于C语言中的main函数。上面的代码中，我们告诉requirejs我们的入口模块是config.js，由于requirejs默认模块都是以.js为后缀的，所以这里我们可以省略，只需要写config就可以了，然后我们在index.html同级目录下创建config.js文件如下：\n\n![config.js文件与index.html同级目录](http://7xlolm.com1.z0.glb.clouddn.com/201511143.pic.jpg)\n\n这个config.js可以看做是我们的入口模块，或者主模块，当requirejs加载完成后，会自动执行config.js文件，我们可以在config.js文件中写下如下代码：\n\n```\nalert('这是config.js文件');\n```\n\n双击打开requirejs文件在浏览器中打开，如下图，如我们所愿，config.js被执行了：\n\n![config.js文件被执行了](http://7xlolm.com1.z0.glb.clouddn.com/20151114c.png)\n\n如果config模块只是简单的alert一句话，那么我们就没有必要用requirejs了，一般来讲，我们在主模块中去引用其他模块，开发我们的业务逻辑，在之前的代码中，我们引入了jQuery库，a.js和b.js，现在我们只引入了requirejs并且告诉它我们的主模块是config.js，那么我们如何使用requirejs去加载a.js、b.js和jQuery库呢？我们知道config.js符合AMD模块编写规范，上一篇文章我们已经讲过了AMD规范中如何编写和引用模块，下面我们需要做的就是把我们的文件都编写成一个个模块就好了，由于我们多在主模块即config.js中去引用其他模块，所以我们修改config.js如下：\n\n```\nrequire(['a', 'b'], function(A, B){\n\tconsole.log(A);\n\tconsole.log(B);\n});\n```\n\n我们在config.js中使用require函数去加载模块a和模块b，注意，requirejs默认模块是.js后缀结尾的，所以我们只需要写a和b即可，它会自动去加载a.js和b.js，但是这样写就可以了嘛？我们刷新浏览器：\n\n![报错](http://7xlolm.com1.z0.glb.clouddn.com/2015111422.pic.jpg)\n\n我们仔细看报错信息，“net::ERR_FILE_NOT_FOUND”，再看模块加载的路径 “file:///Users/huochunyang/hcyObj/temp/a.js”，为什么会这样呢？我们知道，我们刚刚在config.js中加载模块a和b的时候，我们仅仅写了a和b到依赖数组中，可是requirejs怎么知道你这两个模块在哪里？所以默认情况下，requirejs默认会在引用requirejs的html文件所在目录下查找，注意，是html同级目录下查找，不是requirejs同级目录下查找，当然，由于我们这个例子中index.html和requirejs是在同一个目录下，所以怕大家混淆。既然这样，问题就好说了，我们index.html同级目录下并没有a.js和b.js这两个模块，我们把这两个模块放到了js目录下，所以，当然会报错啦，既然找到了问题的原因，我们修改config.js文件：\n\n```\nrequire(['js/a', 'js/b'], function(A, B){\n\tconsole.log(A);\n\tconsole.log(B);\n});\n```\n\n再刷新浏览器，如下图：\n\n![不报错，但输出undefined](http://7xlolm.com1.z0.glb.clouddn.com/201511144.pic.jpg)\n\n怎么样？不报错了吧？那是因为我们家在模块的时候路径写的正确，requirejs能够正确加载模块，所以就不会报错了，但是细心的同学会发现，怎么输出两个undefined？在config.js中我们加载了a、b两个模块后，分别在log中输出了A、B模块对象，也就是说我们使用requirejs加载过来的两个模块竟然是undefined。为什么会这样呢？很简单，因为我们a.js和b.js中，并没有暗中AMD规范去编写模块代码，上一篇文章中我们介绍了如果编写一个模块，下面我们就改写a.js和b.js为模块的写法，如下：\n\na.js\n```\ndefine(function(){\n\tvar a = {\n\t\tcontent : 'a.js'\n\t}\n\n\treturn a;\n});\n```\n\nb.js\n```\ndefine(function(){\n\n\tvar b = {\n\t\tcontent : 'b.js'\n\t}\n\n\treturn b;\n\n});\n```\n\n这两个模块很简单，我们使用return语句返回两个对象，被返回的对象就是模块对象，代表了这个模块，我们刷新浏览器：\n\n![输出模块A和B](http://7xlolm.com1.z0.glb.clouddn.com/201511145.pic.jpg)\n\n如何我们的模块B需要依赖模块A，我们可以改写模块B为如下代码，在依赖数组中依赖模块A：\n\n```\ndefine(['js/a'], function(A){\n\n\tvar b = {\n\t\tcontent : 'b.js'\n\t}\n\n\treturn b;\n\n});\n```\n\n不知道大家有没有发现，我们每次去加载模块的时候，都要写对模块所在路径，比如加载模块a，我们就要这样去加载 “js/a.js” ，假如我们的项目做的比较大，模块分的比较深，及目录层级深，如果我们还这样去加载的话，可能会写成下面这样：\n\n* \"modules/dom/XXX/aaa.js\" *\n\n如果每次为了加载一个模块都要这样去写的话，第一我们还要记住模块所在路径，如果记不住的话还要去查看，很影响开发效率，第二写起来总是感觉很不爽，代码看着很恶心，那么我们如何解决这个问题呢？这就要讲到requirejs的配置了，requirejs有一个config函数，接受一个json对象，设置一些配置选项，我们修改config.js如下：\n\n```\nrequirejs.config({\n\tpaths : {\n\t\ta : 'js/a',\n\t\tb : 'js/b'\n\t}\n});\n\n\nrequire(['a', 'b'], function(A, B){\n\tconsole.log(A);\n\tconsole.log(B);\n});\n```\n\n首先我们在使用require()函数去加载模块之前，我们使用requirejs.config()方法去对requirejs进行配置，requirejs.config方法接收一个对象，对象中有一个paths配置项，顾名思义，这是一项路径配置，再看下面使用require()函数去加载模块时，我们直接去加载a和b，这样是可以正常加载模块的，因为在加载a模块的时候，requirejs发现在paths中配置的路径中a对应“js/a”，所以，require会自动去加载js/a模块，而不是在index.html同级目录下去找，所以paths配置就像一个路由，刷新页面，查看控制台中的输出，我们等待片刻会发现，如下图：\n\n![加载超时](http://7xlolm.com1.z0.glb.clouddn.com/201511146.pic.jpg)\n\n什么？加载超时？什么情况？别紧张，还记我们的b.js中吗？我们在b.js中依赖了a.js，可是我们的代码是怎么依赖的呢？打开b.js：\n\n```\ndefine(['js/a'], function(A){\n\n\tvar b = {\n\t\tcontent : 'b.js'\n\t}\n\n\treturn b;\n\n});\n```\n\n我们发现，我们依赖a，模块的时候依然使用'js/a'进行依赖，而当requirejs在解析'js/a'的时候，发现有一个'a'，然后又再paths配置中发现'a'对应'js/a',于是，requirejs就把'a'换成了'js/a'，所以整体的'js/a'最终被换成了'js/js/a'，然后又再路径中发现了a，于是加载路径又被替换成了'js/js/js/a'，如此下去，最终成了死循环，而超过一定的时间之后，就会报错加载超时，明白了吧，所以，我们把b.js中依赖a.js的字符创直接写成'a'就可以了，如下：\n\n```\ndefine(['a'], function(A){\n\n\tvar b = {\n\t\tcontent : 'b.js'\n\t}\n\n\treturn b;\n\n});\n```\n\n再次刷新浏览器，怎么样？正常加载了吧？这样以后我们只要需要依赖a模块，我们就直接写'a'就可以了：\n\n![正常加载](http://7xlolm.com1.z0.glb.clouddn.com/201511147.pic.jpg)\n\n那么好，a.js和b.js我们都改成了模块的编写方式，并且也做了paths配置，最终也成功加载了，但是我们还遗漏了一个东西，就是jQuery这个第三方库，那么requirejs能够加载第三方库吗？答案是：只要第三方库提供了AMD接口，那么requirejs就可以加载，而jQuery本身也提供了这个接口，所以我们直接加载就好了，为了方便，我们依然在paths中配置一下：\n\n```\nrequirejs.config({\n\tpaths : {\n\t\ta : 'js/a',\n\t\tb : 'js/b',\n\t\t$ : 'js/jquery.min'\n\t}\n});\n```\n\n然后在config中去加载jQuery并试着使用jQuery，看看能不能正常使用，修改我们的config.js如下：\n\n```\nrequirejs.config({\n\tpaths : {\n\t\ta : 'js/a',\n\t\tb : 'js/b',\n\t\tjquery : 'js/jquery.min'\n\t}\n});\n\nrequire(['a', 'b', 'jquery'], function(A, B, $){\n\talert($('html').html());\n\tconsole.log(A);\n\tconsole.log(B);\n});\n```\n\n刷新页面：\n\n![第三方库加载成功](http://7xlolm.com1.z0.glb.clouddn.com/201511148.pic.jpg)\n\n弹出弹窗，证明我们加载jQuery成功并成功使用。\n\n下面我们再来思考一个问题，我们为什么能够直接通过requirejs加载jQuery？是因为jQuery这个第三方库提供了AMD支持，可是并不是所有第三方库都提供了AMD支持，那么require就不能加载那些第三方库了吗？答案是：依然能够加载。不过，这就涉及到如何加载非AMD模块写法的模块了，假设我们有一个模块c，但是c.js并没有按照AMD规范封装为一个模块，我们在js文件加下创建c.js，并写下如下代码：\n\n```\nvar show = function(){\n\talert('调用了c');\n}\n```\n\n我们的c.js很简单。只是单纯的定义了一个c函数，并弹出一个提示框，显示“调用了c”，所以这个c.js并不是一个AMD模块，那么如果我们想使用requirejs加载这个c，该如何加载呢？这就要讲到requirejs.config()中的另一个配置项 shim 了，我们已经知道了paths是用来配置加载模块路径的，shim则是用来加载非AMD模块规范的“模块”的，所以，为了加载c.js，我们可以修改config.js并添加shim配置，如下：\n\n```\nrequirejs.config({\n\tpaths : {\n\t\ta : 'js/a',\n\t\tb : 'js/b',\n\t\tc : 'js/c',\n\t\tjquery : 'js/jquery.min'\n\t},\n\n\tshim : {\n\t\tc : {\n\t\t\texports : 'show'\n\t\t}\n\t}\n});\n\n\nrequire(['a', 'b', 'jquery', 'c'], function(A, B, $, c){\n\tconsole.log(c);\n});\n```\n\n我们添加了shim配置，配置中，c 代表我们在require中引入模块时的名字，即我们可以通过require(['c'])去引用c模块，c对应一个json对象，对象中有一个exports属性，exports属性的值就是我们要到处的接口，注意，我们依然要在paths中添加模块c的配置，这样才能正常加载模块，最后，我们在控制台中输出了模块c，打开浏览器，刷新：\n\n![输出模块c](http://7xlolm.com1.z0.glb.clouddn.com/201511149.pic.jpg)\n\n我们看到，打印出来的就是我们的函数show，也就是说我们到处的接口就是show函数，我们可以调用一下试试，修改config.js：\n\n```\nrequire(['a', 'b', 'jquery', 'c'], function(A, B, $, c){\n\tc();\n});\n```\n\n刷新页面：\n\n![调用了show函数](http://7xlolm.com1.z0.glb.clouddn.com/2015111410.pic.jpg)\n\n怎么样，弹出弹窗了吧，实际上，经过shim配置后，requirejs会自动修改c.js为一个AMD模块，为其添加封装代码，如下：\n\n```\ndefine(function(){\n\tvar show = function(){\n\t\talert('调用了c');\n\t}\t\n\n\treturn show;\n});\n```\n\n我们看到，return返回的是show函数，是因为我们在shim中为c模块配置的导出接口为show，即exports的值是show，所以加入我们修改exports的值为其他值，是没有办法导出成功的，比如我们修改config.js中c模块的shim配置，如下，我们导出的接口不是show而是随意的aaa:\n\n```\nshim : {\n\tc : {\n\t\texports : 'aaa'\n\t}\n}\n```\n\n刷新页面：\n\n![报错](http://7xlolm.com1.z0.glb.clouddn.com/2015111411.pic.jpg)\n\n报错，c不是一个函数，为什么呢？因为我们导出的接口是aaa，鬼知道你这个aaa是什么啊。所以最后调用的时候当然会报错。\n\n我们还可以导出多个接口，比如我们的c.js中有两个函数，分别是show函数和hide函数，修改我们的c.js如下：\n\n```\nvar show = function(){\n\talert('show函数');\n}\t\n\nvar hide = function(){\n\talert('hide函数');\n}\n```\n\n如果我们继续使用上面的shim配置，那么我们将只能导出show函数，没有办法导出hide，如何才能将两个接口都导出来呢？这个时候我们就不能使用exports属性了，我们要用init属性，分别将两个接口导出，修改config.js如下：\n\n```\nshim : {\n\tc : {\n\t\tinit : function(){\n\t\t\treturn {\n\t\t\t\taaa : show,\n\t\t\t\tbbb : hide\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\ninit属性对应一个函数，函数返回一个对象，对象里面对应我们要导出的接口，这样，我们就把两个接口都导出了，我们可以通过模块的aaa调用show函数，模块的bbb调用hide函数，修改config.js去尝试调用一下：\n\n```\nrequire(['a', 'b', 'jquery', 'c'], function(A, B, $, c){\n\tc.aaa();\n\tc.bbb();\n});\n```\n\n打开浏览器刷新，怎么样，两个函数正常调用了吧，不过这里有一个需要注意的地方，init属性对应的函数中，返回的对象里面，show和hide不能用引号引起来，下面的写法是错误的：\n\n```\nshim : {\n\tc : {\n\t\tinit : function(){\n\t\t\treturn {\n\t\t\t\taaa : 'show',\n\t\t\t\tbbb : 'hide'\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n刷新浏览器会报错，如下图：\n\n![加引号后报错](http://7xlolm.com1.z0.glb.clouddn.com/2015111412.pic.jpg)\n\n那么为什么会这样呢？实际上，当我们设置了init属性后，requirejs相当于自动为我们封装了c.js如下面这样：\n\n```\ndefine(function(){\n\tvar show = function(){\n\t\talert('show函数');\n\t}\t\n\n\tvar hide = function(){\n\t\talert('hide函数');\n\t}\n\n\treturn {\n\t\taaa : show,\n\t\tbbb : hide\n\t}\n});\n```\n\n上面代码中show和hide没有加引号，所以是变量，分别引用上面的show函数和hide函数，如果我们加了引号，requirejs封装之后就会想这样：\n\n```\ndefine(function(){\n\tvar show = function(){\n\t\talert('show函数');\n\t}\t\n\n\tvar hide = function(){\n\t\talert('hide函数');\n\t}\n\n\treturn {\n\t\taaa : 'show',\n\t\tbbb : 'hide'\n\t}\n});\n```\n\n我们看上面的代码，'show'和'hide'都加了引号，所以他们是字符串，并没有引用上面的show函数和hide函数，只是导出一个字符串而已，所以当我们把字符串当做函数来调用的时候，当然会报错。我们也可以验证这一点，我们就使用带引号的配置，然后打印出c.aaa的类型，如下：\n\n```\nrequirejs.config({\n\tpaths : {\n\t\ta : 'js/a',\n\t\tb : 'js/b',\n\t\tc : 'js/c',\n\t\tjquery : 'js/jquery.min'\n\t},\n\n\tshim : {\n\t\tc : {\n\t\t\tinit : function(){\n\t\t\t\treturn {\n\t\t\t\t\taaa : 'show',\n\t\t\t\t\tbbb : 'hide'\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n});\n\n\nrequire(['a', 'b', 'jquery', 'c'], function(A, B, $, c){\n\tconsole.log(typeof c.aaa);\n});\n```\n\n刷新浏览器，我们看到，c.aaa的确是一个字符串：\n\n![打印出来的是字符串](http://7xlolm.com1.z0.glb.clouddn.com/2015111413.pic.jpg)\n\n另外，我们注意一点，paths里面的配置，路径中都带有'js/'，如下：\n\n```\npaths : {\n\ta : 'js/a',\n\tb : 'js/b',\n\tc : 'js/c',\n\tjquery : 'js/jquery.min'\n}\n```\n\n也就是说我们的模块都放在js目录下，既然这样，我们可不可以通过一个配置，来告诉我们的requirejs，每次查找模块的时候都基于js目录查找呢？这样我们就不用每次编写paths配置的时候都要写上'js/'了，实际上是可以的，requirejs.config()的配置对象中还有一个 baseUrl 属性，用来制定模块的查找目录，修改配置如下：\n\n```\nrequirejs.config({\n\tbaseUrl : './js',\n\tpaths : {\n\t\ta : 'a',\n\t\tb : 'b',\n\t\tc : 'c',\n\t\tjquery : 'jquery.min'\n\t},\n\n\tshim : {\n\t\tc : {\n\t\t\tinit : function(){\n\t\t\t\treturn {\n\t\t\t\t\taaa : show,\n\t\t\t\t\tbbb : hide\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n});\n```\n\n当然，baseUrl本省是基于引入requirejs的html文件所在目录的，在本例中即index.html所在目录的。\n\n另外，我们发现，当我们配置完baseUrl之后，paths中a、b、c三个模块可以不用配置，因为已经没有什么意义了，但是jquery需要保留，如下：\n\n```\nrequirejs.config({\n\tbaseUrl : './js',\n\tpaths : {\n\t\tjquery : 'jquery.min'\n\t},\n\n\tshim : {\n\t\tc : {\n\t\t\tinit : function(){\n\t\t\t\treturn {\n\t\t\t\t\taaa : show,\n\t\t\t\t\tbbb : hide\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n});\n```\n\n这样，当requirejs去加载的a、b、c模块的时候，就自动会根据baseUrl中的配置去查找模块，而我们的三个模块也恰好在js目录下，所以可以不用配置了，总而言之，这是一个很灵好好用的配置，具体根据你的项目来。\n\n下面，我们在考虑一种情景，假如你的项目很大，在最初阶段，你的项目里引用了jQuery1.x版本，后来随着项目的发展，项目需要引入jQuery2.x的版本，但是又不能删除掉原来的1.x版本，因为项目中有很多模块都在使用1.x的版本，这个时候，我们就希望在某些文件中引入jQuery时使用的1.x版本，而在另外一些文件中使用的是2.x的版本，怎么办呢？有的同学可能会这样想，如下配置：\n\n```\nrequirejs.config({\n\tbaseUrl : './js',\n\tpaths : {\n\t\tjquery1 : 'jquery-1.11.3'\n\t\tjquery2 : 'jquery-2.1.4'\n\t},\n\n\tshim : {\n\t\tc : {\n\t\t\tinit : function(){\n\t\t\t\treturn {\n\t\t\t\t\taaa : show,\n\t\t\t\t\tbbb : hide\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n});\n```\n\n配置两个jquery，一个jquery1，一个jquery2，分别对应不同的版本，当我们使用1.x版本的时候，就引用'jquery1'，当我们想使用2.x版本的时候就引用'jquery2'，这样看上去好像很合理，试着使用一下，修改config.js中require中的代码如下：\n\n```requirejs.config({\n\tbaseUrl : './js',\n\tpaths : {\n\t\tjquery1 : 'jquery-1.11.3',\n\t\tjquery2 : 'jquery-2.1.4'\n\t},\n\n\tshim : {\n\t\tc : {\n\t\t\tinit : function(){\n\t\t\t\treturn {\n\t\t\t\t\taaa : show,\n\t\t\t\t\tbbb : hide\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n});\n\n\nrequire(['jquery1'], function($){\n\talert($('html').html());\n});\n\n```\n\n我们刷新页面，报错了：\n\n![报错](http://7xlolm.com1.z0.glb.clouddn.com/2015111414.pic.jpg)\n\n查看报错信息，他说$没有定义，言外之意就是说我们jQuery模块根本没有引入进来，怎么会这样呢？实际上，当我们在paths中配置jquery时，我们不能使用别名，也就是说我们只能使用 jquery 而不能使用 jquery1和jquery2，不信你将requirejs.config()中的paths修改如下：\n\n```\npaths : {\n\tjquery : 'jquery-1.11.3'\n}\n```\n\n刷新页面可以正常使用，但是修改成下面这样就不能正常使用：\n\n```\npaths : {\n\tjq : 'jquery-1.11.3'\n}\n```\n\n因为你只能用jquery而不能用任何其他别名，为什么这样呢？我们打开jquery的源码，开其中有这么一段代码，如下图：\n\n![jQuery源码中对AMD兼容做法](http://7xlolm.com1.z0.glb.clouddn.com/2015111415.pic.jpg)\n\n这段代码其实就是jQuery库对AMD模块的兼容做法，我们发现，jQuery去使用define定义模块的时候，他显示的传递了第一个参数，是一个字符串 'jquery'，这个参数在我们自己编写的模块中一般是不去手动写死得，一般由构建工具在优化模块时自动填充的，以免模块冲突，因为这个参数代表了模块id，那么jquery为什么要写死呢？\n\n网上有种说法是出于性能考虑，因为像jQuery这种库我们在项目中使用是很频繁的，很多模块都要依赖这个模块，如果id这个参数不写死得话，意味着我们在依赖jQuery的时候可以随意起名字，而非必须使用 'jquery' ，这样其他模块就可以给jQuery起不同的模块名，这就会导致多次引入jQuery。\n\n现在，我们知道了为什么我们在paths配置中配置jQuery的时候为什么只能使用 'jquery' 了，我们回到之前的问题，即在不同的模块引入不同版本的jQuery，想一想我们还能这样去配置了嘛：\n\n```\npaths : {\n\tjquery1 : 'jquery-1.11.3',\n\tjquery2 : 'jquery-2.1.4'\n}\n```\n\n答案是否定的，因为我们只能用 jquery 而不能用 jquery1 或 jquery2，那难道我们这样配置吗？如下：\n\n```\npaths : {\n\tjquery : 'jquery-1.11.3',\n\tjquery : 'jquery-2.1.4'\n}\n```\n\n简直就是笑话，这样第二个jquery属性会覆盖第一个jquery属性，那怎么办？这就涉及requirejs的另一个配置了，map配置项，map配置项的作用是，在不同的模块中，即js文件中，依赖相同的模块名，缺加载不同的模块。\n\n我们先在config.js中增加map配置如下：\n\n```\nrequirejs.config({\n\tbaseUrl : './js',\n\tpaths : {\n\t\tjquery : 'jquery-1.11.3'\n\t},\n\n\tshim : {\n\t\tc : {\n\t\t\tinit : function(){\n\t\t\t\treturn {\n\t\t\t\t\taaa : show,\n\t\t\t\t\tbbb : hide\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tmap : {\n\t\t'a' : {\n\t\t\tjquery : 'jquery-1.11.3'\n\t\t},\n\t\t\n\t\t'b' : {\n\t\t\tjquery : 'jquery-2.1.4'\n\t\t}\n\t}\n});\n```\n\n我们在map中可以对每一个模块进行配置，上面代码中，我们配置了当在 a 模块中依赖 'jquery' 时，我们加载的是 1.11.3 版本，当我们在 b 模块中依赖 'jquery' 时，我们加载的是 2.1.4 版本。我们可以尝试一下，分别修改a.js和b.js这两个模块，让他们都去依赖jquery，然后分别返回所依赖jquery的版本，如下：\n\na.js\n```\ndefine(['jquery'], function(jquery){\n\tvar a = {\n\t\tcontent : $().jquery\n\t}\n\n\treturn a;\n});\n```\n\nb.js\n```\ndefine(['jquery'], function(jquery){\n\tvar b = {\n\t\tcontent : $().jquery\n\t}\n\n\treturn b;\n\n});\n```\n\n然后我们在config.js中打印模块a和b，如下：\n\n```\nrequire(['a', 'b'], function(A, B){\n\tconsole.log('模块a引用的jQuery版本是' + A.content);\n\tconsole.log('模块b引用的jQuery版本是' + B.content);\n});\n```\n\n刷新浏览器，我们看到如下，的确在不同的文件中依赖了不同版本的jQuery：\n\n![不同文件中依赖了不同版本的jQuery](http://7xlolm.com1.z0.glb.clouddn.com/2015111416.pic.jpg)\n\n但是有一点请读者看清楚，在a.js和b.js中我都依赖了jquery，在形式参数中我使用的是jquery，但是在下面我用到的却是(美元符号)，因为笔者在调试过程中，如果形式参数也写成(美元符号)，那么使用(美元符号)参数打印出来的始终都是undefined，但是经过分析的确正常导入模块并且没有报错，我不知道这是什么原因，或者requirejs的BUG，如果读者有知道是什么原因的欢迎在下面评论指针，共同进步。\n\n这样，requirejs中一些必备且不易理解的配置以及一些遇到的问题和解决方案就讲解的差不多了，其实requirejs中的配置不只这些，读者可以查阅[官方文档](http://www.requirejs.cn/) 查看其他配置，都比较简单，掌握笔者讲得这些基本够用了。\n\n下一篇文章我们就来讲一讲如何优化项目的事，包括使用rjs配合gulp构建工具等，如果你觉得对你有帮助，就看看我的话联网祈祷思维的运用吧，如下：\n\n![支付宝二维码](http://7xlolm.com1.z0.glb.clouddn.com/201511122.pic.jpg)\n\n\n","slug":"基于gulp-requirejs-rjs的前端自动化构建系列文章-二","published":1,"updated":"2015-11-17T07:32:11.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj669fsjo000qewfcilwg9kgk","content":"<blockquote>\n<p>上一篇介绍了js模块化的历程和AMD规范中规定模块的定义和引用，这篇文章就以requirejs这个AMD规范的实现来讲解js中的模块化开发</p>\n</blockquote>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20151109amd.jpg\" alt=\"requirejs\"></p>\n<a id=\"more\"></a>\n<p>如果你知道了AMD规范中规定的js模块的定义方法和如何引用一个模块，那么requirejs的使用几乎是零成本的，因为requirejs就是AMD规范的实现，你唯一需要学习的可能就是一些便于我们使用模块的配置，和requirejs的一些特性，接下来，我们就用一个完整的例子，来学习如何使用requirejs。</p>\n<p>我们在项目中很可能会引用第三方库，比如jQuery等，还要引用我们自己写的一些js文件，在最初，我们的目录结构看上去是这样的，如下图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201511141.pic.jpg\" alt=\"原始目录结构\"></p>\n<p>我们有一个index.html文件，然后再建立一个名为js的文件夹，把jQuery库和我们自己写的js文件都放在里面，或者可能你还会为jQuery等第三方库单独建立一个文件夹，但最终在html页面中引用的效果是一样的，即需要几个js文件，就需要几个script标签，如下是index.html的内容：</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;&lt;/title&gt;\n    &lt;meta charset=&quot;utf-8&quot; /&gt;\n&lt;/head&gt;\n&lt;body&gt;\n\n    &lt;script src=&quot;js/jquery.min.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;js/a.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;js/b.js&quot;&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>我们已经了解了上面代码的缺点：</p>\n<ul>\n<li>污染了全局变量，不同文件之间可能会命名冲突</li>\n<li>文件依赖关系难以维护</li>\n<li>发出更多的http请求，影响性能</li>\n</ul>\n<p>再来看看我们的a.js和b.js文件：</p>\n<p>a.js</p>\n<pre><code>var a = {\n    content : &#39;a.js&#39;\n}\n</code></pre><p>b.js</p>\n<pre><code>var b = {\n    content : &#39;b.js&#39;\n}\n</code></pre><p>这两个文件很简单，分别定义了两个污染全局的变量a和b。</p>\n<p>那我们通过requirejs来解决这些问题呢？首先，你得有个女朋友，哦不对，你得先有requirejs库，所以，下载连接 <a href=\"http://www.requirejs.cn/docs/download.html#requirejs\" target=\"_blank\" rel=\"external\">requirejs下载</a></p>\n<p>下载下来之后，我们把requirejs放在与我们index.html同级的目录下，如下图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201511142.pic.jpg\" alt=\"requirejs与html同级\"></p>\n<p>修改我们的index.html，只需引入我们刚刚下载下来的requirejs：</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;&lt;/title&gt;\n    &lt;meta charset=&quot;utf-8&quot; /&gt;\n&lt;/head&gt;\n&lt;body&gt;\n\n    &lt;script src=&quot;require.js&quot; data-main=&quot;config&quot;&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>你可能会疑惑，script标签中data-main是什么？是这样的，requirejs需要一个入口模块，也就是一上来就去执行的模块，类似于C语言中的main函数。上面的代码中，我们告诉requirejs我们的入口模块是config.js，由于requirejs默认模块都是以.js为后缀的，所以这里我们可以省略，只需要写config就可以了，然后我们在index.html同级目录下创建config.js文件如下：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201511143.pic.jpg\" alt=\"config.js文件与index.html同级目录\"></p>\n<p>这个config.js可以看做是我们的入口模块，或者主模块，当requirejs加载完成后，会自动执行config.js文件，我们可以在config.js文件中写下如下代码：</p>\n<pre><code>alert(&#39;这是config.js文件&#39;);\n</code></pre><p>双击打开requirejs文件在浏览器中打开，如下图，如我们所愿，config.js被执行了：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20151114c.png\" alt=\"config.js文件被执行了\"></p>\n<p>如果config模块只是简单的alert一句话，那么我们就没有必要用requirejs了，一般来讲，我们在主模块中去引用其他模块，开发我们的业务逻辑，在之前的代码中，我们引入了jQuery库，a.js和b.js，现在我们只引入了requirejs并且告诉它我们的主模块是config.js，那么我们如何使用requirejs去加载a.js、b.js和jQuery库呢？我们知道config.js符合AMD模块编写规范，上一篇文章我们已经讲过了AMD规范中如何编写和引用模块，下面我们需要做的就是把我们的文件都编写成一个个模块就好了，由于我们多在主模块即config.js中去引用其他模块，所以我们修改config.js如下：</p>\n<pre><code>require([&#39;a&#39;, &#39;b&#39;], function(A, B){\n    console.log(A);\n    console.log(B);\n});\n</code></pre><p>我们在config.js中使用require函数去加载模块a和模块b，注意，requirejs默认模块是.js后缀结尾的，所以我们只需要写a和b即可，它会自动去加载a.js和b.js，但是这样写就可以了嘛？我们刷新浏览器：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/2015111422.pic.jpg\" alt=\"报错\"></p>\n<p>我们仔细看报错信息，“net::ERR_FILE_NOT_FOUND”，再看模块加载的路径 “file:///Users/huochunyang/hcyObj/temp/a.js”，为什么会这样呢？我们知道，我们刚刚在config.js中加载模块a和b的时候，我们仅仅写了a和b到依赖数组中，可是requirejs怎么知道你这两个模块在哪里？所以默认情况下，requirejs默认会在引用requirejs的html文件所在目录下查找，注意，是html同级目录下查找，不是requirejs同级目录下查找，当然，由于我们这个例子中index.html和requirejs是在同一个目录下，所以怕大家混淆。既然这样，问题就好说了，我们index.html同级目录下并没有a.js和b.js这两个模块，我们把这两个模块放到了js目录下，所以，当然会报错啦，既然找到了问题的原因，我们修改config.js文件：</p>\n<pre><code>require([&#39;js/a&#39;, &#39;js/b&#39;], function(A, B){\n    console.log(A);\n    console.log(B);\n});\n</code></pre><p>再刷新浏览器，如下图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201511144.pic.jpg\" alt=\"不报错，但输出undefined\"></p>\n<p>怎么样？不报错了吧？那是因为我们家在模块的时候路径写的正确，requirejs能够正确加载模块，所以就不会报错了，但是细心的同学会发现，怎么输出两个undefined？在config.js中我们加载了a、b两个模块后，分别在log中输出了A、B模块对象，也就是说我们使用requirejs加载过来的两个模块竟然是undefined。为什么会这样呢？很简单，因为我们a.js和b.js中，并没有暗中AMD规范去编写模块代码，上一篇文章中我们介绍了如果编写一个模块，下面我们就改写a.js和b.js为模块的写法，如下：</p>\n<p>a.js</p>\n<pre><code>define(function(){\n    var a = {\n        content : &#39;a.js&#39;\n    }\n\n    return a;\n});\n</code></pre><p>b.js</p>\n<pre><code>define(function(){\n\n    var b = {\n        content : &#39;b.js&#39;\n    }\n\n    return b;\n\n});\n</code></pre><p>这两个模块很简单，我们使用return语句返回两个对象，被返回的对象就是模块对象，代表了这个模块，我们刷新浏览器：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201511145.pic.jpg\" alt=\"输出模块A和B\"></p>\n<p>如何我们的模块B需要依赖模块A，我们可以改写模块B为如下代码，在依赖数组中依赖模块A：</p>\n<pre><code>define([&#39;js/a&#39;], function(A){\n\n    var b = {\n        content : &#39;b.js&#39;\n    }\n\n    return b;\n\n});\n</code></pre><p>不知道大家有没有发现，我们每次去加载模块的时候，都要写对模块所在路径，比如加载模块a，我们就要这样去加载 “js/a.js” ，假如我们的项目做的比较大，模块分的比较深，及目录层级深，如果我们还这样去加载的话，可能会写成下面这样：</p>\n<ul>\n<li>“modules/dom/XXX/aaa.js” *</li>\n</ul>\n<p>如果每次为了加载一个模块都要这样去写的话，第一我们还要记住模块所在路径，如果记不住的话还要去查看，很影响开发效率，第二写起来总是感觉很不爽，代码看着很恶心，那么我们如何解决这个问题呢？这就要讲到requirejs的配置了，requirejs有一个config函数，接受一个json对象，设置一些配置选项，我们修改config.js如下：</p>\n<pre><code>requirejs.config({\n    paths : {\n        a : &#39;js/a&#39;,\n        b : &#39;js/b&#39;\n    }\n});\n\n\nrequire([&#39;a&#39;, &#39;b&#39;], function(A, B){\n    console.log(A);\n    console.log(B);\n});\n</code></pre><p>首先我们在使用require()函数去加载模块之前，我们使用requirejs.config()方法去对requirejs进行配置，requirejs.config方法接收一个对象，对象中有一个paths配置项，顾名思义，这是一项路径配置，再看下面使用require()函数去加载模块时，我们直接去加载a和b，这样是可以正常加载模块的，因为在加载a模块的时候，requirejs发现在paths中配置的路径中a对应“js/a”，所以，require会自动去加载js/a模块，而不是在index.html同级目录下去找，所以paths配置就像一个路由，刷新页面，查看控制台中的输出，我们等待片刻会发现，如下图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201511146.pic.jpg\" alt=\"加载超时\"></p>\n<p>什么？加载超时？什么情况？别紧张，还记我们的b.js中吗？我们在b.js中依赖了a.js，可是我们的代码是怎么依赖的呢？打开b.js：</p>\n<pre><code>define([&#39;js/a&#39;], function(A){\n\n    var b = {\n        content : &#39;b.js&#39;\n    }\n\n    return b;\n\n});\n</code></pre><p>我们发现，我们依赖a，模块的时候依然使用’js/a’进行依赖，而当requirejs在解析’js/a’的时候，发现有一个’a’，然后又再paths配置中发现’a’对应’js/a’,于是，requirejs就把’a’换成了’js/a’，所以整体的’js/a’最终被换成了’js/js/a’，然后又再路径中发现了a，于是加载路径又被替换成了’js/js/js/a’，如此下去，最终成了死循环，而超过一定的时间之后，就会报错加载超时，明白了吧，所以，我们把b.js中依赖a.js的字符创直接写成’a’就可以了，如下：</p>\n<pre><code>define([&#39;a&#39;], function(A){\n\n    var b = {\n        content : &#39;b.js&#39;\n    }\n\n    return b;\n\n});\n</code></pre><p>再次刷新浏览器，怎么样？正常加载了吧？这样以后我们只要需要依赖a模块，我们就直接写’a’就可以了：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201511147.pic.jpg\" alt=\"正常加载\"></p>\n<p>那么好，a.js和b.js我们都改成了模块的编写方式，并且也做了paths配置，最终也成功加载了，但是我们还遗漏了一个东西，就是jQuery这个第三方库，那么requirejs能够加载第三方库吗？答案是：只要第三方库提供了AMD接口，那么requirejs就可以加载，而jQuery本身也提供了这个接口，所以我们直接加载就好了，为了方便，我们依然在paths中配置一下：</p>\n<pre><code>requirejs.config({\n    paths : {\n        a : &#39;js/a&#39;,\n        b : &#39;js/b&#39;,\n        $ : &#39;js/jquery.min&#39;\n    }\n});\n</code></pre><p>然后在config中去加载jQuery并试着使用jQuery，看看能不能正常使用，修改我们的config.js如下：</p>\n<pre><code>requirejs.config({\n    paths : {\n        a : &#39;js/a&#39;,\n        b : &#39;js/b&#39;,\n        jquery : &#39;js/jquery.min&#39;\n    }\n});\n\nrequire([&#39;a&#39;, &#39;b&#39;, &#39;jquery&#39;], function(A, B, $){\n    alert($(&#39;html&#39;).html());\n    console.log(A);\n    console.log(B);\n});\n</code></pre><p>刷新页面：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201511148.pic.jpg\" alt=\"第三方库加载成功\"></p>\n<p>弹出弹窗，证明我们加载jQuery成功并成功使用。</p>\n<p>下面我们再来思考一个问题，我们为什么能够直接通过requirejs加载jQuery？是因为jQuery这个第三方库提供了AMD支持，可是并不是所有第三方库都提供了AMD支持，那么require就不能加载那些第三方库了吗？答案是：依然能够加载。不过，这就涉及到如何加载非AMD模块写法的模块了，假设我们有一个模块c，但是c.js并没有按照AMD规范封装为一个模块，我们在js文件加下创建c.js，并写下如下代码：</p>\n<pre><code>var show = function(){\n    alert(&#39;调用了c&#39;);\n}\n</code></pre><p>我们的c.js很简单。只是单纯的定义了一个c函数，并弹出一个提示框，显示“调用了c”，所以这个c.js并不是一个AMD模块，那么如果我们想使用requirejs加载这个c，该如何加载呢？这就要讲到requirejs.config()中的另一个配置项 shim 了，我们已经知道了paths是用来配置加载模块路径的，shim则是用来加载非AMD模块规范的“模块”的，所以，为了加载c.js，我们可以修改config.js并添加shim配置，如下：</p>\n<pre><code>requirejs.config({\n    paths : {\n        a : &#39;js/a&#39;,\n        b : &#39;js/b&#39;,\n        c : &#39;js/c&#39;,\n        jquery : &#39;js/jquery.min&#39;\n    },\n\n    shim : {\n        c : {\n            exports : &#39;show&#39;\n        }\n    }\n});\n\n\nrequire([&#39;a&#39;, &#39;b&#39;, &#39;jquery&#39;, &#39;c&#39;], function(A, B, $, c){\n    console.log(c);\n});\n</code></pre><p>我们添加了shim配置，配置中，c 代表我们在require中引入模块时的名字，即我们可以通过require([‘c’])去引用c模块，c对应一个json对象，对象中有一个exports属性，exports属性的值就是我们要到处的接口，注意，我们依然要在paths中添加模块c的配置，这样才能正常加载模块，最后，我们在控制台中输出了模块c，打开浏览器，刷新：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201511149.pic.jpg\" alt=\"输出模块c\"></p>\n<p>我们看到，打印出来的就是我们的函数show，也就是说我们到处的接口就是show函数，我们可以调用一下试试，修改config.js：</p>\n<pre><code>require([&#39;a&#39;, &#39;b&#39;, &#39;jquery&#39;, &#39;c&#39;], function(A, B, $, c){\n    c();\n});\n</code></pre><p>刷新页面：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/2015111410.pic.jpg\" alt=\"调用了show函数\"></p>\n<p>怎么样，弹出弹窗了吧，实际上，经过shim配置后，requirejs会自动修改c.js为一个AMD模块，为其添加封装代码，如下：</p>\n<pre><code>define(function(){\n    var show = function(){\n        alert(&#39;调用了c&#39;);\n    }    \n\n    return show;\n});\n</code></pre><p>我们看到，return返回的是show函数，是因为我们在shim中为c模块配置的导出接口为show，即exports的值是show，所以加入我们修改exports的值为其他值，是没有办法导出成功的，比如我们修改config.js中c模块的shim配置，如下，我们导出的接口不是show而是随意的aaa:</p>\n<pre><code>shim : {\n    c : {\n        exports : &#39;aaa&#39;\n    }\n}\n</code></pre><p>刷新页面：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/2015111411.pic.jpg\" alt=\"报错\"></p>\n<p>报错，c不是一个函数，为什么呢？因为我们导出的接口是aaa，鬼知道你这个aaa是什么啊。所以最后调用的时候当然会报错。</p>\n<p>我们还可以导出多个接口，比如我们的c.js中有两个函数，分别是show函数和hide函数，修改我们的c.js如下：</p>\n<pre><code>var show = function(){\n    alert(&#39;show函数&#39;);\n}    \n\nvar hide = function(){\n    alert(&#39;hide函数&#39;);\n}\n</code></pre><p>如果我们继续使用上面的shim配置，那么我们将只能导出show函数，没有办法导出hide，如何才能将两个接口都导出来呢？这个时候我们就不能使用exports属性了，我们要用init属性，分别将两个接口导出，修改config.js如下：</p>\n<pre><code>shim : {\n    c : {\n        init : function(){\n            return {\n                aaa : show,\n                bbb : hide\n            }\n        }\n    }\n}\n</code></pre><p>init属性对应一个函数，函数返回一个对象，对象里面对应我们要导出的接口，这样，我们就把两个接口都导出了，我们可以通过模块的aaa调用show函数，模块的bbb调用hide函数，修改config.js去尝试调用一下：</p>\n<pre><code>require([&#39;a&#39;, &#39;b&#39;, &#39;jquery&#39;, &#39;c&#39;], function(A, B, $, c){\n    c.aaa();\n    c.bbb();\n});\n</code></pre><p>打开浏览器刷新，怎么样，两个函数正常调用了吧，不过这里有一个需要注意的地方，init属性对应的函数中，返回的对象里面，show和hide不能用引号引起来，下面的写法是错误的：</p>\n<pre><code>shim : {\n    c : {\n        init : function(){\n            return {\n                aaa : &#39;show&#39;,\n                bbb : &#39;hide&#39;\n            }\n        }\n    }\n}\n</code></pre><p>刷新浏览器会报错，如下图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/2015111412.pic.jpg\" alt=\"加引号后报错\"></p>\n<p>那么为什么会这样呢？实际上，当我们设置了init属性后，requirejs相当于自动为我们封装了c.js如下面这样：</p>\n<pre><code>define(function(){\n    var show = function(){\n        alert(&#39;show函数&#39;);\n    }    \n\n    var hide = function(){\n        alert(&#39;hide函数&#39;);\n    }\n\n    return {\n        aaa : show,\n        bbb : hide\n    }\n});\n</code></pre><p>上面代码中show和hide没有加引号，所以是变量，分别引用上面的show函数和hide函数，如果我们加了引号，requirejs封装之后就会想这样：</p>\n<pre><code>define(function(){\n    var show = function(){\n        alert(&#39;show函数&#39;);\n    }    \n\n    var hide = function(){\n        alert(&#39;hide函数&#39;);\n    }\n\n    return {\n        aaa : &#39;show&#39;,\n        bbb : &#39;hide&#39;\n    }\n});\n</code></pre><p>我们看上面的代码，’show’和’hide’都加了引号，所以他们是字符串，并没有引用上面的show函数和hide函数，只是导出一个字符串而已，所以当我们把字符串当做函数来调用的时候，当然会报错。我们也可以验证这一点，我们就使用带引号的配置，然后打印出c.aaa的类型，如下：</p>\n<pre><code>requirejs.config({\n    paths : {\n        a : &#39;js/a&#39;,\n        b : &#39;js/b&#39;,\n        c : &#39;js/c&#39;,\n        jquery : &#39;js/jquery.min&#39;\n    },\n\n    shim : {\n        c : {\n            init : function(){\n                return {\n                    aaa : &#39;show&#39;,\n                    bbb : &#39;hide&#39;\n                }\n            }\n        }\n    }\n});\n\n\nrequire([&#39;a&#39;, &#39;b&#39;, &#39;jquery&#39;, &#39;c&#39;], function(A, B, $, c){\n    console.log(typeof c.aaa);\n});\n</code></pre><p>刷新浏览器，我们看到，c.aaa的确是一个字符串：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/2015111413.pic.jpg\" alt=\"打印出来的是字符串\"></p>\n<p>另外，我们注意一点，paths里面的配置，路径中都带有’js/‘，如下：</p>\n<pre><code>paths : {\n    a : &#39;js/a&#39;,\n    b : &#39;js/b&#39;,\n    c : &#39;js/c&#39;,\n    jquery : &#39;js/jquery.min&#39;\n}\n</code></pre><p>也就是说我们的模块都放在js目录下，既然这样，我们可不可以通过一个配置，来告诉我们的requirejs，每次查找模块的时候都基于js目录查找呢？这样我们就不用每次编写paths配置的时候都要写上’js/‘了，实际上是可以的，requirejs.config()的配置对象中还有一个 baseUrl 属性，用来制定模块的查找目录，修改配置如下：</p>\n<pre><code>requirejs.config({\n    baseUrl : &#39;./js&#39;,\n    paths : {\n        a : &#39;a&#39;,\n        b : &#39;b&#39;,\n        c : &#39;c&#39;,\n        jquery : &#39;jquery.min&#39;\n    },\n\n    shim : {\n        c : {\n            init : function(){\n                return {\n                    aaa : show,\n                    bbb : hide\n                }\n            }\n        }\n    }\n});\n</code></pre><p>当然，baseUrl本省是基于引入requirejs的html文件所在目录的，在本例中即index.html所在目录的。</p>\n<p>另外，我们发现，当我们配置完baseUrl之后，paths中a、b、c三个模块可以不用配置，因为已经没有什么意义了，但是jquery需要保留，如下：</p>\n<pre><code>requirejs.config({\n    baseUrl : &#39;./js&#39;,\n    paths : {\n        jquery : &#39;jquery.min&#39;\n    },\n\n    shim : {\n        c : {\n            init : function(){\n                return {\n                    aaa : show,\n                    bbb : hide\n                }\n            }\n        }\n    }\n});\n</code></pre><p>这样，当requirejs去加载的a、b、c模块的时候，就自动会根据baseUrl中的配置去查找模块，而我们的三个模块也恰好在js目录下，所以可以不用配置了，总而言之，这是一个很灵好好用的配置，具体根据你的项目来。</p>\n<p>下面，我们在考虑一种情景，假如你的项目很大，在最初阶段，你的项目里引用了jQuery1.x版本，后来随着项目的发展，项目需要引入jQuery2.x的版本，但是又不能删除掉原来的1.x版本，因为项目中有很多模块都在使用1.x的版本，这个时候，我们就希望在某些文件中引入jQuery时使用的1.x版本，而在另外一些文件中使用的是2.x的版本，怎么办呢？有的同学可能会这样想，如下配置：</p>\n<pre><code>requirejs.config({\n    baseUrl : &#39;./js&#39;,\n    paths : {\n        jquery1 : &#39;jquery-1.11.3&#39;\n        jquery2 : &#39;jquery-2.1.4&#39;\n    },\n\n    shim : {\n        c : {\n            init : function(){\n                return {\n                    aaa : show,\n                    bbb : hide\n                }\n            }\n        }\n    }\n});\n</code></pre><p>配置两个jquery，一个jquery1，一个jquery2，分别对应不同的版本，当我们使用1.x版本的时候，就引用’jquery1’，当我们想使用2.x版本的时候就引用’jquery2’，这样看上去好像很合理，试着使用一下，修改config.js中require中的代码如下：</p>\n<pre><code class=\"requirejs.config({\">    baseUrl : &#39;./js&#39;,\n    paths : {\n        jquery1 : &#39;jquery-1.11.3&#39;,\n        jquery2 : &#39;jquery-2.1.4&#39;\n    },\n\n    shim : {\n        c : {\n            init : function(){\n                return {\n                    aaa : show,\n                    bbb : hide\n                }\n            }\n        }\n    }\n});\n\n\nrequire([&#39;jquery1&#39;], function($){\n    alert($(&#39;html&#39;).html());\n});\n</code></pre>\n<p>我们刷新页面，报错了：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/2015111414.pic.jpg\" alt=\"报错\"></p>\n<p>查看报错信息，他说$没有定义，言外之意就是说我们jQuery模块根本没有引入进来，怎么会这样呢？实际上，当我们在paths中配置jquery时，我们不能使用别名，也就是说我们只能使用 jquery 而不能使用 jquery1和jquery2，不信你将requirejs.config()中的paths修改如下：</p>\n<pre><code>paths : {\n    jquery : &#39;jquery-1.11.3&#39;\n}\n</code></pre><p>刷新页面可以正常使用，但是修改成下面这样就不能正常使用：</p>\n<pre><code>paths : {\n    jq : &#39;jquery-1.11.3&#39;\n}\n</code></pre><p>因为你只能用jquery而不能用任何其他别名，为什么这样呢？我们打开jquery的源码，开其中有这么一段代码，如下图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/2015111415.pic.jpg\" alt=\"jQuery源码中对AMD兼容做法\"></p>\n<p>这段代码其实就是jQuery库对AMD模块的兼容做法，我们发现，jQuery去使用define定义模块的时候，他显示的传递了第一个参数，是一个字符串 ‘jquery’，这个参数在我们自己编写的模块中一般是不去手动写死得，一般由构建工具在优化模块时自动填充的，以免模块冲突，因为这个参数代表了模块id，那么jquery为什么要写死呢？</p>\n<p>网上有种说法是出于性能考虑，因为像jQuery这种库我们在项目中使用是很频繁的，很多模块都要依赖这个模块，如果id这个参数不写死得话，意味着我们在依赖jQuery的时候可以随意起名字，而非必须使用 ‘jquery’ ，这样其他模块就可以给jQuery起不同的模块名，这就会导致多次引入jQuery。</p>\n<p>现在，我们知道了为什么我们在paths配置中配置jQuery的时候为什么只能使用 ‘jquery’ 了，我们回到之前的问题，即在不同的模块引入不同版本的jQuery，想一想我们还能这样去配置了嘛：</p>\n<pre><code>paths : {\n    jquery1 : &#39;jquery-1.11.3&#39;,\n    jquery2 : &#39;jquery-2.1.4&#39;\n}\n</code></pre><p>答案是否定的，因为我们只能用 jquery 而不能用 jquery1 或 jquery2，那难道我们这样配置吗？如下：</p>\n<pre><code>paths : {\n    jquery : &#39;jquery-1.11.3&#39;,\n    jquery : &#39;jquery-2.1.4&#39;\n}\n</code></pre><p>简直就是笑话，这样第二个jquery属性会覆盖第一个jquery属性，那怎么办？这就涉及requirejs的另一个配置了，map配置项，map配置项的作用是，在不同的模块中，即js文件中，依赖相同的模块名，缺加载不同的模块。</p>\n<p>我们先在config.js中增加map配置如下：</p>\n<pre><code>requirejs.config({\n    baseUrl : &#39;./js&#39;,\n    paths : {\n        jquery : &#39;jquery-1.11.3&#39;\n    },\n\n    shim : {\n        c : {\n            init : function(){\n                return {\n                    aaa : show,\n                    bbb : hide\n                }\n            }\n        }\n    },\n\n    map : {\n        &#39;a&#39; : {\n            jquery : &#39;jquery-1.11.3&#39;\n        },\n\n        &#39;b&#39; : {\n            jquery : &#39;jquery-2.1.4&#39;\n        }\n    }\n});\n</code></pre><p>我们在map中可以对每一个模块进行配置，上面代码中，我们配置了当在 a 模块中依赖 ‘jquery’ 时，我们加载的是 1.11.3 版本，当我们在 b 模块中依赖 ‘jquery’ 时，我们加载的是 2.1.4 版本。我们可以尝试一下，分别修改a.js和b.js这两个模块，让他们都去依赖jquery，然后分别返回所依赖jquery的版本，如下：</p>\n<p>a.js</p>\n<pre><code>define([&#39;jquery&#39;], function(jquery){\n    var a = {\n        content : $().jquery\n    }\n\n    return a;\n});\n</code></pre><p>b.js</p>\n<pre><code>define([&#39;jquery&#39;], function(jquery){\n    var b = {\n        content : $().jquery\n    }\n\n    return b;\n\n});\n</code></pre><p>然后我们在config.js中打印模块a和b，如下：</p>\n<pre><code>require([&#39;a&#39;, &#39;b&#39;], function(A, B){\n    console.log(&#39;模块a引用的jQuery版本是&#39; + A.content);\n    console.log(&#39;模块b引用的jQuery版本是&#39; + B.content);\n});\n</code></pre><p>刷新浏览器，我们看到如下，的确在不同的文件中依赖了不同版本的jQuery：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/2015111416.pic.jpg\" alt=\"不同文件中依赖了不同版本的jQuery\"></p>\n<p>但是有一点请读者看清楚，在a.js和b.js中我都依赖了jquery，在形式参数中我使用的是jquery，但是在下面我用到的却是(美元符号)，因为笔者在调试过程中，如果形式参数也写成(美元符号)，那么使用(美元符号)参数打印出来的始终都是undefined，但是经过分析的确正常导入模块并且没有报错，我不知道这是什么原因，或者requirejs的BUG，如果读者有知道是什么原因的欢迎在下面评论指针，共同进步。</p>\n<p>这样，requirejs中一些必备且不易理解的配置以及一些遇到的问题和解决方案就讲解的差不多了，其实requirejs中的配置不只这些，读者可以查阅<a href=\"http://www.requirejs.cn/\" target=\"_blank\" rel=\"external\">官方文档</a> 查看其他配置，都比较简单，掌握笔者讲得这些基本够用了。</p>\n<p>下一篇文章我们就来讲一讲如何优化项目的事，包括使用rjs配合gulp构建工具等，如果你觉得对你有帮助，就看看我的话联网祈祷思维的运用吧，如下：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201511122.pic.jpg\" alt=\"支付宝二维码\"></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>上一篇介绍了js模块化的历程和AMD规范中规定模块的定义和引用，这篇文章就以requirejs这个AMD规范的实现来讲解js中的模块化开发</p>\n</blockquote>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20151109amd.jpg\" alt=\"requirejs\"></p>","more":"<p>如果你知道了AMD规范中规定的js模块的定义方法和如何引用一个模块，那么requirejs的使用几乎是零成本的，因为requirejs就是AMD规范的实现，你唯一需要学习的可能就是一些便于我们使用模块的配置，和requirejs的一些特性，接下来，我们就用一个完整的例子，来学习如何使用requirejs。</p>\n<p>我们在项目中很可能会引用第三方库，比如jQuery等，还要引用我们自己写的一些js文件，在最初，我们的目录结构看上去是这样的，如下图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201511141.pic.jpg\" alt=\"原始目录结构\"></p>\n<p>我们有一个index.html文件，然后再建立一个名为js的文件夹，把jQuery库和我们自己写的js文件都放在里面，或者可能你还会为jQuery等第三方库单独建立一个文件夹，但最终在html页面中引用的效果是一样的，即需要几个js文件，就需要几个script标签，如下是index.html的内容：</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;&lt;/title&gt;\n    &lt;meta charset=&quot;utf-8&quot; /&gt;\n&lt;/head&gt;\n&lt;body&gt;\n\n    &lt;script src=&quot;js/jquery.min.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;js/a.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;js/b.js&quot;&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>我们已经了解了上面代码的缺点：</p>\n<ul>\n<li>污染了全局变量，不同文件之间可能会命名冲突</li>\n<li>文件依赖关系难以维护</li>\n<li>发出更多的http请求，影响性能</li>\n</ul>\n<p>再来看看我们的a.js和b.js文件：</p>\n<p>a.js</p>\n<pre><code>var a = {\n    content : &#39;a.js&#39;\n}\n</code></pre><p>b.js</p>\n<pre><code>var b = {\n    content : &#39;b.js&#39;\n}\n</code></pre><p>这两个文件很简单，分别定义了两个污染全局的变量a和b。</p>\n<p>那我们通过requirejs来解决这些问题呢？首先，你得有个女朋友，哦不对，你得先有requirejs库，所以，下载连接 <a href=\"http://www.requirejs.cn/docs/download.html#requirejs\" target=\"_blank\" rel=\"external\">requirejs下载</a></p>\n<p>下载下来之后，我们把requirejs放在与我们index.html同级的目录下，如下图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201511142.pic.jpg\" alt=\"requirejs与html同级\"></p>\n<p>修改我们的index.html，只需引入我们刚刚下载下来的requirejs：</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;&lt;/title&gt;\n    &lt;meta charset=&quot;utf-8&quot; /&gt;\n&lt;/head&gt;\n&lt;body&gt;\n\n    &lt;script src=&quot;require.js&quot; data-main=&quot;config&quot;&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>你可能会疑惑，script标签中data-main是什么？是这样的，requirejs需要一个入口模块，也就是一上来就去执行的模块，类似于C语言中的main函数。上面的代码中，我们告诉requirejs我们的入口模块是config.js，由于requirejs默认模块都是以.js为后缀的，所以这里我们可以省略，只需要写config就可以了，然后我们在index.html同级目录下创建config.js文件如下：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201511143.pic.jpg\" alt=\"config.js文件与index.html同级目录\"></p>\n<p>这个config.js可以看做是我们的入口模块，或者主模块，当requirejs加载完成后，会自动执行config.js文件，我们可以在config.js文件中写下如下代码：</p>\n<pre><code>alert(&#39;这是config.js文件&#39;);\n</code></pre><p>双击打开requirejs文件在浏览器中打开，如下图，如我们所愿，config.js被执行了：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20151114c.png\" alt=\"config.js文件被执行了\"></p>\n<p>如果config模块只是简单的alert一句话，那么我们就没有必要用requirejs了，一般来讲，我们在主模块中去引用其他模块，开发我们的业务逻辑，在之前的代码中，我们引入了jQuery库，a.js和b.js，现在我们只引入了requirejs并且告诉它我们的主模块是config.js，那么我们如何使用requirejs去加载a.js、b.js和jQuery库呢？我们知道config.js符合AMD模块编写规范，上一篇文章我们已经讲过了AMD规范中如何编写和引用模块，下面我们需要做的就是把我们的文件都编写成一个个模块就好了，由于我们多在主模块即config.js中去引用其他模块，所以我们修改config.js如下：</p>\n<pre><code>require([&#39;a&#39;, &#39;b&#39;], function(A, B){\n    console.log(A);\n    console.log(B);\n});\n</code></pre><p>我们在config.js中使用require函数去加载模块a和模块b，注意，requirejs默认模块是.js后缀结尾的，所以我们只需要写a和b即可，它会自动去加载a.js和b.js，但是这样写就可以了嘛？我们刷新浏览器：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/2015111422.pic.jpg\" alt=\"报错\"></p>\n<p>我们仔细看报错信息，“net::ERR_FILE_NOT_FOUND”，再看模块加载的路径 “file:///Users/huochunyang/hcyObj/temp/a.js”，为什么会这样呢？我们知道，我们刚刚在config.js中加载模块a和b的时候，我们仅仅写了a和b到依赖数组中，可是requirejs怎么知道你这两个模块在哪里？所以默认情况下，requirejs默认会在引用requirejs的html文件所在目录下查找，注意，是html同级目录下查找，不是requirejs同级目录下查找，当然，由于我们这个例子中index.html和requirejs是在同一个目录下，所以怕大家混淆。既然这样，问题就好说了，我们index.html同级目录下并没有a.js和b.js这两个模块，我们把这两个模块放到了js目录下，所以，当然会报错啦，既然找到了问题的原因，我们修改config.js文件：</p>\n<pre><code>require([&#39;js/a&#39;, &#39;js/b&#39;], function(A, B){\n    console.log(A);\n    console.log(B);\n});\n</code></pre><p>再刷新浏览器，如下图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201511144.pic.jpg\" alt=\"不报错，但输出undefined\"></p>\n<p>怎么样？不报错了吧？那是因为我们家在模块的时候路径写的正确，requirejs能够正确加载模块，所以就不会报错了，但是细心的同学会发现，怎么输出两个undefined？在config.js中我们加载了a、b两个模块后，分别在log中输出了A、B模块对象，也就是说我们使用requirejs加载过来的两个模块竟然是undefined。为什么会这样呢？很简单，因为我们a.js和b.js中，并没有暗中AMD规范去编写模块代码，上一篇文章中我们介绍了如果编写一个模块，下面我们就改写a.js和b.js为模块的写法，如下：</p>\n<p>a.js</p>\n<pre><code>define(function(){\n    var a = {\n        content : &#39;a.js&#39;\n    }\n\n    return a;\n});\n</code></pre><p>b.js</p>\n<pre><code>define(function(){\n\n    var b = {\n        content : &#39;b.js&#39;\n    }\n\n    return b;\n\n});\n</code></pre><p>这两个模块很简单，我们使用return语句返回两个对象，被返回的对象就是模块对象，代表了这个模块，我们刷新浏览器：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201511145.pic.jpg\" alt=\"输出模块A和B\"></p>\n<p>如何我们的模块B需要依赖模块A，我们可以改写模块B为如下代码，在依赖数组中依赖模块A：</p>\n<pre><code>define([&#39;js/a&#39;], function(A){\n\n    var b = {\n        content : &#39;b.js&#39;\n    }\n\n    return b;\n\n});\n</code></pre><p>不知道大家有没有发现，我们每次去加载模块的时候，都要写对模块所在路径，比如加载模块a，我们就要这样去加载 “js/a.js” ，假如我们的项目做的比较大，模块分的比较深，及目录层级深，如果我们还这样去加载的话，可能会写成下面这样：</p>\n<ul>\n<li>“modules/dom/XXX/aaa.js” *</li>\n</ul>\n<p>如果每次为了加载一个模块都要这样去写的话，第一我们还要记住模块所在路径，如果记不住的话还要去查看，很影响开发效率，第二写起来总是感觉很不爽，代码看着很恶心，那么我们如何解决这个问题呢？这就要讲到requirejs的配置了，requirejs有一个config函数，接受一个json对象，设置一些配置选项，我们修改config.js如下：</p>\n<pre><code>requirejs.config({\n    paths : {\n        a : &#39;js/a&#39;,\n        b : &#39;js/b&#39;\n    }\n});\n\n\nrequire([&#39;a&#39;, &#39;b&#39;], function(A, B){\n    console.log(A);\n    console.log(B);\n});\n</code></pre><p>首先我们在使用require()函数去加载模块之前，我们使用requirejs.config()方法去对requirejs进行配置，requirejs.config方法接收一个对象，对象中有一个paths配置项，顾名思义，这是一项路径配置，再看下面使用require()函数去加载模块时，我们直接去加载a和b，这样是可以正常加载模块的，因为在加载a模块的时候，requirejs发现在paths中配置的路径中a对应“js/a”，所以，require会自动去加载js/a模块，而不是在index.html同级目录下去找，所以paths配置就像一个路由，刷新页面，查看控制台中的输出，我们等待片刻会发现，如下图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201511146.pic.jpg\" alt=\"加载超时\"></p>\n<p>什么？加载超时？什么情况？别紧张，还记我们的b.js中吗？我们在b.js中依赖了a.js，可是我们的代码是怎么依赖的呢？打开b.js：</p>\n<pre><code>define([&#39;js/a&#39;], function(A){\n\n    var b = {\n        content : &#39;b.js&#39;\n    }\n\n    return b;\n\n});\n</code></pre><p>我们发现，我们依赖a，模块的时候依然使用’js/a’进行依赖，而当requirejs在解析’js/a’的时候，发现有一个’a’，然后又再paths配置中发现’a’对应’js/a’,于是，requirejs就把’a’换成了’js/a’，所以整体的’js/a’最终被换成了’js/js/a’，然后又再路径中发现了a，于是加载路径又被替换成了’js/js/js/a’，如此下去，最终成了死循环，而超过一定的时间之后，就会报错加载超时，明白了吧，所以，我们把b.js中依赖a.js的字符创直接写成’a’就可以了，如下：</p>\n<pre><code>define([&#39;a&#39;], function(A){\n\n    var b = {\n        content : &#39;b.js&#39;\n    }\n\n    return b;\n\n});\n</code></pre><p>再次刷新浏览器，怎么样？正常加载了吧？这样以后我们只要需要依赖a模块，我们就直接写’a’就可以了：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201511147.pic.jpg\" alt=\"正常加载\"></p>\n<p>那么好，a.js和b.js我们都改成了模块的编写方式，并且也做了paths配置，最终也成功加载了，但是我们还遗漏了一个东西，就是jQuery这个第三方库，那么requirejs能够加载第三方库吗？答案是：只要第三方库提供了AMD接口，那么requirejs就可以加载，而jQuery本身也提供了这个接口，所以我们直接加载就好了，为了方便，我们依然在paths中配置一下：</p>\n<pre><code>requirejs.config({\n    paths : {\n        a : &#39;js/a&#39;,\n        b : &#39;js/b&#39;,\n        $ : &#39;js/jquery.min&#39;\n    }\n});\n</code></pre><p>然后在config中去加载jQuery并试着使用jQuery，看看能不能正常使用，修改我们的config.js如下：</p>\n<pre><code>requirejs.config({\n    paths : {\n        a : &#39;js/a&#39;,\n        b : &#39;js/b&#39;,\n        jquery : &#39;js/jquery.min&#39;\n    }\n});\n\nrequire([&#39;a&#39;, &#39;b&#39;, &#39;jquery&#39;], function(A, B, $){\n    alert($(&#39;html&#39;).html());\n    console.log(A);\n    console.log(B);\n});\n</code></pre><p>刷新页面：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201511148.pic.jpg\" alt=\"第三方库加载成功\"></p>\n<p>弹出弹窗，证明我们加载jQuery成功并成功使用。</p>\n<p>下面我们再来思考一个问题，我们为什么能够直接通过requirejs加载jQuery？是因为jQuery这个第三方库提供了AMD支持，可是并不是所有第三方库都提供了AMD支持，那么require就不能加载那些第三方库了吗？答案是：依然能够加载。不过，这就涉及到如何加载非AMD模块写法的模块了，假设我们有一个模块c，但是c.js并没有按照AMD规范封装为一个模块，我们在js文件加下创建c.js，并写下如下代码：</p>\n<pre><code>var show = function(){\n    alert(&#39;调用了c&#39;);\n}\n</code></pre><p>我们的c.js很简单。只是单纯的定义了一个c函数，并弹出一个提示框，显示“调用了c”，所以这个c.js并不是一个AMD模块，那么如果我们想使用requirejs加载这个c，该如何加载呢？这就要讲到requirejs.config()中的另一个配置项 shim 了，我们已经知道了paths是用来配置加载模块路径的，shim则是用来加载非AMD模块规范的“模块”的，所以，为了加载c.js，我们可以修改config.js并添加shim配置，如下：</p>\n<pre><code>requirejs.config({\n    paths : {\n        a : &#39;js/a&#39;,\n        b : &#39;js/b&#39;,\n        c : &#39;js/c&#39;,\n        jquery : &#39;js/jquery.min&#39;\n    },\n\n    shim : {\n        c : {\n            exports : &#39;show&#39;\n        }\n    }\n});\n\n\nrequire([&#39;a&#39;, &#39;b&#39;, &#39;jquery&#39;, &#39;c&#39;], function(A, B, $, c){\n    console.log(c);\n});\n</code></pre><p>我们添加了shim配置，配置中，c 代表我们在require中引入模块时的名字，即我们可以通过require([‘c’])去引用c模块，c对应一个json对象，对象中有一个exports属性，exports属性的值就是我们要到处的接口，注意，我们依然要在paths中添加模块c的配置，这样才能正常加载模块，最后，我们在控制台中输出了模块c，打开浏览器，刷新：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201511149.pic.jpg\" alt=\"输出模块c\"></p>\n<p>我们看到，打印出来的就是我们的函数show，也就是说我们到处的接口就是show函数，我们可以调用一下试试，修改config.js：</p>\n<pre><code>require([&#39;a&#39;, &#39;b&#39;, &#39;jquery&#39;, &#39;c&#39;], function(A, B, $, c){\n    c();\n});\n</code></pre><p>刷新页面：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/2015111410.pic.jpg\" alt=\"调用了show函数\"></p>\n<p>怎么样，弹出弹窗了吧，实际上，经过shim配置后，requirejs会自动修改c.js为一个AMD模块，为其添加封装代码，如下：</p>\n<pre><code>define(function(){\n    var show = function(){\n        alert(&#39;调用了c&#39;);\n    }    \n\n    return show;\n});\n</code></pre><p>我们看到，return返回的是show函数，是因为我们在shim中为c模块配置的导出接口为show，即exports的值是show，所以加入我们修改exports的值为其他值，是没有办法导出成功的，比如我们修改config.js中c模块的shim配置，如下，我们导出的接口不是show而是随意的aaa:</p>\n<pre><code>shim : {\n    c : {\n        exports : &#39;aaa&#39;\n    }\n}\n</code></pre><p>刷新页面：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/2015111411.pic.jpg\" alt=\"报错\"></p>\n<p>报错，c不是一个函数，为什么呢？因为我们导出的接口是aaa，鬼知道你这个aaa是什么啊。所以最后调用的时候当然会报错。</p>\n<p>我们还可以导出多个接口，比如我们的c.js中有两个函数，分别是show函数和hide函数，修改我们的c.js如下：</p>\n<pre><code>var show = function(){\n    alert(&#39;show函数&#39;);\n}    \n\nvar hide = function(){\n    alert(&#39;hide函数&#39;);\n}\n</code></pre><p>如果我们继续使用上面的shim配置，那么我们将只能导出show函数，没有办法导出hide，如何才能将两个接口都导出来呢？这个时候我们就不能使用exports属性了，我们要用init属性，分别将两个接口导出，修改config.js如下：</p>\n<pre><code>shim : {\n    c : {\n        init : function(){\n            return {\n                aaa : show,\n                bbb : hide\n            }\n        }\n    }\n}\n</code></pre><p>init属性对应一个函数，函数返回一个对象，对象里面对应我们要导出的接口，这样，我们就把两个接口都导出了，我们可以通过模块的aaa调用show函数，模块的bbb调用hide函数，修改config.js去尝试调用一下：</p>\n<pre><code>require([&#39;a&#39;, &#39;b&#39;, &#39;jquery&#39;, &#39;c&#39;], function(A, B, $, c){\n    c.aaa();\n    c.bbb();\n});\n</code></pre><p>打开浏览器刷新，怎么样，两个函数正常调用了吧，不过这里有一个需要注意的地方，init属性对应的函数中，返回的对象里面，show和hide不能用引号引起来，下面的写法是错误的：</p>\n<pre><code>shim : {\n    c : {\n        init : function(){\n            return {\n                aaa : &#39;show&#39;,\n                bbb : &#39;hide&#39;\n            }\n        }\n    }\n}\n</code></pre><p>刷新浏览器会报错，如下图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/2015111412.pic.jpg\" alt=\"加引号后报错\"></p>\n<p>那么为什么会这样呢？实际上，当我们设置了init属性后，requirejs相当于自动为我们封装了c.js如下面这样：</p>\n<pre><code>define(function(){\n    var show = function(){\n        alert(&#39;show函数&#39;);\n    }    \n\n    var hide = function(){\n        alert(&#39;hide函数&#39;);\n    }\n\n    return {\n        aaa : show,\n        bbb : hide\n    }\n});\n</code></pre><p>上面代码中show和hide没有加引号，所以是变量，分别引用上面的show函数和hide函数，如果我们加了引号，requirejs封装之后就会想这样：</p>\n<pre><code>define(function(){\n    var show = function(){\n        alert(&#39;show函数&#39;);\n    }    \n\n    var hide = function(){\n        alert(&#39;hide函数&#39;);\n    }\n\n    return {\n        aaa : &#39;show&#39;,\n        bbb : &#39;hide&#39;\n    }\n});\n</code></pre><p>我们看上面的代码，’show’和’hide’都加了引号，所以他们是字符串，并没有引用上面的show函数和hide函数，只是导出一个字符串而已，所以当我们把字符串当做函数来调用的时候，当然会报错。我们也可以验证这一点，我们就使用带引号的配置，然后打印出c.aaa的类型，如下：</p>\n<pre><code>requirejs.config({\n    paths : {\n        a : &#39;js/a&#39;,\n        b : &#39;js/b&#39;,\n        c : &#39;js/c&#39;,\n        jquery : &#39;js/jquery.min&#39;\n    },\n\n    shim : {\n        c : {\n            init : function(){\n                return {\n                    aaa : &#39;show&#39;,\n                    bbb : &#39;hide&#39;\n                }\n            }\n        }\n    }\n});\n\n\nrequire([&#39;a&#39;, &#39;b&#39;, &#39;jquery&#39;, &#39;c&#39;], function(A, B, $, c){\n    console.log(typeof c.aaa);\n});\n</code></pre><p>刷新浏览器，我们看到，c.aaa的确是一个字符串：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/2015111413.pic.jpg\" alt=\"打印出来的是字符串\"></p>\n<p>另外，我们注意一点，paths里面的配置，路径中都带有’js/‘，如下：</p>\n<pre><code>paths : {\n    a : &#39;js/a&#39;,\n    b : &#39;js/b&#39;,\n    c : &#39;js/c&#39;,\n    jquery : &#39;js/jquery.min&#39;\n}\n</code></pre><p>也就是说我们的模块都放在js目录下，既然这样，我们可不可以通过一个配置，来告诉我们的requirejs，每次查找模块的时候都基于js目录查找呢？这样我们就不用每次编写paths配置的时候都要写上’js/‘了，实际上是可以的，requirejs.config()的配置对象中还有一个 baseUrl 属性，用来制定模块的查找目录，修改配置如下：</p>\n<pre><code>requirejs.config({\n    baseUrl : &#39;./js&#39;,\n    paths : {\n        a : &#39;a&#39;,\n        b : &#39;b&#39;,\n        c : &#39;c&#39;,\n        jquery : &#39;jquery.min&#39;\n    },\n\n    shim : {\n        c : {\n            init : function(){\n                return {\n                    aaa : show,\n                    bbb : hide\n                }\n            }\n        }\n    }\n});\n</code></pre><p>当然，baseUrl本省是基于引入requirejs的html文件所在目录的，在本例中即index.html所在目录的。</p>\n<p>另外，我们发现，当我们配置完baseUrl之后，paths中a、b、c三个模块可以不用配置，因为已经没有什么意义了，但是jquery需要保留，如下：</p>\n<pre><code>requirejs.config({\n    baseUrl : &#39;./js&#39;,\n    paths : {\n        jquery : &#39;jquery.min&#39;\n    },\n\n    shim : {\n        c : {\n            init : function(){\n                return {\n                    aaa : show,\n                    bbb : hide\n                }\n            }\n        }\n    }\n});\n</code></pre><p>这样，当requirejs去加载的a、b、c模块的时候，就自动会根据baseUrl中的配置去查找模块，而我们的三个模块也恰好在js目录下，所以可以不用配置了，总而言之，这是一个很灵好好用的配置，具体根据你的项目来。</p>\n<p>下面，我们在考虑一种情景，假如你的项目很大，在最初阶段，你的项目里引用了jQuery1.x版本，后来随着项目的发展，项目需要引入jQuery2.x的版本，但是又不能删除掉原来的1.x版本，因为项目中有很多模块都在使用1.x的版本，这个时候，我们就希望在某些文件中引入jQuery时使用的1.x版本，而在另外一些文件中使用的是2.x的版本，怎么办呢？有的同学可能会这样想，如下配置：</p>\n<pre><code>requirejs.config({\n    baseUrl : &#39;./js&#39;,\n    paths : {\n        jquery1 : &#39;jquery-1.11.3&#39;\n        jquery2 : &#39;jquery-2.1.4&#39;\n    },\n\n    shim : {\n        c : {\n            init : function(){\n                return {\n                    aaa : show,\n                    bbb : hide\n                }\n            }\n        }\n    }\n});\n</code></pre><p>配置两个jquery，一个jquery1，一个jquery2，分别对应不同的版本，当我们使用1.x版本的时候，就引用’jquery1’，当我们想使用2.x版本的时候就引用’jquery2’，这样看上去好像很合理，试着使用一下，修改config.js中require中的代码如下：</p>\n<pre><code class=\"requirejs.config({\">    baseUrl : &#39;./js&#39;,\n    paths : {\n        jquery1 : &#39;jquery-1.11.3&#39;,\n        jquery2 : &#39;jquery-2.1.4&#39;\n    },\n\n    shim : {\n        c : {\n            init : function(){\n                return {\n                    aaa : show,\n                    bbb : hide\n                }\n            }\n        }\n    }\n});\n\n\nrequire([&#39;jquery1&#39;], function($){\n    alert($(&#39;html&#39;).html());\n});\n</code></pre>\n<p>我们刷新页面，报错了：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/2015111414.pic.jpg\" alt=\"报错\"></p>\n<p>查看报错信息，他说$没有定义，言外之意就是说我们jQuery模块根本没有引入进来，怎么会这样呢？实际上，当我们在paths中配置jquery时，我们不能使用别名，也就是说我们只能使用 jquery 而不能使用 jquery1和jquery2，不信你将requirejs.config()中的paths修改如下：</p>\n<pre><code>paths : {\n    jquery : &#39;jquery-1.11.3&#39;\n}\n</code></pre><p>刷新页面可以正常使用，但是修改成下面这样就不能正常使用：</p>\n<pre><code>paths : {\n    jq : &#39;jquery-1.11.3&#39;\n}\n</code></pre><p>因为你只能用jquery而不能用任何其他别名，为什么这样呢？我们打开jquery的源码，开其中有这么一段代码，如下图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/2015111415.pic.jpg\" alt=\"jQuery源码中对AMD兼容做法\"></p>\n<p>这段代码其实就是jQuery库对AMD模块的兼容做法，我们发现，jQuery去使用define定义模块的时候，他显示的传递了第一个参数，是一个字符串 ‘jquery’，这个参数在我们自己编写的模块中一般是不去手动写死得，一般由构建工具在优化模块时自动填充的，以免模块冲突，因为这个参数代表了模块id，那么jquery为什么要写死呢？</p>\n<p>网上有种说法是出于性能考虑，因为像jQuery这种库我们在项目中使用是很频繁的，很多模块都要依赖这个模块，如果id这个参数不写死得话，意味着我们在依赖jQuery的时候可以随意起名字，而非必须使用 ‘jquery’ ，这样其他模块就可以给jQuery起不同的模块名，这就会导致多次引入jQuery。</p>\n<p>现在，我们知道了为什么我们在paths配置中配置jQuery的时候为什么只能使用 ‘jquery’ 了，我们回到之前的问题，即在不同的模块引入不同版本的jQuery，想一想我们还能这样去配置了嘛：</p>\n<pre><code>paths : {\n    jquery1 : &#39;jquery-1.11.3&#39;,\n    jquery2 : &#39;jquery-2.1.4&#39;\n}\n</code></pre><p>答案是否定的，因为我们只能用 jquery 而不能用 jquery1 或 jquery2，那难道我们这样配置吗？如下：</p>\n<pre><code>paths : {\n    jquery : &#39;jquery-1.11.3&#39;,\n    jquery : &#39;jquery-2.1.4&#39;\n}\n</code></pre><p>简直就是笑话，这样第二个jquery属性会覆盖第一个jquery属性，那怎么办？这就涉及requirejs的另一个配置了，map配置项，map配置项的作用是，在不同的模块中，即js文件中，依赖相同的模块名，缺加载不同的模块。</p>\n<p>我们先在config.js中增加map配置如下：</p>\n<pre><code>requirejs.config({\n    baseUrl : &#39;./js&#39;,\n    paths : {\n        jquery : &#39;jquery-1.11.3&#39;\n    },\n\n    shim : {\n        c : {\n            init : function(){\n                return {\n                    aaa : show,\n                    bbb : hide\n                }\n            }\n        }\n    },\n\n    map : {\n        &#39;a&#39; : {\n            jquery : &#39;jquery-1.11.3&#39;\n        },\n\n        &#39;b&#39; : {\n            jquery : &#39;jquery-2.1.4&#39;\n        }\n    }\n});\n</code></pre><p>我们在map中可以对每一个模块进行配置，上面代码中，我们配置了当在 a 模块中依赖 ‘jquery’ 时，我们加载的是 1.11.3 版本，当我们在 b 模块中依赖 ‘jquery’ 时，我们加载的是 2.1.4 版本。我们可以尝试一下，分别修改a.js和b.js这两个模块，让他们都去依赖jquery，然后分别返回所依赖jquery的版本，如下：</p>\n<p>a.js</p>\n<pre><code>define([&#39;jquery&#39;], function(jquery){\n    var a = {\n        content : $().jquery\n    }\n\n    return a;\n});\n</code></pre><p>b.js</p>\n<pre><code>define([&#39;jquery&#39;], function(jquery){\n    var b = {\n        content : $().jquery\n    }\n\n    return b;\n\n});\n</code></pre><p>然后我们在config.js中打印模块a和b，如下：</p>\n<pre><code>require([&#39;a&#39;, &#39;b&#39;], function(A, B){\n    console.log(&#39;模块a引用的jQuery版本是&#39; + A.content);\n    console.log(&#39;模块b引用的jQuery版本是&#39; + B.content);\n});\n</code></pre><p>刷新浏览器，我们看到如下，的确在不同的文件中依赖了不同版本的jQuery：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/2015111416.pic.jpg\" alt=\"不同文件中依赖了不同版本的jQuery\"></p>\n<p>但是有一点请读者看清楚，在a.js和b.js中我都依赖了jquery，在形式参数中我使用的是jquery，但是在下面我用到的却是(美元符号)，因为笔者在调试过程中，如果形式参数也写成(美元符号)，那么使用(美元符号)参数打印出来的始终都是undefined，但是经过分析的确正常导入模块并且没有报错，我不知道这是什么原因，或者requirejs的BUG，如果读者有知道是什么原因的欢迎在下面评论指针，共同进步。</p>\n<p>这样，requirejs中一些必备且不易理解的配置以及一些遇到的问题和解决方案就讲解的差不多了，其实requirejs中的配置不只这些，读者可以查阅<a href=\"http://www.requirejs.cn/\" target=\"_blank\" rel=\"external\">官方文档</a> 查看其他配置，都比较简单，掌握笔者讲得这些基本够用了。</p>\n<p>下一篇文章我们就来讲一讲如何优化项目的事，包括使用rjs配合gulp构建工具等，如果你觉得对你有帮助，就看看我的话联网祈祷思维的运用吧，如下：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201511122.pic.jpg\" alt=\"支付宝二维码\"></p>"},{"title":"Mac下使用brew安装mongodb","date":"2015-11-21T08:57:48.000Z","_content":"\n> Homebrew是Mac下得套件管理器，类似于Linux系统中的 yum 或者 apt-get ，它能让你的Mac更完美。mongodb则是NOSQL数据库，一种文档数据库，不同于传统的关系型数据库(mysql,orcal等)，这篇文章对brew做了基本介绍并使用brew在Mac下安装mongoddb以及其中的问题和注意事项（笔者笔记）\n\n<!-- more -->\n\n最近工作需要完成的任务比较多，所以前一篇系列博客（基于gulp requirejs rjs的前端自动化构建系列文章）还没完成，先在此插一篇博客，记录一些东西，由于最近在工作中需要针对我们的现有前端框架搭建一套配合输出的后台系统，用来完成前端构建，输出项目等工作，于是准备使用node + express做项目估价，mongodb做持久化，而本篇文章，记录了Mac下使用brew安装mongodb的有关东西。\n\n# Homebrew #\n\n[Homebrew](http://brew.sh/index_zh-cn.html) 是Mac下得软件包管理工具，我们可以用它在我们的Mac下安装软件，卸载软件等。要是用Homebrew，首先我们要在我们的Mac下安装Homebrew，执行下面的命令进行安装：\n\n```\nruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n```\n\nHomebrew的安装很简单，使用一条ruby命令，我们的Mac电脑自带ruby，你可以在终端中试一下：\n\n```\nruby -v\n```\n\n如下，输出ruby的版本：\n\n![Mac终端下查看ruby版本](http://7xlolm.com1.z0.glb.clouddn.com/201511211.pic.jpg)\n\n执行安装命令，安装brew，安装完成后，我们就可以使用brew安装Mac下得软件了，在安装mongodb之前，我们再了解了解brew，首先如何卸载brew?如果你不知道怎么去卸载的话，你可以再次执行一次brew的安装命令，如果你已经安装了brew再次执行安装命令的话，会给你一个提示，告诉你你的系统已经安装过brew了，如果想要重复安装就执行卸载命令，这样，你根据终端的提示执行以下卸载命令就可以了，另外我也把brew的卸载命令贴出来：\n\n```\nruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)\"\n```\n\n其实就是把安装命令中的install改成uninstall就ok了。\n\n下面列出一些brew的常用命令：\n\n1、跟新brew本身\n\n```\nbrew update\n```\n\n2、使用brew安装软件\n\n```\nbrew install soft_name\n// soft_name为你所要安装软件的标志，如使用brew安装git\nbrew install git\n```\n\n3、使用brew卸载软件\n\n```\nbrew uninstall soft_name\n// soft_name为你所要卸载软件的标志，如使用brew卸载git\nbrew uninstall git\n```\n\n4、显示使用brew安装的软件列表\n\n```\nbrew list\n```\n\n5、更新软件\n\n```\nbrew upgrade\t\t// 更新所有使用brew安装的软件\nbrew upgrade git\t// 更新某个使用brew安装的软件\n```\n\n6、查看哪些软件需要更新\n\n```\nbrew outdated\n```\n\n7、查找软件\n\n```\n// 当你记不清软件的名字的时候，你可以使用search，只需要写去几个字母，他就会帮你联想，并把所有可能的结果输出给你\nbrew search \n```\n\n下图为使用brew search gi的输出结果：\n\n![使用brew search gi](http://7xlolm.com1.z0.glb.clouddn.com/201511212.pic_hd.jpg)\n\n8、查看使用brew安装的东西，安装在哪里\n\n```\nbrew --cache\n```\n\n[更多命令](https://github.com/Homebrew/homebrew/blob/master/share/doc/homebrew/FAQ.md)\n\n# 使用brew安装mongodb #\n\n1、有了brew，我们安装mongodb就变得很简单了：\n\n```\nbrew install mongodb\n```\n\n![安装完成](http://7xlolm.com1.z0.glb.clouddn.com/201511213.pic.jpg)\n\n2、之后将我们的mongodb升级一下，确保版本最新的\n\n```\nbrew upgrade mongodb\n```\n\n如果你现在就启动mongo你并不会成功，如下：\n\n```\nFailed to connect to 127.0.0.1:27017, reason: errno:61 Connection refused\n\nError: couldn't connect to server 127.0.0.1:27017 (127.0.0.1), connection attempt failed at src/mongo/shell/mongo.js:146\n\nexception: connect failed\n```\n\n3、在启动mongo之前，我们需要创建一个目录，为mongo默认的数据写入目录\n\n```\nmkdir -p /data/db\n```\n\n4、然后给刚刚创建的目录以可读可写的权限\n\n```\nchown `id -u` /data/db\n```\n\n5、修改目录\n\n```\n// /data/db 目录是mongo的默认目录，如果你想使用其他目录，可以使 --dbpath 参数\nmongo --dbpath dir_name\n// dir_name 为你的目录名字\n```\n\n现在，你可以放心的启动mongodb了，执行下面的命令：\n\n```\nmongod\n```\n\n假如依然包上面那个错误的话，或许你可以试试下面的命令：\n\n```\nbrew services start mongodb\n```\n\n不过，brew services 已经将要废除了，并且已经没有人维护了，具体查看[点击这里](https://github.com/Homebrew/homebrew/issues/30628)\n\n现在如果一切顺利的话应该像下面这样：\n\n![启动mongodb成功](http://7xlolm.com1.z0.glb.clouddn.com/201511214.pic.jpg)\n\n如果有一天你发现你的数据库突然启动不了了，可能是你为正常关闭导致的，你可以删除掉mongod.lock文件，然后重新启动，如果还是不可以，你可以查看一下进程，然后杀掉：\n\n```\nps -aef | grep mongo\n```\n\n如下：\n\n![进程](http://7xlolm.com1.z0.glb.clouddn.com/201512031.pic.jpg)\n\n然后根据进程ID杀掉进程：\n\n```\nsudo kill 6955\n```\n\n重新启动mongodb服务，即可：\n\n```\nmongod\n```\n\n我们可以新开一个终端窗口连接数据库并试着查看所有的数据库：\n\n```\nmongo\n\nshow dbs\n```\n\n![查看数据库](http://7xlolm.com1.z0.glb.clouddn.com/201511215.pic.jpg)\n\n最后，像大家推荐一个连接mongo的客户端可视化工具 [robomongodb](http://www.robomongo.org/)，它是跨平台的工具，我们可以下载Mac版的，安装后打开，界面是这个样子：\n\n![robomongodb界面](http://7xlolm.com1.z0.glb.clouddn.com/201511216.pic.jpg)\n\n点击create按钮，创建新的连接，会弹出一个连接的配置框，里面有一些默认的参数，我们保持默认，直接点击save，再点击connect按钮就好了：\n\n![点击create创建连接](http://7xlolm.com1.z0.glb.clouddn.com/201511217.pic.jpg)\n\n下图是点击connect连接数据库成功后的界面\n\n![点击connect连接数据库](http://7xlolm.com1.z0.glb.clouddn.com/201511218.pic.jpg)\n\n好了，其他的作者还要继续捣鼓捣鼓，大家共勉，努力学习吧骚年。\n\n","source":"_posts/2015/11/21/Mac下使用brew安装mongodb.md","raw":"title: Mac下使用brew安装mongodb\ndate: 2015-11-21 16:57:48\ncategories:\n- WebFrontEnd\ntags:\n- mongodb\n- 数据库\n- brew\n---\n\n> Homebrew是Mac下得套件管理器，类似于Linux系统中的 yum 或者 apt-get ，它能让你的Mac更完美。mongodb则是NOSQL数据库，一种文档数据库，不同于传统的关系型数据库(mysql,orcal等)，这篇文章对brew做了基本介绍并使用brew在Mac下安装mongoddb以及其中的问题和注意事项（笔者笔记）\n\n<!-- more -->\n\n最近工作需要完成的任务比较多，所以前一篇系列博客（基于gulp requirejs rjs的前端自动化构建系列文章）还没完成，先在此插一篇博客，记录一些东西，由于最近在工作中需要针对我们的现有前端框架搭建一套配合输出的后台系统，用来完成前端构建，输出项目等工作，于是准备使用node + express做项目估价，mongodb做持久化，而本篇文章，记录了Mac下使用brew安装mongodb的有关东西。\n\n# Homebrew #\n\n[Homebrew](http://brew.sh/index_zh-cn.html) 是Mac下得软件包管理工具，我们可以用它在我们的Mac下安装软件，卸载软件等。要是用Homebrew，首先我们要在我们的Mac下安装Homebrew，执行下面的命令进行安装：\n\n```\nruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n```\n\nHomebrew的安装很简单，使用一条ruby命令，我们的Mac电脑自带ruby，你可以在终端中试一下：\n\n```\nruby -v\n```\n\n如下，输出ruby的版本：\n\n![Mac终端下查看ruby版本](http://7xlolm.com1.z0.glb.clouddn.com/201511211.pic.jpg)\n\n执行安装命令，安装brew，安装完成后，我们就可以使用brew安装Mac下得软件了，在安装mongodb之前，我们再了解了解brew，首先如何卸载brew?如果你不知道怎么去卸载的话，你可以再次执行一次brew的安装命令，如果你已经安装了brew再次执行安装命令的话，会给你一个提示，告诉你你的系统已经安装过brew了，如果想要重复安装就执行卸载命令，这样，你根据终端的提示执行以下卸载命令就可以了，另外我也把brew的卸载命令贴出来：\n\n```\nruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)\"\n```\n\n其实就是把安装命令中的install改成uninstall就ok了。\n\n下面列出一些brew的常用命令：\n\n1、跟新brew本身\n\n```\nbrew update\n```\n\n2、使用brew安装软件\n\n```\nbrew install soft_name\n// soft_name为你所要安装软件的标志，如使用brew安装git\nbrew install git\n```\n\n3、使用brew卸载软件\n\n```\nbrew uninstall soft_name\n// soft_name为你所要卸载软件的标志，如使用brew卸载git\nbrew uninstall git\n```\n\n4、显示使用brew安装的软件列表\n\n```\nbrew list\n```\n\n5、更新软件\n\n```\nbrew upgrade\t\t// 更新所有使用brew安装的软件\nbrew upgrade git\t// 更新某个使用brew安装的软件\n```\n\n6、查看哪些软件需要更新\n\n```\nbrew outdated\n```\n\n7、查找软件\n\n```\n// 当你记不清软件的名字的时候，你可以使用search，只需要写去几个字母，他就会帮你联想，并把所有可能的结果输出给你\nbrew search \n```\n\n下图为使用brew search gi的输出结果：\n\n![使用brew search gi](http://7xlolm.com1.z0.glb.clouddn.com/201511212.pic_hd.jpg)\n\n8、查看使用brew安装的东西，安装在哪里\n\n```\nbrew --cache\n```\n\n[更多命令](https://github.com/Homebrew/homebrew/blob/master/share/doc/homebrew/FAQ.md)\n\n# 使用brew安装mongodb #\n\n1、有了brew，我们安装mongodb就变得很简单了：\n\n```\nbrew install mongodb\n```\n\n![安装完成](http://7xlolm.com1.z0.glb.clouddn.com/201511213.pic.jpg)\n\n2、之后将我们的mongodb升级一下，确保版本最新的\n\n```\nbrew upgrade mongodb\n```\n\n如果你现在就启动mongo你并不会成功，如下：\n\n```\nFailed to connect to 127.0.0.1:27017, reason: errno:61 Connection refused\n\nError: couldn't connect to server 127.0.0.1:27017 (127.0.0.1), connection attempt failed at src/mongo/shell/mongo.js:146\n\nexception: connect failed\n```\n\n3、在启动mongo之前，我们需要创建一个目录，为mongo默认的数据写入目录\n\n```\nmkdir -p /data/db\n```\n\n4、然后给刚刚创建的目录以可读可写的权限\n\n```\nchown `id -u` /data/db\n```\n\n5、修改目录\n\n```\n// /data/db 目录是mongo的默认目录，如果你想使用其他目录，可以使 --dbpath 参数\nmongo --dbpath dir_name\n// dir_name 为你的目录名字\n```\n\n现在，你可以放心的启动mongodb了，执行下面的命令：\n\n```\nmongod\n```\n\n假如依然包上面那个错误的话，或许你可以试试下面的命令：\n\n```\nbrew services start mongodb\n```\n\n不过，brew services 已经将要废除了，并且已经没有人维护了，具体查看[点击这里](https://github.com/Homebrew/homebrew/issues/30628)\n\n现在如果一切顺利的话应该像下面这样：\n\n![启动mongodb成功](http://7xlolm.com1.z0.glb.clouddn.com/201511214.pic.jpg)\n\n如果有一天你发现你的数据库突然启动不了了，可能是你为正常关闭导致的，你可以删除掉mongod.lock文件，然后重新启动，如果还是不可以，你可以查看一下进程，然后杀掉：\n\n```\nps -aef | grep mongo\n```\n\n如下：\n\n![进程](http://7xlolm.com1.z0.glb.clouddn.com/201512031.pic.jpg)\n\n然后根据进程ID杀掉进程：\n\n```\nsudo kill 6955\n```\n\n重新启动mongodb服务，即可：\n\n```\nmongod\n```\n\n我们可以新开一个终端窗口连接数据库并试着查看所有的数据库：\n\n```\nmongo\n\nshow dbs\n```\n\n![查看数据库](http://7xlolm.com1.z0.glb.clouddn.com/201511215.pic.jpg)\n\n最后，像大家推荐一个连接mongo的客户端可视化工具 [robomongodb](http://www.robomongo.org/)，它是跨平台的工具，我们可以下载Mac版的，安装后打开，界面是这个样子：\n\n![robomongodb界面](http://7xlolm.com1.z0.glb.clouddn.com/201511216.pic.jpg)\n\n点击create按钮，创建新的连接，会弹出一个连接的配置框，里面有一些默认的参数，我们保持默认，直接点击save，再点击connect按钮就好了：\n\n![点击create创建连接](http://7xlolm.com1.z0.glb.clouddn.com/201511217.pic.jpg)\n\n下图是点击connect连接数据库成功后的界面\n\n![点击connect连接数据库](http://7xlolm.com1.z0.glb.clouddn.com/201511218.pic.jpg)\n\n好了，其他的作者还要继续捣鼓捣鼓，大家共勉，努力学习吧骚年。\n\n","slug":"Mac下使用brew安装mongodb","published":1,"updated":"2015-12-03T10:12:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj669fsjs000sewfc39bpkfz3","content":"<blockquote>\n<p>Homebrew是Mac下得套件管理器，类似于Linux系统中的 yum 或者 apt-get ，它能让你的Mac更完美。mongodb则是NOSQL数据库，一种文档数据库，不同于传统的关系型数据库(mysql,orcal等)，这篇文章对brew做了基本介绍并使用brew在Mac下安装mongoddb以及其中的问题和注意事项（笔者笔记）</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>最近工作需要完成的任务比较多，所以前一篇系列博客（基于gulp requirejs rjs的前端自动化构建系列文章）还没完成，先在此插一篇博客，记录一些东西，由于最近在工作中需要针对我们的现有前端框架搭建一套配合输出的后台系统，用来完成前端构建，输出项目等工作，于是准备使用node + express做项目估价，mongodb做持久化，而本篇文章，记录了Mac下使用brew安装mongodb的有关东西。</p>\n<h1 id=\"Homebrew\"><a href=\"#Homebrew\" class=\"headerlink\" title=\"Homebrew\"></a>Homebrew</h1><p><a href=\"http://brew.sh/index_zh-cn.html\" target=\"_blank\" rel=\"external\">Homebrew</a> 是Mac下得软件包管理工具，我们可以用它在我们的Mac下安装软件，卸载软件等。要是用Homebrew，首先我们要在我们的Mac下安装Homebrew，执行下面的命令进行安装：</p>\n<pre><code>ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;\n</code></pre><p>Homebrew的安装很简单，使用一条ruby命令，我们的Mac电脑自带ruby，你可以在终端中试一下：</p>\n<pre><code>ruby -v\n</code></pre><p>如下，输出ruby的版本：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201511211.pic.jpg\" alt=\"Mac终端下查看ruby版本\"></p>\n<p>执行安装命令，安装brew，安装完成后，我们就可以使用brew安装Mac下得软件了，在安装mongodb之前，我们再了解了解brew，首先如何卸载brew?如果你不知道怎么去卸载的话，你可以再次执行一次brew的安装命令，如果你已经安装了brew再次执行安装命令的话，会给你一个提示，告诉你你的系统已经安装过brew了，如果想要重复安装就执行卸载命令，这样，你根据终端的提示执行以下卸载命令就可以了，另外我也把brew的卸载命令贴出来：</p>\n<pre><code>ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)&quot;\n</code></pre><p>其实就是把安装命令中的install改成uninstall就ok了。</p>\n<p>下面列出一些brew的常用命令：</p>\n<p>1、跟新brew本身</p>\n<pre><code>brew update\n</code></pre><p>2、使用brew安装软件</p>\n<pre><code>brew install soft_name\n// soft_name为你所要安装软件的标志，如使用brew安装git\nbrew install git\n</code></pre><p>3、使用brew卸载软件</p>\n<pre><code>brew uninstall soft_name\n// soft_name为你所要卸载软件的标志，如使用brew卸载git\nbrew uninstall git\n</code></pre><p>4、显示使用brew安装的软件列表</p>\n<pre><code>brew list\n</code></pre><p>5、更新软件</p>\n<pre><code>brew upgrade        // 更新所有使用brew安装的软件\nbrew upgrade git    // 更新某个使用brew安装的软件\n</code></pre><p>6、查看哪些软件需要更新</p>\n<pre><code>brew outdated\n</code></pre><p>7、查找软件</p>\n<pre><code>// 当你记不清软件的名字的时候，你可以使用search，只需要写去几个字母，他就会帮你联想，并把所有可能的结果输出给你\nbrew search\n</code></pre><p>下图为使用brew search gi的输出结果：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201511212.pic_hd.jpg\" alt=\"使用brew search gi\"></p>\n<p>8、查看使用brew安装的东西，安装在哪里</p>\n<pre><code>brew --cache\n</code></pre><p><a href=\"https://github.com/Homebrew/homebrew/blob/master/share/doc/homebrew/FAQ.md\" target=\"_blank\" rel=\"external\">更多命令</a></p>\n<h1 id=\"使用brew安装mongodb\"><a href=\"#使用brew安装mongodb\" class=\"headerlink\" title=\"使用brew安装mongodb\"></a>使用brew安装mongodb</h1><p>1、有了brew，我们安装mongodb就变得很简单了：</p>\n<pre><code>brew install mongodb\n</code></pre><p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201511213.pic.jpg\" alt=\"安装完成\"></p>\n<p>2、之后将我们的mongodb升级一下，确保版本最新的</p>\n<pre><code>brew upgrade mongodb\n</code></pre><p>如果你现在就启动mongo你并不会成功，如下：</p>\n<pre><code>Failed to connect to 127.0.0.1:27017, reason: errno:61 Connection refused\n\nError: couldn&#39;t connect to server 127.0.0.1:27017 (127.0.0.1), connection attempt failed at src/mongo/shell/mongo.js:146\n\nexception: connect failed\n</code></pre><p>3、在启动mongo之前，我们需要创建一个目录，为mongo默认的数据写入目录</p>\n<pre><code>mkdir -p /data/db\n</code></pre><p>4、然后给刚刚创建的目录以可读可写的权限</p>\n<pre><code>chown `id -u` /data/db\n</code></pre><p>5、修改目录</p>\n<pre><code>// /data/db 目录是mongo的默认目录，如果你想使用其他目录，可以使 --dbpath 参数\nmongo --dbpath dir_name\n// dir_name 为你的目录名字\n</code></pre><p>现在，你可以放心的启动mongodb了，执行下面的命令：</p>\n<pre><code>mongod\n</code></pre><p>假如依然包上面那个错误的话，或许你可以试试下面的命令：</p>\n<pre><code>brew services start mongodb\n</code></pre><p>不过，brew services 已经将要废除了，并且已经没有人维护了，具体查看<a href=\"https://github.com/Homebrew/homebrew/issues/30628\" target=\"_blank\" rel=\"external\">点击这里</a></p>\n<p>现在如果一切顺利的话应该像下面这样：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201511214.pic.jpg\" alt=\"启动mongodb成功\"></p>\n<p>如果有一天你发现你的数据库突然启动不了了，可能是你为正常关闭导致的，你可以删除掉mongod.lock文件，然后重新启动，如果还是不可以，你可以查看一下进程，然后杀掉：</p>\n<pre><code>ps -aef | grep mongo\n</code></pre><p>如下：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201512031.pic.jpg\" alt=\"进程\"></p>\n<p>然后根据进程ID杀掉进程：</p>\n<pre><code>sudo kill 6955\n</code></pre><p>重新启动mongodb服务，即可：</p>\n<pre><code>mongod\n</code></pre><p>我们可以新开一个终端窗口连接数据库并试着查看所有的数据库：</p>\n<pre><code>mongo\n\nshow dbs\n</code></pre><p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201511215.pic.jpg\" alt=\"查看数据库\"></p>\n<p>最后，像大家推荐一个连接mongo的客户端可视化工具 <a href=\"http://www.robomongo.org/\" target=\"_blank\" rel=\"external\">robomongodb</a>，它是跨平台的工具，我们可以下载Mac版的，安装后打开，界面是这个样子：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201511216.pic.jpg\" alt=\"robomongodb界面\"></p>\n<p>点击create按钮，创建新的连接，会弹出一个连接的配置框，里面有一些默认的参数，我们保持默认，直接点击save，再点击connect按钮就好了：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201511217.pic.jpg\" alt=\"点击create创建连接\"></p>\n<p>下图是点击connect连接数据库成功后的界面</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201511218.pic.jpg\" alt=\"点击connect连接数据库\"></p>\n<p>好了，其他的作者还要继续捣鼓捣鼓，大家共勉，努力学习吧骚年。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Homebrew是Mac下得套件管理器，类似于Linux系统中的 yum 或者 apt-get ，它能让你的Mac更完美。mongodb则是NOSQL数据库，一种文档数据库，不同于传统的关系型数据库(mysql,orcal等)，这篇文章对brew做了基本介绍并使用brew在Mac下安装mongoddb以及其中的问题和注意事项（笔者笔记）</p>\n</blockquote>","more":"<p>最近工作需要完成的任务比较多，所以前一篇系列博客（基于gulp requirejs rjs的前端自动化构建系列文章）还没完成，先在此插一篇博客，记录一些东西，由于最近在工作中需要针对我们的现有前端框架搭建一套配合输出的后台系统，用来完成前端构建，输出项目等工作，于是准备使用node + express做项目估价，mongodb做持久化，而本篇文章，记录了Mac下使用brew安装mongodb的有关东西。</p>\n<h1 id=\"Homebrew\"><a href=\"#Homebrew\" class=\"headerlink\" title=\"Homebrew\"></a>Homebrew</h1><p><a href=\"http://brew.sh/index_zh-cn.html\" target=\"_blank\" rel=\"external\">Homebrew</a> 是Mac下得软件包管理工具，我们可以用它在我们的Mac下安装软件，卸载软件等。要是用Homebrew，首先我们要在我们的Mac下安装Homebrew，执行下面的命令进行安装：</p>\n<pre><code>ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;\n</code></pre><p>Homebrew的安装很简单，使用一条ruby命令，我们的Mac电脑自带ruby，你可以在终端中试一下：</p>\n<pre><code>ruby -v\n</code></pre><p>如下，输出ruby的版本：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201511211.pic.jpg\" alt=\"Mac终端下查看ruby版本\"></p>\n<p>执行安装命令，安装brew，安装完成后，我们就可以使用brew安装Mac下得软件了，在安装mongodb之前，我们再了解了解brew，首先如何卸载brew?如果你不知道怎么去卸载的话，你可以再次执行一次brew的安装命令，如果你已经安装了brew再次执行安装命令的话，会给你一个提示，告诉你你的系统已经安装过brew了，如果想要重复安装就执行卸载命令，这样，你根据终端的提示执行以下卸载命令就可以了，另外我也把brew的卸载命令贴出来：</p>\n<pre><code>ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)&quot;\n</code></pre><p>其实就是把安装命令中的install改成uninstall就ok了。</p>\n<p>下面列出一些brew的常用命令：</p>\n<p>1、跟新brew本身</p>\n<pre><code>brew update\n</code></pre><p>2、使用brew安装软件</p>\n<pre><code>brew install soft_name\n// soft_name为你所要安装软件的标志，如使用brew安装git\nbrew install git\n</code></pre><p>3、使用brew卸载软件</p>\n<pre><code>brew uninstall soft_name\n// soft_name为你所要卸载软件的标志，如使用brew卸载git\nbrew uninstall git\n</code></pre><p>4、显示使用brew安装的软件列表</p>\n<pre><code>brew list\n</code></pre><p>5、更新软件</p>\n<pre><code>brew upgrade        // 更新所有使用brew安装的软件\nbrew upgrade git    // 更新某个使用brew安装的软件\n</code></pre><p>6、查看哪些软件需要更新</p>\n<pre><code>brew outdated\n</code></pre><p>7、查找软件</p>\n<pre><code>// 当你记不清软件的名字的时候，你可以使用search，只需要写去几个字母，他就会帮你联想，并把所有可能的结果输出给你\nbrew search\n</code></pre><p>下图为使用brew search gi的输出结果：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201511212.pic_hd.jpg\" alt=\"使用brew search gi\"></p>\n<p>8、查看使用brew安装的东西，安装在哪里</p>\n<pre><code>brew --cache\n</code></pre><p><a href=\"https://github.com/Homebrew/homebrew/blob/master/share/doc/homebrew/FAQ.md\" target=\"_blank\" rel=\"external\">更多命令</a></p>\n<h1 id=\"使用brew安装mongodb\"><a href=\"#使用brew安装mongodb\" class=\"headerlink\" title=\"使用brew安装mongodb\"></a>使用brew安装mongodb</h1><p>1、有了brew，我们安装mongodb就变得很简单了：</p>\n<pre><code>brew install mongodb\n</code></pre><p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201511213.pic.jpg\" alt=\"安装完成\"></p>\n<p>2、之后将我们的mongodb升级一下，确保版本最新的</p>\n<pre><code>brew upgrade mongodb\n</code></pre><p>如果你现在就启动mongo你并不会成功，如下：</p>\n<pre><code>Failed to connect to 127.0.0.1:27017, reason: errno:61 Connection refused\n\nError: couldn&#39;t connect to server 127.0.0.1:27017 (127.0.0.1), connection attempt failed at src/mongo/shell/mongo.js:146\n\nexception: connect failed\n</code></pre><p>3、在启动mongo之前，我们需要创建一个目录，为mongo默认的数据写入目录</p>\n<pre><code>mkdir -p /data/db\n</code></pre><p>4、然后给刚刚创建的目录以可读可写的权限</p>\n<pre><code>chown `id -u` /data/db\n</code></pre><p>5、修改目录</p>\n<pre><code>// /data/db 目录是mongo的默认目录，如果你想使用其他目录，可以使 --dbpath 参数\nmongo --dbpath dir_name\n// dir_name 为你的目录名字\n</code></pre><p>现在，你可以放心的启动mongodb了，执行下面的命令：</p>\n<pre><code>mongod\n</code></pre><p>假如依然包上面那个错误的话，或许你可以试试下面的命令：</p>\n<pre><code>brew services start mongodb\n</code></pre><p>不过，brew services 已经将要废除了，并且已经没有人维护了，具体查看<a href=\"https://github.com/Homebrew/homebrew/issues/30628\" target=\"_blank\" rel=\"external\">点击这里</a></p>\n<p>现在如果一切顺利的话应该像下面这样：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201511214.pic.jpg\" alt=\"启动mongodb成功\"></p>\n<p>如果有一天你发现你的数据库突然启动不了了，可能是你为正常关闭导致的，你可以删除掉mongod.lock文件，然后重新启动，如果还是不可以，你可以查看一下进程，然后杀掉：</p>\n<pre><code>ps -aef | grep mongo\n</code></pre><p>如下：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201512031.pic.jpg\" alt=\"进程\"></p>\n<p>然后根据进程ID杀掉进程：</p>\n<pre><code>sudo kill 6955\n</code></pre><p>重新启动mongodb服务，即可：</p>\n<pre><code>mongod\n</code></pre><p>我们可以新开一个终端窗口连接数据库并试着查看所有的数据库：</p>\n<pre><code>mongo\n\nshow dbs\n</code></pre><p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201511215.pic.jpg\" alt=\"查看数据库\"></p>\n<p>最后，像大家推荐一个连接mongo的客户端可视化工具 <a href=\"http://www.robomongo.org/\" target=\"_blank\" rel=\"external\">robomongodb</a>，它是跨平台的工具，我们可以下载Mac版的，安装后打开，界面是这个样子：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201511216.pic.jpg\" alt=\"robomongodb界面\"></p>\n<p>点击create按钮，创建新的连接，会弹出一个连接的配置框，里面有一些默认的参数，我们保持默认，直接点击save，再点击connect按钮就好了：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201511217.pic.jpg\" alt=\"点击create创建连接\"></p>\n<p>下图是点击connect连接数据库成功后的界面</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201511218.pic.jpg\" alt=\"点击connect连接数据库\"></p>\n<p>好了，其他的作者还要继续捣鼓捣鼓，大家共勉，努力学习吧骚年。</p>"},{"title":"a标签的href属性与click事件的烦恼","date":"2015-11-26T13:48:05.000Z","_content":"\n> 最近公司做项目，Hybrid App，我负责首页H5的开发工作，首页是一个常规app的首页，顶部是轮播图，然后是三个按钮，下面是一个列表，列表是a标签，点击a标签会跳转，然而让我长了姿势。。。\n\n<!-- more -->\n\n首先来看一张图，是我们目前开发的app首页：\n\n![app首页，可点击的列表元素](http://7xlolm.com1.z0.glb.clouddn.com/201511271.pic.jpg)\n\n红色区域就是可点击的列表元素，当点击的时候，会通过a标签的href内的连接进行跳转（href属性内的连接不是http协议，是我们自己定义的协议，native端通过截获协议实现native跳转），但是发现很迟钝，即点击之后会有一点延迟才会执行跳转，我的第一反应就是click事件延迟300毫秒的原因，但是当时自己比较low，觉得这是一个a标签，只是简单的加一个href属性，他得跳转我们怎么去控制了，而且这和click貌似没什么关系吧，所以一直这么想当然着。\n\n问题的转机出现在列表页面，列表页面的DOM结构和首页中的列表DOM结构完全一样，但是列表页面点击跳转的反应速度相当的快，这让我们更加不解，后来铁了心的觉得要对比两个文件到底哪里不一样（相当费力），最终，发现列表页面应用了fastclick模块，仅此区别，于是之前的声音又回荡于耳际：“难道a标签的href属性在跳转的时候与click事件有关？”，经过验证的确如此：\n\n## 当点击浏览器a标签的时候，浏览器的默认机制如下： ##\n\n1、触发a的click事件\n2、读取href属性的值\n3、如果是URI则跳转\n4、如果是javascript代码则执行该代码\n\n下面我们一起来做一个实验：\n\n我们在一个html页面中写下如下代码：\n\n```\n<a href=\"http://www.baidu.com\" id=\"a\">这是一个a标签</a>\n```\n\n代码只有一个a标签，接下来我们使用js分别给a标签触发 touchstart、touchend、mousedown、mouseup、click 事件，测试一下能够是a标签跳转的都有哪些事件，我们的js代码如下：\n\n```\n// 事件数组\nvar events = 'touchstart touchend mousedown mouseup click'.split(' ');\nvar n = 0;\n// 开启定时器，每两秒钟为a标签触发相应事件\nvar timer = setInterval(function(){\n    var event = new Event(events[n]);\n    document.getElementById('a').dispatchEvent(event); // 触发事件。\n    console.log(event.type);\n    n++;\n    if (n == events.length) {\n        clearInterval(timer);\n    }\n},2000);\n```\n\n测试结果如下：\n\n![每隔两秒触发一次事件，只有click事件触发时，a标签才会跳转](http://7xlolm.com1.z0.glb.clouddn.com/20151127a.gif)\n\n我们可以看到，在控制台中每隔两秒钟就会打印出当前a标签触发的事件，当最后一个click事件触发时，a标签执行了跳转，跳转到了百度，这也就说明，a标签的跳转只有click事件能够触发，所以当点击a标签，发出请求的时候，浏览器会先去触发a的click事件，我们都知道，click事件在移动端会有300毫秒的延迟，所以这就是首页中列表点击迟钝的原因，而我之前一直认为的是，a标签的跳转与click事件无关。我怎么这么low呢？？？？？？？？？\n\n所以最后：大家以后开发移动端页面的时候，不要觉得你没有显示的去给某个元素绑定click事件就不会存在300毫秒延迟的问题，实际上a标签的跳转也会触发click事件，如果不加处理的话，也会有300毫秒延迟的问题，这对于用户体验是极其不好的。在这个分享给大家，还是那句老话：共勉。\n\n\n\n","source":"_posts/2015/11/26/a标签的href属性与click事件的烦恼.md","raw":"title: a标签的href属性与click事件的烦恼\ndate: 2015-11-26 21:48:05\ncategories:\n- WebFrontEnd\ntags:\n- html\n- js\n---\n\n> 最近公司做项目，Hybrid App，我负责首页H5的开发工作，首页是一个常规app的首页，顶部是轮播图，然后是三个按钮，下面是一个列表，列表是a标签，点击a标签会跳转，然而让我长了姿势。。。\n\n<!-- more -->\n\n首先来看一张图，是我们目前开发的app首页：\n\n![app首页，可点击的列表元素](http://7xlolm.com1.z0.glb.clouddn.com/201511271.pic.jpg)\n\n红色区域就是可点击的列表元素，当点击的时候，会通过a标签的href内的连接进行跳转（href属性内的连接不是http协议，是我们自己定义的协议，native端通过截获协议实现native跳转），但是发现很迟钝，即点击之后会有一点延迟才会执行跳转，我的第一反应就是click事件延迟300毫秒的原因，但是当时自己比较low，觉得这是一个a标签，只是简单的加一个href属性，他得跳转我们怎么去控制了，而且这和click貌似没什么关系吧，所以一直这么想当然着。\n\n问题的转机出现在列表页面，列表页面的DOM结构和首页中的列表DOM结构完全一样，但是列表页面点击跳转的反应速度相当的快，这让我们更加不解，后来铁了心的觉得要对比两个文件到底哪里不一样（相当费力），最终，发现列表页面应用了fastclick模块，仅此区别，于是之前的声音又回荡于耳际：“难道a标签的href属性在跳转的时候与click事件有关？”，经过验证的确如此：\n\n## 当点击浏览器a标签的时候，浏览器的默认机制如下： ##\n\n1、触发a的click事件\n2、读取href属性的值\n3、如果是URI则跳转\n4、如果是javascript代码则执行该代码\n\n下面我们一起来做一个实验：\n\n我们在一个html页面中写下如下代码：\n\n```\n<a href=\"http://www.baidu.com\" id=\"a\">这是一个a标签</a>\n```\n\n代码只有一个a标签，接下来我们使用js分别给a标签触发 touchstart、touchend、mousedown、mouseup、click 事件，测试一下能够是a标签跳转的都有哪些事件，我们的js代码如下：\n\n```\n// 事件数组\nvar events = 'touchstart touchend mousedown mouseup click'.split(' ');\nvar n = 0;\n// 开启定时器，每两秒钟为a标签触发相应事件\nvar timer = setInterval(function(){\n    var event = new Event(events[n]);\n    document.getElementById('a').dispatchEvent(event); // 触发事件。\n    console.log(event.type);\n    n++;\n    if (n == events.length) {\n        clearInterval(timer);\n    }\n},2000);\n```\n\n测试结果如下：\n\n![每隔两秒触发一次事件，只有click事件触发时，a标签才会跳转](http://7xlolm.com1.z0.glb.clouddn.com/20151127a.gif)\n\n我们可以看到，在控制台中每隔两秒钟就会打印出当前a标签触发的事件，当最后一个click事件触发时，a标签执行了跳转，跳转到了百度，这也就说明，a标签的跳转只有click事件能够触发，所以当点击a标签，发出请求的时候，浏览器会先去触发a的click事件，我们都知道，click事件在移动端会有300毫秒的延迟，所以这就是首页中列表点击迟钝的原因，而我之前一直认为的是，a标签的跳转与click事件无关。我怎么这么low呢？？？？？？？？？\n\n所以最后：大家以后开发移动端页面的时候，不要觉得你没有显示的去给某个元素绑定click事件就不会存在300毫秒延迟的问题，实际上a标签的跳转也会触发click事件，如果不加处理的话，也会有300毫秒延迟的问题，这对于用户体验是极其不好的。在这个分享给大家，还是那句老话：共勉。\n\n\n\n","slug":"a标签的href属性与click事件的烦恼","published":1,"updated":"2015-11-27T03:09:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj669fsjv000yewfch8dqtnk1","content":"<blockquote>\n<p>最近公司做项目，Hybrid App，我负责首页H5的开发工作，首页是一个常规app的首页，顶部是轮播图，然后是三个按钮，下面是一个列表，列表是a标签，点击a标签会跳转，然而让我长了姿势。。。</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>首先来看一张图，是我们目前开发的app首页：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201511271.pic.jpg\" alt=\"app首页，可点击的列表元素\"></p>\n<p>红色区域就是可点击的列表元素，当点击的时候，会通过a标签的href内的连接进行跳转（href属性内的连接不是http协议，是我们自己定义的协议，native端通过截获协议实现native跳转），但是发现很迟钝，即点击之后会有一点延迟才会执行跳转，我的第一反应就是click事件延迟300毫秒的原因，但是当时自己比较low，觉得这是一个a标签，只是简单的加一个href属性，他得跳转我们怎么去控制了，而且这和click貌似没什么关系吧，所以一直这么想当然着。</p>\n<p>问题的转机出现在列表页面，列表页面的DOM结构和首页中的列表DOM结构完全一样，但是列表页面点击跳转的反应速度相当的快，这让我们更加不解，后来铁了心的觉得要对比两个文件到底哪里不一样（相当费力），最终，发现列表页面应用了fastclick模块，仅此区别，于是之前的声音又回荡于耳际：“难道a标签的href属性在跳转的时候与click事件有关？”，经过验证的确如此：</p>\n<h2 id=\"当点击浏览器a标签的时候，浏览器的默认机制如下：\"><a href=\"#当点击浏览器a标签的时候，浏览器的默认机制如下：\" class=\"headerlink\" title=\"当点击浏览器a标签的时候，浏览器的默认机制如下：\"></a>当点击浏览器a标签的时候，浏览器的默认机制如下：</h2><p>1、触发a的click事件<br>2、读取href属性的值<br>3、如果是URI则跳转<br>4、如果是javascript代码则执行该代码</p>\n<p>下面我们一起来做一个实验：</p>\n<p>我们在一个html页面中写下如下代码：</p>\n<pre><code>&lt;a href=&quot;http://www.baidu.com&quot; id=&quot;a&quot;&gt;这是一个a标签&lt;/a&gt;\n</code></pre><p>代码只有一个a标签，接下来我们使用js分别给a标签触发 touchstart、touchend、mousedown、mouseup、click 事件，测试一下能够是a标签跳转的都有哪些事件，我们的js代码如下：</p>\n<pre><code>// 事件数组\nvar events = &#39;touchstart touchend mousedown mouseup click&#39;.split(&#39; &#39;);\nvar n = 0;\n// 开启定时器，每两秒钟为a标签触发相应事件\nvar timer = setInterval(function(){\n    var event = new Event(events[n]);\n    document.getElementById(&#39;a&#39;).dispatchEvent(event); // 触发事件。\n    console.log(event.type);\n    n++;\n    if (n == events.length) {\n        clearInterval(timer);\n    }\n},2000);\n</code></pre><p>测试结果如下：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20151127a.gif\" alt=\"每隔两秒触发一次事件，只有click事件触发时，a标签才会跳转\"></p>\n<p>我们可以看到，在控制台中每隔两秒钟就会打印出当前a标签触发的事件，当最后一个click事件触发时，a标签执行了跳转，跳转到了百度，这也就说明，a标签的跳转只有click事件能够触发，所以当点击a标签，发出请求的时候，浏览器会先去触发a的click事件，我们都知道，click事件在移动端会有300毫秒的延迟，所以这就是首页中列表点击迟钝的原因，而我之前一直认为的是，a标签的跳转与click事件无关。我怎么这么low呢？？？？？？？？？</p>\n<p>所以最后：大家以后开发移动端页面的时候，不要觉得你没有显示的去给某个元素绑定click事件就不会存在300毫秒延迟的问题，实际上a标签的跳转也会触发click事件，如果不加处理的话，也会有300毫秒延迟的问题，这对于用户体验是极其不好的。在这个分享给大家，还是那句老话：共勉。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>最近公司做项目，Hybrid App，我负责首页H5的开发工作，首页是一个常规app的首页，顶部是轮播图，然后是三个按钮，下面是一个列表，列表是a标签，点击a标签会跳转，然而让我长了姿势。。。</p>\n</blockquote>","more":"<p>首先来看一张图，是我们目前开发的app首页：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201511271.pic.jpg\" alt=\"app首页，可点击的列表元素\"></p>\n<p>红色区域就是可点击的列表元素，当点击的时候，会通过a标签的href内的连接进行跳转（href属性内的连接不是http协议，是我们自己定义的协议，native端通过截获协议实现native跳转），但是发现很迟钝，即点击之后会有一点延迟才会执行跳转，我的第一反应就是click事件延迟300毫秒的原因，但是当时自己比较low，觉得这是一个a标签，只是简单的加一个href属性，他得跳转我们怎么去控制了，而且这和click貌似没什么关系吧，所以一直这么想当然着。</p>\n<p>问题的转机出现在列表页面，列表页面的DOM结构和首页中的列表DOM结构完全一样，但是列表页面点击跳转的反应速度相当的快，这让我们更加不解，后来铁了心的觉得要对比两个文件到底哪里不一样（相当费力），最终，发现列表页面应用了fastclick模块，仅此区别，于是之前的声音又回荡于耳际：“难道a标签的href属性在跳转的时候与click事件有关？”，经过验证的确如此：</p>\n<h2 id=\"当点击浏览器a标签的时候，浏览器的默认机制如下：\"><a href=\"#当点击浏览器a标签的时候，浏览器的默认机制如下：\" class=\"headerlink\" title=\"当点击浏览器a标签的时候，浏览器的默认机制如下：\"></a>当点击浏览器a标签的时候，浏览器的默认机制如下：</h2><p>1、触发a的click事件<br>2、读取href属性的值<br>3、如果是URI则跳转<br>4、如果是javascript代码则执行该代码</p>\n<p>下面我们一起来做一个实验：</p>\n<p>我们在一个html页面中写下如下代码：</p>\n<pre><code>&lt;a href=&quot;http://www.baidu.com&quot; id=&quot;a&quot;&gt;这是一个a标签&lt;/a&gt;\n</code></pre><p>代码只有一个a标签，接下来我们使用js分别给a标签触发 touchstart、touchend、mousedown、mouseup、click 事件，测试一下能够是a标签跳转的都有哪些事件，我们的js代码如下：</p>\n<pre><code>// 事件数组\nvar events = &#39;touchstart touchend mousedown mouseup click&#39;.split(&#39; &#39;);\nvar n = 0;\n// 开启定时器，每两秒钟为a标签触发相应事件\nvar timer = setInterval(function(){\n    var event = new Event(events[n]);\n    document.getElementById(&#39;a&#39;).dispatchEvent(event); // 触发事件。\n    console.log(event.type);\n    n++;\n    if (n == events.length) {\n        clearInterval(timer);\n    }\n},2000);\n</code></pre><p>测试结果如下：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20151127a.gif\" alt=\"每隔两秒触发一次事件，只有click事件触发时，a标签才会跳转\"></p>\n<p>我们可以看到，在控制台中每隔两秒钟就会打印出当前a标签触发的事件，当最后一个click事件触发时，a标签执行了跳转，跳转到了百度，这也就说明，a标签的跳转只有click事件能够触发，所以当点击a标签，发出请求的时候，浏览器会先去触发a的click事件，我们都知道，click事件在移动端会有300毫秒的延迟，所以这就是首页中列表点击迟钝的原因，而我之前一直认为的是，a标签的跳转与click事件无关。我怎么这么low呢？？？？？？？？？</p>\n<p>所以最后：大家以后开发移动端页面的时候，不要觉得你没有显示的去给某个元素绑定click事件就不会存在300毫秒延迟的问题，实际上a标签的跳转也会触发click事件，如果不加处理的话，也会有300毫秒延迟的问题，这对于用户体验是极其不好的。在这个分享给大家，还是那句老话：共勉。</p>"},{"title":"nodejs使用mongodb做数据持久化","date":"2015-12-02T06:30:47.000Z","_content":"\n>前段时间，写了一篇博客，讲解了在[Mac下使用brew安装mongodb](http://hcysun.me/2015/11/21/Mac%E4%B8%8B%E4%BD%BF%E7%94%A8brew%E5%AE%89%E8%A3%85mongodb/)，这篇文章可以看做是续篇，使用nodejs操作mongodb，并封装一些有用的方法。\n\n<!-- more -->\n\nnodejs操作mongodb，首先要使用npm安装操作mongodb数据库的包，有两个选择 [mongoose](https://www.npmjs.com/package/mongoose) 和 [mongodb](https://www.npmjs.com/package/mongodb)，由于mongodb的使用方式更接近mongodb原生的语法，所以这里我们使用[mongodb](https://www.npmjs.com/package/mongodb)模块，操作数据库。\n\n在[Mac下使用brew安装mongodb](http://hcysun.me/2015/11/21/Mac%E4%B8%8B%E4%BD%BF%E7%94%A8brew%E5%AE%89%E8%A3%85mongodb/)这篇文章中，已经讲解了mongodb数据库的性质和安装，也介绍了一个连接mongodb的客户端工具 Robomongo ，所以这里就不在赘述。\n\n不过，简单介绍下mongodb数据库的语法还是有必要的，如果你已经了解，那么可以跳过这里，接下来，我们就使用原生的语法来做一次CURD操作。\n\n## 1、启动mongodb服务 ##\n\n```\nmongo\n```\n\n在终端执行命令 mongo 就可以启动mongodb服务了，我们会进入到mongo的交互模式，如图：\n\n![启动mongodb服务](http://7xlolm.com1.z0.glb.clouddn.com/201512021.pic.jpg)\n\n我们可以看到，mongo启动后，默认连接的是test数据库，注意，mongodb是非关系型数据库，和MySQL不同，在mongodb中：\n\n```\nnodql       \t<=====>\t\tsql\n数据库(database) <=====> 数据库(database)\n集合(collection) <=====> 表(table)\n文档(docs) \t\t<=====> 行(rows)\n字段(field) \t\t<=====> 列(field)\n```\n\n我们执行下面的命令来查看我们当前操作的数据库：\n\n```\ndb\n```\n\n如下，我们当前操作的数据库是 test 库：\n\n![显示当前我们所操作的数据库](http://7xlolm.com1.z0.glb.clouddn.com/201512026.pic.jpg)\n\n也可以执行下面这条命令来查看所以数据库：\n\n```\nshow dbs\n```\n\n如下图，展示出我们所有的数据库，但是请注意，如果你的数据库里面没有任何数据，是不会被显示出来的：\n\n![显示所有数据库，空数据库没有显示](http://7xlolm.com1.z0.glb.clouddn.com/201512023.pic.jpg)\n\n我们可以使用下面这条命令切换数据库：\n\n```\nuse hcy\n```\n\n这样，我们就切换到了数据库名字为hcy的数据库，我们可以执行 db 命令来查看是否切换成功：\n\n![切换数据库](http://7xlolm.com1.z0.glb.clouddn.com/201512024.pic.jpg)\n\n注意，使用use db_name来切换数据库的时候，如果该数据库不存在，那么会创建该数据库，所以如果你要创建一个数据库，也是用use命令就好啦。\n\n如果要删除一个数据库，我们首先要切换到当前数据库下，然后执行下面的命令就可以删除这个数据库了：\n\n```\nuse hcy\n\ndb.dropDatabase()\n```\n\n这样就会删除hcy这个数据库，我们再来查看所有数据库，发现hcy库已经不见了，被我们删掉了：\n\n![删除数据库](http://7xlolm.com1.z0.glb.clouddn.com/201512025.pic.jpg)\n\n下面，我们讲述最简单的curd操作：\n\n### 1、向hcy数据库中的users集合插入一个文档 ###\n\n标题中的话如果翻译成sql数据库的语言就是：“向hcy数据库中的users表中插入一条数据”，那么我们看看怎么向mongodb数据库的集合中插入文档：\n\n```\nuse hcy\n\ndb.users.insert({\n\tname : 'hcy',\n\tage : 21\n})\n```\n\n首先，我们切换到hcy数据库，如果没有该数据库就会自动创建该数据库，然后执行插入数据操作，我们可以使用下面的命令查询一个集合中的数据：\n\n```\ndb.users.find()\n```\n\n这样会查询出hcy库中users集合下面的所有数据，如果需要条件查找，像下面这条命令，只需要在find()方法中传入一个json对象作为筛选条件即可：\n\n```\ndb.users.find({name:'hcy'})\n```\n\n删除数据：\n\n```\ndb.users.remove()\n```\n\n上面的数据会删除users集合下得所有文档(数据)，也可以传入第一个参数，作为筛选条件：\n\n```\ndb.users.remove({\n\tname : 'hcy'\n})\n```\n\n上面的命令会删除掉users集合中，所有name值为hcy的所有文档，也可以传入第二个参数，是一个boolean值，true为只删除一条：\n\n```\ndb.users.remove({\n\tname : 'hcy'\n}, true)\n```\n\n修改数据有两种方法，可以使用 update()方法，也可以使用save()方法，先来看update()方法:\n\n```\ndb.collection.update(\n   <query>,\n   <update>,\n   {\n     upsert: <boolean>,\n     multi: <boolean>,\n     writeConcern: <document>\n   }\n)\n```\n\n>query : update的查询条件，类似sql update查询内where后面的。\n>update : update的对象和一些更新的操作符（如$,$inc...）等，也可以理解为sql update查询内set后面的\n>upsert : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。\n>multi : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。\n>writeConcern :可选，抛出异常的级别。\n\n这里我只介绍了语法，也可以使用save()方法：\n\n```\ndb.collection.save(\n   <document>,\n   {\n     writeConcern: <document>\n   }\n)\n```\n\n>document : 文档数据。\n>writeConcern :可选，抛出异常的级别。\n\n例子如下：\n\n```\ndb.users.save({\n\t\"_id\" : ObjectId(\"56064f89ade2f21f36b03136\"),\n    \"name\" : \"aaaa\",\n    \"age\" : \"100\"\n})\n```\n\n上面的例子中，我们替换了 _id 为 56064f89ade2f21f36b03136 的文档数据。\n\n如果想了解更多mongodb原生语法知识，[这里](http://www.runoob.com/mongodb/mongodb-tutorial.html)是一个好去处\n\n现在，你应该对mongodb有了一定的了解了，那么我们如何在nodejs中操作mongodb呢？\n\n首先在项目中使用npm安装mongodb模块\n\n```\nnpm install --save mongodb\n```\n\n当我们想要在项目中使用这个模块操作数据库的时候，我们就可以引入该模块\n\n```\nvar MongoClient = require('mongodb').MongoClient;\n```\n\n上面的代码返回一个mongodb客户端实例，连接数据库：\n\n```\nvar mongoConnectUrl = 'mongodb://localhost:27017/hcy';\nMongoClient.connect(mongoConnectUrl, function(err, db){\n\tif(err) return console.log(err);\n\tconsole.log('连接成功');\n});\n```\n\n上面的mongoConnectUrl是我们连接mongodb数据库的一个url，注意，mongodb默认监听的端口是27017，另外，如果始终连接不成功，你可以把localhost换成你电脑的ip地址试一试，笔者在测试的时候只能使用ip地址，使用localhost始终连接失败，在url的最后是你要连接的数据库，这里我们连接到hcy数据库。\n\n连接数据库成功后，我们可以创建一个集合，并操作里面的数据，我们封装一个方法：\n\n## 插入数据 ##\n\n```\n/**\n * 插入数据\n * @method insertData\n * @param {String} mongoConnectUrl 数据库连接\n * @param {String} coll 集合名称\n * @param {Array} data 插入的数据\n * @param {Function} callback 回调函数\n * @return {Null}\n *\n */\nfunction insertData(mongoConnectUrl, coll, data, callback){\n\tMongoClient.connect(mongoConnectUrl, function(err, db){\n\t\tif(err) return console.log(err);\n\t\t// 打开集合\n\t\tvar collection = db.collection(coll);\n\t\t// 插入数据\n\t\tcollection.insertMany(data, function(err, result){\n\t\t\t//console.log(result)\n\t\t\t// 记得要关闭数据库\n\t\t\tdb.close();\n\t\t\tcallback(result);\n\t\t});\n\n\t});\n}\n```\n\n## 查询数据 ##\n\n```\n/**\n * 查询数据\n * @method findData\n * @param {String} mongoConnectUrl 数据库连接\n * @param {String} coll 集合名称\n * @param {Object} opation 条件\n * @param {Function} callback 回调函数\n * @return {Null}\n *\n */\nfunction findData(mongoConnectUrl, coll, opation, callback){\n\tMongoClient.connect(mongoConnectUrl, function(err, db){\n\t\tif(err) return console.log(err);\n\t\t// 打开集合\n\t\tvar collection = db.collection(coll);\n\t\t// 根据条件查询数据\n\t\tvar userData = collection.find(opation);\n\t\t// 遍历数据\n\t\tuserData.toArray(function(err2, docs) {\n\t\t\t// docs是查询出来的文档，json对象，可以打印出来看看\n\t\t\tdb.close();\n\t\t\tcallback(docs);\n\t\t});\n\n\t});\n}\n```\n\n## 删除数据 ##\n\n```\n/**\n * @method deleteData\n * @param {String} mongoConnectUrl 数据库连接\n * @param {String} coll 集合名称\n * @param {Object} opation 条件\n * @param {Number} num 删除数据的数量，即删除几条\n * @return {Null}\n *\n */\nfunction deleteData(mongoConnectUrl, coll, opation, num, callback){\n\tvar i = num;\n\tvar res = [];\n\tvar tempRes = [];\n\tvar thisFn = arguments.callee;\n\tMongoClient.connect(mongoConnectUrl, function(err, db){\n\t\tif(err) return console.log(err);\n\n\t\tvar collection = db.collection(coll);\n\t\tif(i > 0){\n\t\t\ti--;\n\t\t\tcollection.deleteOne(opation, function(err, result){\n\t\t\t\t// console.log(result)\n\t\t\t\tres.push(result);\n\t\t\t\tthisFn(mongoConnectUrl, coll, opation, i, callback);\n\t\t\t\tif(i == 0){\n\t\t\t\t\tdb.close();\n\t\t\t\t\ttempRes = res;\n\t\t\t\t\tres = []\n\t\t\t\t\ti = 0;\n\t\t\t\t\tcallback(tempRes);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t});\n\t\t}\n\n\t});\n},\n```\n\n## 修改一条数据 ##\n\n```\n/**\n * @method deleteData\n * @param {String} mongoConnectUrl 数据库连接\n * @param {String} coll 集合名称\n * @param {Object} opation 条件\n * @param {Object} data 更新的数据\n * @return {Null}\n *\n */\nfunction deleteData(mongoConnectUrl, coll, opation, data, callback){\n\tMongoClient.connect(mongoConnectUrl, function(err, db){\n\t\tif(err) return console.log(err);\n\n\t\tvar collection = db.collection(coll);\n\t\t\n\t\tcollection.updateOne(opation, { $set: data }, function(err, result) {\n\t\t\tdb.close();\n\t\t\tcallback(result);\n\t\t});\n\n\t});\n},\n```\n\n\n\n\n\n\n","source":"_posts/2015/12/02/nodejs使用mongodb做数据持久化.md","raw":"title: nodejs使用mongodb做数据持久化\ndate: 2015-12-02 14:30:47\ncategories:\n- WebFrontEnd\ntags:\n- mongodb\n- nodejs\n---\n\n>前段时间，写了一篇博客，讲解了在[Mac下使用brew安装mongodb](http://hcysun.me/2015/11/21/Mac%E4%B8%8B%E4%BD%BF%E7%94%A8brew%E5%AE%89%E8%A3%85mongodb/)，这篇文章可以看做是续篇，使用nodejs操作mongodb，并封装一些有用的方法。\n\n<!-- more -->\n\nnodejs操作mongodb，首先要使用npm安装操作mongodb数据库的包，有两个选择 [mongoose](https://www.npmjs.com/package/mongoose) 和 [mongodb](https://www.npmjs.com/package/mongodb)，由于mongodb的使用方式更接近mongodb原生的语法，所以这里我们使用[mongodb](https://www.npmjs.com/package/mongodb)模块，操作数据库。\n\n在[Mac下使用brew安装mongodb](http://hcysun.me/2015/11/21/Mac%E4%B8%8B%E4%BD%BF%E7%94%A8brew%E5%AE%89%E8%A3%85mongodb/)这篇文章中，已经讲解了mongodb数据库的性质和安装，也介绍了一个连接mongodb的客户端工具 Robomongo ，所以这里就不在赘述。\n\n不过，简单介绍下mongodb数据库的语法还是有必要的，如果你已经了解，那么可以跳过这里，接下来，我们就使用原生的语法来做一次CURD操作。\n\n## 1、启动mongodb服务 ##\n\n```\nmongo\n```\n\n在终端执行命令 mongo 就可以启动mongodb服务了，我们会进入到mongo的交互模式，如图：\n\n![启动mongodb服务](http://7xlolm.com1.z0.glb.clouddn.com/201512021.pic.jpg)\n\n我们可以看到，mongo启动后，默认连接的是test数据库，注意，mongodb是非关系型数据库，和MySQL不同，在mongodb中：\n\n```\nnodql       \t<=====>\t\tsql\n数据库(database) <=====> 数据库(database)\n集合(collection) <=====> 表(table)\n文档(docs) \t\t<=====> 行(rows)\n字段(field) \t\t<=====> 列(field)\n```\n\n我们执行下面的命令来查看我们当前操作的数据库：\n\n```\ndb\n```\n\n如下，我们当前操作的数据库是 test 库：\n\n![显示当前我们所操作的数据库](http://7xlolm.com1.z0.glb.clouddn.com/201512026.pic.jpg)\n\n也可以执行下面这条命令来查看所以数据库：\n\n```\nshow dbs\n```\n\n如下图，展示出我们所有的数据库，但是请注意，如果你的数据库里面没有任何数据，是不会被显示出来的：\n\n![显示所有数据库，空数据库没有显示](http://7xlolm.com1.z0.glb.clouddn.com/201512023.pic.jpg)\n\n我们可以使用下面这条命令切换数据库：\n\n```\nuse hcy\n```\n\n这样，我们就切换到了数据库名字为hcy的数据库，我们可以执行 db 命令来查看是否切换成功：\n\n![切换数据库](http://7xlolm.com1.z0.glb.clouddn.com/201512024.pic.jpg)\n\n注意，使用use db_name来切换数据库的时候，如果该数据库不存在，那么会创建该数据库，所以如果你要创建一个数据库，也是用use命令就好啦。\n\n如果要删除一个数据库，我们首先要切换到当前数据库下，然后执行下面的命令就可以删除这个数据库了：\n\n```\nuse hcy\n\ndb.dropDatabase()\n```\n\n这样就会删除hcy这个数据库，我们再来查看所有数据库，发现hcy库已经不见了，被我们删掉了：\n\n![删除数据库](http://7xlolm.com1.z0.glb.clouddn.com/201512025.pic.jpg)\n\n下面，我们讲述最简单的curd操作：\n\n### 1、向hcy数据库中的users集合插入一个文档 ###\n\n标题中的话如果翻译成sql数据库的语言就是：“向hcy数据库中的users表中插入一条数据”，那么我们看看怎么向mongodb数据库的集合中插入文档：\n\n```\nuse hcy\n\ndb.users.insert({\n\tname : 'hcy',\n\tage : 21\n})\n```\n\n首先，我们切换到hcy数据库，如果没有该数据库就会自动创建该数据库，然后执行插入数据操作，我们可以使用下面的命令查询一个集合中的数据：\n\n```\ndb.users.find()\n```\n\n这样会查询出hcy库中users集合下面的所有数据，如果需要条件查找，像下面这条命令，只需要在find()方法中传入一个json对象作为筛选条件即可：\n\n```\ndb.users.find({name:'hcy'})\n```\n\n删除数据：\n\n```\ndb.users.remove()\n```\n\n上面的数据会删除users集合下得所有文档(数据)，也可以传入第一个参数，作为筛选条件：\n\n```\ndb.users.remove({\n\tname : 'hcy'\n})\n```\n\n上面的命令会删除掉users集合中，所有name值为hcy的所有文档，也可以传入第二个参数，是一个boolean值，true为只删除一条：\n\n```\ndb.users.remove({\n\tname : 'hcy'\n}, true)\n```\n\n修改数据有两种方法，可以使用 update()方法，也可以使用save()方法，先来看update()方法:\n\n```\ndb.collection.update(\n   <query>,\n   <update>,\n   {\n     upsert: <boolean>,\n     multi: <boolean>,\n     writeConcern: <document>\n   }\n)\n```\n\n>query : update的查询条件，类似sql update查询内where后面的。\n>update : update的对象和一些更新的操作符（如$,$inc...）等，也可以理解为sql update查询内set后面的\n>upsert : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。\n>multi : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。\n>writeConcern :可选，抛出异常的级别。\n\n这里我只介绍了语法，也可以使用save()方法：\n\n```\ndb.collection.save(\n   <document>,\n   {\n     writeConcern: <document>\n   }\n)\n```\n\n>document : 文档数据。\n>writeConcern :可选，抛出异常的级别。\n\n例子如下：\n\n```\ndb.users.save({\n\t\"_id\" : ObjectId(\"56064f89ade2f21f36b03136\"),\n    \"name\" : \"aaaa\",\n    \"age\" : \"100\"\n})\n```\n\n上面的例子中，我们替换了 _id 为 56064f89ade2f21f36b03136 的文档数据。\n\n如果想了解更多mongodb原生语法知识，[这里](http://www.runoob.com/mongodb/mongodb-tutorial.html)是一个好去处\n\n现在，你应该对mongodb有了一定的了解了，那么我们如何在nodejs中操作mongodb呢？\n\n首先在项目中使用npm安装mongodb模块\n\n```\nnpm install --save mongodb\n```\n\n当我们想要在项目中使用这个模块操作数据库的时候，我们就可以引入该模块\n\n```\nvar MongoClient = require('mongodb').MongoClient;\n```\n\n上面的代码返回一个mongodb客户端实例，连接数据库：\n\n```\nvar mongoConnectUrl = 'mongodb://localhost:27017/hcy';\nMongoClient.connect(mongoConnectUrl, function(err, db){\n\tif(err) return console.log(err);\n\tconsole.log('连接成功');\n});\n```\n\n上面的mongoConnectUrl是我们连接mongodb数据库的一个url，注意，mongodb默认监听的端口是27017，另外，如果始终连接不成功，你可以把localhost换成你电脑的ip地址试一试，笔者在测试的时候只能使用ip地址，使用localhost始终连接失败，在url的最后是你要连接的数据库，这里我们连接到hcy数据库。\n\n连接数据库成功后，我们可以创建一个集合，并操作里面的数据，我们封装一个方法：\n\n## 插入数据 ##\n\n```\n/**\n * 插入数据\n * @method insertData\n * @param {String} mongoConnectUrl 数据库连接\n * @param {String} coll 集合名称\n * @param {Array} data 插入的数据\n * @param {Function} callback 回调函数\n * @return {Null}\n *\n */\nfunction insertData(mongoConnectUrl, coll, data, callback){\n\tMongoClient.connect(mongoConnectUrl, function(err, db){\n\t\tif(err) return console.log(err);\n\t\t// 打开集合\n\t\tvar collection = db.collection(coll);\n\t\t// 插入数据\n\t\tcollection.insertMany(data, function(err, result){\n\t\t\t//console.log(result)\n\t\t\t// 记得要关闭数据库\n\t\t\tdb.close();\n\t\t\tcallback(result);\n\t\t});\n\n\t});\n}\n```\n\n## 查询数据 ##\n\n```\n/**\n * 查询数据\n * @method findData\n * @param {String} mongoConnectUrl 数据库连接\n * @param {String} coll 集合名称\n * @param {Object} opation 条件\n * @param {Function} callback 回调函数\n * @return {Null}\n *\n */\nfunction findData(mongoConnectUrl, coll, opation, callback){\n\tMongoClient.connect(mongoConnectUrl, function(err, db){\n\t\tif(err) return console.log(err);\n\t\t// 打开集合\n\t\tvar collection = db.collection(coll);\n\t\t// 根据条件查询数据\n\t\tvar userData = collection.find(opation);\n\t\t// 遍历数据\n\t\tuserData.toArray(function(err2, docs) {\n\t\t\t// docs是查询出来的文档，json对象，可以打印出来看看\n\t\t\tdb.close();\n\t\t\tcallback(docs);\n\t\t});\n\n\t});\n}\n```\n\n## 删除数据 ##\n\n```\n/**\n * @method deleteData\n * @param {String} mongoConnectUrl 数据库连接\n * @param {String} coll 集合名称\n * @param {Object} opation 条件\n * @param {Number} num 删除数据的数量，即删除几条\n * @return {Null}\n *\n */\nfunction deleteData(mongoConnectUrl, coll, opation, num, callback){\n\tvar i = num;\n\tvar res = [];\n\tvar tempRes = [];\n\tvar thisFn = arguments.callee;\n\tMongoClient.connect(mongoConnectUrl, function(err, db){\n\t\tif(err) return console.log(err);\n\n\t\tvar collection = db.collection(coll);\n\t\tif(i > 0){\n\t\t\ti--;\n\t\t\tcollection.deleteOne(opation, function(err, result){\n\t\t\t\t// console.log(result)\n\t\t\t\tres.push(result);\n\t\t\t\tthisFn(mongoConnectUrl, coll, opation, i, callback);\n\t\t\t\tif(i == 0){\n\t\t\t\t\tdb.close();\n\t\t\t\t\ttempRes = res;\n\t\t\t\t\tres = []\n\t\t\t\t\ti = 0;\n\t\t\t\t\tcallback(tempRes);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t});\n\t\t}\n\n\t});\n},\n```\n\n## 修改一条数据 ##\n\n```\n/**\n * @method deleteData\n * @param {String} mongoConnectUrl 数据库连接\n * @param {String} coll 集合名称\n * @param {Object} opation 条件\n * @param {Object} data 更新的数据\n * @return {Null}\n *\n */\nfunction deleteData(mongoConnectUrl, coll, opation, data, callback){\n\tMongoClient.connect(mongoConnectUrl, function(err, db){\n\t\tif(err) return console.log(err);\n\n\t\tvar collection = db.collection(coll);\n\t\t\n\t\tcollection.updateOne(opation, { $set: data }, function(err, result) {\n\t\t\tdb.close();\n\t\t\tcallback(result);\n\t\t});\n\n\t});\n},\n```\n\n\n\n\n\n\n","slug":"nodejs使用mongodb做数据持久化","published":1,"updated":"2015-12-02T08:59:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj669fsjw0012ewfc9g70auhx","content":"<blockquote>\n<p>前段时间，写了一篇博客，讲解了在<a href=\"http://hcysun.me/2015/11/21/Mac%E4%B8%8B%E4%BD%BF%E7%94%A8brew%E5%AE%89%E8%A3%85mongodb/\">Mac下使用brew安装mongodb</a>，这篇文章可以看做是续篇，使用nodejs操作mongodb，并封装一些有用的方法。</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>nodejs操作mongodb，首先要使用npm安装操作mongodb数据库的包，有两个选择 <a href=\"https://www.npmjs.com/package/mongoose\" target=\"_blank\" rel=\"external\">mongoose</a> 和 <a href=\"https://www.npmjs.com/package/mongodb\" target=\"_blank\" rel=\"external\">mongodb</a>，由于mongodb的使用方式更接近mongodb原生的语法，所以这里我们使用<a href=\"https://www.npmjs.com/package/mongodb\" target=\"_blank\" rel=\"external\">mongodb</a>模块，操作数据库。</p>\n<p>在<a href=\"http://hcysun.me/2015/11/21/Mac%E4%B8%8B%E4%BD%BF%E7%94%A8brew%E5%AE%89%E8%A3%85mongodb/\">Mac下使用brew安装mongodb</a>这篇文章中，已经讲解了mongodb数据库的性质和安装，也介绍了一个连接mongodb的客户端工具 Robomongo ，所以这里就不在赘述。</p>\n<p>不过，简单介绍下mongodb数据库的语法还是有必要的，如果你已经了解，那么可以跳过这里，接下来，我们就使用原生的语法来做一次CURD操作。</p>\n<h2 id=\"1、启动mongodb服务\"><a href=\"#1、启动mongodb服务\" class=\"headerlink\" title=\"1、启动mongodb服务\"></a>1、启动mongodb服务</h2><pre><code>mongo\n</code></pre><p>在终端执行命令 mongo 就可以启动mongodb服务了，我们会进入到mongo的交互模式，如图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201512021.pic.jpg\" alt=\"启动mongodb服务\"></p>\n<p>我们可以看到，mongo启动后，默认连接的是test数据库，注意，mongodb是非关系型数据库，和MySQL不同，在mongodb中：</p>\n<pre><code>nodql           &lt;=====&gt;        sql\n数据库(database) &lt;=====&gt; 数据库(database)\n集合(collection) &lt;=====&gt; 表(table)\n文档(docs)         &lt;=====&gt; 行(rows)\n字段(field)         &lt;=====&gt; 列(field)\n</code></pre><p>我们执行下面的命令来查看我们当前操作的数据库：</p>\n<pre><code>db\n</code></pre><p>如下，我们当前操作的数据库是 test 库：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201512026.pic.jpg\" alt=\"显示当前我们所操作的数据库\"></p>\n<p>也可以执行下面这条命令来查看所以数据库：</p>\n<pre><code>show dbs\n</code></pre><p>如下图，展示出我们所有的数据库，但是请注意，如果你的数据库里面没有任何数据，是不会被显示出来的：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201512023.pic.jpg\" alt=\"显示所有数据库，空数据库没有显示\"></p>\n<p>我们可以使用下面这条命令切换数据库：</p>\n<pre><code>use hcy\n</code></pre><p>这样，我们就切换到了数据库名字为hcy的数据库，我们可以执行 db 命令来查看是否切换成功：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201512024.pic.jpg\" alt=\"切换数据库\"></p>\n<p>注意，使用use db_name来切换数据库的时候，如果该数据库不存在，那么会创建该数据库，所以如果你要创建一个数据库，也是用use命令就好啦。</p>\n<p>如果要删除一个数据库，我们首先要切换到当前数据库下，然后执行下面的命令就可以删除这个数据库了：</p>\n<pre><code>use hcy\n\ndb.dropDatabase()\n</code></pre><p>这样就会删除hcy这个数据库，我们再来查看所有数据库，发现hcy库已经不见了，被我们删掉了：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201512025.pic.jpg\" alt=\"删除数据库\"></p>\n<p>下面，我们讲述最简单的curd操作：</p>\n<h3 id=\"1、向hcy数据库中的users集合插入一个文档\"><a href=\"#1、向hcy数据库中的users集合插入一个文档\" class=\"headerlink\" title=\"1、向hcy数据库中的users集合插入一个文档\"></a>1、向hcy数据库中的users集合插入一个文档</h3><p>标题中的话如果翻译成sql数据库的语言就是：“向hcy数据库中的users表中插入一条数据”，那么我们看看怎么向mongodb数据库的集合中插入文档：</p>\n<pre><code>use hcy\n\ndb.users.insert({\n    name : &#39;hcy&#39;,\n    age : 21\n})\n</code></pre><p>首先，我们切换到hcy数据库，如果没有该数据库就会自动创建该数据库，然后执行插入数据操作，我们可以使用下面的命令查询一个集合中的数据：</p>\n<pre><code>db.users.find()\n</code></pre><p>这样会查询出hcy库中users集合下面的所有数据，如果需要条件查找，像下面这条命令，只需要在find()方法中传入一个json对象作为筛选条件即可：</p>\n<pre><code>db.users.find({name:&#39;hcy&#39;})\n</code></pre><p>删除数据：</p>\n<pre><code>db.users.remove()\n</code></pre><p>上面的数据会删除users集合下得所有文档(数据)，也可以传入第一个参数，作为筛选条件：</p>\n<pre><code>db.users.remove({\n    name : &#39;hcy&#39;\n})\n</code></pre><p>上面的命令会删除掉users集合中，所有name值为hcy的所有文档，也可以传入第二个参数，是一个boolean值，true为只删除一条：</p>\n<pre><code>db.users.remove({\n    name : &#39;hcy&#39;\n}, true)\n</code></pre><p>修改数据有两种方法，可以使用 update()方法，也可以使用save()方法，先来看update()方法:</p>\n<pre><code>db.collection.update(\n   &lt;query&gt;,\n   &lt;update&gt;,\n   {\n     upsert: &lt;boolean&gt;,\n     multi: &lt;boolean&gt;,\n     writeConcern: &lt;document&gt;\n   }\n)\n</code></pre><blockquote>\n<p>query : update的查询条件，类似sql update查询内where后面的。<br>update : update的对象和一些更新的操作符（如$,$inc…）等，也可以理解为sql update查询内set后面的<br>upsert : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。<br>multi : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。<br>writeConcern :可选，抛出异常的级别。</p>\n</blockquote>\n<p>这里我只介绍了语法，也可以使用save()方法：</p>\n<pre><code>db.collection.save(\n   &lt;document&gt;,\n   {\n     writeConcern: &lt;document&gt;\n   }\n)\n</code></pre><blockquote>\n<p>document : 文档数据。<br>writeConcern :可选，抛出异常的级别。</p>\n</blockquote>\n<p>例子如下：</p>\n<pre><code>db.users.save({\n    &quot;_id&quot; : ObjectId(&quot;56064f89ade2f21f36b03136&quot;),\n    &quot;name&quot; : &quot;aaaa&quot;,\n    &quot;age&quot; : &quot;100&quot;\n})\n</code></pre><p>上面的例子中，我们替换了 _id 为 56064f89ade2f21f36b03136 的文档数据。</p>\n<p>如果想了解更多mongodb原生语法知识，<a href=\"http://www.runoob.com/mongodb/mongodb-tutorial.html\" target=\"_blank\" rel=\"external\">这里</a>是一个好去处</p>\n<p>现在，你应该对mongodb有了一定的了解了，那么我们如何在nodejs中操作mongodb呢？</p>\n<p>首先在项目中使用npm安装mongodb模块</p>\n<pre><code>npm install --save mongodb\n</code></pre><p>当我们想要在项目中使用这个模块操作数据库的时候，我们就可以引入该模块</p>\n<pre><code>var MongoClient = require(&#39;mongodb&#39;).MongoClient;\n</code></pre><p>上面的代码返回一个mongodb客户端实例，连接数据库：</p>\n<pre><code>var mongoConnectUrl = &#39;mongodb://localhost:27017/hcy&#39;;\nMongoClient.connect(mongoConnectUrl, function(err, db){\n    if(err) return console.log(err);\n    console.log(&#39;连接成功&#39;);\n});\n</code></pre><p>上面的mongoConnectUrl是我们连接mongodb数据库的一个url，注意，mongodb默认监听的端口是27017，另外，如果始终连接不成功，你可以把localhost换成你电脑的ip地址试一试，笔者在测试的时候只能使用ip地址，使用localhost始终连接失败，在url的最后是你要连接的数据库，这里我们连接到hcy数据库。</p>\n<p>连接数据库成功后，我们可以创建一个集合，并操作里面的数据，我们封装一个方法：</p>\n<h2 id=\"插入数据\"><a href=\"#插入数据\" class=\"headerlink\" title=\"插入数据\"></a>插入数据</h2><pre><code>/**\n * 插入数据\n * @method insertData\n * @param {String} mongoConnectUrl 数据库连接\n * @param {String} coll 集合名称\n * @param {Array} data 插入的数据\n * @param {Function} callback 回调函数\n * @return {Null}\n *\n */\nfunction insertData(mongoConnectUrl, coll, data, callback){\n    MongoClient.connect(mongoConnectUrl, function(err, db){\n        if(err) return console.log(err);\n        // 打开集合\n        var collection = db.collection(coll);\n        // 插入数据\n        collection.insertMany(data, function(err, result){\n            //console.log(result)\n            // 记得要关闭数据库\n            db.close();\n            callback(result);\n        });\n\n    });\n}\n</code></pre><h2 id=\"查询数据\"><a href=\"#查询数据\" class=\"headerlink\" title=\"查询数据\"></a>查询数据</h2><pre><code>/**\n * 查询数据\n * @method findData\n * @param {String} mongoConnectUrl 数据库连接\n * @param {String} coll 集合名称\n * @param {Object} opation 条件\n * @param {Function} callback 回调函数\n * @return {Null}\n *\n */\nfunction findData(mongoConnectUrl, coll, opation, callback){\n    MongoClient.connect(mongoConnectUrl, function(err, db){\n        if(err) return console.log(err);\n        // 打开集合\n        var collection = db.collection(coll);\n        // 根据条件查询数据\n        var userData = collection.find(opation);\n        // 遍历数据\n        userData.toArray(function(err2, docs) {\n            // docs是查询出来的文档，json对象，可以打印出来看看\n            db.close();\n            callback(docs);\n        });\n\n    });\n}\n</code></pre><h2 id=\"删除数据\"><a href=\"#删除数据\" class=\"headerlink\" title=\"删除数据\"></a>删除数据</h2><pre><code>/**\n * @method deleteData\n * @param {String} mongoConnectUrl 数据库连接\n * @param {String} coll 集合名称\n * @param {Object} opation 条件\n * @param {Number} num 删除数据的数量，即删除几条\n * @return {Null}\n *\n */\nfunction deleteData(mongoConnectUrl, coll, opation, num, callback){\n    var i = num;\n    var res = [];\n    var tempRes = [];\n    var thisFn = arguments.callee;\n    MongoClient.connect(mongoConnectUrl, function(err, db){\n        if(err) return console.log(err);\n\n        var collection = db.collection(coll);\n        if(i &gt; 0){\n            i--;\n            collection.deleteOne(opation, function(err, result){\n                // console.log(result)\n                res.push(result);\n                thisFn(mongoConnectUrl, coll, opation, i, callback);\n                if(i == 0){\n                    db.close();\n                    tempRes = res;\n                    res = []\n                    i = 0;\n                    callback(tempRes);\n                }\n\n            });\n        }\n\n    });\n},\n</code></pre><h2 id=\"修改一条数据\"><a href=\"#修改一条数据\" class=\"headerlink\" title=\"修改一条数据\"></a>修改一条数据</h2><pre><code>/**\n * @method deleteData\n * @param {String} mongoConnectUrl 数据库连接\n * @param {String} coll 集合名称\n * @param {Object} opation 条件\n * @param {Object} data 更新的数据\n * @return {Null}\n *\n */\nfunction deleteData(mongoConnectUrl, coll, opation, data, callback){\n    MongoClient.connect(mongoConnectUrl, function(err, db){\n        if(err) return console.log(err);\n\n        var collection = db.collection(coll);\n\n        collection.updateOne(opation, { $set: data }, function(err, result) {\n            db.close();\n            callback(result);\n        });\n\n    });\n},\n</code></pre>","site":{"data":{}},"excerpt":"<blockquote>\n<p>前段时间，写了一篇博客，讲解了在<a href=\"http://hcysun.me/2015/11/21/Mac%E4%B8%8B%E4%BD%BF%E7%94%A8brew%E5%AE%89%E8%A3%85mongodb/\">Mac下使用brew安装mongodb</a>，这篇文章可以看做是续篇，使用nodejs操作mongodb，并封装一些有用的方法。</p>\n</blockquote>","more":"<p>nodejs操作mongodb，首先要使用npm安装操作mongodb数据库的包，有两个选择 <a href=\"https://www.npmjs.com/package/mongoose\" target=\"_blank\" rel=\"external\">mongoose</a> 和 <a href=\"https://www.npmjs.com/package/mongodb\" target=\"_blank\" rel=\"external\">mongodb</a>，由于mongodb的使用方式更接近mongodb原生的语法，所以这里我们使用<a href=\"https://www.npmjs.com/package/mongodb\" target=\"_blank\" rel=\"external\">mongodb</a>模块，操作数据库。</p>\n<p>在<a href=\"http://hcysun.me/2015/11/21/Mac%E4%B8%8B%E4%BD%BF%E7%94%A8brew%E5%AE%89%E8%A3%85mongodb/\">Mac下使用brew安装mongodb</a>这篇文章中，已经讲解了mongodb数据库的性质和安装，也介绍了一个连接mongodb的客户端工具 Robomongo ，所以这里就不在赘述。</p>\n<p>不过，简单介绍下mongodb数据库的语法还是有必要的，如果你已经了解，那么可以跳过这里，接下来，我们就使用原生的语法来做一次CURD操作。</p>\n<h2 id=\"1、启动mongodb服务\"><a href=\"#1、启动mongodb服务\" class=\"headerlink\" title=\"1、启动mongodb服务\"></a>1、启动mongodb服务</h2><pre><code>mongo\n</code></pre><p>在终端执行命令 mongo 就可以启动mongodb服务了，我们会进入到mongo的交互模式，如图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201512021.pic.jpg\" alt=\"启动mongodb服务\"></p>\n<p>我们可以看到，mongo启动后，默认连接的是test数据库，注意，mongodb是非关系型数据库，和MySQL不同，在mongodb中：</p>\n<pre><code>nodql           &lt;=====&gt;        sql\n数据库(database) &lt;=====&gt; 数据库(database)\n集合(collection) &lt;=====&gt; 表(table)\n文档(docs)         &lt;=====&gt; 行(rows)\n字段(field)         &lt;=====&gt; 列(field)\n</code></pre><p>我们执行下面的命令来查看我们当前操作的数据库：</p>\n<pre><code>db\n</code></pre><p>如下，我们当前操作的数据库是 test 库：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201512026.pic.jpg\" alt=\"显示当前我们所操作的数据库\"></p>\n<p>也可以执行下面这条命令来查看所以数据库：</p>\n<pre><code>show dbs\n</code></pre><p>如下图，展示出我们所有的数据库，但是请注意，如果你的数据库里面没有任何数据，是不会被显示出来的：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201512023.pic.jpg\" alt=\"显示所有数据库，空数据库没有显示\"></p>\n<p>我们可以使用下面这条命令切换数据库：</p>\n<pre><code>use hcy\n</code></pre><p>这样，我们就切换到了数据库名字为hcy的数据库，我们可以执行 db 命令来查看是否切换成功：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201512024.pic.jpg\" alt=\"切换数据库\"></p>\n<p>注意，使用use db_name来切换数据库的时候，如果该数据库不存在，那么会创建该数据库，所以如果你要创建一个数据库，也是用use命令就好啦。</p>\n<p>如果要删除一个数据库，我们首先要切换到当前数据库下，然后执行下面的命令就可以删除这个数据库了：</p>\n<pre><code>use hcy\n\ndb.dropDatabase()\n</code></pre><p>这样就会删除hcy这个数据库，我们再来查看所有数据库，发现hcy库已经不见了，被我们删掉了：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201512025.pic.jpg\" alt=\"删除数据库\"></p>\n<p>下面，我们讲述最简单的curd操作：</p>\n<h3 id=\"1、向hcy数据库中的users集合插入一个文档\"><a href=\"#1、向hcy数据库中的users集合插入一个文档\" class=\"headerlink\" title=\"1、向hcy数据库中的users集合插入一个文档\"></a>1、向hcy数据库中的users集合插入一个文档</h3><p>标题中的话如果翻译成sql数据库的语言就是：“向hcy数据库中的users表中插入一条数据”，那么我们看看怎么向mongodb数据库的集合中插入文档：</p>\n<pre><code>use hcy\n\ndb.users.insert({\n    name : &#39;hcy&#39;,\n    age : 21\n})\n</code></pre><p>首先，我们切换到hcy数据库，如果没有该数据库就会自动创建该数据库，然后执行插入数据操作，我们可以使用下面的命令查询一个集合中的数据：</p>\n<pre><code>db.users.find()\n</code></pre><p>这样会查询出hcy库中users集合下面的所有数据，如果需要条件查找，像下面这条命令，只需要在find()方法中传入一个json对象作为筛选条件即可：</p>\n<pre><code>db.users.find({name:&#39;hcy&#39;})\n</code></pre><p>删除数据：</p>\n<pre><code>db.users.remove()\n</code></pre><p>上面的数据会删除users集合下得所有文档(数据)，也可以传入第一个参数，作为筛选条件：</p>\n<pre><code>db.users.remove({\n    name : &#39;hcy&#39;\n})\n</code></pre><p>上面的命令会删除掉users集合中，所有name值为hcy的所有文档，也可以传入第二个参数，是一个boolean值，true为只删除一条：</p>\n<pre><code>db.users.remove({\n    name : &#39;hcy&#39;\n}, true)\n</code></pre><p>修改数据有两种方法，可以使用 update()方法，也可以使用save()方法，先来看update()方法:</p>\n<pre><code>db.collection.update(\n   &lt;query&gt;,\n   &lt;update&gt;,\n   {\n     upsert: &lt;boolean&gt;,\n     multi: &lt;boolean&gt;,\n     writeConcern: &lt;document&gt;\n   }\n)\n</code></pre><blockquote>\n<p>query : update的查询条件，类似sql update查询内where后面的。<br>update : update的对象和一些更新的操作符（如$,$inc…）等，也可以理解为sql update查询内set后面的<br>upsert : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。<br>multi : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。<br>writeConcern :可选，抛出异常的级别。</p>\n</blockquote>\n<p>这里我只介绍了语法，也可以使用save()方法：</p>\n<pre><code>db.collection.save(\n   &lt;document&gt;,\n   {\n     writeConcern: &lt;document&gt;\n   }\n)\n</code></pre><blockquote>\n<p>document : 文档数据。<br>writeConcern :可选，抛出异常的级别。</p>\n</blockquote>\n<p>例子如下：</p>\n<pre><code>db.users.save({\n    &quot;_id&quot; : ObjectId(&quot;56064f89ade2f21f36b03136&quot;),\n    &quot;name&quot; : &quot;aaaa&quot;,\n    &quot;age&quot; : &quot;100&quot;\n})\n</code></pre><p>上面的例子中，我们替换了 _id 为 56064f89ade2f21f36b03136 的文档数据。</p>\n<p>如果想了解更多mongodb原生语法知识，<a href=\"http://www.runoob.com/mongodb/mongodb-tutorial.html\" target=\"_blank\" rel=\"external\">这里</a>是一个好去处</p>\n<p>现在，你应该对mongodb有了一定的了解了，那么我们如何在nodejs中操作mongodb呢？</p>\n<p>首先在项目中使用npm安装mongodb模块</p>\n<pre><code>npm install --save mongodb\n</code></pre><p>当我们想要在项目中使用这个模块操作数据库的时候，我们就可以引入该模块</p>\n<pre><code>var MongoClient = require(&#39;mongodb&#39;).MongoClient;\n</code></pre><p>上面的代码返回一个mongodb客户端实例，连接数据库：</p>\n<pre><code>var mongoConnectUrl = &#39;mongodb://localhost:27017/hcy&#39;;\nMongoClient.connect(mongoConnectUrl, function(err, db){\n    if(err) return console.log(err);\n    console.log(&#39;连接成功&#39;);\n});\n</code></pre><p>上面的mongoConnectUrl是我们连接mongodb数据库的一个url，注意，mongodb默认监听的端口是27017，另外，如果始终连接不成功，你可以把localhost换成你电脑的ip地址试一试，笔者在测试的时候只能使用ip地址，使用localhost始终连接失败，在url的最后是你要连接的数据库，这里我们连接到hcy数据库。</p>\n<p>连接数据库成功后，我们可以创建一个集合，并操作里面的数据，我们封装一个方法：</p>\n<h2 id=\"插入数据\"><a href=\"#插入数据\" class=\"headerlink\" title=\"插入数据\"></a>插入数据</h2><pre><code>/**\n * 插入数据\n * @method insertData\n * @param {String} mongoConnectUrl 数据库连接\n * @param {String} coll 集合名称\n * @param {Array} data 插入的数据\n * @param {Function} callback 回调函数\n * @return {Null}\n *\n */\nfunction insertData(mongoConnectUrl, coll, data, callback){\n    MongoClient.connect(mongoConnectUrl, function(err, db){\n        if(err) return console.log(err);\n        // 打开集合\n        var collection = db.collection(coll);\n        // 插入数据\n        collection.insertMany(data, function(err, result){\n            //console.log(result)\n            // 记得要关闭数据库\n            db.close();\n            callback(result);\n        });\n\n    });\n}\n</code></pre><h2 id=\"查询数据\"><a href=\"#查询数据\" class=\"headerlink\" title=\"查询数据\"></a>查询数据</h2><pre><code>/**\n * 查询数据\n * @method findData\n * @param {String} mongoConnectUrl 数据库连接\n * @param {String} coll 集合名称\n * @param {Object} opation 条件\n * @param {Function} callback 回调函数\n * @return {Null}\n *\n */\nfunction findData(mongoConnectUrl, coll, opation, callback){\n    MongoClient.connect(mongoConnectUrl, function(err, db){\n        if(err) return console.log(err);\n        // 打开集合\n        var collection = db.collection(coll);\n        // 根据条件查询数据\n        var userData = collection.find(opation);\n        // 遍历数据\n        userData.toArray(function(err2, docs) {\n            // docs是查询出来的文档，json对象，可以打印出来看看\n            db.close();\n            callback(docs);\n        });\n\n    });\n}\n</code></pre><h2 id=\"删除数据\"><a href=\"#删除数据\" class=\"headerlink\" title=\"删除数据\"></a>删除数据</h2><pre><code>/**\n * @method deleteData\n * @param {String} mongoConnectUrl 数据库连接\n * @param {String} coll 集合名称\n * @param {Object} opation 条件\n * @param {Number} num 删除数据的数量，即删除几条\n * @return {Null}\n *\n */\nfunction deleteData(mongoConnectUrl, coll, opation, num, callback){\n    var i = num;\n    var res = [];\n    var tempRes = [];\n    var thisFn = arguments.callee;\n    MongoClient.connect(mongoConnectUrl, function(err, db){\n        if(err) return console.log(err);\n\n        var collection = db.collection(coll);\n        if(i &gt; 0){\n            i--;\n            collection.deleteOne(opation, function(err, result){\n                // console.log(result)\n                res.push(result);\n                thisFn(mongoConnectUrl, coll, opation, i, callback);\n                if(i == 0){\n                    db.close();\n                    tempRes = res;\n                    res = []\n                    i = 0;\n                    callback(tempRes);\n                }\n\n            });\n        }\n\n    });\n},\n</code></pre><h2 id=\"修改一条数据\"><a href=\"#修改一条数据\" class=\"headerlink\" title=\"修改一条数据\"></a>修改一条数据</h2><pre><code>/**\n * @method deleteData\n * @param {String} mongoConnectUrl 数据库连接\n * @param {String} coll 集合名称\n * @param {Object} opation 条件\n * @param {Object} data 更新的数据\n * @return {Null}\n *\n */\nfunction deleteData(mongoConnectUrl, coll, opation, data, callback){\n    MongoClient.connect(mongoConnectUrl, function(err, db){\n        if(err) return console.log(err);\n\n        var collection = db.collection(coll);\n\n        collection.updateOne(opation, { $set: data }, function(err, result) {\n            db.close();\n            callback(result);\n        });\n\n    });\n},\n</code></pre>"},{"title":"项目迁移问题总结","date":"2015-12-26T02:53:12.000Z","_content":"\n>之前在Mac系统下搭建了一套用于自动化构建H5项目的平台，一直用Mac做service服务，现在要将项目迁移到Ubuntu上面，下面是整理了迁移过程中遇到的问题，供以后查阅\n\n![Ubuntu](http://7xlolm.com1.z0.glb.clouddn.com/20151226Ubuntu.jpg)\n\n<!-- more -->\n\n# Ubuntu下安装git和node #\n\n当时在做项目迁移的时候并没有服务器，所以只能用旁边的一台windows安装个双系统，来充当服务器了，安装方法网上很多，不过我推荐一个朋友的博客中的一篇文章，我所安装的Ubuntu的版本是14.04的，并且是server版的，与该博客不符，但是原理相同，贴出[博客地址](https://xuri.me/2013/04/09/easybcd-install-ubuntu.html)。\n\n## Ubuntu 下安装 git ##\n\nUbuntu的包管理是apt-get，可以使用如下命令安装git:\n\n```\nsudo apt-get install git\n```\n\n但是这样安装的git版本是比较老的，并不推荐这样安装，如果想安装最新可用版本的可以执行下面的命令：\n\n```\nsudo add-apt-repository ppa:git-core/ppa\nsudo apt-get update\nsudo apt-get install git\n```\n\n安装完成后可以查看git版本，确定安装是否成功\n\n```\ngit --version\n```\n\n## Ubuntu 下安装 node ##\n\n我采用的源码编译安装的方式，首先去[node得资源列表](https://nodejs.org/dist/)找到你要现在的资源包，如我所选择的资源包是：\n\nhttps://nodejs.org/dist/v5.0.0/node-v5.0.0.tar.gz\n\n选择好资源包后执行下面的命令即可：\n\n```\n# 下载资源\nwget https://nodejs.org/dist/v5.0.0/node-v5.0.0.tar.gz\n# 解压\ntar zxvf node-v5.0.0.tar.gz\n# 编译安装\ncd node-v5.0.0\n./configure \nmake \nmake install\ncp /usr/local/bin/node /usr/sbin/\n```\n\n查看是否安装成功\n\n```\nnode -v\n```\n\n如果正确输出版本号，那么说明我们安装成功了，也有其他安装方式，大家去网上看看吧\n\n# Ubuntu默认是用dash解析shell脚本 #\n\n由于项目中我使用到了shell脚本，所以当项目迁移到Ubuntu的时候报错：\n\n```\nsource xxx.sh时提示 source: not found\n```\n\n原因是当时项目在Mac下跑得，Mac解析shell脚本使用的是bash，而Ubuntu默认是用的dash，我们可以使用下面的命令查看：\n\n```\nls -l `which sh`\n```\n\n如下图\n![Ubuntu默认使用dash解析shell脚本](http://7xlolm.com1.z0.glb.clouddn.com/201512266.pic.jpg)\n\n我们可以修改Ubuntu解析shell的方式：\n\n```\nsudo dpkg-reconfigure dash\n```\n\n执行该命令后会出现如下图所示的选项，我们只需要选择否即可：\n![选择否](http://7xlolm.com1.z0.glb.clouddn.com/201512264.pic.jpg)\n\n这时在查看一下Ubuntu解析shell的方式：\n\n```\nls -l `which sh`\n```\n\n如下图，已经变为了 bash\n\n![bash](http://7xlolm.com1.z0.glb.clouddn.com/201512263.pic.jpg)\n\n# git的一些小事儿 #\n\n另外，总结两点git中的一些东西\n\n## 1、让git忽略文件权限 ##\n\n项目幻想搭建好了之后，我就把代码使用git克隆了下来，由于运行项目的时候报错提示文件权限有问题，于是我就修改了整个项目目录的权限，当我使用git pull拉取项目的时候提示我本地仓库有修改，让我提交后再拉取，我很疑惑因为我刚刚clone下来，毛儿都没动，我改什么了我？后来是用git status查看发现，一大片红色(修改未提交的文件)，后来我猜想应该是git把文件权限也纳入管理的范围内了，后来上网一查，果然，不过可以执行下面的命令，使git忽略对文件权限的管理：\n\n```\ngit config core.filemode false\n```\n\n这是在使用 git status 查看，会发现工作区干净了，搞定。\n\n## 2、https方式克隆的项目每次都提示输入用户名和密码 ##\n\n另外还有一个问题，就是当时克隆项目的时候我使用的是https的方式，并不是ssh的方式，https的好处就是告诉，而ssh的好处是安全，正因如此，使用https克隆的项目每次push、pull等操作都要提示输入用户名密码，所以我们要解决这个问题。\n\n第一步：切换到家目录 “~”\n\n```\ncd ~\n```\n\n第二步：创建并编辑 .git-credentials 文件\n\n```\ntouch .git-credentials\n\nvim .git-credentials\n```\n\n第三步：把如下内容写入.git-credentials文件中，报错并退出\n\n```\n# {username} 你的git账户名\n# {password} 你的git密码\n# example.com 你的git仓库域名\n# 例子：https://hcysunyang:12345678@github.com\n\nhttps://{username}:{password}@example.com\n```\n\n第四步：执行下面的命令\n\n```\ngit config --global credential.helper store\n```\n\n接下来你就可以执行push、pull等操作了，但是还是会提示你输入一次账号密码的，别着急，仅此一次而已，以后就不会再让你输入了，搞定。\n\n# Ubuntu下mongodb启动失败 #\n\n如下图：\n\n![mongodb启动失败](http://7xlolm.com1.z0.glb.clouddn.com/201512267.pic_hd.jpg)\n\n造成启动失败的原因有很多，其中最常见的就是非正常退出，下一次再启动的时候就会遇到如上情况，在Mac下或者windows下，一般我们需要把mongod.lock文件删除就可以成功重启了，但是今天在Ubuntu下却不行，在Ubuntu下记得要把mongodb-27017.sock文件也删除掉：\n\n```\nsudo rm -rf /var/lib/mongodb/mongod.lock\nsudo rm -rf /tmp/mongodb-27017.sock\n```\n\n之后重启：\n\n```\nsudo service mongod start\n```\n\n就可以正常启动了\n\n# nohup 命令让进程在后台运行 #\n\n当时我是使用ssh远程登录的，又不想多开窗口，所以希望node服务在后台运行，这时候可以使用nohup命令，该命令能够让进程在后台运行，nohup命令的格式如下：\n\n```\nnohup Command [ Arg ... ] [　& ] \n```\n\n例如我想要node的web服务在后台运行，在我的项目中可以执行下面的代码带到目的：\n\n```\nnohup node admin.js &\n```\n\n# Ubuntu下添加用户并赋予root权限 #\n\n在Ubuntu下可以使用 adduser 命令添加一个用户：\n\n```\nadduser <username>\n```\n\n执行该命令之后会让你为该用户设置密码，但是这样添加的用户是没有使用root权限的用户，我们需要一些配置来赋予该用户使用root权限的能力，修改配置需要编辑 /etc/sudoers 文件，这个文件默认是只读的，所以第一步修改文件为可写：\n\n```\nchmod u+w /etc/sudoers\n```\n\n然后编辑该文件：\n\n```\nsudo vim /etc/sudoers\n```\n\n找到下面这句话：\n\n```\n# Allow members of group sudo to execute any command\n%sudo   ALL=(ALL:ALL) ALL\n```\n\n在其 %sudo   ALL=(ALL:ALL) ALL 下面再添加一行：\n\n```\n%username   ALL=(ALL:ALL) ALL\n```\n\nusername为你创建用户的用户名，之后保存退出，并还原 sudoers 文件只读的权限：\n\n```\nchmod u-w /etc/sudoers\n```\n\n接下来新用户就可以登录并使用root权限了。\n\n# 安装完Ubuntu后乱码 #\n\n修改/etc/default/locale\n\n```\nsudo vim /etc/default/locale\n```\n\n将：\n\n```\nLANG=zh_CN.UTF-8\nLANGUAGE=zh_CN:zh\n```\n\n修改为：\n\n```\nLANG=\"en_US.UTF-8\"\nLANGUAGE=\"en_US:en\"\n```\n\n最后reboot一下就可以了：\n\n```\nsudo reboot\n```\n","source":"_posts/2015/12/26/项目迁移问题总结.md","raw":"title: 项目迁移问题总结\ndate: 2015-12-26 10:53:12\ncategories:\n- WebFrontEnd\ntags:\n- Ubuntu\n- git\n- nodejs\n---\n\n>之前在Mac系统下搭建了一套用于自动化构建H5项目的平台，一直用Mac做service服务，现在要将项目迁移到Ubuntu上面，下面是整理了迁移过程中遇到的问题，供以后查阅\n\n![Ubuntu](http://7xlolm.com1.z0.glb.clouddn.com/20151226Ubuntu.jpg)\n\n<!-- more -->\n\n# Ubuntu下安装git和node #\n\n当时在做项目迁移的时候并没有服务器，所以只能用旁边的一台windows安装个双系统，来充当服务器了，安装方法网上很多，不过我推荐一个朋友的博客中的一篇文章，我所安装的Ubuntu的版本是14.04的，并且是server版的，与该博客不符，但是原理相同，贴出[博客地址](https://xuri.me/2013/04/09/easybcd-install-ubuntu.html)。\n\n## Ubuntu 下安装 git ##\n\nUbuntu的包管理是apt-get，可以使用如下命令安装git:\n\n```\nsudo apt-get install git\n```\n\n但是这样安装的git版本是比较老的，并不推荐这样安装，如果想安装最新可用版本的可以执行下面的命令：\n\n```\nsudo add-apt-repository ppa:git-core/ppa\nsudo apt-get update\nsudo apt-get install git\n```\n\n安装完成后可以查看git版本，确定安装是否成功\n\n```\ngit --version\n```\n\n## Ubuntu 下安装 node ##\n\n我采用的源码编译安装的方式，首先去[node得资源列表](https://nodejs.org/dist/)找到你要现在的资源包，如我所选择的资源包是：\n\nhttps://nodejs.org/dist/v5.0.0/node-v5.0.0.tar.gz\n\n选择好资源包后执行下面的命令即可：\n\n```\n# 下载资源\nwget https://nodejs.org/dist/v5.0.0/node-v5.0.0.tar.gz\n# 解压\ntar zxvf node-v5.0.0.tar.gz\n# 编译安装\ncd node-v5.0.0\n./configure \nmake \nmake install\ncp /usr/local/bin/node /usr/sbin/\n```\n\n查看是否安装成功\n\n```\nnode -v\n```\n\n如果正确输出版本号，那么说明我们安装成功了，也有其他安装方式，大家去网上看看吧\n\n# Ubuntu默认是用dash解析shell脚本 #\n\n由于项目中我使用到了shell脚本，所以当项目迁移到Ubuntu的时候报错：\n\n```\nsource xxx.sh时提示 source: not found\n```\n\n原因是当时项目在Mac下跑得，Mac解析shell脚本使用的是bash，而Ubuntu默认是用的dash，我们可以使用下面的命令查看：\n\n```\nls -l `which sh`\n```\n\n如下图\n![Ubuntu默认使用dash解析shell脚本](http://7xlolm.com1.z0.glb.clouddn.com/201512266.pic.jpg)\n\n我们可以修改Ubuntu解析shell的方式：\n\n```\nsudo dpkg-reconfigure dash\n```\n\n执行该命令后会出现如下图所示的选项，我们只需要选择否即可：\n![选择否](http://7xlolm.com1.z0.glb.clouddn.com/201512264.pic.jpg)\n\n这时在查看一下Ubuntu解析shell的方式：\n\n```\nls -l `which sh`\n```\n\n如下图，已经变为了 bash\n\n![bash](http://7xlolm.com1.z0.glb.clouddn.com/201512263.pic.jpg)\n\n# git的一些小事儿 #\n\n另外，总结两点git中的一些东西\n\n## 1、让git忽略文件权限 ##\n\n项目幻想搭建好了之后，我就把代码使用git克隆了下来，由于运行项目的时候报错提示文件权限有问题，于是我就修改了整个项目目录的权限，当我使用git pull拉取项目的时候提示我本地仓库有修改，让我提交后再拉取，我很疑惑因为我刚刚clone下来，毛儿都没动，我改什么了我？后来是用git status查看发现，一大片红色(修改未提交的文件)，后来我猜想应该是git把文件权限也纳入管理的范围内了，后来上网一查，果然，不过可以执行下面的命令，使git忽略对文件权限的管理：\n\n```\ngit config core.filemode false\n```\n\n这是在使用 git status 查看，会发现工作区干净了，搞定。\n\n## 2、https方式克隆的项目每次都提示输入用户名和密码 ##\n\n另外还有一个问题，就是当时克隆项目的时候我使用的是https的方式，并不是ssh的方式，https的好处就是告诉，而ssh的好处是安全，正因如此，使用https克隆的项目每次push、pull等操作都要提示输入用户名密码，所以我们要解决这个问题。\n\n第一步：切换到家目录 “~”\n\n```\ncd ~\n```\n\n第二步：创建并编辑 .git-credentials 文件\n\n```\ntouch .git-credentials\n\nvim .git-credentials\n```\n\n第三步：把如下内容写入.git-credentials文件中，报错并退出\n\n```\n# {username} 你的git账户名\n# {password} 你的git密码\n# example.com 你的git仓库域名\n# 例子：https://hcysunyang:12345678@github.com\n\nhttps://{username}:{password}@example.com\n```\n\n第四步：执行下面的命令\n\n```\ngit config --global credential.helper store\n```\n\n接下来你就可以执行push、pull等操作了，但是还是会提示你输入一次账号密码的，别着急，仅此一次而已，以后就不会再让你输入了，搞定。\n\n# Ubuntu下mongodb启动失败 #\n\n如下图：\n\n![mongodb启动失败](http://7xlolm.com1.z0.glb.clouddn.com/201512267.pic_hd.jpg)\n\n造成启动失败的原因有很多，其中最常见的就是非正常退出，下一次再启动的时候就会遇到如上情况，在Mac下或者windows下，一般我们需要把mongod.lock文件删除就可以成功重启了，但是今天在Ubuntu下却不行，在Ubuntu下记得要把mongodb-27017.sock文件也删除掉：\n\n```\nsudo rm -rf /var/lib/mongodb/mongod.lock\nsudo rm -rf /tmp/mongodb-27017.sock\n```\n\n之后重启：\n\n```\nsudo service mongod start\n```\n\n就可以正常启动了\n\n# nohup 命令让进程在后台运行 #\n\n当时我是使用ssh远程登录的，又不想多开窗口，所以希望node服务在后台运行，这时候可以使用nohup命令，该命令能够让进程在后台运行，nohup命令的格式如下：\n\n```\nnohup Command [ Arg ... ] [　& ] \n```\n\n例如我想要node的web服务在后台运行，在我的项目中可以执行下面的代码带到目的：\n\n```\nnohup node admin.js &\n```\n\n# Ubuntu下添加用户并赋予root权限 #\n\n在Ubuntu下可以使用 adduser 命令添加一个用户：\n\n```\nadduser <username>\n```\n\n执行该命令之后会让你为该用户设置密码，但是这样添加的用户是没有使用root权限的用户，我们需要一些配置来赋予该用户使用root权限的能力，修改配置需要编辑 /etc/sudoers 文件，这个文件默认是只读的，所以第一步修改文件为可写：\n\n```\nchmod u+w /etc/sudoers\n```\n\n然后编辑该文件：\n\n```\nsudo vim /etc/sudoers\n```\n\n找到下面这句话：\n\n```\n# Allow members of group sudo to execute any command\n%sudo   ALL=(ALL:ALL) ALL\n```\n\n在其 %sudo   ALL=(ALL:ALL) ALL 下面再添加一行：\n\n```\n%username   ALL=(ALL:ALL) ALL\n```\n\nusername为你创建用户的用户名，之后保存退出，并还原 sudoers 文件只读的权限：\n\n```\nchmod u-w /etc/sudoers\n```\n\n接下来新用户就可以登录并使用root权限了。\n\n# 安装完Ubuntu后乱码 #\n\n修改/etc/default/locale\n\n```\nsudo vim /etc/default/locale\n```\n\n将：\n\n```\nLANG=zh_CN.UTF-8\nLANGUAGE=zh_CN:zh\n```\n\n修改为：\n\n```\nLANG=\"en_US.UTF-8\"\nLANGUAGE=\"en_US:en\"\n```\n\n最后reboot一下就可以了：\n\n```\nsudo reboot\n```\n","slug":"项目迁移问题总结","published":1,"updated":"2015-12-29T09:42:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj669fsjy0015ewfcap7bbz9x","content":"<blockquote>\n<p>之前在Mac系统下搭建了一套用于自动化构建H5项目的平台，一直用Mac做service服务，现在要将项目迁移到Ubuntu上面，下面是整理了迁移过程中遇到的问题，供以后查阅</p>\n</blockquote>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20151226Ubuntu.jpg\" alt=\"Ubuntu\"></p>\n<a id=\"more\"></a>\n<h1 id=\"Ubuntu下安装git和node\"><a href=\"#Ubuntu下安装git和node\" class=\"headerlink\" title=\"Ubuntu下安装git和node\"></a>Ubuntu下安装git和node</h1><p>当时在做项目迁移的时候并没有服务器，所以只能用旁边的一台windows安装个双系统，来充当服务器了，安装方法网上很多，不过我推荐一个朋友的博客中的一篇文章，我所安装的Ubuntu的版本是14.04的，并且是server版的，与该博客不符，但是原理相同，贴出<a href=\"https://xuri.me/2013/04/09/easybcd-install-ubuntu.html\" target=\"_blank\" rel=\"external\">博客地址</a>。</p>\n<h2 id=\"Ubuntu-下安装-git\"><a href=\"#Ubuntu-下安装-git\" class=\"headerlink\" title=\"Ubuntu 下安装 git\"></a>Ubuntu 下安装 git</h2><p>Ubuntu的包管理是apt-get，可以使用如下命令安装git:</p>\n<pre><code>sudo apt-get install git\n</code></pre><p>但是这样安装的git版本是比较老的，并不推荐这样安装，如果想安装最新可用版本的可以执行下面的命令：</p>\n<pre><code>sudo add-apt-repository ppa:git-core/ppa\nsudo apt-get update\nsudo apt-get install git\n</code></pre><p>安装完成后可以查看git版本，确定安装是否成功</p>\n<pre><code>git --version\n</code></pre><h2 id=\"Ubuntu-下安装-node\"><a href=\"#Ubuntu-下安装-node\" class=\"headerlink\" title=\"Ubuntu 下安装 node\"></a>Ubuntu 下安装 node</h2><p>我采用的源码编译安装的方式，首先去<a href=\"https://nodejs.org/dist/\" target=\"_blank\" rel=\"external\">node得资源列表</a>找到你要现在的资源包，如我所选择的资源包是：</p>\n<p><a href=\"https://nodejs.org/dist/v5.0.0/node-v5.0.0.tar.gz\" target=\"_blank\" rel=\"external\">https://nodejs.org/dist/v5.0.0/node-v5.0.0.tar.gz</a></p>\n<p>选择好资源包后执行下面的命令即可：</p>\n<pre><code># 下载资源\nwget https://nodejs.org/dist/v5.0.0/node-v5.0.0.tar.gz\n# 解压\ntar zxvf node-v5.0.0.tar.gz\n# 编译安装\ncd node-v5.0.0\n./configure \nmake \nmake install\ncp /usr/local/bin/node /usr/sbin/\n</code></pre><p>查看是否安装成功</p>\n<pre><code>node -v\n</code></pre><p>如果正确输出版本号，那么说明我们安装成功了，也有其他安装方式，大家去网上看看吧</p>\n<h1 id=\"Ubuntu默认是用dash解析shell脚本\"><a href=\"#Ubuntu默认是用dash解析shell脚本\" class=\"headerlink\" title=\"Ubuntu默认是用dash解析shell脚本\"></a>Ubuntu默认是用dash解析shell脚本</h1><p>由于项目中我使用到了shell脚本，所以当项目迁移到Ubuntu的时候报错：</p>\n<pre><code>source xxx.sh时提示 source: not found\n</code></pre><p>原因是当时项目在Mac下跑得，Mac解析shell脚本使用的是bash，而Ubuntu默认是用的dash，我们可以使用下面的命令查看：</p>\n<pre><code>ls -l `which sh`\n</code></pre><p>如下图<br><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201512266.pic.jpg\" alt=\"Ubuntu默认使用dash解析shell脚本\"></p>\n<p>我们可以修改Ubuntu解析shell的方式：</p>\n<pre><code>sudo dpkg-reconfigure dash\n</code></pre><p>执行该命令后会出现如下图所示的选项，我们只需要选择否即可：<br><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201512264.pic.jpg\" alt=\"选择否\"></p>\n<p>这时在查看一下Ubuntu解析shell的方式：</p>\n<pre><code>ls -l `which sh`\n</code></pre><p>如下图，已经变为了 bash</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201512263.pic.jpg\" alt=\"bash\"></p>\n<h1 id=\"git的一些小事儿\"><a href=\"#git的一些小事儿\" class=\"headerlink\" title=\"git的一些小事儿\"></a>git的一些小事儿</h1><p>另外，总结两点git中的一些东西</p>\n<h2 id=\"1、让git忽略文件权限\"><a href=\"#1、让git忽略文件权限\" class=\"headerlink\" title=\"1、让git忽略文件权限\"></a>1、让git忽略文件权限</h2><p>项目幻想搭建好了之后，我就把代码使用git克隆了下来，由于运行项目的时候报错提示文件权限有问题，于是我就修改了整个项目目录的权限，当我使用git pull拉取项目的时候提示我本地仓库有修改，让我提交后再拉取，我很疑惑因为我刚刚clone下来，毛儿都没动，我改什么了我？后来是用git status查看发现，一大片红色(修改未提交的文件)，后来我猜想应该是git把文件权限也纳入管理的范围内了，后来上网一查，果然，不过可以执行下面的命令，使git忽略对文件权限的管理：</p>\n<pre><code>git config core.filemode false\n</code></pre><p>这是在使用 git status 查看，会发现工作区干净了，搞定。</p>\n<h2 id=\"2、https方式克隆的项目每次都提示输入用户名和密码\"><a href=\"#2、https方式克隆的项目每次都提示输入用户名和密码\" class=\"headerlink\" title=\"2、https方式克隆的项目每次都提示输入用户名和密码\"></a>2、https方式克隆的项目每次都提示输入用户名和密码</h2><p>另外还有一个问题，就是当时克隆项目的时候我使用的是https的方式，并不是ssh的方式，https的好处就是告诉，而ssh的好处是安全，正因如此，使用https克隆的项目每次push、pull等操作都要提示输入用户名密码，所以我们要解决这个问题。</p>\n<p>第一步：切换到家目录 “~”</p>\n<pre><code>cd ~\n</code></pre><p>第二步：创建并编辑 .git-credentials 文件</p>\n<pre><code>touch .git-credentials\n\nvim .git-credentials\n</code></pre><p>第三步：把如下内容写入.git-credentials文件中，报错并退出</p>\n<pre><code># {username} 你的git账户名\n# {password} 你的git密码\n# example.com 你的git仓库域名\n# 例子：https://hcysunyang:12345678@github.com\n\nhttps://{username}:{password}@example.com\n</code></pre><p>第四步：执行下面的命令</p>\n<pre><code>git config --global credential.helper store\n</code></pre><p>接下来你就可以执行push、pull等操作了，但是还是会提示你输入一次账号密码的，别着急，仅此一次而已，以后就不会再让你输入了，搞定。</p>\n<h1 id=\"Ubuntu下mongodb启动失败\"><a href=\"#Ubuntu下mongodb启动失败\" class=\"headerlink\" title=\"Ubuntu下mongodb启动失败\"></a>Ubuntu下mongodb启动失败</h1><p>如下图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201512267.pic_hd.jpg\" alt=\"mongodb启动失败\"></p>\n<p>造成启动失败的原因有很多，其中最常见的就是非正常退出，下一次再启动的时候就会遇到如上情况，在Mac下或者windows下，一般我们需要把mongod.lock文件删除就可以成功重启了，但是今天在Ubuntu下却不行，在Ubuntu下记得要把mongodb-27017.sock文件也删除掉：</p>\n<pre><code>sudo rm -rf /var/lib/mongodb/mongod.lock\nsudo rm -rf /tmp/mongodb-27017.sock\n</code></pre><p>之后重启：</p>\n<pre><code>sudo service mongod start\n</code></pre><p>就可以正常启动了</p>\n<h1 id=\"nohup-命令让进程在后台运行\"><a href=\"#nohup-命令让进程在后台运行\" class=\"headerlink\" title=\"nohup 命令让进程在后台运行\"></a>nohup 命令让进程在后台运行</h1><p>当时我是使用ssh远程登录的，又不想多开窗口，所以希望node服务在后台运行，这时候可以使用nohup命令，该命令能够让进程在后台运行，nohup命令的格式如下：</p>\n<pre><code>nohup Command [ Arg ... ] [　&amp; ]\n</code></pre><p>例如我想要node的web服务在后台运行，在我的项目中可以执行下面的代码带到目的：</p>\n<pre><code>nohup node admin.js &amp;\n</code></pre><h1 id=\"Ubuntu下添加用户并赋予root权限\"><a href=\"#Ubuntu下添加用户并赋予root权限\" class=\"headerlink\" title=\"Ubuntu下添加用户并赋予root权限\"></a>Ubuntu下添加用户并赋予root权限</h1><p>在Ubuntu下可以使用 adduser 命令添加一个用户：</p>\n<pre><code>adduser &lt;username&gt;\n</code></pre><p>执行该命令之后会让你为该用户设置密码，但是这样添加的用户是没有使用root权限的用户，我们需要一些配置来赋予该用户使用root权限的能力，修改配置需要编辑 /etc/sudoers 文件，这个文件默认是只读的，所以第一步修改文件为可写：</p>\n<pre><code>chmod u+w /etc/sudoers\n</code></pre><p>然后编辑该文件：</p>\n<pre><code>sudo vim /etc/sudoers\n</code></pre><p>找到下面这句话：</p>\n<pre><code># Allow members of group sudo to execute any command\n%sudo   ALL=(ALL:ALL) ALL\n</code></pre><p>在其 %sudo   ALL=(ALL:ALL) ALL 下面再添加一行：</p>\n<pre><code>%username   ALL=(ALL:ALL) ALL\n</code></pre><p>username为你创建用户的用户名，之后保存退出，并还原 sudoers 文件只读的权限：</p>\n<pre><code>chmod u-w /etc/sudoers\n</code></pre><p>接下来新用户就可以登录并使用root权限了。</p>\n<h1 id=\"安装完Ubuntu后乱码\"><a href=\"#安装完Ubuntu后乱码\" class=\"headerlink\" title=\"安装完Ubuntu后乱码\"></a>安装完Ubuntu后乱码</h1><p>修改/etc/default/locale</p>\n<pre><code>sudo vim /etc/default/locale\n</code></pre><p>将：</p>\n<pre><code>LANG=zh_CN.UTF-8\nLANGUAGE=zh_CN:zh\n</code></pre><p>修改为：</p>\n<pre><code>LANG=&quot;en_US.UTF-8&quot;\nLANGUAGE=&quot;en_US:en&quot;\n</code></pre><p>最后reboot一下就可以了：</p>\n<pre><code>sudo reboot\n</code></pre>","site":{"data":{}},"excerpt":"<blockquote>\n<p>之前在Mac系统下搭建了一套用于自动化构建H5项目的平台，一直用Mac做service服务，现在要将项目迁移到Ubuntu上面，下面是整理了迁移过程中遇到的问题，供以后查阅</p>\n</blockquote>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20151226Ubuntu.jpg\" alt=\"Ubuntu\"></p>","more":"<h1 id=\"Ubuntu下安装git和node\"><a href=\"#Ubuntu下安装git和node\" class=\"headerlink\" title=\"Ubuntu下安装git和node\"></a>Ubuntu下安装git和node</h1><p>当时在做项目迁移的时候并没有服务器，所以只能用旁边的一台windows安装个双系统，来充当服务器了，安装方法网上很多，不过我推荐一个朋友的博客中的一篇文章，我所安装的Ubuntu的版本是14.04的，并且是server版的，与该博客不符，但是原理相同，贴出<a href=\"https://xuri.me/2013/04/09/easybcd-install-ubuntu.html\" target=\"_blank\" rel=\"external\">博客地址</a>。</p>\n<h2 id=\"Ubuntu-下安装-git\"><a href=\"#Ubuntu-下安装-git\" class=\"headerlink\" title=\"Ubuntu 下安装 git\"></a>Ubuntu 下安装 git</h2><p>Ubuntu的包管理是apt-get，可以使用如下命令安装git:</p>\n<pre><code>sudo apt-get install git\n</code></pre><p>但是这样安装的git版本是比较老的，并不推荐这样安装，如果想安装最新可用版本的可以执行下面的命令：</p>\n<pre><code>sudo add-apt-repository ppa:git-core/ppa\nsudo apt-get update\nsudo apt-get install git\n</code></pre><p>安装完成后可以查看git版本，确定安装是否成功</p>\n<pre><code>git --version\n</code></pre><h2 id=\"Ubuntu-下安装-node\"><a href=\"#Ubuntu-下安装-node\" class=\"headerlink\" title=\"Ubuntu 下安装 node\"></a>Ubuntu 下安装 node</h2><p>我采用的源码编译安装的方式，首先去<a href=\"https://nodejs.org/dist/\" target=\"_blank\" rel=\"external\">node得资源列表</a>找到你要现在的资源包，如我所选择的资源包是：</p>\n<p><a href=\"https://nodejs.org/dist/v5.0.0/node-v5.0.0.tar.gz\" target=\"_blank\" rel=\"external\">https://nodejs.org/dist/v5.0.0/node-v5.0.0.tar.gz</a></p>\n<p>选择好资源包后执行下面的命令即可：</p>\n<pre><code># 下载资源\nwget https://nodejs.org/dist/v5.0.0/node-v5.0.0.tar.gz\n# 解压\ntar zxvf node-v5.0.0.tar.gz\n# 编译安装\ncd node-v5.0.0\n./configure \nmake \nmake install\ncp /usr/local/bin/node /usr/sbin/\n</code></pre><p>查看是否安装成功</p>\n<pre><code>node -v\n</code></pre><p>如果正确输出版本号，那么说明我们安装成功了，也有其他安装方式，大家去网上看看吧</p>\n<h1 id=\"Ubuntu默认是用dash解析shell脚本\"><a href=\"#Ubuntu默认是用dash解析shell脚本\" class=\"headerlink\" title=\"Ubuntu默认是用dash解析shell脚本\"></a>Ubuntu默认是用dash解析shell脚本</h1><p>由于项目中我使用到了shell脚本，所以当项目迁移到Ubuntu的时候报错：</p>\n<pre><code>source xxx.sh时提示 source: not found\n</code></pre><p>原因是当时项目在Mac下跑得，Mac解析shell脚本使用的是bash，而Ubuntu默认是用的dash，我们可以使用下面的命令查看：</p>\n<pre><code>ls -l `which sh`\n</code></pre><p>如下图<br><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201512266.pic.jpg\" alt=\"Ubuntu默认使用dash解析shell脚本\"></p>\n<p>我们可以修改Ubuntu解析shell的方式：</p>\n<pre><code>sudo dpkg-reconfigure dash\n</code></pre><p>执行该命令后会出现如下图所示的选项，我们只需要选择否即可：<br><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201512264.pic.jpg\" alt=\"选择否\"></p>\n<p>这时在查看一下Ubuntu解析shell的方式：</p>\n<pre><code>ls -l `which sh`\n</code></pre><p>如下图，已经变为了 bash</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201512263.pic.jpg\" alt=\"bash\"></p>\n<h1 id=\"git的一些小事儿\"><a href=\"#git的一些小事儿\" class=\"headerlink\" title=\"git的一些小事儿\"></a>git的一些小事儿</h1><p>另外，总结两点git中的一些东西</p>\n<h2 id=\"1、让git忽略文件权限\"><a href=\"#1、让git忽略文件权限\" class=\"headerlink\" title=\"1、让git忽略文件权限\"></a>1、让git忽略文件权限</h2><p>项目幻想搭建好了之后，我就把代码使用git克隆了下来，由于运行项目的时候报错提示文件权限有问题，于是我就修改了整个项目目录的权限，当我使用git pull拉取项目的时候提示我本地仓库有修改，让我提交后再拉取，我很疑惑因为我刚刚clone下来，毛儿都没动，我改什么了我？后来是用git status查看发现，一大片红色(修改未提交的文件)，后来我猜想应该是git把文件权限也纳入管理的范围内了，后来上网一查，果然，不过可以执行下面的命令，使git忽略对文件权限的管理：</p>\n<pre><code>git config core.filemode false\n</code></pre><p>这是在使用 git status 查看，会发现工作区干净了，搞定。</p>\n<h2 id=\"2、https方式克隆的项目每次都提示输入用户名和密码\"><a href=\"#2、https方式克隆的项目每次都提示输入用户名和密码\" class=\"headerlink\" title=\"2、https方式克隆的项目每次都提示输入用户名和密码\"></a>2、https方式克隆的项目每次都提示输入用户名和密码</h2><p>另外还有一个问题，就是当时克隆项目的时候我使用的是https的方式，并不是ssh的方式，https的好处就是告诉，而ssh的好处是安全，正因如此，使用https克隆的项目每次push、pull等操作都要提示输入用户名密码，所以我们要解决这个问题。</p>\n<p>第一步：切换到家目录 “~”</p>\n<pre><code>cd ~\n</code></pre><p>第二步：创建并编辑 .git-credentials 文件</p>\n<pre><code>touch .git-credentials\n\nvim .git-credentials\n</code></pre><p>第三步：把如下内容写入.git-credentials文件中，报错并退出</p>\n<pre><code># {username} 你的git账户名\n# {password} 你的git密码\n# example.com 你的git仓库域名\n# 例子：https://hcysunyang:12345678@github.com\n\nhttps://{username}:{password}@example.com\n</code></pre><p>第四步：执行下面的命令</p>\n<pre><code>git config --global credential.helper store\n</code></pre><p>接下来你就可以执行push、pull等操作了，但是还是会提示你输入一次账号密码的，别着急，仅此一次而已，以后就不会再让你输入了，搞定。</p>\n<h1 id=\"Ubuntu下mongodb启动失败\"><a href=\"#Ubuntu下mongodb启动失败\" class=\"headerlink\" title=\"Ubuntu下mongodb启动失败\"></a>Ubuntu下mongodb启动失败</h1><p>如下图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201512267.pic_hd.jpg\" alt=\"mongodb启动失败\"></p>\n<p>造成启动失败的原因有很多，其中最常见的就是非正常退出，下一次再启动的时候就会遇到如上情况，在Mac下或者windows下，一般我们需要把mongod.lock文件删除就可以成功重启了，但是今天在Ubuntu下却不行，在Ubuntu下记得要把mongodb-27017.sock文件也删除掉：</p>\n<pre><code>sudo rm -rf /var/lib/mongodb/mongod.lock\nsudo rm -rf /tmp/mongodb-27017.sock\n</code></pre><p>之后重启：</p>\n<pre><code>sudo service mongod start\n</code></pre><p>就可以正常启动了</p>\n<h1 id=\"nohup-命令让进程在后台运行\"><a href=\"#nohup-命令让进程在后台运行\" class=\"headerlink\" title=\"nohup 命令让进程在后台运行\"></a>nohup 命令让进程在后台运行</h1><p>当时我是使用ssh远程登录的，又不想多开窗口，所以希望node服务在后台运行，这时候可以使用nohup命令，该命令能够让进程在后台运行，nohup命令的格式如下：</p>\n<pre><code>nohup Command [ Arg ... ] [　&amp; ]\n</code></pre><p>例如我想要node的web服务在后台运行，在我的项目中可以执行下面的代码带到目的：</p>\n<pre><code>nohup node admin.js &amp;\n</code></pre><h1 id=\"Ubuntu下添加用户并赋予root权限\"><a href=\"#Ubuntu下添加用户并赋予root权限\" class=\"headerlink\" title=\"Ubuntu下添加用户并赋予root权限\"></a>Ubuntu下添加用户并赋予root权限</h1><p>在Ubuntu下可以使用 adduser 命令添加一个用户：</p>\n<pre><code>adduser &lt;username&gt;\n</code></pre><p>执行该命令之后会让你为该用户设置密码，但是这样添加的用户是没有使用root权限的用户，我们需要一些配置来赋予该用户使用root权限的能力，修改配置需要编辑 /etc/sudoers 文件，这个文件默认是只读的，所以第一步修改文件为可写：</p>\n<pre><code>chmod u+w /etc/sudoers\n</code></pre><p>然后编辑该文件：</p>\n<pre><code>sudo vim /etc/sudoers\n</code></pre><p>找到下面这句话：</p>\n<pre><code># Allow members of group sudo to execute any command\n%sudo   ALL=(ALL:ALL) ALL\n</code></pre><p>在其 %sudo   ALL=(ALL:ALL) ALL 下面再添加一行：</p>\n<pre><code>%username   ALL=(ALL:ALL) ALL\n</code></pre><p>username为你创建用户的用户名，之后保存退出，并还原 sudoers 文件只读的权限：</p>\n<pre><code>chmod u-w /etc/sudoers\n</code></pre><p>接下来新用户就可以登录并使用root权限了。</p>\n<h1 id=\"安装完Ubuntu后乱码\"><a href=\"#安装完Ubuntu后乱码\" class=\"headerlink\" title=\"安装完Ubuntu后乱码\"></a>安装完Ubuntu后乱码</h1><p>修改/etc/default/locale</p>\n<pre><code>sudo vim /etc/default/locale\n</code></pre><p>将：</p>\n<pre><code>LANG=zh_CN.UTF-8\nLANGUAGE=zh_CN:zh\n</code></pre><p>修改为：</p>\n<pre><code>LANG=&quot;en_US.UTF-8&quot;\nLANGUAGE=&quot;en_US:en&quot;\n</code></pre><p>最后reboot一下就可以了：</p>\n<pre><code>sudo reboot\n</code></pre>"},{"title":"Ubuntu连接的网络需要登陆认证后才能使用的解决办法","date":"2016-01-14T06:51:34.000Z","_content":"\n> 公司团队内部继续一台服务器，做一些对内使用的网站的部署工作，于是把旁边的一台windows电脑安装成了双系统----一个server版本的Ubuntu，但是公司的网络有个问题，就是每天早上来了都要重新登录认证，之后才能正常使用网络，一开始还好，每天早上来了先启动windows系统认证完网络之后再启动Ubuntu，这样就能正常使用，不过后来突然不好使了，于是想了个办法，使用Python写个脚本，再设一个定时任务，每天定时执行一次该脚本，从此告别网络的烦恼了，这篇文章就记了这次网络处理的过程，用到的一些东西。\n\n<!-- more -->\n\n# Ubuntu下使用U盘 #\n\n由于要执行Python脚本，而这台电脑又没有安装Python，有没有网络，所以只能有网络的电脑下载Python以及一个Python库----pycurl，然后使用U盘拷贝到这台Ubuntu下，下面介绍了Ubuntu下如果使用U盘。\n\n首先执行下面的命令，查看你的磁盘区块：\n\n```$\nls /dev/ | grep sd\n```\n\n然后插入U盘，再次执行该命令，再次查看：\n\n```$\nls /dev/ | grep sd\n```\n\n观察多出来了什么，一般会有两个，其中一个的名字比另一个多一个数字1，比如sdb和sdb1 \n\n这时候说明U盘被识别了，接下来创建挂载目录：\n\n```$\nsudo mkdir -p /mnt/usb\n```\n\n然后使用mount命令挂载（假设你的U盘为sdb和sdb1）：\n\n```$\nsudo mount /dev/sdb1 /mnt/usb\n```\n\n然后就可以使用 /mnt/usb 目录访问U盘内容了：\n\n```$\ncd /mnt/usb\nls\n```\n\n处理完你想要做的事情之后，比如我将U盘里下载好的Python和pycurl拷贝到Ubuntu上，拔出U盘之前记得卸载，执行下面的命令：\n\n```$\nsudo amount  /dev/sdb1 /mnt/usb\n```\n\n拔出U盘即可\n\n# Ubuntu编译安装软件 #\n\n在使用Linux时，很多时候我们需要编译安装软件，我安装Python也是编译安装的，借着这个就好好把Ubuntu下编译安装的一些事项介绍一下。\n\n## 1、获取源码包（tar.gz、tar.gz2、zip、tgz），并解压 ##\n\n如果有网络，我们可以通过curl下载，如果没有网络，就像我一样，使用U盘，总之，你要获取到源码包，然后解压：\n\n```$\ntar -zxvf Python-3.5.1.tgz\t// 我下载的是3.5.1版本的\n```\n\n## 2、configure ##\n\n绝大多数linux上需要源码安装的程序可以通过./configure；make；make install这三步来实现安装，而最困难的一步往往都在./configure这一步，那后面的几步是可以很轻松的完成的。\n\nconfigure是用来做下面这些事的一个脚本：\n\n>1、用以检查计算机建立包所必须的完整性；\n2、帮助你根据需要改变默认的路径；\n3、用以激活/禁用编译程序中的各种选项；\n4、用以改变程序将要被安装的路径；\n\n你可以通过执行下面的命令来查看特定configure脚本所提供的选项个功能：\n\n```$\n./configure --help | less\n```\n\n例如，默认的configure脚本会指定安装到/usr/local下面，如果你想改变路径，可以执行下面显示的configure脚本命令：\n\n```$\n./configure --PREFIX=/opt\n```\n\n如果你真的想从零开始编译，可以认真研读一下README或者INSTALL文件。你会看到需要什么样的软件碎片，比起在包系统中，在这些文件中他们通常有着不一样的名字。接下来，可以通过使用apt-cache工具来寻找相应的包。如果你已经通过仓库中编译包，那么还有一个诀窍，就是通过下面的命令来安装包的依赖：\n\n```#\nsudo apt-get build-dep <package>\n```\n\n这可以确保所有所需的包以来都可以被安装，以期configure不会由于过旧的依赖包而报错，否则你将不得不继续编译相关的依赖。\n\n寻找并修复configure的故障\n\n恰巧在下面这几种情况下，configure可能会失败：\n\n>1、编译的时候需要-dev包；\n2、要编译GNOME应用那么需要相应的gnome-level；而编译KDE应用则需要kde-level；\n3、C和C++库的名称总是以lib开头，因此，如果./configure报错说丢失了库foo，那么你需要安装libfoo-dev包；\n4、如果configure说要“X includes”，那么你可能需要安装下面这些包“xlibs-dev,xlibs-static-dev,x-window-system-dev”，注意，有时候，仅仅需要xorg-dev和x-dev就可以了。-Racecar56 Under Jaunty则需要安装xorg-dev和libx11-dev。\n5、查看哪些包被需要的技巧，可以使用auto-apt工具或者apt-file工具（auto-apt可能更快一些）：\n```$\nsudo apt-get install auto-apt\nsudo auto-apt update\nauto-apt search missing-file.h\n```\n6、如果编译软件禁用失败的选项，可以使用./configure –disable-FEATURE选项。\n7、如果你自己没能修复你遇到的问题，你也可以寻求ubuntu官方的帮助哦。\n\n如果根本不存在configure的文件，那么最好查看一下configure.ac文件（有必要认真阅读一下INSTALL和README文件），如果configure.ac文件存在，那就是开发者忘记创建最终configure文件了，你可以自己创建，不过需要autoconf包：\n\n```$\nsudo apt-get install autoconf\n```\n\n安装成功之后，键入：\n\n```$\nautoconf\n```\n\n如果幸运的话，一个可工作的configure文件应该被创建了。\n\n## 编译 ##\n\n可喜可喝，configure步骤已经完成了，真正的编译安装可以开始了。非常简单：\n\n```$\nmake\n```\n\n现在如果一切顺利的话，你应该的到了一个可工作的程序copy在你的源目录下，你可以运行下面的命令来试用一下：\n\n```\nsrc/program_name\n```\n\n如果程序这一步失败了，那么就有可能是程序的bug，这时候你最好联系一下作者，告诉他程序的问题。\n\n安装软件包\n\n如果一切进展顺利的话，你可以键入下面的命令来安装程序：\n\n```$\nsudo checkinstall\n```\n\n使用CheckInstall可以创建一个.deb包，这货稍后可以很容易被移除哦！\n\n然而，由于某些原因，你不想使用CheckInstall，这是安装的最后方法（不推荐）：\n\n```$\nsudo make install\n```\n\n# 安装Python #\n\n回到正题，安装Python，前面讲完了Ubuntu下编译安装软件的方法，那么下载安装起来就方便多了：\n\n首先在这里下载Python包 [python.tgz](https://www.python.org/getit/)。\n\n解压安装：\n\n```$\ntar -zvxf Python-3.5.1.tgz\ncd Python-3.5.1\n./configure\nsudo make\nsudo make install\n```\n\n执行python，查看是否安装成功\n\n```$\npython\n```\n\n# 安装pycurl #\n\n在这里下载资源包：[pycurl.tgz](http://pycurl.sourceforge.net/) 下载，可能需要翻墙，然后解压安装，注意，他有自己的安装方式：\n\n```$\ntar -zxvf pycurl-$VER.tar.gz\ncd pycurl-$VER\npython setup.py install\n```\n\n经过如上步骤，我们可以在这台Ubuntu上执行自动登录认证网络的Python脚本了：\n\n```$\npython xxx.py\n```\n\n# Ubuntu下开启定时任务 #\n\n在Ubuntu下开启定时任务，我们要使用到 cron，什么事cron呢？点击下面的连接了解：\n\n[cron教程](http://wiki.ubuntu.org.cn/UbuntuHelp:CronHowto/zh)\n\n上面的教程并不长，如果你读完了教程，那么看看我是怎么做的吧，首先执行下面的命令编辑crontab文件：\n\n```$\ncrontab -e\n```\n\n然后写下一下内容：\n\n```\n8 8 * * * sh ~/test/test.sh\n```\n\n上面的命令的意思是：每天早上的8点8分时，执行 tesh.sh脚本，之后保存退出（Ctrl + x  ->  y  ->  enter回车），保存退出的方式根据你使用编辑器决定，自己看吧。保存之后，执行下面的命令，启动cron服务：\n\n```$\nsudo service cron start\n```\n\n更多命令：\n\n```$\nsudo service cron stop \t\t// 停止cron服务\nsudo service cron restart \t// 重启cron服务\n```\n\n好了，从此无忧了，不用手动XXOO了。\n","source":"_posts/2016/01/14/Ubuntu连接的网络需要登陆认证后才能使用的解决办法.md","raw":"title: Ubuntu连接的网络需要登陆认证后才能使用的解决办法\ndate: 2016-01-14 14:51:34\ncategories:\n- WebFrontEnd\ntags:\n- Ubuntu\n- python\n- pycurl\n---\n\n> 公司团队内部继续一台服务器，做一些对内使用的网站的部署工作，于是把旁边的一台windows电脑安装成了双系统----一个server版本的Ubuntu，但是公司的网络有个问题，就是每天早上来了都要重新登录认证，之后才能正常使用网络，一开始还好，每天早上来了先启动windows系统认证完网络之后再启动Ubuntu，这样就能正常使用，不过后来突然不好使了，于是想了个办法，使用Python写个脚本，再设一个定时任务，每天定时执行一次该脚本，从此告别网络的烦恼了，这篇文章就记了这次网络处理的过程，用到的一些东西。\n\n<!-- more -->\n\n# Ubuntu下使用U盘 #\n\n由于要执行Python脚本，而这台电脑又没有安装Python，有没有网络，所以只能有网络的电脑下载Python以及一个Python库----pycurl，然后使用U盘拷贝到这台Ubuntu下，下面介绍了Ubuntu下如果使用U盘。\n\n首先执行下面的命令，查看你的磁盘区块：\n\n```$\nls /dev/ | grep sd\n```\n\n然后插入U盘，再次执行该命令，再次查看：\n\n```$\nls /dev/ | grep sd\n```\n\n观察多出来了什么，一般会有两个，其中一个的名字比另一个多一个数字1，比如sdb和sdb1 \n\n这时候说明U盘被识别了，接下来创建挂载目录：\n\n```$\nsudo mkdir -p /mnt/usb\n```\n\n然后使用mount命令挂载（假设你的U盘为sdb和sdb1）：\n\n```$\nsudo mount /dev/sdb1 /mnt/usb\n```\n\n然后就可以使用 /mnt/usb 目录访问U盘内容了：\n\n```$\ncd /mnt/usb\nls\n```\n\n处理完你想要做的事情之后，比如我将U盘里下载好的Python和pycurl拷贝到Ubuntu上，拔出U盘之前记得卸载，执行下面的命令：\n\n```$\nsudo amount  /dev/sdb1 /mnt/usb\n```\n\n拔出U盘即可\n\n# Ubuntu编译安装软件 #\n\n在使用Linux时，很多时候我们需要编译安装软件，我安装Python也是编译安装的，借着这个就好好把Ubuntu下编译安装的一些事项介绍一下。\n\n## 1、获取源码包（tar.gz、tar.gz2、zip、tgz），并解压 ##\n\n如果有网络，我们可以通过curl下载，如果没有网络，就像我一样，使用U盘，总之，你要获取到源码包，然后解压：\n\n```$\ntar -zxvf Python-3.5.1.tgz\t// 我下载的是3.5.1版本的\n```\n\n## 2、configure ##\n\n绝大多数linux上需要源码安装的程序可以通过./configure；make；make install这三步来实现安装，而最困难的一步往往都在./configure这一步，那后面的几步是可以很轻松的完成的。\n\nconfigure是用来做下面这些事的一个脚本：\n\n>1、用以检查计算机建立包所必须的完整性；\n2、帮助你根据需要改变默认的路径；\n3、用以激活/禁用编译程序中的各种选项；\n4、用以改变程序将要被安装的路径；\n\n你可以通过执行下面的命令来查看特定configure脚本所提供的选项个功能：\n\n```$\n./configure --help | less\n```\n\n例如，默认的configure脚本会指定安装到/usr/local下面，如果你想改变路径，可以执行下面显示的configure脚本命令：\n\n```$\n./configure --PREFIX=/opt\n```\n\n如果你真的想从零开始编译，可以认真研读一下README或者INSTALL文件。你会看到需要什么样的软件碎片，比起在包系统中，在这些文件中他们通常有着不一样的名字。接下来，可以通过使用apt-cache工具来寻找相应的包。如果你已经通过仓库中编译包，那么还有一个诀窍，就是通过下面的命令来安装包的依赖：\n\n```#\nsudo apt-get build-dep <package>\n```\n\n这可以确保所有所需的包以来都可以被安装，以期configure不会由于过旧的依赖包而报错，否则你将不得不继续编译相关的依赖。\n\n寻找并修复configure的故障\n\n恰巧在下面这几种情况下，configure可能会失败：\n\n>1、编译的时候需要-dev包；\n2、要编译GNOME应用那么需要相应的gnome-level；而编译KDE应用则需要kde-level；\n3、C和C++库的名称总是以lib开头，因此，如果./configure报错说丢失了库foo，那么你需要安装libfoo-dev包；\n4、如果configure说要“X includes”，那么你可能需要安装下面这些包“xlibs-dev,xlibs-static-dev,x-window-system-dev”，注意，有时候，仅仅需要xorg-dev和x-dev就可以了。-Racecar56 Under Jaunty则需要安装xorg-dev和libx11-dev。\n5、查看哪些包被需要的技巧，可以使用auto-apt工具或者apt-file工具（auto-apt可能更快一些）：\n```$\nsudo apt-get install auto-apt\nsudo auto-apt update\nauto-apt search missing-file.h\n```\n6、如果编译软件禁用失败的选项，可以使用./configure –disable-FEATURE选项。\n7、如果你自己没能修复你遇到的问题，你也可以寻求ubuntu官方的帮助哦。\n\n如果根本不存在configure的文件，那么最好查看一下configure.ac文件（有必要认真阅读一下INSTALL和README文件），如果configure.ac文件存在，那就是开发者忘记创建最终configure文件了，你可以自己创建，不过需要autoconf包：\n\n```$\nsudo apt-get install autoconf\n```\n\n安装成功之后，键入：\n\n```$\nautoconf\n```\n\n如果幸运的话，一个可工作的configure文件应该被创建了。\n\n## 编译 ##\n\n可喜可喝，configure步骤已经完成了，真正的编译安装可以开始了。非常简单：\n\n```$\nmake\n```\n\n现在如果一切顺利的话，你应该的到了一个可工作的程序copy在你的源目录下，你可以运行下面的命令来试用一下：\n\n```\nsrc/program_name\n```\n\n如果程序这一步失败了，那么就有可能是程序的bug，这时候你最好联系一下作者，告诉他程序的问题。\n\n安装软件包\n\n如果一切进展顺利的话，你可以键入下面的命令来安装程序：\n\n```$\nsudo checkinstall\n```\n\n使用CheckInstall可以创建一个.deb包，这货稍后可以很容易被移除哦！\n\n然而，由于某些原因，你不想使用CheckInstall，这是安装的最后方法（不推荐）：\n\n```$\nsudo make install\n```\n\n# 安装Python #\n\n回到正题，安装Python，前面讲完了Ubuntu下编译安装软件的方法，那么下载安装起来就方便多了：\n\n首先在这里下载Python包 [python.tgz](https://www.python.org/getit/)。\n\n解压安装：\n\n```$\ntar -zvxf Python-3.5.1.tgz\ncd Python-3.5.1\n./configure\nsudo make\nsudo make install\n```\n\n执行python，查看是否安装成功\n\n```$\npython\n```\n\n# 安装pycurl #\n\n在这里下载资源包：[pycurl.tgz](http://pycurl.sourceforge.net/) 下载，可能需要翻墙，然后解压安装，注意，他有自己的安装方式：\n\n```$\ntar -zxvf pycurl-$VER.tar.gz\ncd pycurl-$VER\npython setup.py install\n```\n\n经过如上步骤，我们可以在这台Ubuntu上执行自动登录认证网络的Python脚本了：\n\n```$\npython xxx.py\n```\n\n# Ubuntu下开启定时任务 #\n\n在Ubuntu下开启定时任务，我们要使用到 cron，什么事cron呢？点击下面的连接了解：\n\n[cron教程](http://wiki.ubuntu.org.cn/UbuntuHelp:CronHowto/zh)\n\n上面的教程并不长，如果你读完了教程，那么看看我是怎么做的吧，首先执行下面的命令编辑crontab文件：\n\n```$\ncrontab -e\n```\n\n然后写下一下内容：\n\n```\n8 8 * * * sh ~/test/test.sh\n```\n\n上面的命令的意思是：每天早上的8点8分时，执行 tesh.sh脚本，之后保存退出（Ctrl + x  ->  y  ->  enter回车），保存退出的方式根据你使用编辑器决定，自己看吧。保存之后，执行下面的命令，启动cron服务：\n\n```$\nsudo service cron start\n```\n\n更多命令：\n\n```$\nsudo service cron stop \t\t// 停止cron服务\nsudo service cron restart \t// 重启cron服务\n```\n\n好了，从此无忧了，不用手动XXOO了。\n","slug":"Ubuntu连接的网络需要登陆认证后才能使用的解决办法","published":1,"updated":"2016-01-14T10:58:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj669fsk00018ewfc864avg3o","content":"<blockquote>\n<p>公司团队内部继续一台服务器，做一些对内使用的网站的部署工作，于是把旁边的一台windows电脑安装成了双系统—-一个server版本的Ubuntu，但是公司的网络有个问题，就是每天早上来了都要重新登录认证，之后才能正常使用网络，一开始还好，每天早上来了先启动windows系统认证完网络之后再启动Ubuntu，这样就能正常使用，不过后来突然不好使了，于是想了个办法，使用Python写个脚本，再设一个定时任务，每天定时执行一次该脚本，从此告别网络的烦恼了，这篇文章就记了这次网络处理的过程，用到的一些东西。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h1 id=\"Ubuntu下使用U盘\"><a href=\"#Ubuntu下使用U盘\" class=\"headerlink\" title=\"Ubuntu下使用U盘\"></a>Ubuntu下使用U盘</h1><p>由于要执行Python脚本，而这台电脑又没有安装Python，有没有网络，所以只能有网络的电脑下载Python以及一个Python库—-pycurl，然后使用U盘拷贝到这台Ubuntu下，下面介绍了Ubuntu下如果使用U盘。</p>\n<p>首先执行下面的命令，查看你的磁盘区块：</p>\n<pre><code class=\"$\">ls /dev/ | grep sd\n</code></pre>\n<p>然后插入U盘，再次执行该命令，再次查看：</p>\n<pre><code class=\"$\">ls /dev/ | grep sd\n</code></pre>\n<p>观察多出来了什么，一般会有两个，其中一个的名字比另一个多一个数字1，比如sdb和sdb1 </p>\n<p>这时候说明U盘被识别了，接下来创建挂载目录：</p>\n<pre><code class=\"$\">sudo mkdir -p /mnt/usb\n</code></pre>\n<p>然后使用mount命令挂载（假设你的U盘为sdb和sdb1）：</p>\n<pre><code class=\"$\">sudo mount /dev/sdb1 /mnt/usb\n</code></pre>\n<p>然后就可以使用 /mnt/usb 目录访问U盘内容了：</p>\n<pre><code class=\"$\">cd /mnt/usb\nls\n</code></pre>\n<p>处理完你想要做的事情之后，比如我将U盘里下载好的Python和pycurl拷贝到Ubuntu上，拔出U盘之前记得卸载，执行下面的命令：</p>\n<pre><code class=\"$\">sudo amount  /dev/sdb1 /mnt/usb\n</code></pre>\n<p>拔出U盘即可</p>\n<h1 id=\"Ubuntu编译安装软件\"><a href=\"#Ubuntu编译安装软件\" class=\"headerlink\" title=\"Ubuntu编译安装软件\"></a>Ubuntu编译安装软件</h1><p>在使用Linux时，很多时候我们需要编译安装软件，我安装Python也是编译安装的，借着这个就好好把Ubuntu下编译安装的一些事项介绍一下。</p>\n<h2 id=\"1、获取源码包（tar-gz、tar-gz2、zip、tgz），并解压\"><a href=\"#1、获取源码包（tar-gz、tar-gz2、zip、tgz），并解压\" class=\"headerlink\" title=\"1、获取源码包（tar.gz、tar.gz2、zip、tgz），并解压\"></a>1、获取源码包（tar.gz、tar.gz2、zip、tgz），并解压</h2><p>如果有网络，我们可以通过curl下载，如果没有网络，就像我一样，使用U盘，总之，你要获取到源码包，然后解压：</p>\n<pre><code class=\"$\">tar -zxvf Python-3.5.1.tgz    // 我下载的是3.5.1版本的\n</code></pre>\n<h2 id=\"2、configure\"><a href=\"#2、configure\" class=\"headerlink\" title=\"2、configure\"></a>2、configure</h2><p>绝大多数linux上需要源码安装的程序可以通过./configure；make；make install这三步来实现安装，而最困难的一步往往都在./configure这一步，那后面的几步是可以很轻松的完成的。</p>\n<p>configure是用来做下面这些事的一个脚本：</p>\n<blockquote>\n<p>1、用以检查计算机建立包所必须的完整性；<br>2、帮助你根据需要改变默认的路径；<br>3、用以激活/禁用编译程序中的各种选项；<br>4、用以改变程序将要被安装的路径；</p>\n</blockquote>\n<p>你可以通过执行下面的命令来查看特定configure脚本所提供的选项个功能：</p>\n<pre><code class=\"$\">./configure --help | less\n</code></pre>\n<p>例如，默认的configure脚本会指定安装到/usr/local下面，如果你想改变路径，可以执行下面显示的configure脚本命令：</p>\n<pre><code class=\"$\">./configure --PREFIX=/opt\n</code></pre>\n<p>如果你真的想从零开始编译，可以认真研读一下README或者INSTALL文件。你会看到需要什么样的软件碎片，比起在包系统中，在这些文件中他们通常有着不一样的名字。接下来，可以通过使用apt-cache工具来寻找相应的包。如果你已经通过仓库中编译包，那么还有一个诀窍，就是通过下面的命令来安装包的依赖：</p>\n<pre><code class=\"#\">sudo apt-get build-dep &lt;package&gt;\n</code></pre>\n<p>这可以确保所有所需的包以来都可以被安装，以期configure不会由于过旧的依赖包而报错，否则你将不得不继续编译相关的依赖。</p>\n<p>寻找并修复configure的故障</p>\n<p>恰巧在下面这几种情况下，configure可能会失败：</p>\n<blockquote>\n<p>1、编译的时候需要-dev包；<br>2、要编译GNOME应用那么需要相应的gnome-level；而编译KDE应用则需要kde-level；<br>3、C和C++库的名称总是以lib开头，因此，如果./configure报错说丢失了库foo，那么你需要安装libfoo-dev包；<br>4、如果configure说要“X includes”，那么你可能需要安装下面这些包“xlibs-dev,xlibs-static-dev,x-window-system-dev”，注意，有时候，仅仅需要xorg-dev和x-dev就可以了。-Racecar56 Under Jaunty则需要安装xorg-dev和libx11-dev。<br>5、查看哪些包被需要的技巧，可以使用auto-apt工具或者apt-file工具（auto-apt可能更快一些）：</p>\n<pre><code class=\"$\">sudo apt-get install auto-apt\nsudo auto-apt update\nauto-apt search missing-file.h\n</code></pre>\n<p>6、如果编译软件禁用失败的选项，可以使用./configure –disable-FEATURE选项。<br>7、如果你自己没能修复你遇到的问题，你也可以寻求ubuntu官方的帮助哦。</p>\n</blockquote>\n<p>如果根本不存在configure的文件，那么最好查看一下configure.ac文件（有必要认真阅读一下INSTALL和README文件），如果configure.ac文件存在，那就是开发者忘记创建最终configure文件了，你可以自己创建，不过需要autoconf包：</p>\n<pre><code class=\"$\">sudo apt-get install autoconf\n</code></pre>\n<p>安装成功之后，键入：</p>\n<pre><code class=\"$\">autoconf\n</code></pre>\n<p>如果幸运的话，一个可工作的configure文件应该被创建了。</p>\n<h2 id=\"编译\"><a href=\"#编译\" class=\"headerlink\" title=\"编译\"></a>编译</h2><p>可喜可喝，configure步骤已经完成了，真正的编译安装可以开始了。非常简单：</p>\n<pre><code class=\"$\">make\n</code></pre>\n<p>现在如果一切顺利的话，你应该的到了一个可工作的程序copy在你的源目录下，你可以运行下面的命令来试用一下：</p>\n<pre><code>src/program_name\n</code></pre><p>如果程序这一步失败了，那么就有可能是程序的bug，这时候你最好联系一下作者，告诉他程序的问题。</p>\n<p>安装软件包</p>\n<p>如果一切进展顺利的话，你可以键入下面的命令来安装程序：</p>\n<pre><code class=\"$\">sudo checkinstall\n</code></pre>\n<p>使用CheckInstall可以创建一个.deb包，这货稍后可以很容易被移除哦！</p>\n<p>然而，由于某些原因，你不想使用CheckInstall，这是安装的最后方法（不推荐）：</p>\n<pre><code class=\"$\">sudo make install\n</code></pre>\n<h1 id=\"安装Python\"><a href=\"#安装Python\" class=\"headerlink\" title=\"安装Python\"></a>安装Python</h1><p>回到正题，安装Python，前面讲完了Ubuntu下编译安装软件的方法，那么下载安装起来就方便多了：</p>\n<p>首先在这里下载Python包 <a href=\"https://www.python.org/getit/\" target=\"_blank\" rel=\"external\">python.tgz</a>。</p>\n<p>解压安装：</p>\n<pre><code class=\"$\">tar -zvxf Python-3.5.1.tgz\ncd Python-3.5.1\n./configure\nsudo make\nsudo make install\n</code></pre>\n<p>执行python，查看是否安装成功</p>\n<pre><code class=\"$\">python\n</code></pre>\n<h1 id=\"安装pycurl\"><a href=\"#安装pycurl\" class=\"headerlink\" title=\"安装pycurl\"></a>安装pycurl</h1><p>在这里下载资源包：<a href=\"http://pycurl.sourceforge.net/\" target=\"_blank\" rel=\"external\">pycurl.tgz</a> 下载，可能需要翻墙，然后解压安装，注意，他有自己的安装方式：</p>\n<pre><code class=\"$\">tar -zxvf pycurl-$VER.tar.gz\ncd pycurl-$VER\npython setup.py install\n</code></pre>\n<p>经过如上步骤，我们可以在这台Ubuntu上执行自动登录认证网络的Python脚本了：</p>\n<pre><code class=\"$\">python xxx.py\n</code></pre>\n<h1 id=\"Ubuntu下开启定时任务\"><a href=\"#Ubuntu下开启定时任务\" class=\"headerlink\" title=\"Ubuntu下开启定时任务\"></a>Ubuntu下开启定时任务</h1><p>在Ubuntu下开启定时任务，我们要使用到 cron，什么事cron呢？点击下面的连接了解：</p>\n<p><a href=\"http://wiki.ubuntu.org.cn/UbuntuHelp:CronHowto/zh\" target=\"_blank\" rel=\"external\">cron教程</a></p>\n<p>上面的教程并不长，如果你读完了教程，那么看看我是怎么做的吧，首先执行下面的命令编辑crontab文件：</p>\n<pre><code class=\"$\">crontab -e\n</code></pre>\n<p>然后写下一下内容：</p>\n<pre><code>8 8 * * * sh ~/test/test.sh\n</code></pre><p>上面的命令的意思是：每天早上的8点8分时，执行 tesh.sh脚本，之后保存退出（Ctrl + x  -&gt;  y  -&gt;  enter回车），保存退出的方式根据你使用编辑器决定，自己看吧。保存之后，执行下面的命令，启动cron服务：</p>\n<pre><code class=\"$\">sudo service cron start\n</code></pre>\n<p>更多命令：</p>\n<pre><code class=\"$\">sudo service cron stop         // 停止cron服务\nsudo service cron restart     // 重启cron服务\n</code></pre>\n<p>好了，从此无忧了，不用手动XXOO了。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>公司团队内部继续一台服务器，做一些对内使用的网站的部署工作，于是把旁边的一台windows电脑安装成了双系统—-一个server版本的Ubuntu，但是公司的网络有个问题，就是每天早上来了都要重新登录认证，之后才能正常使用网络，一开始还好，每天早上来了先启动windows系统认证完网络之后再启动Ubuntu，这样就能正常使用，不过后来突然不好使了，于是想了个办法，使用Python写个脚本，再设一个定时任务，每天定时执行一次该脚本，从此告别网络的烦恼了，这篇文章就记了这次网络处理的过程，用到的一些东西。</p>\n</blockquote>","more":"<h1 id=\"Ubuntu下使用U盘\"><a href=\"#Ubuntu下使用U盘\" class=\"headerlink\" title=\"Ubuntu下使用U盘\"></a>Ubuntu下使用U盘</h1><p>由于要执行Python脚本，而这台电脑又没有安装Python，有没有网络，所以只能有网络的电脑下载Python以及一个Python库—-pycurl，然后使用U盘拷贝到这台Ubuntu下，下面介绍了Ubuntu下如果使用U盘。</p>\n<p>首先执行下面的命令，查看你的磁盘区块：</p>\n<pre><code class=\"$\">ls /dev/ | grep sd\n</code></pre>\n<p>然后插入U盘，再次执行该命令，再次查看：</p>\n<pre><code class=\"$\">ls /dev/ | grep sd\n</code></pre>\n<p>观察多出来了什么，一般会有两个，其中一个的名字比另一个多一个数字1，比如sdb和sdb1 </p>\n<p>这时候说明U盘被识别了，接下来创建挂载目录：</p>\n<pre><code class=\"$\">sudo mkdir -p /mnt/usb\n</code></pre>\n<p>然后使用mount命令挂载（假设你的U盘为sdb和sdb1）：</p>\n<pre><code class=\"$\">sudo mount /dev/sdb1 /mnt/usb\n</code></pre>\n<p>然后就可以使用 /mnt/usb 目录访问U盘内容了：</p>\n<pre><code class=\"$\">cd /mnt/usb\nls\n</code></pre>\n<p>处理完你想要做的事情之后，比如我将U盘里下载好的Python和pycurl拷贝到Ubuntu上，拔出U盘之前记得卸载，执行下面的命令：</p>\n<pre><code class=\"$\">sudo amount  /dev/sdb1 /mnt/usb\n</code></pre>\n<p>拔出U盘即可</p>\n<h1 id=\"Ubuntu编译安装软件\"><a href=\"#Ubuntu编译安装软件\" class=\"headerlink\" title=\"Ubuntu编译安装软件\"></a>Ubuntu编译安装软件</h1><p>在使用Linux时，很多时候我们需要编译安装软件，我安装Python也是编译安装的，借着这个就好好把Ubuntu下编译安装的一些事项介绍一下。</p>\n<h2 id=\"1、获取源码包（tar-gz、tar-gz2、zip、tgz），并解压\"><a href=\"#1、获取源码包（tar-gz、tar-gz2、zip、tgz），并解压\" class=\"headerlink\" title=\"1、获取源码包（tar.gz、tar.gz2、zip、tgz），并解压\"></a>1、获取源码包（tar.gz、tar.gz2、zip、tgz），并解压</h2><p>如果有网络，我们可以通过curl下载，如果没有网络，就像我一样，使用U盘，总之，你要获取到源码包，然后解压：</p>\n<pre><code class=\"$\">tar -zxvf Python-3.5.1.tgz    // 我下载的是3.5.1版本的\n</code></pre>\n<h2 id=\"2、configure\"><a href=\"#2、configure\" class=\"headerlink\" title=\"2、configure\"></a>2、configure</h2><p>绝大多数linux上需要源码安装的程序可以通过./configure；make；make install这三步来实现安装，而最困难的一步往往都在./configure这一步，那后面的几步是可以很轻松的完成的。</p>\n<p>configure是用来做下面这些事的一个脚本：</p>\n<blockquote>\n<p>1、用以检查计算机建立包所必须的完整性；<br>2、帮助你根据需要改变默认的路径；<br>3、用以激活/禁用编译程序中的各种选项；<br>4、用以改变程序将要被安装的路径；</p>\n</blockquote>\n<p>你可以通过执行下面的命令来查看特定configure脚本所提供的选项个功能：</p>\n<pre><code class=\"$\">./configure --help | less\n</code></pre>\n<p>例如，默认的configure脚本会指定安装到/usr/local下面，如果你想改变路径，可以执行下面显示的configure脚本命令：</p>\n<pre><code class=\"$\">./configure --PREFIX=/opt\n</code></pre>\n<p>如果你真的想从零开始编译，可以认真研读一下README或者INSTALL文件。你会看到需要什么样的软件碎片，比起在包系统中，在这些文件中他们通常有着不一样的名字。接下来，可以通过使用apt-cache工具来寻找相应的包。如果你已经通过仓库中编译包，那么还有一个诀窍，就是通过下面的命令来安装包的依赖：</p>\n<pre><code class=\"#\">sudo apt-get build-dep &lt;package&gt;\n</code></pre>\n<p>这可以确保所有所需的包以来都可以被安装，以期configure不会由于过旧的依赖包而报错，否则你将不得不继续编译相关的依赖。</p>\n<p>寻找并修复configure的故障</p>\n<p>恰巧在下面这几种情况下，configure可能会失败：</p>\n<blockquote>\n<p>1、编译的时候需要-dev包；<br>2、要编译GNOME应用那么需要相应的gnome-level；而编译KDE应用则需要kde-level；<br>3、C和C++库的名称总是以lib开头，因此，如果./configure报错说丢失了库foo，那么你需要安装libfoo-dev包；<br>4、如果configure说要“X includes”，那么你可能需要安装下面这些包“xlibs-dev,xlibs-static-dev,x-window-system-dev”，注意，有时候，仅仅需要xorg-dev和x-dev就可以了。-Racecar56 Under Jaunty则需要安装xorg-dev和libx11-dev。<br>5、查看哪些包被需要的技巧，可以使用auto-apt工具或者apt-file工具（auto-apt可能更快一些）：</p>\n<pre><code class=\"$\">sudo apt-get install auto-apt\nsudo auto-apt update\nauto-apt search missing-file.h\n</code></pre>\n<p>6、如果编译软件禁用失败的选项，可以使用./configure –disable-FEATURE选项。<br>7、如果你自己没能修复你遇到的问题，你也可以寻求ubuntu官方的帮助哦。</p>\n</blockquote>\n<p>如果根本不存在configure的文件，那么最好查看一下configure.ac文件（有必要认真阅读一下INSTALL和README文件），如果configure.ac文件存在，那就是开发者忘记创建最终configure文件了，你可以自己创建，不过需要autoconf包：</p>\n<pre><code class=\"$\">sudo apt-get install autoconf\n</code></pre>\n<p>安装成功之后，键入：</p>\n<pre><code class=\"$\">autoconf\n</code></pre>\n<p>如果幸运的话，一个可工作的configure文件应该被创建了。</p>\n<h2 id=\"编译\"><a href=\"#编译\" class=\"headerlink\" title=\"编译\"></a>编译</h2><p>可喜可喝，configure步骤已经完成了，真正的编译安装可以开始了。非常简单：</p>\n<pre><code class=\"$\">make\n</code></pre>\n<p>现在如果一切顺利的话，你应该的到了一个可工作的程序copy在你的源目录下，你可以运行下面的命令来试用一下：</p>\n<pre><code>src/program_name\n</code></pre><p>如果程序这一步失败了，那么就有可能是程序的bug，这时候你最好联系一下作者，告诉他程序的问题。</p>\n<p>安装软件包</p>\n<p>如果一切进展顺利的话，你可以键入下面的命令来安装程序：</p>\n<pre><code class=\"$\">sudo checkinstall\n</code></pre>\n<p>使用CheckInstall可以创建一个.deb包，这货稍后可以很容易被移除哦！</p>\n<p>然而，由于某些原因，你不想使用CheckInstall，这是安装的最后方法（不推荐）：</p>\n<pre><code class=\"$\">sudo make install\n</code></pre>\n<h1 id=\"安装Python\"><a href=\"#安装Python\" class=\"headerlink\" title=\"安装Python\"></a>安装Python</h1><p>回到正题，安装Python，前面讲完了Ubuntu下编译安装软件的方法，那么下载安装起来就方便多了：</p>\n<p>首先在这里下载Python包 <a href=\"https://www.python.org/getit/\" target=\"_blank\" rel=\"external\">python.tgz</a>。</p>\n<p>解压安装：</p>\n<pre><code class=\"$\">tar -zvxf Python-3.5.1.tgz\ncd Python-3.5.1\n./configure\nsudo make\nsudo make install\n</code></pre>\n<p>执行python，查看是否安装成功</p>\n<pre><code class=\"$\">python\n</code></pre>\n<h1 id=\"安装pycurl\"><a href=\"#安装pycurl\" class=\"headerlink\" title=\"安装pycurl\"></a>安装pycurl</h1><p>在这里下载资源包：<a href=\"http://pycurl.sourceforge.net/\" target=\"_blank\" rel=\"external\">pycurl.tgz</a> 下载，可能需要翻墙，然后解压安装，注意，他有自己的安装方式：</p>\n<pre><code class=\"$\">tar -zxvf pycurl-$VER.tar.gz\ncd pycurl-$VER\npython setup.py install\n</code></pre>\n<p>经过如上步骤，我们可以在这台Ubuntu上执行自动登录认证网络的Python脚本了：</p>\n<pre><code class=\"$\">python xxx.py\n</code></pre>\n<h1 id=\"Ubuntu下开启定时任务\"><a href=\"#Ubuntu下开启定时任务\" class=\"headerlink\" title=\"Ubuntu下开启定时任务\"></a>Ubuntu下开启定时任务</h1><p>在Ubuntu下开启定时任务，我们要使用到 cron，什么事cron呢？点击下面的连接了解：</p>\n<p><a href=\"http://wiki.ubuntu.org.cn/UbuntuHelp:CronHowto/zh\" target=\"_blank\" rel=\"external\">cron教程</a></p>\n<p>上面的教程并不长，如果你读完了教程，那么看看我是怎么做的吧，首先执行下面的命令编辑crontab文件：</p>\n<pre><code class=\"$\">crontab -e\n</code></pre>\n<p>然后写下一下内容：</p>\n<pre><code>8 8 * * * sh ~/test/test.sh\n</code></pre><p>上面的命令的意思是：每天早上的8点8分时，执行 tesh.sh脚本，之后保存退出（Ctrl + x  -&gt;  y  -&gt;  enter回车），保存退出的方式根据你使用编辑器决定，自己看吧。保存之后，执行下面的命令，启动cron服务：</p>\n<pre><code class=\"$\">sudo service cron start\n</code></pre>\n<p>更多命令：</p>\n<pre><code class=\"$\">sudo service cron stop         // 停止cron服务\nsudo service cron restart     // 重启cron服务\n</code></pre>\n<p>好了，从此无忧了，不用手动XXOO了。</p>"},{"title":"使用gulp实现项目模板化","date":"2016-01-06T07:30:32.000Z","_content":"\n> 当一个大项目逐渐成型，或者一个框架又或者一个开发方式逐渐成型的时候，总会有一个所谓的“套路”，我们在工作中往往遵循着这个套路走。所以更换一家公司或者一个部门团队的时候，上手项目并不难，你只需要掌握这个团队管用的“套路”就ok了，关键是：要想办法优化这个“套路”。\n\n<!-- more -->\n\n之前一直在做内部框架的跨平台和自动化构建的事，加上开发业务逻辑的页面已经完成，就没去优化这个开发套路，什么套路呢？当项目中需要一个新的H5页面的时候，就需要手动去copy之前的一个页面代码，然后逐个修改，改成另外一个页面。去掉代码中的业务逻辑，会发现除了名称不同，其余的代码全部相同，秉承着“上级命令一定要完成”总宗旨，非也，是秉承着“我是一个程序员”的宗旨，就应该将一切需要手工完成的工作变成自动化的。所以......所以就不吹NB了，好好写......\n\n一个古老的思路是，你应该有一套模板，当有新的页面需要开发的时候，只需一条命令或者一个按钮就可以自动帮你基于这套模板创建一个可直接用于开发的环境。为了达成这个目的，我是用到了：\n\n1.gulp\n\ngulp的教程这里就不写了，这里讲的很清楚 [gulp教程](http://www.gulpjs.com.cn/docs/api/)\n\n2.该功能主要使用到的gulp插件\n\n[gulp-load-plugins](https://www.npmjs.com/package/gulp-load-plugins) 加载gulp插件的插件\n\n[gulp-file-include](https://www.npmjs.com/package/gulp-file-include) 文件包含插件\n\n[gulp-data](https://www.npmjs.com/package/gulp-data) 提供数据，该数据可被其他gulp插件使用\n\n[gulp-rename](https://www.npmjs.com/package/gulp-rename) 重命名文件\n\n[gulp-template](https://www.npmjs.com/package/gulp-template) 渲染模板\n\n上面的插件连接，点击进去就是文档。\n\n笔者认为最好的学习方式就是有一个能运行起来的项目，然后看着代码一步步走，所以我把模板化从公司的项目中抽离出来，并做了删减，提炼出一个完整的可运行的项目，并放在我的git仓库，可以运行一下命令查看效果，调试并学习：\n\n```\ngit clone git@github.com:HcySunYang/modapp.git\n\nnpm install\n\ngulp createapp --name=aaa\n```\n\n下面是gulpfile.js文件和package.json文件\n\n# gulpfile.js #\n\n```\nvar gulp = require('gulp');\nvar gulpLoadPlugins = require(\"gulp-load-plugins\");\nvar plugins = gulpLoadPlugins();\nvar util     = require(\"gulp-util\");\nvar devPath = './html';\nvar appData = {};\n\n/*\n * @desc 组装模板\n * @src  devPath \n * @deps \n * @dest devPath + '/tmod/app/dest'\n */\ngulp.task('includeTpl',function () {\n    // 获取 gulp 命令的 --name参数的值 （gulp createapp --name=aaa）\n    var appName = util.env.name || 'special';\n    \n    // 首字母大写\n    var appNameBig = appName.replace((/\\w/), function(char){\n        return char.toUpperCase();\n    });\n\n    appData={\n        app: appName,\n        appapi: appNameBig,\n        appDo: appName + \"Do\",\n        title: appName\n    }\n    return gulp.src([\n            devPath + '/tmod/app/app.tpl',\n            devPath + '/tmod/app/appDo.tpl',\n            devPath + '/tmod/app/app.html',\n            devPath + '/tmod/app/appApi.tpl',\n            devPath + '/tmod/app/appapiInterFace.tpl'\n        ])\n        .pipe(plugins.fileInclude({\n            prefix: '@@',\n            basepath: '@file'\n        }))\n        .pipe(gulp.dest(devPath + '/tmod/app/dest'));\n});\n\n/*\n * @desc 解析模板\n * @src  devPath \n * @deps includeTpl\n * @dest devPath + '/tmod/app/dest'\n */\ngulp.task('resolveTpl',[\"includeTpl\"],function () {\n    return gulp.src([\n            devPath + '/tmod/app/dest/app.tpl',\n            devPath + '/tmod/app/dest/appDo.tpl',\n            devPath + '/tmod/app/dest/app.html',\n            devPath + '/tmod/app/dest/appApi.tpl',\n            devPath + '/tmod/app/dest/appapiInterFace.tpl'\n        ])\n        .pipe(plugins.data(function () {\n            return {app: appData.app, appDo:appData.appDo,title:appData.title, appapi : appData.appapi};\n        }))\n        .pipe(plugins.template())\n        .pipe(gulp.dest(devPath + '/tmod/app/dest'));\n});\n\n/*\n * @desc 创建部署\n * @src  devPath + '/tmod/app/dest \n * @deps resolveTpl\n * @dest devPath + '/modules/'\n */\ngulp.task('createapp', [\"resolveTpl\"], function () {\n    // 创建部署入口js文件，如 index.js\n    gulp.src(devPath + '/tmod/app/dest/app.tpl')\n        .pipe(plugins.rename({\n            basename: appData.app,\n            extname: \".js\"\n        }))\n        .pipe(gulp.dest(devPath + '/target/'+appData.app));\n\n    // 创建部署业务逻辑js文件，如 indexDo.js\n    gulp.src(devPath + '/tmod/app/dest/appDo.tpl')\n        .pipe(plugins.rename({\n            basename: appData.appDo,\n            extname: \".js\"\n        }))\n        .pipe(gulp.dest(devPath + '/target/'+appData.app));\n\n    // 创建部署html页面文件，如 index.html\n    gulp.src([devPath + '/tmod/app/dest/*.html'])\n        .pipe(plugins.rename({\n            basename: appData.app,\n            extname: \".html\"\n        }))\n        .pipe(gulp.dest(devPath + '/target/'+appData.app));\n\n    // 创建部署api接口js文件，如 indexApi.js\n    gulp.src(devPath + '/tmod/app/dest/appApi.tpl')\n        .pipe(plugins.rename({\n            basename: appData.app + 'Api',\n            extname: \".js\"\n        }))\n        .pipe(gulp.dest(devPath + '/target/clientApi'));\n\n    // 创建部署跨平台接口js文件，如 indexapiInterFace.js\n    gulp.src(devPath + '/tmod/app/dest/appapiInterFace.tpl')\n        .pipe(plugins.rename({\n            basename: appData.app + 'apiInterFace',\n            extname: \".js\"\n        }))\n        .pipe(gulp.dest(devPath + '/target/clientApi'));\n});\n\n```\n\n# package.json #\n\n```\n{\n  \"name\": \"app\",\n  \"project\": \"app\",\n  \"version\": \"1.0.0\",\n  \"host\": \"http://10.0.69.79\",\n  \"path\": \"/home/huangjian/workstation/bridge/newssdk/bin\",\n  \"devDependencies\": {\n    \"gulp\": \"^3.9.0\",\n    \"gulp-data\": \"^1.2.0\",\n    \"gulp-file-include\": \"^0.13.7\",\n    \"gulp-load-plugins\": \"^0.10.0\",\n    \"gulp-rename\": \"^1.2.0\",\n    \"gulp-template\": \"^2.1.0\",\n    \"gulp-util\": \"^3.0.6\"\n  }\n}\n\n```\n\n大家重在研究代码的思路和各个组件的用法及配合，不要去研究代码的细节，比如这个构建出来的项目有什么用啊？当然对于你来说没什么用，因为这个是应用在公司项目中的，这个是为了给大家方便，抽离出来的，所以大家把握好重点。\n\n\n\n","source":"_posts/2016/01/06/使用gulp实现项目模板化.md","raw":"title: 使用gulp实现项目模板化\ndate: 2016-01-06 15:30:32\ncategories:\n- WebFrontEnd\ntags:\n- gulp\n- nodejs\n- 自动化\n- 插件\n---\n\n> 当一个大项目逐渐成型，或者一个框架又或者一个开发方式逐渐成型的时候，总会有一个所谓的“套路”，我们在工作中往往遵循着这个套路走。所以更换一家公司或者一个部门团队的时候，上手项目并不难，你只需要掌握这个团队管用的“套路”就ok了，关键是：要想办法优化这个“套路”。\n\n<!-- more -->\n\n之前一直在做内部框架的跨平台和自动化构建的事，加上开发业务逻辑的页面已经完成，就没去优化这个开发套路，什么套路呢？当项目中需要一个新的H5页面的时候，就需要手动去copy之前的一个页面代码，然后逐个修改，改成另外一个页面。去掉代码中的业务逻辑，会发现除了名称不同，其余的代码全部相同，秉承着“上级命令一定要完成”总宗旨，非也，是秉承着“我是一个程序员”的宗旨，就应该将一切需要手工完成的工作变成自动化的。所以......所以就不吹NB了，好好写......\n\n一个古老的思路是，你应该有一套模板，当有新的页面需要开发的时候，只需一条命令或者一个按钮就可以自动帮你基于这套模板创建一个可直接用于开发的环境。为了达成这个目的，我是用到了：\n\n1.gulp\n\ngulp的教程这里就不写了，这里讲的很清楚 [gulp教程](http://www.gulpjs.com.cn/docs/api/)\n\n2.该功能主要使用到的gulp插件\n\n[gulp-load-plugins](https://www.npmjs.com/package/gulp-load-plugins) 加载gulp插件的插件\n\n[gulp-file-include](https://www.npmjs.com/package/gulp-file-include) 文件包含插件\n\n[gulp-data](https://www.npmjs.com/package/gulp-data) 提供数据，该数据可被其他gulp插件使用\n\n[gulp-rename](https://www.npmjs.com/package/gulp-rename) 重命名文件\n\n[gulp-template](https://www.npmjs.com/package/gulp-template) 渲染模板\n\n上面的插件连接，点击进去就是文档。\n\n笔者认为最好的学习方式就是有一个能运行起来的项目，然后看着代码一步步走，所以我把模板化从公司的项目中抽离出来，并做了删减，提炼出一个完整的可运行的项目，并放在我的git仓库，可以运行一下命令查看效果，调试并学习：\n\n```\ngit clone git@github.com:HcySunYang/modapp.git\n\nnpm install\n\ngulp createapp --name=aaa\n```\n\n下面是gulpfile.js文件和package.json文件\n\n# gulpfile.js #\n\n```\nvar gulp = require('gulp');\nvar gulpLoadPlugins = require(\"gulp-load-plugins\");\nvar plugins = gulpLoadPlugins();\nvar util     = require(\"gulp-util\");\nvar devPath = './html';\nvar appData = {};\n\n/*\n * @desc 组装模板\n * @src  devPath \n * @deps \n * @dest devPath + '/tmod/app/dest'\n */\ngulp.task('includeTpl',function () {\n    // 获取 gulp 命令的 --name参数的值 （gulp createapp --name=aaa）\n    var appName = util.env.name || 'special';\n    \n    // 首字母大写\n    var appNameBig = appName.replace((/\\w/), function(char){\n        return char.toUpperCase();\n    });\n\n    appData={\n        app: appName,\n        appapi: appNameBig,\n        appDo: appName + \"Do\",\n        title: appName\n    }\n    return gulp.src([\n            devPath + '/tmod/app/app.tpl',\n            devPath + '/tmod/app/appDo.tpl',\n            devPath + '/tmod/app/app.html',\n            devPath + '/tmod/app/appApi.tpl',\n            devPath + '/tmod/app/appapiInterFace.tpl'\n        ])\n        .pipe(plugins.fileInclude({\n            prefix: '@@',\n            basepath: '@file'\n        }))\n        .pipe(gulp.dest(devPath + '/tmod/app/dest'));\n});\n\n/*\n * @desc 解析模板\n * @src  devPath \n * @deps includeTpl\n * @dest devPath + '/tmod/app/dest'\n */\ngulp.task('resolveTpl',[\"includeTpl\"],function () {\n    return gulp.src([\n            devPath + '/tmod/app/dest/app.tpl',\n            devPath + '/tmod/app/dest/appDo.tpl',\n            devPath + '/tmod/app/dest/app.html',\n            devPath + '/tmod/app/dest/appApi.tpl',\n            devPath + '/tmod/app/dest/appapiInterFace.tpl'\n        ])\n        .pipe(plugins.data(function () {\n            return {app: appData.app, appDo:appData.appDo,title:appData.title, appapi : appData.appapi};\n        }))\n        .pipe(plugins.template())\n        .pipe(gulp.dest(devPath + '/tmod/app/dest'));\n});\n\n/*\n * @desc 创建部署\n * @src  devPath + '/tmod/app/dest \n * @deps resolveTpl\n * @dest devPath + '/modules/'\n */\ngulp.task('createapp', [\"resolveTpl\"], function () {\n    // 创建部署入口js文件，如 index.js\n    gulp.src(devPath + '/tmod/app/dest/app.tpl')\n        .pipe(plugins.rename({\n            basename: appData.app,\n            extname: \".js\"\n        }))\n        .pipe(gulp.dest(devPath + '/target/'+appData.app));\n\n    // 创建部署业务逻辑js文件，如 indexDo.js\n    gulp.src(devPath + '/tmod/app/dest/appDo.tpl')\n        .pipe(plugins.rename({\n            basename: appData.appDo,\n            extname: \".js\"\n        }))\n        .pipe(gulp.dest(devPath + '/target/'+appData.app));\n\n    // 创建部署html页面文件，如 index.html\n    gulp.src([devPath + '/tmod/app/dest/*.html'])\n        .pipe(plugins.rename({\n            basename: appData.app,\n            extname: \".html\"\n        }))\n        .pipe(gulp.dest(devPath + '/target/'+appData.app));\n\n    // 创建部署api接口js文件，如 indexApi.js\n    gulp.src(devPath + '/tmod/app/dest/appApi.tpl')\n        .pipe(plugins.rename({\n            basename: appData.app + 'Api',\n            extname: \".js\"\n        }))\n        .pipe(gulp.dest(devPath + '/target/clientApi'));\n\n    // 创建部署跨平台接口js文件，如 indexapiInterFace.js\n    gulp.src(devPath + '/tmod/app/dest/appapiInterFace.tpl')\n        .pipe(plugins.rename({\n            basename: appData.app + 'apiInterFace',\n            extname: \".js\"\n        }))\n        .pipe(gulp.dest(devPath + '/target/clientApi'));\n});\n\n```\n\n# package.json #\n\n```\n{\n  \"name\": \"app\",\n  \"project\": \"app\",\n  \"version\": \"1.0.0\",\n  \"host\": \"http://10.0.69.79\",\n  \"path\": \"/home/huangjian/workstation/bridge/newssdk/bin\",\n  \"devDependencies\": {\n    \"gulp\": \"^3.9.0\",\n    \"gulp-data\": \"^1.2.0\",\n    \"gulp-file-include\": \"^0.13.7\",\n    \"gulp-load-plugins\": \"^0.10.0\",\n    \"gulp-rename\": \"^1.2.0\",\n    \"gulp-template\": \"^2.1.0\",\n    \"gulp-util\": \"^3.0.6\"\n  }\n}\n\n```\n\n大家重在研究代码的思路和各个组件的用法及配合，不要去研究代码的细节，比如这个构建出来的项目有什么用啊？当然对于你来说没什么用，因为这个是应用在公司项目中的，这个是为了给大家方便，抽离出来的，所以大家把握好重点。\n\n\n\n","slug":"使用gulp实现项目模板化","published":1,"updated":"2016-01-06T11:24:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj669fsk3001bewfcarq2x2un","content":"<blockquote>\n<p>当一个大项目逐渐成型，或者一个框架又或者一个开发方式逐渐成型的时候，总会有一个所谓的“套路”，我们在工作中往往遵循着这个套路走。所以更换一家公司或者一个部门团队的时候，上手项目并不难，你只需要掌握这个团队管用的“套路”就ok了，关键是：要想办法优化这个“套路”。</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>之前一直在做内部框架的跨平台和自动化构建的事，加上开发业务逻辑的页面已经完成，就没去优化这个开发套路，什么套路呢？当项目中需要一个新的H5页面的时候，就需要手动去copy之前的一个页面代码，然后逐个修改，改成另外一个页面。去掉代码中的业务逻辑，会发现除了名称不同，其余的代码全部相同，秉承着“上级命令一定要完成”总宗旨，非也，是秉承着“我是一个程序员”的宗旨，就应该将一切需要手工完成的工作变成自动化的。所以……所以就不吹NB了，好好写……</p>\n<p>一个古老的思路是，你应该有一套模板，当有新的页面需要开发的时候，只需一条命令或者一个按钮就可以自动帮你基于这套模板创建一个可直接用于开发的环境。为了达成这个目的，我是用到了：</p>\n<p>1.gulp</p>\n<p>gulp的教程这里就不写了，这里讲的很清楚 <a href=\"http://www.gulpjs.com.cn/docs/api/\" target=\"_blank\" rel=\"external\">gulp教程</a></p>\n<p>2.该功能主要使用到的gulp插件</p>\n<p><a href=\"https://www.npmjs.com/package/gulp-load-plugins\" target=\"_blank\" rel=\"external\">gulp-load-plugins</a> 加载gulp插件的插件</p>\n<p><a href=\"https://www.npmjs.com/package/gulp-file-include\" target=\"_blank\" rel=\"external\">gulp-file-include</a> 文件包含插件</p>\n<p><a href=\"https://www.npmjs.com/package/gulp-data\" target=\"_blank\" rel=\"external\">gulp-data</a> 提供数据，该数据可被其他gulp插件使用</p>\n<p><a href=\"https://www.npmjs.com/package/gulp-rename\" target=\"_blank\" rel=\"external\">gulp-rename</a> 重命名文件</p>\n<p><a href=\"https://www.npmjs.com/package/gulp-template\" target=\"_blank\" rel=\"external\">gulp-template</a> 渲染模板</p>\n<p>上面的插件连接，点击进去就是文档。</p>\n<p>笔者认为最好的学习方式就是有一个能运行起来的项目，然后看着代码一步步走，所以我把模板化从公司的项目中抽离出来，并做了删减，提炼出一个完整的可运行的项目，并放在我的git仓库，可以运行一下命令查看效果，调试并学习：</p>\n<pre><code>git clone git@github.com:HcySunYang/modapp.git\n\nnpm install\n\ngulp createapp --name=aaa\n</code></pre><p>下面是gulpfile.js文件和package.json文件</p>\n<h1 id=\"gulpfile-js\"><a href=\"#gulpfile-js\" class=\"headerlink\" title=\"gulpfile.js\"></a>gulpfile.js</h1><pre><code>var gulp = require(&#39;gulp&#39;);\nvar gulpLoadPlugins = require(&quot;gulp-load-plugins&quot;);\nvar plugins = gulpLoadPlugins();\nvar util     = require(&quot;gulp-util&quot;);\nvar devPath = &#39;./html&#39;;\nvar appData = {};\n\n/*\n * @desc 组装模板\n * @src  devPath \n * @deps \n * @dest devPath + &#39;/tmod/app/dest&#39;\n */\ngulp.task(&#39;includeTpl&#39;,function () {\n    // 获取 gulp 命令的 --name参数的值 （gulp createapp --name=aaa）\n    var appName = util.env.name || &#39;special&#39;;\n\n    // 首字母大写\n    var appNameBig = appName.replace((/\\w/), function(char){\n        return char.toUpperCase();\n    });\n\n    appData={\n        app: appName,\n        appapi: appNameBig,\n        appDo: appName + &quot;Do&quot;,\n        title: appName\n    }\n    return gulp.src([\n            devPath + &#39;/tmod/app/app.tpl&#39;,\n            devPath + &#39;/tmod/app/appDo.tpl&#39;,\n            devPath + &#39;/tmod/app/app.html&#39;,\n            devPath + &#39;/tmod/app/appApi.tpl&#39;,\n            devPath + &#39;/tmod/app/appapiInterFace.tpl&#39;\n        ])\n        .pipe(plugins.fileInclude({\n            prefix: &#39;@@&#39;,\n            basepath: &#39;@file&#39;\n        }))\n        .pipe(gulp.dest(devPath + &#39;/tmod/app/dest&#39;));\n});\n\n/*\n * @desc 解析模板\n * @src  devPath \n * @deps includeTpl\n * @dest devPath + &#39;/tmod/app/dest&#39;\n */\ngulp.task(&#39;resolveTpl&#39;,[&quot;includeTpl&quot;],function () {\n    return gulp.src([\n            devPath + &#39;/tmod/app/dest/app.tpl&#39;,\n            devPath + &#39;/tmod/app/dest/appDo.tpl&#39;,\n            devPath + &#39;/tmod/app/dest/app.html&#39;,\n            devPath + &#39;/tmod/app/dest/appApi.tpl&#39;,\n            devPath + &#39;/tmod/app/dest/appapiInterFace.tpl&#39;\n        ])\n        .pipe(plugins.data(function () {\n            return {app: appData.app, appDo:appData.appDo,title:appData.title, appapi : appData.appapi};\n        }))\n        .pipe(plugins.template())\n        .pipe(gulp.dest(devPath + &#39;/tmod/app/dest&#39;));\n});\n\n/*\n * @desc 创建部署\n * @src  devPath + &#39;/tmod/app/dest \n * @deps resolveTpl\n * @dest devPath + &#39;/modules/&#39;\n */\ngulp.task(&#39;createapp&#39;, [&quot;resolveTpl&quot;], function () {\n    // 创建部署入口js文件，如 index.js\n    gulp.src(devPath + &#39;/tmod/app/dest/app.tpl&#39;)\n        .pipe(plugins.rename({\n            basename: appData.app,\n            extname: &quot;.js&quot;\n        }))\n        .pipe(gulp.dest(devPath + &#39;/target/&#39;+appData.app));\n\n    // 创建部署业务逻辑js文件，如 indexDo.js\n    gulp.src(devPath + &#39;/tmod/app/dest/appDo.tpl&#39;)\n        .pipe(plugins.rename({\n            basename: appData.appDo,\n            extname: &quot;.js&quot;\n        }))\n        .pipe(gulp.dest(devPath + &#39;/target/&#39;+appData.app));\n\n    // 创建部署html页面文件，如 index.html\n    gulp.src([devPath + &#39;/tmod/app/dest/*.html&#39;])\n        .pipe(plugins.rename({\n            basename: appData.app,\n            extname: &quot;.html&quot;\n        }))\n        .pipe(gulp.dest(devPath + &#39;/target/&#39;+appData.app));\n\n    // 创建部署api接口js文件，如 indexApi.js\n    gulp.src(devPath + &#39;/tmod/app/dest/appApi.tpl&#39;)\n        .pipe(plugins.rename({\n            basename: appData.app + &#39;Api&#39;,\n            extname: &quot;.js&quot;\n        }))\n        .pipe(gulp.dest(devPath + &#39;/target/clientApi&#39;));\n\n    // 创建部署跨平台接口js文件，如 indexapiInterFace.js\n    gulp.src(devPath + &#39;/tmod/app/dest/appapiInterFace.tpl&#39;)\n        .pipe(plugins.rename({\n            basename: appData.app + &#39;apiInterFace&#39;,\n            extname: &quot;.js&quot;\n        }))\n        .pipe(gulp.dest(devPath + &#39;/target/clientApi&#39;));\n});\n</code></pre><h1 id=\"package-json\"><a href=\"#package-json\" class=\"headerlink\" title=\"package.json\"></a>package.json</h1><pre><code>{\n  &quot;name&quot;: &quot;app&quot;,\n  &quot;project&quot;: &quot;app&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;host&quot;: &quot;http://10.0.69.79&quot;,\n  &quot;path&quot;: &quot;/home/huangjian/workstation/bridge/newssdk/bin&quot;,\n  &quot;devDependencies&quot;: {\n    &quot;gulp&quot;: &quot;^3.9.0&quot;,\n    &quot;gulp-data&quot;: &quot;^1.2.0&quot;,\n    &quot;gulp-file-include&quot;: &quot;^0.13.7&quot;,\n    &quot;gulp-load-plugins&quot;: &quot;^0.10.0&quot;,\n    &quot;gulp-rename&quot;: &quot;^1.2.0&quot;,\n    &quot;gulp-template&quot;: &quot;^2.1.0&quot;,\n    &quot;gulp-util&quot;: &quot;^3.0.6&quot;\n  }\n}\n</code></pre><p>大家重在研究代码的思路和各个组件的用法及配合，不要去研究代码的细节，比如这个构建出来的项目有什么用啊？当然对于你来说没什么用，因为这个是应用在公司项目中的，这个是为了给大家方便，抽离出来的，所以大家把握好重点。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>当一个大项目逐渐成型，或者一个框架又或者一个开发方式逐渐成型的时候，总会有一个所谓的“套路”，我们在工作中往往遵循着这个套路走。所以更换一家公司或者一个部门团队的时候，上手项目并不难，你只需要掌握这个团队管用的“套路”就ok了，关键是：要想办法优化这个“套路”。</p>\n</blockquote>","more":"<p>之前一直在做内部框架的跨平台和自动化构建的事，加上开发业务逻辑的页面已经完成，就没去优化这个开发套路，什么套路呢？当项目中需要一个新的H5页面的时候，就需要手动去copy之前的一个页面代码，然后逐个修改，改成另外一个页面。去掉代码中的业务逻辑，会发现除了名称不同，其余的代码全部相同，秉承着“上级命令一定要完成”总宗旨，非也，是秉承着“我是一个程序员”的宗旨，就应该将一切需要手工完成的工作变成自动化的。所以……所以就不吹NB了，好好写……</p>\n<p>一个古老的思路是，你应该有一套模板，当有新的页面需要开发的时候，只需一条命令或者一个按钮就可以自动帮你基于这套模板创建一个可直接用于开发的环境。为了达成这个目的，我是用到了：</p>\n<p>1.gulp</p>\n<p>gulp的教程这里就不写了，这里讲的很清楚 <a href=\"http://www.gulpjs.com.cn/docs/api/\" target=\"_blank\" rel=\"external\">gulp教程</a></p>\n<p>2.该功能主要使用到的gulp插件</p>\n<p><a href=\"https://www.npmjs.com/package/gulp-load-plugins\" target=\"_blank\" rel=\"external\">gulp-load-plugins</a> 加载gulp插件的插件</p>\n<p><a href=\"https://www.npmjs.com/package/gulp-file-include\" target=\"_blank\" rel=\"external\">gulp-file-include</a> 文件包含插件</p>\n<p><a href=\"https://www.npmjs.com/package/gulp-data\" target=\"_blank\" rel=\"external\">gulp-data</a> 提供数据，该数据可被其他gulp插件使用</p>\n<p><a href=\"https://www.npmjs.com/package/gulp-rename\" target=\"_blank\" rel=\"external\">gulp-rename</a> 重命名文件</p>\n<p><a href=\"https://www.npmjs.com/package/gulp-template\" target=\"_blank\" rel=\"external\">gulp-template</a> 渲染模板</p>\n<p>上面的插件连接，点击进去就是文档。</p>\n<p>笔者认为最好的学习方式就是有一个能运行起来的项目，然后看着代码一步步走，所以我把模板化从公司的项目中抽离出来，并做了删减，提炼出一个完整的可运行的项目，并放在我的git仓库，可以运行一下命令查看效果，调试并学习：</p>\n<pre><code>git clone git@github.com:HcySunYang/modapp.git\n\nnpm install\n\ngulp createapp --name=aaa\n</code></pre><p>下面是gulpfile.js文件和package.json文件</p>\n<h1 id=\"gulpfile-js\"><a href=\"#gulpfile-js\" class=\"headerlink\" title=\"gulpfile.js\"></a>gulpfile.js</h1><pre><code>var gulp = require(&#39;gulp&#39;);\nvar gulpLoadPlugins = require(&quot;gulp-load-plugins&quot;);\nvar plugins = gulpLoadPlugins();\nvar util     = require(&quot;gulp-util&quot;);\nvar devPath = &#39;./html&#39;;\nvar appData = {};\n\n/*\n * @desc 组装模板\n * @src  devPath \n * @deps \n * @dest devPath + &#39;/tmod/app/dest&#39;\n */\ngulp.task(&#39;includeTpl&#39;,function () {\n    // 获取 gulp 命令的 --name参数的值 （gulp createapp --name=aaa）\n    var appName = util.env.name || &#39;special&#39;;\n\n    // 首字母大写\n    var appNameBig = appName.replace((/\\w/), function(char){\n        return char.toUpperCase();\n    });\n\n    appData={\n        app: appName,\n        appapi: appNameBig,\n        appDo: appName + &quot;Do&quot;,\n        title: appName\n    }\n    return gulp.src([\n            devPath + &#39;/tmod/app/app.tpl&#39;,\n            devPath + &#39;/tmod/app/appDo.tpl&#39;,\n            devPath + &#39;/tmod/app/app.html&#39;,\n            devPath + &#39;/tmod/app/appApi.tpl&#39;,\n            devPath + &#39;/tmod/app/appapiInterFace.tpl&#39;\n        ])\n        .pipe(plugins.fileInclude({\n            prefix: &#39;@@&#39;,\n            basepath: &#39;@file&#39;\n        }))\n        .pipe(gulp.dest(devPath + &#39;/tmod/app/dest&#39;));\n});\n\n/*\n * @desc 解析模板\n * @src  devPath \n * @deps includeTpl\n * @dest devPath + &#39;/tmod/app/dest&#39;\n */\ngulp.task(&#39;resolveTpl&#39;,[&quot;includeTpl&quot;],function () {\n    return gulp.src([\n            devPath + &#39;/tmod/app/dest/app.tpl&#39;,\n            devPath + &#39;/tmod/app/dest/appDo.tpl&#39;,\n            devPath + &#39;/tmod/app/dest/app.html&#39;,\n            devPath + &#39;/tmod/app/dest/appApi.tpl&#39;,\n            devPath + &#39;/tmod/app/dest/appapiInterFace.tpl&#39;\n        ])\n        .pipe(plugins.data(function () {\n            return {app: appData.app, appDo:appData.appDo,title:appData.title, appapi : appData.appapi};\n        }))\n        .pipe(plugins.template())\n        .pipe(gulp.dest(devPath + &#39;/tmod/app/dest&#39;));\n});\n\n/*\n * @desc 创建部署\n * @src  devPath + &#39;/tmod/app/dest \n * @deps resolveTpl\n * @dest devPath + &#39;/modules/&#39;\n */\ngulp.task(&#39;createapp&#39;, [&quot;resolveTpl&quot;], function () {\n    // 创建部署入口js文件，如 index.js\n    gulp.src(devPath + &#39;/tmod/app/dest/app.tpl&#39;)\n        .pipe(plugins.rename({\n            basename: appData.app,\n            extname: &quot;.js&quot;\n        }))\n        .pipe(gulp.dest(devPath + &#39;/target/&#39;+appData.app));\n\n    // 创建部署业务逻辑js文件，如 indexDo.js\n    gulp.src(devPath + &#39;/tmod/app/dest/appDo.tpl&#39;)\n        .pipe(plugins.rename({\n            basename: appData.appDo,\n            extname: &quot;.js&quot;\n        }))\n        .pipe(gulp.dest(devPath + &#39;/target/&#39;+appData.app));\n\n    // 创建部署html页面文件，如 index.html\n    gulp.src([devPath + &#39;/tmod/app/dest/*.html&#39;])\n        .pipe(plugins.rename({\n            basename: appData.app,\n            extname: &quot;.html&quot;\n        }))\n        .pipe(gulp.dest(devPath + &#39;/target/&#39;+appData.app));\n\n    // 创建部署api接口js文件，如 indexApi.js\n    gulp.src(devPath + &#39;/tmod/app/dest/appApi.tpl&#39;)\n        .pipe(plugins.rename({\n            basename: appData.app + &#39;Api&#39;,\n            extname: &quot;.js&quot;\n        }))\n        .pipe(gulp.dest(devPath + &#39;/target/clientApi&#39;));\n\n    // 创建部署跨平台接口js文件，如 indexapiInterFace.js\n    gulp.src(devPath + &#39;/tmod/app/dest/appapiInterFace.tpl&#39;)\n        .pipe(plugins.rename({\n            basename: appData.app + &#39;apiInterFace&#39;,\n            extname: &quot;.js&quot;\n        }))\n        .pipe(gulp.dest(devPath + &#39;/target/clientApi&#39;));\n});\n</code></pre><h1 id=\"package-json\"><a href=\"#package-json\" class=\"headerlink\" title=\"package.json\"></a>package.json</h1><pre><code>{\n  &quot;name&quot;: &quot;app&quot;,\n  &quot;project&quot;: &quot;app&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;host&quot;: &quot;http://10.0.69.79&quot;,\n  &quot;path&quot;: &quot;/home/huangjian/workstation/bridge/newssdk/bin&quot;,\n  &quot;devDependencies&quot;: {\n    &quot;gulp&quot;: &quot;^3.9.0&quot;,\n    &quot;gulp-data&quot;: &quot;^1.2.0&quot;,\n    &quot;gulp-file-include&quot;: &quot;^0.13.7&quot;,\n    &quot;gulp-load-plugins&quot;: &quot;^0.10.0&quot;,\n    &quot;gulp-rename&quot;: &quot;^1.2.0&quot;,\n    &quot;gulp-template&quot;: &quot;^2.1.0&quot;,\n    &quot;gulp-util&quot;: &quot;^3.0.6&quot;\n  }\n}\n</code></pre><p>大家重在研究代码的思路和各个组件的用法及配合，不要去研究代码的细节，比如这个构建出来的项目有什么用啊？当然对于你来说没什么用，因为这个是应用在公司项目中的，这个是为了给大家方便，抽离出来的，所以大家把握好重点。</p>"},{"title":"使用npm和node开发命令行工具并使用npm管理你的包","date":"2016-01-14T06:51:34.000Z","_content":"\n> 对于前端开发者来讲，玩儿js的你们肯定对nodejs已经npm并不陌生，现在npm已经集成到了node里，所以当你安装了node之后也就默认安装了npm，npm的全称是node package manager : node 包管理器，提供一个registry，你只要注册一个npm账号，就可是使用npm进行包管理了，比如发布，安装，更新...等等。最近再做公司内部框架的重构，准备使用npm开发一套命令行工具，管理核心代码，只输出业务目录给框架使用者，一方面减轻了项目体积，另一方面给开发者一个更好的开发体验，同时保证了核心代码的安全，这篇文章记录了使用npm进行包管理的事项、已经使用npm和node开发命令行工具的方法。\n\n<!-- more -->\n\n想要使用npm进行包管理，有两种方案，一种是使用npm官方，即[https://www.npmjs.com/](https://www.npmjs.com/)，注册你自己的账号然后进行管理，但是如果不使用私有包的话，你的代码是暴露的，如果是企业内部的私有包，不想对外暴露，避免潜在的风险，那么就必须使用私有包管理，不过，是要交保护费的，虽然也不多，如果你连保护费都不想交的话，那么也有办法，搭建私有npm服务，国内比如[cnpm](https://github.com/cnpm/cnpmjs.org)，或者使用npm官方提供的 [On-Site](https://www.npmjs.com/npm/on-site)，都可以搭建企业内部的私有npm服务，但是我可以在这里给大家提个醒，如果你真的要自己搭建私有npm服务，那么你准备好接受各种折磨，让我偷乐一会儿......\n\n乐完了，回到正题，为了给大家讲解，我这里就采用npm官方registry进行npm包管理的操作，首先，你要有个女朋友，哦 sorry，是有一个npm账号：\n\n# 注册npm账号 #\n\n填写你的信息注册账号，然后会给你发一封激活邮件，激活你的账号就ok了，就是一个普通的不能再普通的注册流程了：\n\n![注册npm账号](http://7xlolm.com1.z0.glb.clouddn.com/201501301.pic.jpg)\n\n有了账号，就可以登录，注意，我说的是在终端登录，不是在网站登录，打开你的终端，执行命令：\n\n```$\nnpm login\n```\n\n会让你输入你刚才注册的用户名密码已经邮箱，你就实话实说就ok了，它不会为难你的，如下图：\n\n![终端中登录npm](http://7xlolm.com1.z0.glb.clouddn.com/201501302.pic.jpg)\n\n如果一切正常，那么不会有任何提示信息，说明你登录成功了。\n\n我们写一个测试包，测试一下：\n\n执行：\n\n```$\nmkdir test\ncd test\nnpm init\n```\n\n生成package.json文件，这个文件很重要，npm就是依据这个文件进行包管理工作的，然后我们我们新建一个html文件：\n\n```$\ntouch index.html\n```\n\n这个html文件是我随便建的，作为我们这个测试包的内容，现在我们已经有了一个最简单的包了，接下来，我们就可以把我们的包，通过npm推送到远程，进行管理，执行：\n\n```$\nnpm publish\n```\n\n这条命令的意思是发布我们的包，如果你真的按照我的教程敲代码，你可能会得到如下错误：\n\n![npm publish发布错误](http://7xlolm.com1.z0.glb.clouddn.com/201501303.pic.jpg)\n\n如果你可以确认你已经使用了正确的账号登陆，那么就不要被提示信息所迷惑着，这可能是你所要发布的包的名字，已经有人使用并发布了，编辑你的package.json文件，找到name字段，修改一个独一无二的名字：\n\n![修改name字段](http://7xlolm.com1.z0.glb.clouddn.com/201501304.pic.jpg)\n\n好吧，我承认这个名字99.99999999%可以用了。\n\n然后再发布，就可以成功了，执行：\n\n```$\nnpm publish\n```\n\n如下：\n\n![发布成功](http://7xlolm.com1.z0.glb.clouddn.com/201501305.pic.jpg)\n\n发布成功后，在npm官网登陆你的账号，你是可以看到你自己的包的：\n\n![你发布的包](http://7xlolm.com1.z0.glb.clouddn.com/201501306.pic.jpg)\n\n发布了包之后，你就可以像安装其他第三方包一下来安装你的包了：\n\n```\nnpm install <you package name>\n```\n\n如果你的本地包有更新，需要再次发布的话，直接执行 npm publish 是不可以的，你还要更新一下包的版本号，然后再执行发布命令才行，也就是修改一下package.json文件的 version 字段，不过，不需要手动修改，执行：\n\n```\nnpm version <update_type>\n```\n\nupdate_type 可以取三个值：major minor patch\n\n我们知道，版本号的格式是这样的 1.0.0\n\n其中 1 是主要版本，只有重大的更新才会修改它的值（major），第二个位置是次要的(minor)，第三个位置是补丁(patch)，根据包修改的程度来定你要修改那个位置的数字，为了测试，我们就执行如下命令：\n\n```$\nnpm version patch\n```\n\n![更新版本](http://7xlolm.com1.z0.glb.clouddn.com/201501307.pic.jpg)\n\n我们看到，版本由原来的 1.0.0 变成了 1.0.1。这时，我们就可以执行 npm publish 命令更新我们的包了。\n\n上面描述了最基本的管理命令，npm远不止这些，官方文档写的很详细：[npm](https://docs.npmjs.com/getting-started/what-is-npm)\n\n# 如果使用npm和node开发命令行工具 #\n\n什么是命令行工具？最通俗的解释就是，敲一串字符，命令行能够识别，并做一些事。比如 ls 查看文件， cd 切换目录等等，都是命令行工具，及可执行的文件。\n\n其实用npm和node开发命令行工具特别简单，我们还继续使用上面的例子。\n\n## 第一步：编写一个nodejs文件 ##\n\n名字你随便起，这里我们就叫 test.js，在package.json的同级目录新建一个test.js文件，并编辑如下内容：\n\n```test.js\n#! /usr/bin/env node\n\nconsole.log('test command line!');\n```\n\n注意，第一行的 #! /usr/bin/env node 不可以省略，这是告诉机器，这个文件要在node环境下运行，当我们直接执行这个文件的时候，相当于使用node去执行它，即：\n\n```\n./test.js\n```\n\n相当于\n\n```\nnode ./test.js\n```\n\n## 第二部：在package.json文件中添加bin字段 ##\n\n```package.json\n\"bin\": {\n    \"hcy-cmd\": \"./test.js\"\n}\n```\n\nbin字段是一个json对象，键是命令的名称，即我们可以在终端执行的命令名称，值是该命令对应的可执行文件，在我们这个例子中，就是当前目录下的 test.js 文件，其中，命令的名称你自己随便定义。\n\n致此，我们还没有结束，如果现在就在终端敲 hcy-cmd 的话，是不行的，还需要最后一步。\n\n## 第三部：连接到全局 ##\n\n如何连接到全局，很简单，只需一条命令，执行：\n\n```$\nnpm link\n```\n\n这是在终端敲入我们自定义的命令，查看结果：\n\n![执行命令](http://7xlolm.com1.z0.glb.clouddn.com/201501308.pic.jpg)\n\n这样，我们就可以发挥我们的创造力，利用它做一些有趣的事情，快去实现你的想象吧，另外推荐两个库，配合它们，我们可以开发出很强大的命令行工具：\n\n[shelljs - 强大的执行unix系统命令的npm包](https://www.npmjs.com/package/shelljs)\n\n[yargs - 命令行参数的处理](https://www.npmjs.com/package/yargs)\n\n\n\n\n\n\n","source":"_posts/2016/01/30/使用npm和node开发命令行工具并使用npm管理你的包.md","raw":"title: 使用npm和node开发命令行工具并使用npm管理你的包\ndate: 2016-01-14 14:51:34\ncategories:\n- WebFrontEnd\ntags:\n- node\n- npm\n- 命令行工具\n---\n\n> 对于前端开发者来讲，玩儿js的你们肯定对nodejs已经npm并不陌生，现在npm已经集成到了node里，所以当你安装了node之后也就默认安装了npm，npm的全称是node package manager : node 包管理器，提供一个registry，你只要注册一个npm账号，就可是使用npm进行包管理了，比如发布，安装，更新...等等。最近再做公司内部框架的重构，准备使用npm开发一套命令行工具，管理核心代码，只输出业务目录给框架使用者，一方面减轻了项目体积，另一方面给开发者一个更好的开发体验，同时保证了核心代码的安全，这篇文章记录了使用npm进行包管理的事项、已经使用npm和node开发命令行工具的方法。\n\n<!-- more -->\n\n想要使用npm进行包管理，有两种方案，一种是使用npm官方，即[https://www.npmjs.com/](https://www.npmjs.com/)，注册你自己的账号然后进行管理，但是如果不使用私有包的话，你的代码是暴露的，如果是企业内部的私有包，不想对外暴露，避免潜在的风险，那么就必须使用私有包管理，不过，是要交保护费的，虽然也不多，如果你连保护费都不想交的话，那么也有办法，搭建私有npm服务，国内比如[cnpm](https://github.com/cnpm/cnpmjs.org)，或者使用npm官方提供的 [On-Site](https://www.npmjs.com/npm/on-site)，都可以搭建企业内部的私有npm服务，但是我可以在这里给大家提个醒，如果你真的要自己搭建私有npm服务，那么你准备好接受各种折磨，让我偷乐一会儿......\n\n乐完了，回到正题，为了给大家讲解，我这里就采用npm官方registry进行npm包管理的操作，首先，你要有个女朋友，哦 sorry，是有一个npm账号：\n\n# 注册npm账号 #\n\n填写你的信息注册账号，然后会给你发一封激活邮件，激活你的账号就ok了，就是一个普通的不能再普通的注册流程了：\n\n![注册npm账号](http://7xlolm.com1.z0.glb.clouddn.com/201501301.pic.jpg)\n\n有了账号，就可以登录，注意，我说的是在终端登录，不是在网站登录，打开你的终端，执行命令：\n\n```$\nnpm login\n```\n\n会让你输入你刚才注册的用户名密码已经邮箱，你就实话实说就ok了，它不会为难你的，如下图：\n\n![终端中登录npm](http://7xlolm.com1.z0.glb.clouddn.com/201501302.pic.jpg)\n\n如果一切正常，那么不会有任何提示信息，说明你登录成功了。\n\n我们写一个测试包，测试一下：\n\n执行：\n\n```$\nmkdir test\ncd test\nnpm init\n```\n\n生成package.json文件，这个文件很重要，npm就是依据这个文件进行包管理工作的，然后我们我们新建一个html文件：\n\n```$\ntouch index.html\n```\n\n这个html文件是我随便建的，作为我们这个测试包的内容，现在我们已经有了一个最简单的包了，接下来，我们就可以把我们的包，通过npm推送到远程，进行管理，执行：\n\n```$\nnpm publish\n```\n\n这条命令的意思是发布我们的包，如果你真的按照我的教程敲代码，你可能会得到如下错误：\n\n![npm publish发布错误](http://7xlolm.com1.z0.glb.clouddn.com/201501303.pic.jpg)\n\n如果你可以确认你已经使用了正确的账号登陆，那么就不要被提示信息所迷惑着，这可能是你所要发布的包的名字，已经有人使用并发布了，编辑你的package.json文件，找到name字段，修改一个独一无二的名字：\n\n![修改name字段](http://7xlolm.com1.z0.glb.clouddn.com/201501304.pic.jpg)\n\n好吧，我承认这个名字99.99999999%可以用了。\n\n然后再发布，就可以成功了，执行：\n\n```$\nnpm publish\n```\n\n如下：\n\n![发布成功](http://7xlolm.com1.z0.glb.clouddn.com/201501305.pic.jpg)\n\n发布成功后，在npm官网登陆你的账号，你是可以看到你自己的包的：\n\n![你发布的包](http://7xlolm.com1.z0.glb.clouddn.com/201501306.pic.jpg)\n\n发布了包之后，你就可以像安装其他第三方包一下来安装你的包了：\n\n```\nnpm install <you package name>\n```\n\n如果你的本地包有更新，需要再次发布的话，直接执行 npm publish 是不可以的，你还要更新一下包的版本号，然后再执行发布命令才行，也就是修改一下package.json文件的 version 字段，不过，不需要手动修改，执行：\n\n```\nnpm version <update_type>\n```\n\nupdate_type 可以取三个值：major minor patch\n\n我们知道，版本号的格式是这样的 1.0.0\n\n其中 1 是主要版本，只有重大的更新才会修改它的值（major），第二个位置是次要的(minor)，第三个位置是补丁(patch)，根据包修改的程度来定你要修改那个位置的数字，为了测试，我们就执行如下命令：\n\n```$\nnpm version patch\n```\n\n![更新版本](http://7xlolm.com1.z0.glb.clouddn.com/201501307.pic.jpg)\n\n我们看到，版本由原来的 1.0.0 变成了 1.0.1。这时，我们就可以执行 npm publish 命令更新我们的包了。\n\n上面描述了最基本的管理命令，npm远不止这些，官方文档写的很详细：[npm](https://docs.npmjs.com/getting-started/what-is-npm)\n\n# 如果使用npm和node开发命令行工具 #\n\n什么是命令行工具？最通俗的解释就是，敲一串字符，命令行能够识别，并做一些事。比如 ls 查看文件， cd 切换目录等等，都是命令行工具，及可执行的文件。\n\n其实用npm和node开发命令行工具特别简单，我们还继续使用上面的例子。\n\n## 第一步：编写一个nodejs文件 ##\n\n名字你随便起，这里我们就叫 test.js，在package.json的同级目录新建一个test.js文件，并编辑如下内容：\n\n```test.js\n#! /usr/bin/env node\n\nconsole.log('test command line!');\n```\n\n注意，第一行的 #! /usr/bin/env node 不可以省略，这是告诉机器，这个文件要在node环境下运行，当我们直接执行这个文件的时候，相当于使用node去执行它，即：\n\n```\n./test.js\n```\n\n相当于\n\n```\nnode ./test.js\n```\n\n## 第二部：在package.json文件中添加bin字段 ##\n\n```package.json\n\"bin\": {\n    \"hcy-cmd\": \"./test.js\"\n}\n```\n\nbin字段是一个json对象，键是命令的名称，即我们可以在终端执行的命令名称，值是该命令对应的可执行文件，在我们这个例子中，就是当前目录下的 test.js 文件，其中，命令的名称你自己随便定义。\n\n致此，我们还没有结束，如果现在就在终端敲 hcy-cmd 的话，是不行的，还需要最后一步。\n\n## 第三部：连接到全局 ##\n\n如何连接到全局，很简单，只需一条命令，执行：\n\n```$\nnpm link\n```\n\n这是在终端敲入我们自定义的命令，查看结果：\n\n![执行命令](http://7xlolm.com1.z0.glb.clouddn.com/201501308.pic.jpg)\n\n这样，我们就可以发挥我们的创造力，利用它做一些有趣的事情，快去实现你的想象吧，另外推荐两个库，配合它们，我们可以开发出很强大的命令行工具：\n\n[shelljs - 强大的执行unix系统命令的npm包](https://www.npmjs.com/package/shelljs)\n\n[yargs - 命令行参数的处理](https://www.npmjs.com/package/yargs)\n\n\n\n\n\n\n","slug":"使用npm和node开发命令行工具并使用npm管理你的包","published":1,"updated":"2016-01-30T07:44:07.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj669fsk4001dewfcznewfwfl","content":"<blockquote>\n<p>对于前端开发者来讲，玩儿js的你们肯定对nodejs已经npm并不陌生，现在npm已经集成到了node里，所以当你安装了node之后也就默认安装了npm，npm的全称是node package manager : node 包管理器，提供一个registry，你只要注册一个npm账号，就可是使用npm进行包管理了，比如发布，安装，更新…等等。最近再做公司内部框架的重构，准备使用npm开发一套命令行工具，管理核心代码，只输出业务目录给框架使用者，一方面减轻了项目体积，另一方面给开发者一个更好的开发体验，同时保证了核心代码的安全，这篇文章记录了使用npm进行包管理的事项、已经使用npm和node开发命令行工具的方法。</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>想要使用npm进行包管理，有两种方案，一种是使用npm官方，即<a href=\"https://www.npmjs.com/\" target=\"_blank\" rel=\"external\">https://www.npmjs.com/</a>，注册你自己的账号然后进行管理，但是如果不使用私有包的话，你的代码是暴露的，如果是企业内部的私有包，不想对外暴露，避免潜在的风险，那么就必须使用私有包管理，不过，是要交保护费的，虽然也不多，如果你连保护费都不想交的话，那么也有办法，搭建私有npm服务，国内比如<a href=\"https://github.com/cnpm/cnpmjs.org\" target=\"_blank\" rel=\"external\">cnpm</a>，或者使用npm官方提供的 <a href=\"https://www.npmjs.com/npm/on-site\" target=\"_blank\" rel=\"external\">On-Site</a>，都可以搭建企业内部的私有npm服务，但是我可以在这里给大家提个醒，如果你真的要自己搭建私有npm服务，那么你准备好接受各种折磨，让我偷乐一会儿……</p>\n<p>乐完了，回到正题，为了给大家讲解，我这里就采用npm官方registry进行npm包管理的操作，首先，你要有个女朋友，哦 sorry，是有一个npm账号：</p>\n<h1 id=\"注册npm账号\"><a href=\"#注册npm账号\" class=\"headerlink\" title=\"注册npm账号\"></a>注册npm账号</h1><p>填写你的信息注册账号，然后会给你发一封激活邮件，激活你的账号就ok了，就是一个普通的不能再普通的注册流程了：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201501301.pic.jpg\" alt=\"注册npm账号\"></p>\n<p>有了账号，就可以登录，注意，我说的是在终端登录，不是在网站登录，打开你的终端，执行命令：</p>\n<pre><code class=\"$\">npm login\n</code></pre>\n<p>会让你输入你刚才注册的用户名密码已经邮箱，你就实话实说就ok了，它不会为难你的，如下图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201501302.pic.jpg\" alt=\"终端中登录npm\"></p>\n<p>如果一切正常，那么不会有任何提示信息，说明你登录成功了。</p>\n<p>我们写一个测试包，测试一下：</p>\n<p>执行：</p>\n<pre><code class=\"$\">mkdir test\ncd test\nnpm init\n</code></pre>\n<p>生成package.json文件，这个文件很重要，npm就是依据这个文件进行包管理工作的，然后我们我们新建一个html文件：</p>\n<pre><code class=\"$\">touch index.html\n</code></pre>\n<p>这个html文件是我随便建的，作为我们这个测试包的内容，现在我们已经有了一个最简单的包了，接下来，我们就可以把我们的包，通过npm推送到远程，进行管理，执行：</p>\n<pre><code class=\"$\">npm publish\n</code></pre>\n<p>这条命令的意思是发布我们的包，如果你真的按照我的教程敲代码，你可能会得到如下错误：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201501303.pic.jpg\" alt=\"npm publish发布错误\"></p>\n<p>如果你可以确认你已经使用了正确的账号登陆，那么就不要被提示信息所迷惑着，这可能是你所要发布的包的名字，已经有人使用并发布了，编辑你的package.json文件，找到name字段，修改一个独一无二的名字：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201501304.pic.jpg\" alt=\"修改name字段\"></p>\n<p>好吧，我承认这个名字99.99999999%可以用了。</p>\n<p>然后再发布，就可以成功了，执行：</p>\n<pre><code class=\"$\">npm publish\n</code></pre>\n<p>如下：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201501305.pic.jpg\" alt=\"发布成功\"></p>\n<p>发布成功后，在npm官网登陆你的账号，你是可以看到你自己的包的：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201501306.pic.jpg\" alt=\"你发布的包\"></p>\n<p>发布了包之后，你就可以像安装其他第三方包一下来安装你的包了：</p>\n<pre><code>npm install &lt;you package name&gt;\n</code></pre><p>如果你的本地包有更新，需要再次发布的话，直接执行 npm publish 是不可以的，你还要更新一下包的版本号，然后再执行发布命令才行，也就是修改一下package.json文件的 version 字段，不过，不需要手动修改，执行：</p>\n<pre><code>npm version &lt;update_type&gt;\n</code></pre><p>update_type 可以取三个值：major minor patch</p>\n<p>我们知道，版本号的格式是这样的 1.0.0</p>\n<p>其中 1 是主要版本，只有重大的更新才会修改它的值（major），第二个位置是次要的(minor)，第三个位置是补丁(patch)，根据包修改的程度来定你要修改那个位置的数字，为了测试，我们就执行如下命令：</p>\n<pre><code class=\"$\">npm version patch\n</code></pre>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201501307.pic.jpg\" alt=\"更新版本\"></p>\n<p>我们看到，版本由原来的 1.0.0 变成了 1.0.1。这时，我们就可以执行 npm publish 命令更新我们的包了。</p>\n<p>上面描述了最基本的管理命令，npm远不止这些，官方文档写的很详细：<a href=\"https://docs.npmjs.com/getting-started/what-is-npm\" target=\"_blank\" rel=\"external\">npm</a></p>\n<h1 id=\"如果使用npm和node开发命令行工具\"><a href=\"#如果使用npm和node开发命令行工具\" class=\"headerlink\" title=\"如果使用npm和node开发命令行工具\"></a>如果使用npm和node开发命令行工具</h1><p>什么是命令行工具？最通俗的解释就是，敲一串字符，命令行能够识别，并做一些事。比如 ls 查看文件， cd 切换目录等等，都是命令行工具，及可执行的文件。</p>\n<p>其实用npm和node开发命令行工具特别简单，我们还继续使用上面的例子。</p>\n<h2 id=\"第一步：编写一个nodejs文件\"><a href=\"#第一步：编写一个nodejs文件\" class=\"headerlink\" title=\"第一步：编写一个nodejs文件\"></a>第一步：编写一个nodejs文件</h2><p>名字你随便起，这里我们就叫 test.js，在package.json的同级目录新建一个test.js文件，并编辑如下内容：</p>\n<pre><code class=\"test.js\">#! /usr/bin/env node\n\nconsole.log(&#39;test command line!&#39;);\n</code></pre>\n<p>注意，第一行的 #! /usr/bin/env node 不可以省略，这是告诉机器，这个文件要在node环境下运行，当我们直接执行这个文件的时候，相当于使用node去执行它，即：</p>\n<pre><code>./test.js\n</code></pre><p>相当于</p>\n<pre><code>node ./test.js\n</code></pre><h2 id=\"第二部：在package-json文件中添加bin字段\"><a href=\"#第二部：在package-json文件中添加bin字段\" class=\"headerlink\" title=\"第二部：在package.json文件中添加bin字段\"></a>第二部：在package.json文件中添加bin字段</h2><pre><code class=\"package.json\">&quot;bin&quot;: {\n    &quot;hcy-cmd&quot;: &quot;./test.js&quot;\n}\n</code></pre>\n<p>bin字段是一个json对象，键是命令的名称，即我们可以在终端执行的命令名称，值是该命令对应的可执行文件，在我们这个例子中，就是当前目录下的 test.js 文件，其中，命令的名称你自己随便定义。</p>\n<p>致此，我们还没有结束，如果现在就在终端敲 hcy-cmd 的话，是不行的，还需要最后一步。</p>\n<h2 id=\"第三部：连接到全局\"><a href=\"#第三部：连接到全局\" class=\"headerlink\" title=\"第三部：连接到全局\"></a>第三部：连接到全局</h2><p>如何连接到全局，很简单，只需一条命令，执行：</p>\n<pre><code class=\"$\">npm link\n</code></pre>\n<p>这是在终端敲入我们自定义的命令，查看结果：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201501308.pic.jpg\" alt=\"执行命令\"></p>\n<p>这样，我们就可以发挥我们的创造力，利用它做一些有趣的事情，快去实现你的想象吧，另外推荐两个库，配合它们，我们可以开发出很强大的命令行工具：</p>\n<p><a href=\"https://www.npmjs.com/package/shelljs\" target=\"_blank\" rel=\"external\">shelljs - 强大的执行unix系统命令的npm包</a></p>\n<p><a href=\"https://www.npmjs.com/package/yargs\" target=\"_blank\" rel=\"external\">yargs - 命令行参数的处理</a></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>对于前端开发者来讲，玩儿js的你们肯定对nodejs已经npm并不陌生，现在npm已经集成到了node里，所以当你安装了node之后也就默认安装了npm，npm的全称是node package manager : node 包管理器，提供一个registry，你只要注册一个npm账号，就可是使用npm进行包管理了，比如发布，安装，更新…等等。最近再做公司内部框架的重构，准备使用npm开发一套命令行工具，管理核心代码，只输出业务目录给框架使用者，一方面减轻了项目体积，另一方面给开发者一个更好的开发体验，同时保证了核心代码的安全，这篇文章记录了使用npm进行包管理的事项、已经使用npm和node开发命令行工具的方法。</p>\n</blockquote>","more":"<p>想要使用npm进行包管理，有两种方案，一种是使用npm官方，即<a href=\"https://www.npmjs.com/\" target=\"_blank\" rel=\"external\">https://www.npmjs.com/</a>，注册你自己的账号然后进行管理，但是如果不使用私有包的话，你的代码是暴露的，如果是企业内部的私有包，不想对外暴露，避免潜在的风险，那么就必须使用私有包管理，不过，是要交保护费的，虽然也不多，如果你连保护费都不想交的话，那么也有办法，搭建私有npm服务，国内比如<a href=\"https://github.com/cnpm/cnpmjs.org\" target=\"_blank\" rel=\"external\">cnpm</a>，或者使用npm官方提供的 <a href=\"https://www.npmjs.com/npm/on-site\" target=\"_blank\" rel=\"external\">On-Site</a>，都可以搭建企业内部的私有npm服务，但是我可以在这里给大家提个醒，如果你真的要自己搭建私有npm服务，那么你准备好接受各种折磨，让我偷乐一会儿……</p>\n<p>乐完了，回到正题，为了给大家讲解，我这里就采用npm官方registry进行npm包管理的操作，首先，你要有个女朋友，哦 sorry，是有一个npm账号：</p>\n<h1 id=\"注册npm账号\"><a href=\"#注册npm账号\" class=\"headerlink\" title=\"注册npm账号\"></a>注册npm账号</h1><p>填写你的信息注册账号，然后会给你发一封激活邮件，激活你的账号就ok了，就是一个普通的不能再普通的注册流程了：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201501301.pic.jpg\" alt=\"注册npm账号\"></p>\n<p>有了账号，就可以登录，注意，我说的是在终端登录，不是在网站登录，打开你的终端，执行命令：</p>\n<pre><code class=\"$\">npm login\n</code></pre>\n<p>会让你输入你刚才注册的用户名密码已经邮箱，你就实话实说就ok了，它不会为难你的，如下图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201501302.pic.jpg\" alt=\"终端中登录npm\"></p>\n<p>如果一切正常，那么不会有任何提示信息，说明你登录成功了。</p>\n<p>我们写一个测试包，测试一下：</p>\n<p>执行：</p>\n<pre><code class=\"$\">mkdir test\ncd test\nnpm init\n</code></pre>\n<p>生成package.json文件，这个文件很重要，npm就是依据这个文件进行包管理工作的，然后我们我们新建一个html文件：</p>\n<pre><code class=\"$\">touch index.html\n</code></pre>\n<p>这个html文件是我随便建的，作为我们这个测试包的内容，现在我们已经有了一个最简单的包了，接下来，我们就可以把我们的包，通过npm推送到远程，进行管理，执行：</p>\n<pre><code class=\"$\">npm publish\n</code></pre>\n<p>这条命令的意思是发布我们的包，如果你真的按照我的教程敲代码，你可能会得到如下错误：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201501303.pic.jpg\" alt=\"npm publish发布错误\"></p>\n<p>如果你可以确认你已经使用了正确的账号登陆，那么就不要被提示信息所迷惑着，这可能是你所要发布的包的名字，已经有人使用并发布了，编辑你的package.json文件，找到name字段，修改一个独一无二的名字：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201501304.pic.jpg\" alt=\"修改name字段\"></p>\n<p>好吧，我承认这个名字99.99999999%可以用了。</p>\n<p>然后再发布，就可以成功了，执行：</p>\n<pre><code class=\"$\">npm publish\n</code></pre>\n<p>如下：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201501305.pic.jpg\" alt=\"发布成功\"></p>\n<p>发布成功后，在npm官网登陆你的账号，你是可以看到你自己的包的：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201501306.pic.jpg\" alt=\"你发布的包\"></p>\n<p>发布了包之后，你就可以像安装其他第三方包一下来安装你的包了：</p>\n<pre><code>npm install &lt;you package name&gt;\n</code></pre><p>如果你的本地包有更新，需要再次发布的话，直接执行 npm publish 是不可以的，你还要更新一下包的版本号，然后再执行发布命令才行，也就是修改一下package.json文件的 version 字段，不过，不需要手动修改，执行：</p>\n<pre><code>npm version &lt;update_type&gt;\n</code></pre><p>update_type 可以取三个值：major minor patch</p>\n<p>我们知道，版本号的格式是这样的 1.0.0</p>\n<p>其中 1 是主要版本，只有重大的更新才会修改它的值（major），第二个位置是次要的(minor)，第三个位置是补丁(patch)，根据包修改的程度来定你要修改那个位置的数字，为了测试，我们就执行如下命令：</p>\n<pre><code class=\"$\">npm version patch\n</code></pre>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201501307.pic.jpg\" alt=\"更新版本\"></p>\n<p>我们看到，版本由原来的 1.0.0 变成了 1.0.1。这时，我们就可以执行 npm publish 命令更新我们的包了。</p>\n<p>上面描述了最基本的管理命令，npm远不止这些，官方文档写的很详细：<a href=\"https://docs.npmjs.com/getting-started/what-is-npm\" target=\"_blank\" rel=\"external\">npm</a></p>\n<h1 id=\"如果使用npm和node开发命令行工具\"><a href=\"#如果使用npm和node开发命令行工具\" class=\"headerlink\" title=\"如果使用npm和node开发命令行工具\"></a>如果使用npm和node开发命令行工具</h1><p>什么是命令行工具？最通俗的解释就是，敲一串字符，命令行能够识别，并做一些事。比如 ls 查看文件， cd 切换目录等等，都是命令行工具，及可执行的文件。</p>\n<p>其实用npm和node开发命令行工具特别简单，我们还继续使用上面的例子。</p>\n<h2 id=\"第一步：编写一个nodejs文件\"><a href=\"#第一步：编写一个nodejs文件\" class=\"headerlink\" title=\"第一步：编写一个nodejs文件\"></a>第一步：编写一个nodejs文件</h2><p>名字你随便起，这里我们就叫 test.js，在package.json的同级目录新建一个test.js文件，并编辑如下内容：</p>\n<pre><code class=\"test.js\">#! /usr/bin/env node\n\nconsole.log(&#39;test command line!&#39;);\n</code></pre>\n<p>注意，第一行的 #! /usr/bin/env node 不可以省略，这是告诉机器，这个文件要在node环境下运行，当我们直接执行这个文件的时候，相当于使用node去执行它，即：</p>\n<pre><code>./test.js\n</code></pre><p>相当于</p>\n<pre><code>node ./test.js\n</code></pre><h2 id=\"第二部：在package-json文件中添加bin字段\"><a href=\"#第二部：在package-json文件中添加bin字段\" class=\"headerlink\" title=\"第二部：在package.json文件中添加bin字段\"></a>第二部：在package.json文件中添加bin字段</h2><pre><code class=\"package.json\">&quot;bin&quot;: {\n    &quot;hcy-cmd&quot;: &quot;./test.js&quot;\n}\n</code></pre>\n<p>bin字段是一个json对象，键是命令的名称，即我们可以在终端执行的命令名称，值是该命令对应的可执行文件，在我们这个例子中，就是当前目录下的 test.js 文件，其中，命令的名称你自己随便定义。</p>\n<p>致此，我们还没有结束，如果现在就在终端敲 hcy-cmd 的话，是不行的，还需要最后一步。</p>\n<h2 id=\"第三部：连接到全局\"><a href=\"#第三部：连接到全局\" class=\"headerlink\" title=\"第三部：连接到全局\"></a>第三部：连接到全局</h2><p>如何连接到全局，很简单，只需一条命令，执行：</p>\n<pre><code class=\"$\">npm link\n</code></pre>\n<p>这是在终端敲入我们自定义的命令，查看结果：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201501308.pic.jpg\" alt=\"执行命令\"></p>\n<p>这样，我们就可以发挥我们的创造力，利用它做一些有趣的事情，快去实现你的想象吧，另外推荐两个库，配合它们，我们可以开发出很强大的命令行工具：</p>\n<p><a href=\"https://www.npmjs.com/package/shelljs\" target=\"_blank\" rel=\"external\">shelljs - 强大的执行unix系统命令的npm包</a></p>\n<p><a href=\"https://www.npmjs.com/package/yargs\" target=\"_blank\" rel=\"external\">yargs - 命令行参数的处理</a></p>"},{"title":"策略模式在表单验证中的应用","date":"2016-02-21T11:58:19.000Z","_content":"\n> 在任何一个系统里面，几乎都缺少不了提交表单的过程，比如注册、登陆、下订单等等。这篇文章就阐述了如何编写看着舒服的表单验证代码。\n\n<!-- more -->\n\n# 1、问题 #\n\n相信大家平时再做表单验证的时候基本与如下代码相同：\n\n```js\nif(input1.value === ''){\n\talert('xxx不能为空');\n\treturn false;\n}else if(input2.length < 6){\n\talert('xxx最少6个字符');\n\treturn false;\n}else if(...){\n\t...\n\treturn false;\n}\n```\n\n这样编写代码，的确能够完成业务的需求，能够完成表单的验证，但是存在很多问题，比如：\n\n> 1、代码中包含太多的 if - else 语句，如果验证规则较多的话，看上去太过于恶心......\n\n> 2、验证规则不可复用，如果我们另外一个页面也需要验证相似的表单，我们唯一的做法就是，复制一份，粘贴过去......\n\n> 3、代码不易维护，不需要解释了吧......\n\n# 2、解决办法 #\n\n所谓办法总比问题多，办法是有的，比如马上要讲解的使用 策略模式 使表单验证更优雅更完美，我相信很多人很抵触设计模式，一听设计模式就觉得很遥远，觉得自己在工作中很少用到设计模式，那么你就错了，特别是js这种灵活的语言，有的时候你已经在你的代码中使用了设计模式，只是你不知道而已。更多关于设计模式的东西，以后会陆续写博客描述，这里只希望大家抛弃设计模式神秘的感觉，通俗的讲，它无非就是完成一件事情通用的办法而已。\n\n# 3、畅想 #\n\n回到正题，假如我们不想使用过多的 if - else 语句，那么我们心中比较理想的代码编写方式是什么呢？我们能不能像编写配置一样的去做表单验证呢？再来一个”一键验证“的功能，是不是很爽？答案是肯定的，所以我们心中理想的编写代码的方式如下：\n\n```js\n\n// 获取表单form元素\nvar form = document.getElementById('f1');\n\n// 创建表单校验实例\nvar validation = new Formvalidation(VerifiPolicy);\n// 编写校验配置\nvalidation.add(form.username, 'isNoEmpty', '用户名不能为空');\nvalidation.add(form.password, 'minLength: 6', '密码长度不能小于6个字符');\nvalidation.add(form.code, 'isMobile', '请填写正确的手机号');\n\n// 开始校验，并接收错误信息\nvar errorMsg = validation.start();\n\n// 如果有错误信息输出，说明校验未通过\nif(errorMsg){\n\t// 做一些其他的事\n\treturn false;\n}\n```\n\n怎么样？感受感受，是不是看上去优雅多了？好了，有了心中的畅想，我们就可以向目标迈进了，下一步就要了解了解什么事策略模式了。\n\n# 4、策略模式 #\n\n策略模式，单纯的看它的名字”策略“，指的是做事情的方法，比如你从北京到哈尔滨（为什么到哈尔滨呢？因为我老家是哈尔滨的[偷笑]），你可以有几种策略供选择：\n\n1、飞机，嗖嗖嗖直接就到了，节省时间。\n2、火车，可以选择高铁出行，专为飞机恐惧症者提供。\n3、徒步，不失为一个锻炼身体的选择。\n4、other method......\n\n所以，做一件事你会有很多方法，也就是所谓的策略，而我们今天要讲的策略模式也就是这个意思，它的核心思想是，将做什么和谁去做相分离。所以，一个完整的策略模式要有两个类，一个是策略类，一个是环境类(主要类)，环境类接收请求，但不处理请求，它会把请求委托给策略类，让策略类去处理，而策略类的扩展是很容易的，这样，使得我们的代码易于扩展。\n\n在表单验证的例子中，各种验证的方法组成了策略类，比如：判断是否为空的方法(如：isNoEmpty)，判断最小长度的方法(如：minLength)，判断是否为手机号的方法(isMobule)等等，他们组成了策略类，供给环境类去委托请求。下面，我们就来实战一下。\n\n# 5、编写策略类 #\n\n策略类很简单，它是由一组验证方法组成的对象，即策略对象\n\n```js\n// 策略对象\nvar VerifiPolicy = {\n\t// 判断是否为空\n\tisNoEmpty : function(value, errorMsg){\n\t\tif(value == ''){\n\t\t\treturn errorMsg;\n\t\t}\n\t},\n\t// 判断最小长度\n\tminLength : function(value, length, errorMsg){\n\t\tif(value.length < length){\n\t\t\treturn errorMsg;\n\t\t}\n\t},\n\t// 判断是否为手机号\n\tisMobile : function(value, errorMsg){\n\t\tif(!/(^1[3|5|8][0-9]{9}$)/.test(value)){\n\t\t\treturn errorMsg;\n\t\t}\n\t}\n\t// 其他\n}\n\n```\n\n# 6、编写环境类 #\n\n根据我们的畅想，我们使用add方法添加验证配置，如下：\n\n```js\nvalidation.add(form.username, 'isNoEmpty', '用户名不能为空');\n```\n\nadd方法接受三个参数，第一个参数是表单字段，第二个参数是策略对象中策略方法的名字，第三个参数是验证未通过的错误信息。\n\n然后使用 start 方法开始验证，若验证未通过，返回验证错误信息，如下：\n\n```js\nvar errorMsg = validation.start();\n```\n\n另外，再解释一下下面这句代码：\n\n```\nvalidation.add(form.password, 'minLength: 6', '密码长度不能小于6个字符');\n```\n\nadd方法第一个参数我们说过了，是要验证的表单元素，第二个参数是一个字符串，使用 冒号(:) 分割，前面是策略方法名称，后面是传给这个方法的参数，第三个参数仍然是错误信息，我们希望完成这样的代码，废话不多说，直接上代码，如下：\n\n```\n// 构造函数\nvar Formvalidation = function(VerifiPolicy){\n\t// 保存策略对象\n\tthis.strategies = VerifiPolicy;\n\t// 验证缓存\n\tthis.validationFns = [];\n}\n\n// add 方法\nFormvalidation.prototype.add = function(dom, rule, errorMsg){\n\t\n\tvar ary = rule.split(':');\n\tvar arg = [];\n\tvar self = this;\n\tthis.validationFns.push(function(){\n\t\targ = [];\t// 重置参数\n\t\tvar ruleName = ary[0];\t// 策略对象方法名\n\t\t\n\t\t// 组装参数\n\t\targ.push(dom.value);\n\t\tif(ary[1]){\n\t\t\targ.push(ary[1]);\n\t\t}\n\t\targ.push(errorMsg);\n\t\t\n\t\t// 调用策略函数\n\t\treturn self.strategies[ruleName].apply(dom, arg);\n\t});\n}\n\n// 开始验证\nFormvalidation.prototype.start = function(){\n\tfor(var i = 0; ; i++){\n\t\tvar msg = this.validationFns[i]();\n\t\tif(msg){\n\t\t\treturn msg;\n\t\t}\n\t}\n}\n```\n\n至此，一个最简单的应用就完成了，另外你还可以对这个环境类进行扩展，比如支持复选框、单选框等表单的验证，还可以支持一个表单多规则的验证方式，总之，只要你觉得可以，就ok。程序世界从来都欢迎创造，去发挥你的想象吧。\n\n\n","source":"_posts/2016/02/21/策略模式在表单验证中的应用.md","raw":"title: 策略模式在表单验证中的应用\ndate: 2016-02-21 19:58:19\ncategories:\n- WebFrontEnd\ntags:\n- 设计模式\n- 表单验证\n---\n\n> 在任何一个系统里面，几乎都缺少不了提交表单的过程，比如注册、登陆、下订单等等。这篇文章就阐述了如何编写看着舒服的表单验证代码。\n\n<!-- more -->\n\n# 1、问题 #\n\n相信大家平时再做表单验证的时候基本与如下代码相同：\n\n```js\nif(input1.value === ''){\n\talert('xxx不能为空');\n\treturn false;\n}else if(input2.length < 6){\n\talert('xxx最少6个字符');\n\treturn false;\n}else if(...){\n\t...\n\treturn false;\n}\n```\n\n这样编写代码，的确能够完成业务的需求，能够完成表单的验证，但是存在很多问题，比如：\n\n> 1、代码中包含太多的 if - else 语句，如果验证规则较多的话，看上去太过于恶心......\n\n> 2、验证规则不可复用，如果我们另外一个页面也需要验证相似的表单，我们唯一的做法就是，复制一份，粘贴过去......\n\n> 3、代码不易维护，不需要解释了吧......\n\n# 2、解决办法 #\n\n所谓办法总比问题多，办法是有的，比如马上要讲解的使用 策略模式 使表单验证更优雅更完美，我相信很多人很抵触设计模式，一听设计模式就觉得很遥远，觉得自己在工作中很少用到设计模式，那么你就错了，特别是js这种灵活的语言，有的时候你已经在你的代码中使用了设计模式，只是你不知道而已。更多关于设计模式的东西，以后会陆续写博客描述，这里只希望大家抛弃设计模式神秘的感觉，通俗的讲，它无非就是完成一件事情通用的办法而已。\n\n# 3、畅想 #\n\n回到正题，假如我们不想使用过多的 if - else 语句，那么我们心中比较理想的代码编写方式是什么呢？我们能不能像编写配置一样的去做表单验证呢？再来一个”一键验证“的功能，是不是很爽？答案是肯定的，所以我们心中理想的编写代码的方式如下：\n\n```js\n\n// 获取表单form元素\nvar form = document.getElementById('f1');\n\n// 创建表单校验实例\nvar validation = new Formvalidation(VerifiPolicy);\n// 编写校验配置\nvalidation.add(form.username, 'isNoEmpty', '用户名不能为空');\nvalidation.add(form.password, 'minLength: 6', '密码长度不能小于6个字符');\nvalidation.add(form.code, 'isMobile', '请填写正确的手机号');\n\n// 开始校验，并接收错误信息\nvar errorMsg = validation.start();\n\n// 如果有错误信息输出，说明校验未通过\nif(errorMsg){\n\t// 做一些其他的事\n\treturn false;\n}\n```\n\n怎么样？感受感受，是不是看上去优雅多了？好了，有了心中的畅想，我们就可以向目标迈进了，下一步就要了解了解什么事策略模式了。\n\n# 4、策略模式 #\n\n策略模式，单纯的看它的名字”策略“，指的是做事情的方法，比如你从北京到哈尔滨（为什么到哈尔滨呢？因为我老家是哈尔滨的[偷笑]），你可以有几种策略供选择：\n\n1、飞机，嗖嗖嗖直接就到了，节省时间。\n2、火车，可以选择高铁出行，专为飞机恐惧症者提供。\n3、徒步，不失为一个锻炼身体的选择。\n4、other method......\n\n所以，做一件事你会有很多方法，也就是所谓的策略，而我们今天要讲的策略模式也就是这个意思，它的核心思想是，将做什么和谁去做相分离。所以，一个完整的策略模式要有两个类，一个是策略类，一个是环境类(主要类)，环境类接收请求，但不处理请求，它会把请求委托给策略类，让策略类去处理，而策略类的扩展是很容易的，这样，使得我们的代码易于扩展。\n\n在表单验证的例子中，各种验证的方法组成了策略类，比如：判断是否为空的方法(如：isNoEmpty)，判断最小长度的方法(如：minLength)，判断是否为手机号的方法(isMobule)等等，他们组成了策略类，供给环境类去委托请求。下面，我们就来实战一下。\n\n# 5、编写策略类 #\n\n策略类很简单，它是由一组验证方法组成的对象，即策略对象\n\n```js\n// 策略对象\nvar VerifiPolicy = {\n\t// 判断是否为空\n\tisNoEmpty : function(value, errorMsg){\n\t\tif(value == ''){\n\t\t\treturn errorMsg;\n\t\t}\n\t},\n\t// 判断最小长度\n\tminLength : function(value, length, errorMsg){\n\t\tif(value.length < length){\n\t\t\treturn errorMsg;\n\t\t}\n\t},\n\t// 判断是否为手机号\n\tisMobile : function(value, errorMsg){\n\t\tif(!/(^1[3|5|8][0-9]{9}$)/.test(value)){\n\t\t\treturn errorMsg;\n\t\t}\n\t}\n\t// 其他\n}\n\n```\n\n# 6、编写环境类 #\n\n根据我们的畅想，我们使用add方法添加验证配置，如下：\n\n```js\nvalidation.add(form.username, 'isNoEmpty', '用户名不能为空');\n```\n\nadd方法接受三个参数，第一个参数是表单字段，第二个参数是策略对象中策略方法的名字，第三个参数是验证未通过的错误信息。\n\n然后使用 start 方法开始验证，若验证未通过，返回验证错误信息，如下：\n\n```js\nvar errorMsg = validation.start();\n```\n\n另外，再解释一下下面这句代码：\n\n```\nvalidation.add(form.password, 'minLength: 6', '密码长度不能小于6个字符');\n```\n\nadd方法第一个参数我们说过了，是要验证的表单元素，第二个参数是一个字符串，使用 冒号(:) 分割，前面是策略方法名称，后面是传给这个方法的参数，第三个参数仍然是错误信息，我们希望完成这样的代码，废话不多说，直接上代码，如下：\n\n```\n// 构造函数\nvar Formvalidation = function(VerifiPolicy){\n\t// 保存策略对象\n\tthis.strategies = VerifiPolicy;\n\t// 验证缓存\n\tthis.validationFns = [];\n}\n\n// add 方法\nFormvalidation.prototype.add = function(dom, rule, errorMsg){\n\t\n\tvar ary = rule.split(':');\n\tvar arg = [];\n\tvar self = this;\n\tthis.validationFns.push(function(){\n\t\targ = [];\t// 重置参数\n\t\tvar ruleName = ary[0];\t// 策略对象方法名\n\t\t\n\t\t// 组装参数\n\t\targ.push(dom.value);\n\t\tif(ary[1]){\n\t\t\targ.push(ary[1]);\n\t\t}\n\t\targ.push(errorMsg);\n\t\t\n\t\t// 调用策略函数\n\t\treturn self.strategies[ruleName].apply(dom, arg);\n\t});\n}\n\n// 开始验证\nFormvalidation.prototype.start = function(){\n\tfor(var i = 0; ; i++){\n\t\tvar msg = this.validationFns[i]();\n\t\tif(msg){\n\t\t\treturn msg;\n\t\t}\n\t}\n}\n```\n\n至此，一个最简单的应用就完成了，另外你还可以对这个环境类进行扩展，比如支持复选框、单选框等表单的验证，还可以支持一个表单多规则的验证方式，总之，只要你觉得可以，就ok。程序世界从来都欢迎创造，去发挥你的想象吧。\n\n\n","slug":"策略模式在表单验证中的应用","published":1,"updated":"2016-02-22T02:22:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj669fsk9001gewfclwd6i6am","content":"<blockquote>\n<p>在任何一个系统里面，几乎都缺少不了提交表单的过程，比如注册、登陆、下订单等等。这篇文章就阐述了如何编写看着舒服的表单验证代码。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h1 id=\"1、问题\"><a href=\"#1、问题\" class=\"headerlink\" title=\"1、问题\"></a>1、问题</h1><p>相信大家平时再做表单验证的时候基本与如下代码相同：</p>\n<pre><code class=\"js\">if(input1.value === &#39;&#39;){\n    alert(&#39;xxx不能为空&#39;);\n    return false;\n}else if(input2.length &lt; 6){\n    alert(&#39;xxx最少6个字符&#39;);\n    return false;\n}else if(...){\n    ...\n    return false;\n}\n</code></pre>\n<p>这样编写代码，的确能够完成业务的需求，能够完成表单的验证，但是存在很多问题，比如：</p>\n<blockquote>\n<p>1、代码中包含太多的 if - else 语句，如果验证规则较多的话，看上去太过于恶心……</p>\n<p>2、验证规则不可复用，如果我们另外一个页面也需要验证相似的表单，我们唯一的做法就是，复制一份，粘贴过去……</p>\n<p>3、代码不易维护，不需要解释了吧……</p>\n</blockquote>\n<h1 id=\"2、解决办法\"><a href=\"#2、解决办法\" class=\"headerlink\" title=\"2、解决办法\"></a>2、解决办法</h1><p>所谓办法总比问题多，办法是有的，比如马上要讲解的使用 策略模式 使表单验证更优雅更完美，我相信很多人很抵触设计模式，一听设计模式就觉得很遥远，觉得自己在工作中很少用到设计模式，那么你就错了，特别是js这种灵活的语言，有的时候你已经在你的代码中使用了设计模式，只是你不知道而已。更多关于设计模式的东西，以后会陆续写博客描述，这里只希望大家抛弃设计模式神秘的感觉，通俗的讲，它无非就是完成一件事情通用的办法而已。</p>\n<h1 id=\"3、畅想\"><a href=\"#3、畅想\" class=\"headerlink\" title=\"3、畅想\"></a>3、畅想</h1><p>回到正题，假如我们不想使用过多的 if - else 语句，那么我们心中比较理想的代码编写方式是什么呢？我们能不能像编写配置一样的去做表单验证呢？再来一个”一键验证“的功能，是不是很爽？答案是肯定的，所以我们心中理想的编写代码的方式如下：</p>\n<pre><code class=\"js\">\n// 获取表单form元素\nvar form = document.getElementById(&#39;f1&#39;);\n\n// 创建表单校验实例\nvar validation = new Formvalidation(VerifiPolicy);\n// 编写校验配置\nvalidation.add(form.username, &#39;isNoEmpty&#39;, &#39;用户名不能为空&#39;);\nvalidation.add(form.password, &#39;minLength: 6&#39;, &#39;密码长度不能小于6个字符&#39;);\nvalidation.add(form.code, &#39;isMobile&#39;, &#39;请填写正确的手机号&#39;);\n\n// 开始校验，并接收错误信息\nvar errorMsg = validation.start();\n\n// 如果有错误信息输出，说明校验未通过\nif(errorMsg){\n    // 做一些其他的事\n    return false;\n}\n</code></pre>\n<p>怎么样？感受感受，是不是看上去优雅多了？好了，有了心中的畅想，我们就可以向目标迈进了，下一步就要了解了解什么事策略模式了。</p>\n<h1 id=\"4、策略模式\"><a href=\"#4、策略模式\" class=\"headerlink\" title=\"4、策略模式\"></a>4、策略模式</h1><p>策略模式，单纯的看它的名字”策略“，指的是做事情的方法，比如你从北京到哈尔滨（为什么到哈尔滨呢？因为我老家是哈尔滨的[偷笑]），你可以有几种策略供选择：</p>\n<p>1、飞机，嗖嗖嗖直接就到了，节省时间。<br>2、火车，可以选择高铁出行，专为飞机恐惧症者提供。<br>3、徒步，不失为一个锻炼身体的选择。<br>4、other method……</p>\n<p>所以，做一件事你会有很多方法，也就是所谓的策略，而我们今天要讲的策略模式也就是这个意思，它的核心思想是，将做什么和谁去做相分离。所以，一个完整的策略模式要有两个类，一个是策略类，一个是环境类(主要类)，环境类接收请求，但不处理请求，它会把请求委托给策略类，让策略类去处理，而策略类的扩展是很容易的，这样，使得我们的代码易于扩展。</p>\n<p>在表单验证的例子中，各种验证的方法组成了策略类，比如：判断是否为空的方法(如：isNoEmpty)，判断最小长度的方法(如：minLength)，判断是否为手机号的方法(isMobule)等等，他们组成了策略类，供给环境类去委托请求。下面，我们就来实战一下。</p>\n<h1 id=\"5、编写策略类\"><a href=\"#5、编写策略类\" class=\"headerlink\" title=\"5、编写策略类\"></a>5、编写策略类</h1><p>策略类很简单，它是由一组验证方法组成的对象，即策略对象</p>\n<pre><code class=\"js\">// 策略对象\nvar VerifiPolicy = {\n    // 判断是否为空\n    isNoEmpty : function(value, errorMsg){\n        if(value == &#39;&#39;){\n            return errorMsg;\n        }\n    },\n    // 判断最小长度\n    minLength : function(value, length, errorMsg){\n        if(value.length &lt; length){\n            return errorMsg;\n        }\n    },\n    // 判断是否为手机号\n    isMobile : function(value, errorMsg){\n        if(!/(^1[3|5|8][0-9]{9}$)/.test(value)){\n            return errorMsg;\n        }\n    }\n    // 其他\n}\n</code></pre>\n<h1 id=\"6、编写环境类\"><a href=\"#6、编写环境类\" class=\"headerlink\" title=\"6、编写环境类\"></a>6、编写环境类</h1><p>根据我们的畅想，我们使用add方法添加验证配置，如下：</p>\n<pre><code class=\"js\">validation.add(form.username, &#39;isNoEmpty&#39;, &#39;用户名不能为空&#39;);\n</code></pre>\n<p>add方法接受三个参数，第一个参数是表单字段，第二个参数是策略对象中策略方法的名字，第三个参数是验证未通过的错误信息。</p>\n<p>然后使用 start 方法开始验证，若验证未通过，返回验证错误信息，如下：</p>\n<pre><code class=\"js\">var errorMsg = validation.start();\n</code></pre>\n<p>另外，再解释一下下面这句代码：</p>\n<pre><code>validation.add(form.password, &#39;minLength: 6&#39;, &#39;密码长度不能小于6个字符&#39;);\n</code></pre><p>add方法第一个参数我们说过了，是要验证的表单元素，第二个参数是一个字符串，使用 冒号(:) 分割，前面是策略方法名称，后面是传给这个方法的参数，第三个参数仍然是错误信息，我们希望完成这样的代码，废话不多说，直接上代码，如下：</p>\n<pre><code>// 构造函数\nvar Formvalidation = function(VerifiPolicy){\n    // 保存策略对象\n    this.strategies = VerifiPolicy;\n    // 验证缓存\n    this.validationFns = [];\n}\n\n// add 方法\nFormvalidation.prototype.add = function(dom, rule, errorMsg){\n\n    var ary = rule.split(&#39;:&#39;);\n    var arg = [];\n    var self = this;\n    this.validationFns.push(function(){\n        arg = [];    // 重置参数\n        var ruleName = ary[0];    // 策略对象方法名\n\n        // 组装参数\n        arg.push(dom.value);\n        if(ary[1]){\n            arg.push(ary[1]);\n        }\n        arg.push(errorMsg);\n\n        // 调用策略函数\n        return self.strategies[ruleName].apply(dom, arg);\n    });\n}\n\n// 开始验证\nFormvalidation.prototype.start = function(){\n    for(var i = 0; ; i++){\n        var msg = this.validationFns[i]();\n        if(msg){\n            return msg;\n        }\n    }\n}\n</code></pre><p>至此，一个最简单的应用就完成了，另外你还可以对这个环境类进行扩展，比如支持复选框、单选框等表单的验证，还可以支持一个表单多规则的验证方式，总之，只要你觉得可以，就ok。程序世界从来都欢迎创造，去发挥你的想象吧。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>在任何一个系统里面，几乎都缺少不了提交表单的过程，比如注册、登陆、下订单等等。这篇文章就阐述了如何编写看着舒服的表单验证代码。</p>\n</blockquote>","more":"<h1 id=\"1、问题\"><a href=\"#1、问题\" class=\"headerlink\" title=\"1、问题\"></a>1、问题</h1><p>相信大家平时再做表单验证的时候基本与如下代码相同：</p>\n<pre><code class=\"js\">if(input1.value === &#39;&#39;){\n    alert(&#39;xxx不能为空&#39;);\n    return false;\n}else if(input2.length &lt; 6){\n    alert(&#39;xxx最少6个字符&#39;);\n    return false;\n}else if(...){\n    ...\n    return false;\n}\n</code></pre>\n<p>这样编写代码，的确能够完成业务的需求，能够完成表单的验证，但是存在很多问题，比如：</p>\n<blockquote>\n<p>1、代码中包含太多的 if - else 语句，如果验证规则较多的话，看上去太过于恶心……</p>\n<p>2、验证规则不可复用，如果我们另外一个页面也需要验证相似的表单，我们唯一的做法就是，复制一份，粘贴过去……</p>\n<p>3、代码不易维护，不需要解释了吧……</p>\n</blockquote>\n<h1 id=\"2、解决办法\"><a href=\"#2、解决办法\" class=\"headerlink\" title=\"2、解决办法\"></a>2、解决办法</h1><p>所谓办法总比问题多，办法是有的，比如马上要讲解的使用 策略模式 使表单验证更优雅更完美，我相信很多人很抵触设计模式，一听设计模式就觉得很遥远，觉得自己在工作中很少用到设计模式，那么你就错了，特别是js这种灵活的语言，有的时候你已经在你的代码中使用了设计模式，只是你不知道而已。更多关于设计模式的东西，以后会陆续写博客描述，这里只希望大家抛弃设计模式神秘的感觉，通俗的讲，它无非就是完成一件事情通用的办法而已。</p>\n<h1 id=\"3、畅想\"><a href=\"#3、畅想\" class=\"headerlink\" title=\"3、畅想\"></a>3、畅想</h1><p>回到正题，假如我们不想使用过多的 if - else 语句，那么我们心中比较理想的代码编写方式是什么呢？我们能不能像编写配置一样的去做表单验证呢？再来一个”一键验证“的功能，是不是很爽？答案是肯定的，所以我们心中理想的编写代码的方式如下：</p>\n<pre><code class=\"js\">\n// 获取表单form元素\nvar form = document.getElementById(&#39;f1&#39;);\n\n// 创建表单校验实例\nvar validation = new Formvalidation(VerifiPolicy);\n// 编写校验配置\nvalidation.add(form.username, &#39;isNoEmpty&#39;, &#39;用户名不能为空&#39;);\nvalidation.add(form.password, &#39;minLength: 6&#39;, &#39;密码长度不能小于6个字符&#39;);\nvalidation.add(form.code, &#39;isMobile&#39;, &#39;请填写正确的手机号&#39;);\n\n// 开始校验，并接收错误信息\nvar errorMsg = validation.start();\n\n// 如果有错误信息输出，说明校验未通过\nif(errorMsg){\n    // 做一些其他的事\n    return false;\n}\n</code></pre>\n<p>怎么样？感受感受，是不是看上去优雅多了？好了，有了心中的畅想，我们就可以向目标迈进了，下一步就要了解了解什么事策略模式了。</p>\n<h1 id=\"4、策略模式\"><a href=\"#4、策略模式\" class=\"headerlink\" title=\"4、策略模式\"></a>4、策略模式</h1><p>策略模式，单纯的看它的名字”策略“，指的是做事情的方法，比如你从北京到哈尔滨（为什么到哈尔滨呢？因为我老家是哈尔滨的[偷笑]），你可以有几种策略供选择：</p>\n<p>1、飞机，嗖嗖嗖直接就到了，节省时间。<br>2、火车，可以选择高铁出行，专为飞机恐惧症者提供。<br>3、徒步，不失为一个锻炼身体的选择。<br>4、other method……</p>\n<p>所以，做一件事你会有很多方法，也就是所谓的策略，而我们今天要讲的策略模式也就是这个意思，它的核心思想是，将做什么和谁去做相分离。所以，一个完整的策略模式要有两个类，一个是策略类，一个是环境类(主要类)，环境类接收请求，但不处理请求，它会把请求委托给策略类，让策略类去处理，而策略类的扩展是很容易的，这样，使得我们的代码易于扩展。</p>\n<p>在表单验证的例子中，各种验证的方法组成了策略类，比如：判断是否为空的方法(如：isNoEmpty)，判断最小长度的方法(如：minLength)，判断是否为手机号的方法(isMobule)等等，他们组成了策略类，供给环境类去委托请求。下面，我们就来实战一下。</p>\n<h1 id=\"5、编写策略类\"><a href=\"#5、编写策略类\" class=\"headerlink\" title=\"5、编写策略类\"></a>5、编写策略类</h1><p>策略类很简单，它是由一组验证方法组成的对象，即策略对象</p>\n<pre><code class=\"js\">// 策略对象\nvar VerifiPolicy = {\n    // 判断是否为空\n    isNoEmpty : function(value, errorMsg){\n        if(value == &#39;&#39;){\n            return errorMsg;\n        }\n    },\n    // 判断最小长度\n    minLength : function(value, length, errorMsg){\n        if(value.length &lt; length){\n            return errorMsg;\n        }\n    },\n    // 判断是否为手机号\n    isMobile : function(value, errorMsg){\n        if(!/(^1[3|5|8][0-9]{9}$)/.test(value)){\n            return errorMsg;\n        }\n    }\n    // 其他\n}\n</code></pre>\n<h1 id=\"6、编写环境类\"><a href=\"#6、编写环境类\" class=\"headerlink\" title=\"6、编写环境类\"></a>6、编写环境类</h1><p>根据我们的畅想，我们使用add方法添加验证配置，如下：</p>\n<pre><code class=\"js\">validation.add(form.username, &#39;isNoEmpty&#39;, &#39;用户名不能为空&#39;);\n</code></pre>\n<p>add方法接受三个参数，第一个参数是表单字段，第二个参数是策略对象中策略方法的名字，第三个参数是验证未通过的错误信息。</p>\n<p>然后使用 start 方法开始验证，若验证未通过，返回验证错误信息，如下：</p>\n<pre><code class=\"js\">var errorMsg = validation.start();\n</code></pre>\n<p>另外，再解释一下下面这句代码：</p>\n<pre><code>validation.add(form.password, &#39;minLength: 6&#39;, &#39;密码长度不能小于6个字符&#39;);\n</code></pre><p>add方法第一个参数我们说过了，是要验证的表单元素，第二个参数是一个字符串，使用 冒号(:) 分割，前面是策略方法名称，后面是传给这个方法的参数，第三个参数仍然是错误信息，我们希望完成这样的代码，废话不多说，直接上代码，如下：</p>\n<pre><code>// 构造函数\nvar Formvalidation = function(VerifiPolicy){\n    // 保存策略对象\n    this.strategies = VerifiPolicy;\n    // 验证缓存\n    this.validationFns = [];\n}\n\n// add 方法\nFormvalidation.prototype.add = function(dom, rule, errorMsg){\n\n    var ary = rule.split(&#39;:&#39;);\n    var arg = [];\n    var self = this;\n    this.validationFns.push(function(){\n        arg = [];    // 重置参数\n        var ruleName = ary[0];    // 策略对象方法名\n\n        // 组装参数\n        arg.push(dom.value);\n        if(ary[1]){\n            arg.push(ary[1]);\n        }\n        arg.push(errorMsg);\n\n        // 调用策略函数\n        return self.strategies[ruleName].apply(dom, arg);\n    });\n}\n\n// 开始验证\nFormvalidation.prototype.start = function(){\n    for(var i = 0; ; i++){\n        var msg = this.validationFns[i]();\n        if(msg){\n            return msg;\n        }\n    }\n}\n</code></pre><p>至此，一个最简单的应用就完成了，另外你还可以对这个环境类进行扩展，比如支持复选框、单选框等表单的验证，还可以支持一个表单多规则的验证方式，总之，只要你觉得可以，就ok。程序世界从来都欢迎创造，去发挥你的想象吧。</p>"},{"title":"基于webpack和vue.js搭建的H5端框架(其实主要用于Hybrid开发H5端框架，但是依然能够作为纯web端使用)","date":"2016-03-25T07:17:33.000Z","_content":"\n人类的发展得益于对追求不断的提升，在能活着的基础上是否要活得潇洒一点，技术的发展亦如是。在公司作为一个最最最最最最最底层的搬砖码农，经历了两个版本的铸(zhe)炼(mo)之后，我痛下决心今后一定要：..............一定要和产品惺(shi)惺(bu)相(liang)惜(li)。\n\n<!-- more -->\n\n# 开始之前 #\n\n本文包含以下技术，文中尽量给与详细的描述，并且附上参考链接，读者可以深入学习：\n\n1、[webpack](http://webpack.github.io/)\n2、[Vue.js](http://cn.vuejs.org/)\n3、[npm](https://www.npmjs.com/)\n4、nodejs ---- 这个就不给连接了，因为上面的连接都是在你实践的过程中要去不断访问的\n5、[ES6语法](http://es6.ruanyifeng.com/#README)\n\n另外，这套教程的代码都在我的github上，读者可以对照着代码来看，不过还是希望大家自己亲手搭建，体验这个过程，git地址：\n\n[git地址](https://github.com/HcySunYang/h5_frame)\n\n# 前言 #\n\n在对着产品高举中指怒发心中之愤后，真正能够解决问题的是自身上的改变，有句话说的好：你虽然改变不了全世界，但是你有机会改变你自己。秉承着“不听老人言，吃亏在眼前”的优良作风，我还是决定玩火自焚。\n\n### 问题所在 ###\n\n之前的项目总结为以下内容：\n\n>1、AMD模块规范开发，使用requirejs实现，使用rjs打包，最终导致的结果是，输出的项目臃肿，肿的就像一坨狗不理......不忍直视\n2、使用gulp进行打包，这一点貌似没有可吐槽的地方，毕竟都是被grunt折磨过来的......\n3、数据的渲染使用模板引擎，这就意味着你要手动管理DOM，这样，你的业务代码参杂着你的数据处理、DOM管理，满屏幕的毛线......\n4、模块化不足，虽然使用require进行了模块管理，但是大部分业务逻辑还是充斥在一个文件里，这与最近流行的组件化概念冰火不容，拒绝落后......\n5、诸如 扩展性 、 维护性 我想早已不言而喻，不需赘述，再述就真TM是累赘了。\n\n新框架要解决的问题：\n\n>1、要使构建输出的项目像你邻家小妹妹一样、瘦的皮包骨。（也许是营养不良）\n2、要实现真正的模块化、组件化的开发方式，真正去解决维护难、扩展难的问题。（从此不怕产品汪）\n3、业务逻辑专注数据处理，手动管理DOM的年代就像......像什么呢？（毕竟成人用品也越来越自动化了）\n4、等等.......（其实好处无需赘述，来，往下看）\n\n为了达成以上目标，我们探讨一下解决方案：\n\n*<b>1、老项目的构建输出为什么臃肿？</b>*\n\n答：因为使用的是require的rjs进行构建打包的，了解rjs的都知道，它会把项目所有依赖都打包在一个文件里，如果项目中有很多页面依赖这个模块，那么rjs并不会把这个模块提取出来作为公共模块，所以就会有很多复制性的内容，所以项目自然臃肿。\n\n*解决方案：*使用webpack配合相应的loader，来完成模块加载和构建的工作。\n\n*<b>2、老项目为什么模块化的不足？</b>*\n\n答：老项目的模块化，仅仅体现在js层面，解决了模块引用的问题，但在开发方式上，依然可以看做是过程式的，这样的结果就导致了项目的难扩展和难维护，让开发人员在与产品汪的对峙中，并不从容。\n\n*解决方案：*Vue.js能够很好的解决组件化的问题，配合 Vue.js 官方提供的 *vue-loader* 能够很好的结合webpack做组件化的开发架构。\n\n*<b>3、如何避免手动管理DOM？</b>*\n\n答：如果你在做数据展示这一块的开发工作，相信你一定体会颇深，发送http请求到服务端，拿到返回的数据后手动渲染DOM至页面，这是最原始的开发方式，无非再加一个模板引擎之类的，但最终还是避免不了手动渲染，如果页面逻辑复杂，比如给你来一个翻页的功能，再来一个筛选项，估计你会觉得世界并不那么美好。\n\n*解决方案：*MVVM模式能够很好的解决这个问题，而Vue.js的核心也是MVVM。\n\n# webpack #\n\n你肯定听说过webpack，如果直接对你描述什么是webpack你可能感受不到他的好处，那么在这之前，我相信你肯定使用过gulp或者grunt，如果你没使用过也可以，至少你要听说过并且知道gulp和grunt是干什么的，假如这个你还不清楚，那么你并不是一个合格的前端开发人员，这篇文章也不适合你，你可以从基础的地方慢慢学起。\n\ngulp和grunt对于每一个前端开发人员应该是不陌生的，它们为前端提供了自动化构建的能力，并且有自己的生态圈，有很多插件，使得我们告别刀耕火种的时代，但是它们并没有解决模块加载的问题，比如我们之前的项目是使用gulp构建的，但是模块化得工作还是要靠require和rjs来完成，而gulp除了完成一些其他任务之外，就变成了帮助我们免除手动执行命令的工具了，别无它用。\n\n而webpack就不同了，webpack的哲学是一切皆是模块，无论是js/css/sass/img/coffeejs/ttf....等等，webpack可以使用自定义的loader去把一切资源当做模块加载，这样就解决了模块依赖的问题，同时，利用插件还可以对项目进行优化，由于模块的加载和项目的构建优化都是通过webpack一个”人“来解决的，所以模块的加载和项目的构建优化并不是无机分离的，而是有机的结合在一起的，是一个组合的过程，这使得webpack在这方面能够完成的更出色，这也是webpack的优势所在。\n\n如果你看不懂上面的描述，没关系，你只需要知道一下几点：\n\n1、过去使用require和rjs等进行模块加载的方式，可以替换为webpack提供的指定loader去完成，你也可以自己开发加载特定资源的loader。\n2、过去使用gulp和grunt完成项目构建优化的方式，可以替换成webpack提供的插件和特定的配置去完成。\n3、由于模块的加载和项目的构建优化有机的结合，所以webpack能够更好的完成这项工作\n4、并不是说有了webpack就淘汰的gulp等，有些特定的任务，还是要使用gulp去自定义完成的。但是不保证webpack的未来发展趋势会怎么样。\n\n最后，给大家分享一个官方的教程，这个教程的最开始有坑的地方，如果读者遇到了坑，可以在这里给我留言，我会为大家解答，不过总体来讲，这个教程适合入门，唯一不足的就是教程是英文的，英文的也不用怕，本人的英语没过四级，但是现在依然能够看得懂英文技术文章。教程链接：[http://blog.madewithlove.be/post/webpack-your-bags/](http://blog.madewithlove.be/post/webpack-your-bags/)\n\n# Vue.js #\n\n[Vue.js](http://cn.vuejs.org/)是一个MVVM模式的框架，如果读者有angular经验，一定能够很快入门Vue的，那么问题来了，为什么使用Vue而不用angular，\n首先，Vue的体积小，轻量在移动端开发始终是一个不可忽略的话题，其次，Vue在实现上与angular有本质的区别，读者可以通过下面两个链接来了解：\n\n1、[Vue的变化追踪和计算属性的区别等](http://cn.vuejs.org/guide/reactivity.html)\n\n2、[Vue 与 angular 及 react 等框架的对比](http://cn.vuejs.org/guide/comparison.html)\n\n3、第三点就是Vue提供了webpack的loader ----> [vue-loader]，使用它可以让项目的组件化思想更加清晰\n\n综上所述，这就是选用Vue的原因\n\n# npm 和 nodejs #\n\nnpm 的全称是 *nodejs包管理*，现在越来越多的项目(包)都可以通过npm来安装管理，nodejs是js运行在服务器端的平台，它使得js的能力进一步提高，我们还要使用nodejs配合 webpack 来完成热加载的功能。所以读者最好有nodejs的开发经验，如果有express的经验更好。\n\n# 让我们一步一步从零搭建这个项目 #\n\n首先新建一个目录，名为 myProject ，这是我们的项目目录。然后执行一些基本的步骤，比如 npm init 命令，在我们的项目中生成 package.json 文件，这几乎是必选的，因为我们的项目要有很多依赖，都是通过npm来管理的，而npm对于我们项目的管理，则是通过package.json文件：\n\n```$\nnpm init\n```\n\n执行npm init之后，会提示你填写一些项目的信息，一直回车默认就好了，或者直接执行 npm init -y 直接跳过询问步骤\n然后我们新建一个叫做 app 的目录，这个是我们页面模块的目录，再在app目录下建立一个index目录，假设这个是首页模块的目录，然后再在index目录下建立一个 index.html 文件和 index.js 文件，分别是首页入口html文件和主js文件，然后再在index目录下建立一个components目录，这个目录用作存放首页组件模块的目录，因为我们最终要实现组件化开发。这样，当你完成上面的步骤后，你的项目看上去应该是这样的：\n\n![项目结构](http://7xlolm.com1.z0.glb.clouddn.com/20160325b.jpg)\n\n接下来通过npm安装项目依赖项：\n\n```$\nnpm install\\\n  webpack webpack-dev-server\\\n  vue-loader vue-html-loader css-loader vue-style-loader vue-hot-reload-api\\\n  babel-loader babel-core babel-plugin-transform-runtime babel-preset-es2015\\\n  babel-runtime@5\\\n  --save-dev\n\nnpm install vue --save\n```\n\n这个时候，你的package.json文件看起来应该是这样的：\n\n```\n\"devDependencies\": {\n    \"babel-core\": \"^6.3.17\",\n    \"babel-loader\": \"^6.2.0\",\n    \"babel-plugin-transform-runtime\": \"^6.3.13\",\n    \"babel-preset-es2015\": \"^6.3.13\",\n    \"babel-runtime\": \"^5.8.34\",\n    \"css-loader\": \"^0.23.0\",\n    \"vue-hot-reload-api\": \"^1.2.2\",\n    \"vue-html-loader\": \"^1.0.0\",\n    \"vue-style-loader\": \"^1.0.0\",\n    \"vue-loader\": \"^7.2.0\",\n    \"webpack\": \"^1.12.9\",\n    \"webpack-dev-server\": \"^1.14.0\"\n  },\n  \"dependencies\": {\n    \"vue\": \"^1.0.13\"\n  },\n```\n\n我们安装了 babel 一系列包，用来解析ES6语法，因为我们使用ES6来开发项目，如果你不了解ES6语法，建议你看一看[阮老师的教程](http://es6.ruanyifeng.com/)，然后我们安装了一些loader包，比如css-loader/vue-loader等等，因为webpack是使用这些指定的loader去加载指定的文件的。\n\n另外我们还使用 npm install vue --save 命令安装了 vue ，这个就是我们要在项目中使用的vue.js，我们可以直接像开发nodejs应用一样，直接require('vue');即可，而不需要通过script标签引入，这一点在开发中很爽。\n\n安装完了依赖，编辑以下文件并保存到相应位置：\n\n1、index.html文件：\n\n```\n<!DOCTYPE html>\n<html lang=\"zh\">\n\t<head>\n\t\t<meta name=\"viewport\" content=\"width=device-width, height=device-height, initial-scale=1.0, user-scalable=no\">\n\t\t<meta charset=\"utf-8\">\n\t\t<title>首页</title>\n\t</head>\n\t<body>\n\t\t<!-- vue的组件以自定义标签的形式使用 -->\n\t\t<favlist></favlist>\n\t</body>\n</html>\n\n```\n\n2、index.js文件：\n\n```\nimport Vue from 'Vue'\nimport Favlist from './components/Favlist'\n\nnew Vue({\n\tel: 'body',\n\tcomponents: { Favlist }\n})\n```\n\n3、在components目录下新建一个 Favlist.vue 文件，作为我们的第一个组件：\n\n```\n<template>\n    <div v-for=\"n in 10\">div</div>\n</template>\n\n<script>\n    export default {\n        data () {\n            return {\n                msg: 'Hello World!'\n            }\n        }\n    }\n</script>\n\n<style>\n    html{\n        background: red;\n    }\n</style>\n\n```\n\n要看懂上面的代码，你需要了解vue.js，假如你看不懂也没关系，我们首先在index.html中使用了自定义标签（即组件），然后在index.js中引入了Vue和我们的Favlist.vue组件，Favlist.vue文件中，我们使用了基本的vue组件语法，最后，我们希望它运行起来，这个时候，我们就需要webpack了。\n\n在项目目录下新建 build 目录，用来存放我们的构建相关的代码文件等，然后在build目录下新建 webpack.config.js 这是我们的webpack配置文件，webpack需要通过读取你的配置，进行相应的操作，类似于gulpfile.js或者gruntfile.js等。\n\nwebpack.config.js\n\n```\n// nodejs 中的path模块\nvar path = require('path');\n\nmodule.exports = {\n    // 入口文件，path.resolve()方法，可以结合我们给定的两个参数最后生成绝对路径，最终指向的就是我们的index.js文件\n    entry: path.resolve(__dirname, '../app/index/index.js'),\n    // 输出配置\n    output: {\n        // 输出路径是 myProject/output/static\n        path: path.resolve(__dirname, '../output/static'),\n        publicPath: 'static/',\n        filename: '[name].[hash].js',\n        chunkFilename: '[id].[chunkhash].js'\n    },\n    module: {\n        \n        loaders: [\n            // 使用vue-loader 加载 .vue 结尾的文件\n            {\n                test: /\\.vue$/, \n                loader: 'vue'   \n            }\n        ]\n    }\n}\n```\n\n上例中，相信你已经看懂了我的配置，入口文件是index.js文件，配置了相应输出，然后使用 vue-loader 去加载 .vue 结尾的文件，接下来我们就可以构建项目了，我们可以在命令行中执行：\n\n```\nwebpack --display-modules --display-chunks --config build/webpack.config.js\n```\n\n通过webpack命令，并且通过 --config 选项指定了我们配置文件的位置是 'build/webpack.config.js'，并通过 --display-modules 和 --display-chunks 选项显示相应的信息。如果你执行上面的命令，可能得到下图的错误：\n\n![报错](http://7xlolm.com1.z0.glb.clouddn.com/20160325c.jpg)\n\n错误提示我们应该选择合适的loader去加载这个 './app/index/index.js' 这个文件，并且说不期望index.js文件中的标识符（Unexpected token），这是因为我们使用了ES6的语法 import 语句，所以我们要使用 babel-loader 去加载我们的js文件，在配置文件中添加一个loaders项目，如下：\n\n```\n// nodejs 中的path模块\nvar path = require('path');\n\nmodule.exports = {\n    // 入口文件，path.resolve()方法，可以结合我们给定的两个参数最后生成绝对路径，最终指向的就是我们的index.js文件\n    entry: path.resolve(__dirname, '../app/index/index.js'),\n    // 输出配置\n    output: {\n        // 输出路径是 myProject/output/static\n        path: path.resolve(__dirname, '../output/static'),\n        publicPath: 'static/',\n        filename: '[name].[hash].js',\n        chunkFilename: '[id].[chunkhash].js'\n    },\n    module: {\n        \n        loaders: [\n            // 使用vue-loader 加载 .vue 结尾的文件\n            {\n                test: /\\.vue$/, \n                loader: 'vue'   \n            },\n            {\n                test: /\\.js$/,\n                loader: 'babel?presets=es2015',\n                exclude: /node_modules/\n            }\n        ]\n    }\n}\n```\n\n现在再运行构建命令 ： 'webpack --display-modules --display-chunks --config build/webpack.config.js'\n\nsorry，不出意外，你应该得到如下错误：\n\n![错误](http://7xlolm.com1.z0.glb.clouddn.com/20160325d.jpg)\n\n它说没有发现 './components/Favlist' 模块，而我们明明有 ./components/Favlist.vue 文件，为什么它没发现呢？它瞎了？其实是这样的，当webpack试图去加载模块的时候，它默认是查找以 .js 结尾的文件的，它并不知道 .vue 结尾的文件是什么鬼玩意儿，所以我们要在配置文件中告诉webpack，遇到 .vue 结尾的也要去加载，添加 resolve 配置项，如下：\n\n```\n// nodejs 中的path模块\nvar path = require('path');\n\nmodule.exports = {\n    // 入口文件，path.resolve()方法，可以结合我们给定的两个参数最后生成绝对路径，最终指向的就是我们的index.js文件\n    entry: path.resolve(__dirname, '../app/index/index.js'),\n    // 输出配置\n    output: {\n        // 输出路径是 myProject/output/static\n        path: path.resolve(__dirname, '../output/static'),\n        publicPath: 'static/',\n        filename: '[name].[hash].js',\n        chunkFilename: '[id].[chunkhash].js'\n    },\n    resolve: {\n        extensions: ['', '.js', '.vue']\n    },\n    module: {\n        \n        loaders: [\n            // 使用vue-loader 加载 .vue 结尾的文件\n            {\n                test: /\\.vue$/, \n                loader: 'vue'   \n            },\n            {\n                test: /\\.js$/,\n                loader: 'babel?presets=es2015',\n                exclude: /node_modules/\n            }\n        ]\n    }\n}\n```\n\n这样，当我们去加载 './components/Favlist' 这样的模块时，webpack首先会查找 ./components/Favlist.js 如果没有发现Favlist.js文件就会继续查找 Favlist.vue 文件，现在再次运行构建命令，我们成功了，这时我们会在我们的输出目录中看到一个js文件：\n\n![输出](http://7xlolm.com1.z0.glb.clouddn.com/20160325e.jpg)\n\n之所以会这样输出，是因为我们的 webpack.config.js 文件中的输出配置中指定了相应的输出信息，这个时候，我们修改 index.html ，将输出的js文件引入：\n\n```\n<!DOCTYPE html>\n<html lang=\"zh\">\n\t<head>\n\t\t<meta name=\"viewport\" content=\"width=device-width, height=device-height, initial-scale=1.0, user-scalable=no\">\n\t\t<meta charset=\"utf-8\">\n\t\t<title>首页</title>\n\t</head>\n\t<body>\n\t\t<!-- vue的组件以自定义标签的形式使用 -->\n\t\t<favlist></favlist>\n\n\t\t<script src=\"../../output/static/main.ce853b65bcffc3b16328.js\"></script>\n\t</body>\n</html>\n```\n\n然后用浏览器打开这个页面，你可以看到你写的代码正确的执行了。\n\n那么问题来了，难道我们每次都要手动的引入输出的js文件吗？因为每次构建输出的js文件都带有 hash 值，如 main.ce853b65bcffc3b16328.js，就不能更智能一点吗？每次都自动写入？怎么会不可能，否则这东西还能火吗，要实现这个功能，我们就要使用webpack的插件了，[html-webpack-plugin](https://www.npmjs.com/package/html-webpack-plugin)插件，这个插件可以创建html文件，并自动将依赖写入html文件中。\n\n首先安装 html-webpack-plugin 插件：\n\n```\nnpm install html-webpack-plugin --save-dev\n```\n\n然后在修改配置项：\n\n```\n// nodejs 中的path模块\nvar path = require('path');\nvar HtmlWebpackPlugin = require('html-webpack-plugin')\n\nmodule.exports = {\n    // 入口文件，path.resolve()方法，可以结合我们给定的两个参数最后生成绝对路径，最终指向的就是我们的index.js文件\n    entry: path.resolve(__dirname, '../app/index/index.js'),\n    // 输出配置\n    output: {\n        // 输出路径是 myProject/output/static\n        path: path.resolve(__dirname, '../output/static'),\n        publicPath: 'static/',\n        filename: '[name].[hash].js',\n        chunkFilename: '[id].[chunkhash].js'\n    },\n    resolve: {\n        extensions: ['', '.js', '.vue']\n    },\n    module: {\n        \n        loaders: [\n            // 使用vue-loader 加载 .vue 结尾的文件\n            {\n                test: /\\.vue$/, \n                loader: 'vue'   \n            },\n            {\n                test: /\\.js$/,\n                loader: 'babel?presets=es2015',\n                exclude: /node_modules/\n            }\n        ]\n    },\n    plugins: [\n        new HtmlWebpackPlugin({\n            filename: '../index.html',\n            template: path.resolve(__dirname, '../app/index/index.html'),\n            inject: true\n        })\n    ]\n}\n```\n\n然后再次执行构建命令，成功之后，看你的输出目录，多出来一个index.html文件，双击它，代码正确执行，你可以打开这个文件查看一下，webpack自动帮我们引入了相应的文件。\n\n问题继续来了，难道每次我们都要构建之后才能查看运行的代码吗？那岂不是很没有效率，别担心，webpack提供了几种方式，进行热加载，在开发模式中，我们使用这种方式来提高效率，这里要介绍的，是使用 [webpack-dev-middleware](https://www.npmjs.com/package/webpack-dev-middleware)中间件和[webpack-hot-middleware](https://www.npmjs.com/package/webpack-hot-middleware)中间件，首先安装两个中间件：\n\n```\nnpm install webpack-dev-middleware webpack-hot-middleware --save-dev\n```\n\n另外，还要安装express，这是一个nodejs框架\n\n```\nnpm install express --save-dev\n```\n\n在开始之前，我先简单介绍一下这两个中间件，之所以叫做中间件，是因为nodejs的一个叫做express的框架中有中间件的概念，而这两个包要作为express中间件使用，所以称它们为中间件，那么他们能干什么呢？\n\n*<b>1、webpack-dev-middleware</b>*\n\n我们之前所面临的问题是，如果我们的代码改动了，我们要想看到浏览器的变化，需要先对项目进行构建，然后才能查看效果，这样对于开发效率来讲，简直就是不可忍受的一件事，试想我仅仅修改一个背景颜色就要构建一下项目，这尼玛坑爹啊，好在有[webpack-dev-middleware](https://www.npmjs.com/package/webpack-dev-middleware)中间件，它是对webpack一个简单的包装，它可以通过连接服务器服务那些从webpack发射出来的文件，它有一下几点好处：\n\n1、不会向硬盘写文件，而是在内存中，注意我们构建项目实际就是向硬盘写文件。\n\n2、当文件改变的时候，这个中间件不会再服务旧的包，你可以直接帅新浏览器就能看到最新的效果，这样你就不必等待构建的时间，所见即所得。\n\n下面我们在build目录中创建一个 dev-server.js 的文件，并写入一下内容：\n\n```\n// 引入必要的模块\nvar express = require('express')\nvar webpack = require('webpack')\nvar config = require('./webpack.config')\n\n// 创建一个express实例\nvar app = express()\n\n// 调用webpack并把配置传递过去\nvar compiler = webpack(config)\n\n// 使用 webpack-dev-middleware 中间件\nvar devMiddleware = require('webpack-dev-middleware')(compiler, {\n    publicPath: config.output.publicPath,\n    stats: {\n        colors: true,\n        chunks: false\n    }\n})\n\n// 注册中间件\napp.use(devMiddleware)\n\n// 监听 8888端口，开启服务器\napp.listen(8888, function (err) {\n    if (err) {\n        console.log(err)\n        return\n    }\n    console.log('Listening at http://localhost:8888')\n})\n```\n\n此时，我们在项目根目录运行下面的命令，开启服务：\n\n```\nnode build/dev-server.js\n```\n\n如果看到下图所示，证明你的服务成功开启了：\n\n![开启服务成功](http://7xlolm.com1.z0.glb.clouddn.com/20160325f.jpg)\n\n接下来打开浏览器，输入：\n\n```\nhttp://localhost:8888/app/index/index.html\n```\n\n回车，如果不出意外，你应该得到一个404，如下图：\n\n![404](http://7xlolm.com1.z0.glb.clouddn.com/20160325g.jpg)\n\n我们要对我们的 webpack.config.js 配置文件做两处修改：\n\n1、将 config.output.publicPath 修改为 '/'：\n\n```\noutput: {\n    // 输出路径是 myProject/output/static\n    path: path.resolve(__dirname, '../output/static'),\n    publicPath: '/',\n    filename: '[name].[hash].js',\n    chunkFilename: '[id].[chunkhash].js'\n},\n\n```\n\n2、将 plugins 中 HtmlWebpackPlugin 中的 filename 修改为 'app/index/index.html'\n\n```\nplugins: [\n    new HtmlWebpackPlugin({\n        filename: 'app/index/index.html',\n        template: path.resolve(__dirname, '../app/index/index.html'),\n        inject: true\n    })\n]\n```\n\n重启服务，再刷新页面，如果看到如下界面，证明你成功了：\n\n![成功](http://7xlolm.com1.z0.glb.clouddn.com/20160325h.jpg)\n\n但是这样开发模式下的确是成功了，可是我们直接修改了 webpack.config.js 文件，这就意味着当我们执行 构建命令 的时候，配置变了，那么我们的构建也跟着变了，所以，一个好的方式是，不去修改webpack.config.js文件，我们在build目录下新建一个 webpack.dev.conf.js文件，意思是开发模式下要读取的配置文件，并写入一下内容：\n\n```\nvar HtmlWebpackPlugin = require('html-webpack-plugin')\nvar path = require('path');\n// 引入基本配置\nvar config = require('./webpack.config');\n\nconfig.output.publicPath = '/';\n\nconfig.plugins = [\n    new HtmlWebpackPlugin({\n        filename: 'app/index/index.html',\n        template: path.resolve(__dirname, '../app/index/index.html'),\n        inject: true\n    })\n];\n\nmodule.exports = config;\n```\n\n这样，我们在dev环境下的配置文件中覆盖了基本配置文件，我们只需要在dev-server.js中将 \n\n```\nvar config = require('./webpack.config')\n```\n\n修改为：\n\n```\nvar config = require('./webpack.dev.conf')\n```\n\n即可，然后，重启服务，刷新浏览器，你应该得到同样的成功结果，而这一次当我们执行构建命令：\n\n```\nwebpack --display-modules --display-chunks --config build/webpack.config.js\n```\n\n并不会影响构建输出，因为我们没有直接修改webpack.config.js文件。\n\n现在我们已经使用 webpack-dev-middleware 搭建基本的开发环境了，但是我们并不满足，因为我们每次都要手动去刷新浏览器，所谓的热加载，意思就是说能够追踪我们代码的变化，并自动更新界面，甚至还能保留程序状态。要完成热加载，我们就需要使用另外一个中间件 *webpack-hot-middleware*\n\n\n*<b>2、webpack-hot-middleware</b>*\n\n[webpack-hot-middleware](https://www.npmjs.com/package/webpack-hot-middleware) 只配合 webpack-dev-middleware 使用，它能给你提供热加载。\n\n它的使用很简单，总共分4步：\n\n1、安装，我们上面已经安装过了\n2、在 webpack.dev.conf.js 配置文件中添加三个插件，如下：\n\n```\n\nvar HtmlWebpackPlugin = require('html-webpack-plugin')\nvar path = require('path');\nvar webpack = require('webpack');\n// 引入基本配置\nvar config = require('./webpack.config');\n\nconfig.output.publicPath = '/';\n\nconfig.plugins = [\n    // 添加三个插件\n    new webpack.optimize.OccurenceOrderPlugin(),\n    new webpack.HotModuleReplacementPlugin(),\n    new webpack.NoErrorsPlugin(),\n\n    new HtmlWebpackPlugin({\n        filename: 'app/index/index.html',\n        template: path.resolve(__dirname, '../app/index/index.html'),\n        inject: true\n    })\n];\n\nmodule.exports = config;\n```\n\n3、在 webpack.config.js 文件中入口配置中添加 'webpack-hot-middleware/client'，如下：\n\n```\nentry: ['webpack-hot-middleware/client', path.resolve(__dirname, '../app/index/index.js')],\n```\n\n4、在 dev-server.js 文件中使用插件\n\n```\n// 引入必要的模块\nvar express = require('express')\nvar webpack = require('webpack')\nvar config = require('./webpack.dev.conf')\n\n// 创建一个express实例\nvar app = express()\n\n// 调用webpack并把配置传递过去\nvar compiler = webpack(config)\n\n// 使用 webpack-dev-middleware 中间件\nvar devMiddleware = require('webpack-dev-middleware')(compiler, {\n    publicPath: config.output.publicPath,\n    stats: {\n        colors: true,\n        chunks: false\n    }\n})\n\n// 使用 webpack-hot-middleware 中间件\nvar hotMiddleware = require('webpack-hot-middleware')(compiler)\n\n// 注册中间件\napp.use(devMiddleware)\n// 注册中间件\napp.use(hotMiddleware)\n\n// 监听 8888端口，开启服务器\napp.listen(8888, function (err) {\n    if (err) {\n        console.log(err)\n        return\n    }\n    console.log('Listening at http://localhost:8888')\n})\n\n```\n\nok，现在重启的服务，然后修改 Favlist.vue 中的页面背景颜色为 '#000'：\n\n```\n<style>\n    html{\n        background: #000;\n    }\n</style>\n\n```\n\n然后查看你的浏览器，是不是你还没有刷新就已经得带改变了？\n\n那么这样就完美了吗？还没有，如果你细心，你会注意到，我们上面在第2步中修改了 webpack.config.js 这个基本配置文件，修改了入口配置，如下：\n\n```\nentry: ['webpack-hot-middleware/client', path.resolve(__dirname, '../app/index/index.js')],\n```\n\n这也会导致我们之前讨论过的问题，就是会影响构建，所以我们不要直接修改 webpack.config.js 文件，我们还是在 webpack.dev.conf.js 文件中配置，如下：\n\n```\n\nvar HtmlWebpackPlugin = require('html-webpack-plugin')\nvar path = require('path');\nvar webpack = require('webpack');\n// 引入基本配置\nvar config = require('./webpack.config');\n\nconfig.output.publicPath = '/';\n\nconfig.plugins = [\n    new webpack.optimize.OccurenceOrderPlugin(),\n    new webpack.HotModuleReplacementPlugin(),\n    new webpack.NoErrorsPlugin(),\n    new HtmlWebpackPlugin({\n        filename: 'app/index/index.html',\n        template: path.resolve(__dirname, '../app/index/index.html'),\n        inject: true\n    })\n];\n\n// 动态向入口配置中注入 webpack-hot-middleware/client\nvar devClient = 'webpack-hot-middleware/client';\nObject.keys(config.entry).forEach(function (name, i) {\n    var extras = [devClient]\n    config.entry[name] = extras.concat(config.entry[name])\n})\n\nmodule.exports = config;\n```\n\n但是我们还是要讲 webpack.config.js 文件中的入口配置修改为多入口配置的方式，这个修改不会影响构建，所以无所谓：\n\n```\nentry: {\n    index: path.resolve(__dirname, '../app/index/index.js')\n},\n```\n\n重启你的服务，刷新一下浏览器，然后修改 Favlist.vue 中的背景色为 green：\n\n```\n<style>\n    html{\n        background: green;\n    }\n</style>\n```\n\n再次查看浏览器，发现可以热加载。但是这样就结束了吗？还没有，不信你修改 index.html 文件，看看会不会热加载，实际上不会，你还是需要手动刷新页面，为了能够当 index.html 文件的改动也能够触发自动刷新，我们还需要做一些工作。\n\n*<b>第一步：在 dev-server.js 文件中监听html文件改变事件，修改后的 dev-server.js 文件如下：</b>*\n\n```\n// 引入必要的模块\nvar express = require('express')\nvar webpack = require('webpack')\nvar config = require('./webpack.dev.conf')\n\n// 创建一个express实例\nvar app = express()\n\n// 调用webpack并把配置传递过去\nvar compiler = webpack(config)\n\n// 使用 webpack-dev-middleware 中间件\nvar devMiddleware = require('webpack-dev-middleware')(compiler, {\n    publicPath: config.output.publicPath,\n    stats: {\n        colors: true,\n        chunks: false\n    }\n})\n\nvar hotMiddleware = require('webpack-hot-middleware')(compiler)\n\n// webpack插件，监听html文件改变事件\ncompiler.plugin('compilation', function (compilation) {\n    compilation.plugin('html-webpack-plugin-after-emit', function (data, cb) {\n        // 发布事件\n        hotMiddleware.publish({ action: 'reload' })\n        cb()\n    })\n})\n\n// 注册中间件\napp.use(devMiddleware)\n// 注册中间件\napp.use(hotMiddleware)\n\n// 监听 8888端口，开启服务器\napp.listen(8888, function (err) {\n    if (err) {\n        console.log(err)\n        return\n    }\n    console.log('Listening at http://localhost:8888')\n})\n\n```\n\n从上面的代码中可以看到，我们增加了如下代码：\n\n```\n// webpack插件，监听html文件改变事件\ncompiler.plugin('compilation', function (compilation) {\n    compilation.plugin('html-webpack-plugin-after-emit', function (data, cb) {\n        // 发布事件\n        hotMiddleware.publish({ action: 'reload' })\n        cb()\n    })\n})\n```\n\n这段代码可能你看不懂，因为这涉及到webpack插件的编写，读者可以参阅下面的连接：\n\n[webpack 插件doc1](https://github.com/webpack/docs/wiki/plugins)\n\n[webpack 插件doc2](https://github.com/webpack/docs/wiki/How-to-write-a-plugin)\n\n在这段代码中，我们监听了 'html-webpack-plugin-after-emit' 事件，那么这个事件是从哪里发射的呢？我们通过名字可知，这个事件应该和html-webpack-plugin这个插件有关，在npm搜索 [html-webpack-plugin](https://www.npmjs.com/package/html-webpack-plugin) 插件，在页面最底部我们可以发现如下图：\n\n![html-webpack-plugin可以发射事件](http://7xlolm.com1.z0.glb.clouddn.com/20160325i.jpg)\n\n我们可以看到，html-webpack-plugin 这个插件的确提供了几个可选的事件，下面也提供了使用方法，这样，我们就能够监听到html文件的变化，然后我们使用下面的代码发布一个事件：\n\n```\nhotMiddleware.publish({ action: 'reload' })\n```\n\n*<b>第二步：修改 webpack.dev.conf.js 文件如下：</b>*\n\n```\n\nvar HtmlWebpackPlugin = require('html-webpack-plugin')\nvar path = require('path');\nvar webpack = require('webpack');\n// 引入基本配置\nvar config = require('./webpack.config');\n\nconfig.output.publicPath = '/';\n\nconfig.plugins = [\n    new webpack.optimize.OccurenceOrderPlugin(),\n    new webpack.HotModuleReplacementPlugin(),\n    new webpack.NoErrorsPlugin(),\n    new HtmlWebpackPlugin({\n        filename: 'app/index/index.html',\n        template: path.resolve(__dirname, '../app/index/index.html'),\n        inject: true\n    })\n];\n\n// var devClient = 'webpack-hot-middleware/client';\nvar devClient = './build/dev-client';\nObject.keys(config.entry).forEach(function (name, i) {\n    var extras = [devClient]\n    config.entry[name] = extras.concat(config.entry[name])\n})\n\nmodule.exports = config;\n```\n\n我们修改了devClient变量，将 'webpack-hot-middleware/client' 替换成 './build/dev-client'，最终会导致，我们入口配置会变成下面这样：\n\n```\nentry: {\n    index: [\n        './build/dev-client',\n        path.resolve(__dirname, '../app/index/index.js')\n    ]\n},\n```\n\n*<b>第三步：新建 build/dev-client.js 文件，并编辑如下内容：</b>*\n\n```\nvar hotClient = require('webpack-hot-middleware/client')\n\n// 订阅事件，当 event.action === 'reload' 时执行页面刷新\nhotClient.subscribe(function (event) {\n    if (event.action === 'reload') {\n        window.location.reload()\n    }\n})\n\n```\n\n这里我们除了引入 'webpack-hot-middleware/client' 之外订阅了一个事件，当 event.action === 'reload' 时触发，还记得我们在 dev-server.js 中发布的事件吗：\n\n```\nhotMiddleware.publish({ action: 'reload' })\n```\n\n这样，当我们的html文件改变后，就可以监听的到，最终会执行页面刷新，而不需要我们手动刷新，现在重启服务，去尝试能否对html文件热加载吧。答案是yes。\n好了，开发环境终于搞定了，下面我们再来谈一谈生产环境，也就是构建输出，我们现在可以执行一下构建命令，看看输出的内容是什么，为了不必每次都要输入下面这条长命令：\n\n```\nwebpack --display-modules --display-chunks --config build/webpack.config.js\n```\n\n我们在 package.js 文件中添加 \"scripts\" 项，如下图：\n\n![npm](http://7xlolm.com1.z0.glb.clouddn.com/20160325m.jpg)\n\n这样，我们就可以通过执行下面命令来进行构建，同时我们还增加了一条开启开发服务器的命令：\n\n```\n// 构建\nnpm run build\n// 开启开发服务器\nnpm run dev\n```\n\n回过头来，我们执行构建命令： npm run build，查看输出内容，如下图：\n\n![输出内容](http://7xlolm.com1.z0.glb.clouddn.com/20160325n.jpg)\n\n现在我们只有一个js文件输出了，并没有css文件输出，在生产环境，我们希望css文件生成单独的文件，所以我们要使用 extract-text-webpack-plugin 插件，安装：\n\n```\nnpm install extract-text-webpack-plugin --save-dev\n```\n\n然后在build目录下新建 webpack.prod.conf.js 文件，顾名思义，这个使我们区别于开发环境，用于生产环境的配置文件，并编辑一下内容：\n\n```\n\nvar HtmlWebpackPlugin = require('html-webpack-plugin')\nvar ExtractTextPlugin = require('extract-text-webpack-plugin')\nvar path = require('path');\nvar webpack = require('webpack');\n// 引入基本配置\nvar config = require('./webpack.config');\n\nconfig.vue = {\n    loaders: {\n        css: ExtractTextPlugin.extract(\"css\")\n    }\n};\n\nconfig.plugins = [\n    // 提取css为单文件\n    new ExtractTextPlugin(\"../[name].[contenthash].css\"),\n\n    new HtmlWebpackPlugin({\n        filename: '../index.html',\n        template: path.resolve(__dirname, '../app/index/index.html'),\n        inject: true\n    })\n];\n\nmodule.exports = config;\n```\n\n上面的代码中，我们覆盖了 webpack.config.js 配置文件的 config.plugins 项，并且添加了 config.vue 项，补血药知道为什么，就是这么用的，如果一定要知道为什么也可以，这需要你多去了解vue以及vue-loader的工作原理，这里有连接[点击这里](http://vuejs.github.io/vue-loader/configurations/extract-css.html)\n然后修改 package.json 文件中的 script 项为如下：\n\n```\n\"scripts\": {\n    \"build\": \"webpack --display-modules --display-chunks --config build/webpack.prod.conf.js\",\n    \"dev\": \"node ./build/dev-server.js\"\n},\n```\n\n我们使用 webpack.prod.conf.js 为配置去构建，接下来执行：\n\n```\nnpm run build\n```\n\n查看你的输出内容，如下图，css文件未提取出来了：\n\n![css文件被提取](http://7xlolm.com1.z0.glb.clouddn.com/20160325l.jpg)\n\n另外我们还可以添加如下插件在我们的 webpack.prod.conf.js 文件中，作为生产环境使用：\n\n```\nconfig.plugins = [\n    new webpack.DefinePlugin({\n        'process.env': {\n            NODE_ENV: '\"production\"'\n        }\n    }),\n    // 压缩代码\n    new webpack.optimize.UglifyJsPlugin({\n        compress: {\n            warnings: false\n        }\n    }),\n    new webpack.optimize.OccurenceOrderPlugin(),\n    // 提取css为单文件\n    new ExtractTextPlugin(\"../[name].[contenthash].css\"),\n    new HtmlWebpackPlugin({\n        filename: '../index.html',\n        template: path.resolve(__dirname, '../app/index/index.html'),\n        inject: true\n    })\n];\n```\n\n大家可以搜索这些插件，了解他的作用，这篇文章要介绍的太多，所以我一一讲解了。\n\n到这里实际上搭建的已经差不多了，唯一要做的就是完善，比如公共模块的提取，如何加载图片，对于第一个问题，如何提取公共模块，我们可以使用 CommonsChunkPlugin 插件，在 webpack.prod.conf.js 文件中添加如下插件：\n\n```\nnew webpack.optimize.CommonsChunkPlugin({\n    name: 'vendors',\n    filename: 'vendors.js',\n}),\n```\n\n然后在 webpack.config.js 文件中配置入口文件：\n\n```\nentry: {\n    index: path.resolve(__dirname, '../app/index/index.js'),\n    vendors: [\n        'Vue'\n    ]\n},\n```\n\n上面代码的意思是，我们把Vue.js当做公共模块单独打包，你可以在这个数组中增加其他模块，一起作为公共模块打包成一个文件，我们执行构建命令，然后查看输出，如下图，成功提取：\n\n![提取公共模块](http://7xlolm.com1.z0.glb.clouddn.com/20160325u.jpg)\n\n对于加载图片的问题，我们知道，webpack的哲学是一切皆是模块，然后通过相应的loader去加载，所以加载图片，我们就需要使用到 url-loader，在webpack.config.js 文件中添加一个loader配置：\n\n```\nloaders: [\n    // 使用vue-loader 加载 .vue 结尾的文件\n    {\n        test: /\\.vue$/, \n        loader: 'vue'   \n    },\n    {\n        test: /\\.js$/,\n        loader: 'babel?presets=es2015',\n        exclude: /node_modules/\n    },\n    // 加载图片\n    {\n        test: /\\.(png|jpg|gif|svg)$/,\n        loader: 'url',\n        query: {\n            limit: 10000,\n            name: '[name].[ext]?[hash:7]'\n        }\n    }\n]\n```\n\n这样，当我们的css样式表文件中使用 url(xxxx.png)或者js中去require('xxxx.png')的时候，webpack就知道如何处理，另外url-loader的一个好处就是，以上面的配置来说，当我们的图片大小小于10000字节的时候，webpack会把图片转换成base64格式插入到代码中，从而减少http请求，另外，我们在这里谈到的任何一个loader都可以在npm中查找到，读者可以查询更多的loader了解并使用。\n\n\n\n\n","source":"_posts/2016/03/25/基于webpack和vue.js搭建的H5端框架(其实主要用于Hybrid开发H5端框架，但是依然能够作为纯web端使用).md","raw":"title: 基于webpack和vue.js搭建的H5端框架(其实主要用于Hybrid开发H5端框架，但是依然能够作为纯web端使用)\ndate: 2016-03-25 15:17:33\ncategories:\n- WebFrontEnd\ntags:\n- 框架\n- 架构\n- vue\n- webpack\n---\n\n人类的发展得益于对追求不断的提升，在能活着的基础上是否要活得潇洒一点，技术的发展亦如是。在公司作为一个最最最最最最最底层的搬砖码农，经历了两个版本的铸(zhe)炼(mo)之后，我痛下决心今后一定要：..............一定要和产品惺(shi)惺(bu)相(liang)惜(li)。\n\n<!-- more -->\n\n# 开始之前 #\n\n本文包含以下技术，文中尽量给与详细的描述，并且附上参考链接，读者可以深入学习：\n\n1、[webpack](http://webpack.github.io/)\n2、[Vue.js](http://cn.vuejs.org/)\n3、[npm](https://www.npmjs.com/)\n4、nodejs ---- 这个就不给连接了，因为上面的连接都是在你实践的过程中要去不断访问的\n5、[ES6语法](http://es6.ruanyifeng.com/#README)\n\n另外，这套教程的代码都在我的github上，读者可以对照着代码来看，不过还是希望大家自己亲手搭建，体验这个过程，git地址：\n\n[git地址](https://github.com/HcySunYang/h5_frame)\n\n# 前言 #\n\n在对着产品高举中指怒发心中之愤后，真正能够解决问题的是自身上的改变，有句话说的好：你虽然改变不了全世界，但是你有机会改变你自己。秉承着“不听老人言，吃亏在眼前”的优良作风，我还是决定玩火自焚。\n\n### 问题所在 ###\n\n之前的项目总结为以下内容：\n\n>1、AMD模块规范开发，使用requirejs实现，使用rjs打包，最终导致的结果是，输出的项目臃肿，肿的就像一坨狗不理......不忍直视\n2、使用gulp进行打包，这一点貌似没有可吐槽的地方，毕竟都是被grunt折磨过来的......\n3、数据的渲染使用模板引擎，这就意味着你要手动管理DOM，这样，你的业务代码参杂着你的数据处理、DOM管理，满屏幕的毛线......\n4、模块化不足，虽然使用require进行了模块管理，但是大部分业务逻辑还是充斥在一个文件里，这与最近流行的组件化概念冰火不容，拒绝落后......\n5、诸如 扩展性 、 维护性 我想早已不言而喻，不需赘述，再述就真TM是累赘了。\n\n新框架要解决的问题：\n\n>1、要使构建输出的项目像你邻家小妹妹一样、瘦的皮包骨。（也许是营养不良）\n2、要实现真正的模块化、组件化的开发方式，真正去解决维护难、扩展难的问题。（从此不怕产品汪）\n3、业务逻辑专注数据处理，手动管理DOM的年代就像......像什么呢？（毕竟成人用品也越来越自动化了）\n4、等等.......（其实好处无需赘述，来，往下看）\n\n为了达成以上目标，我们探讨一下解决方案：\n\n*<b>1、老项目的构建输出为什么臃肿？</b>*\n\n答：因为使用的是require的rjs进行构建打包的，了解rjs的都知道，它会把项目所有依赖都打包在一个文件里，如果项目中有很多页面依赖这个模块，那么rjs并不会把这个模块提取出来作为公共模块，所以就会有很多复制性的内容，所以项目自然臃肿。\n\n*解决方案：*使用webpack配合相应的loader，来完成模块加载和构建的工作。\n\n*<b>2、老项目为什么模块化的不足？</b>*\n\n答：老项目的模块化，仅仅体现在js层面，解决了模块引用的问题，但在开发方式上，依然可以看做是过程式的，这样的结果就导致了项目的难扩展和难维护，让开发人员在与产品汪的对峙中，并不从容。\n\n*解决方案：*Vue.js能够很好的解决组件化的问题，配合 Vue.js 官方提供的 *vue-loader* 能够很好的结合webpack做组件化的开发架构。\n\n*<b>3、如何避免手动管理DOM？</b>*\n\n答：如果你在做数据展示这一块的开发工作，相信你一定体会颇深，发送http请求到服务端，拿到返回的数据后手动渲染DOM至页面，这是最原始的开发方式，无非再加一个模板引擎之类的，但最终还是避免不了手动渲染，如果页面逻辑复杂，比如给你来一个翻页的功能，再来一个筛选项，估计你会觉得世界并不那么美好。\n\n*解决方案：*MVVM模式能够很好的解决这个问题，而Vue.js的核心也是MVVM。\n\n# webpack #\n\n你肯定听说过webpack，如果直接对你描述什么是webpack你可能感受不到他的好处，那么在这之前，我相信你肯定使用过gulp或者grunt，如果你没使用过也可以，至少你要听说过并且知道gulp和grunt是干什么的，假如这个你还不清楚，那么你并不是一个合格的前端开发人员，这篇文章也不适合你，你可以从基础的地方慢慢学起。\n\ngulp和grunt对于每一个前端开发人员应该是不陌生的，它们为前端提供了自动化构建的能力，并且有自己的生态圈，有很多插件，使得我们告别刀耕火种的时代，但是它们并没有解决模块加载的问题，比如我们之前的项目是使用gulp构建的，但是模块化得工作还是要靠require和rjs来完成，而gulp除了完成一些其他任务之外，就变成了帮助我们免除手动执行命令的工具了，别无它用。\n\n而webpack就不同了，webpack的哲学是一切皆是模块，无论是js/css/sass/img/coffeejs/ttf....等等，webpack可以使用自定义的loader去把一切资源当做模块加载，这样就解决了模块依赖的问题，同时，利用插件还可以对项目进行优化，由于模块的加载和项目的构建优化都是通过webpack一个”人“来解决的，所以模块的加载和项目的构建优化并不是无机分离的，而是有机的结合在一起的，是一个组合的过程，这使得webpack在这方面能够完成的更出色，这也是webpack的优势所在。\n\n如果你看不懂上面的描述，没关系，你只需要知道一下几点：\n\n1、过去使用require和rjs等进行模块加载的方式，可以替换为webpack提供的指定loader去完成，你也可以自己开发加载特定资源的loader。\n2、过去使用gulp和grunt完成项目构建优化的方式，可以替换成webpack提供的插件和特定的配置去完成。\n3、由于模块的加载和项目的构建优化有机的结合，所以webpack能够更好的完成这项工作\n4、并不是说有了webpack就淘汰的gulp等，有些特定的任务，还是要使用gulp去自定义完成的。但是不保证webpack的未来发展趋势会怎么样。\n\n最后，给大家分享一个官方的教程，这个教程的最开始有坑的地方，如果读者遇到了坑，可以在这里给我留言，我会为大家解答，不过总体来讲，这个教程适合入门，唯一不足的就是教程是英文的，英文的也不用怕，本人的英语没过四级，但是现在依然能够看得懂英文技术文章。教程链接：[http://blog.madewithlove.be/post/webpack-your-bags/](http://blog.madewithlove.be/post/webpack-your-bags/)\n\n# Vue.js #\n\n[Vue.js](http://cn.vuejs.org/)是一个MVVM模式的框架，如果读者有angular经验，一定能够很快入门Vue的，那么问题来了，为什么使用Vue而不用angular，\n首先，Vue的体积小，轻量在移动端开发始终是一个不可忽略的话题，其次，Vue在实现上与angular有本质的区别，读者可以通过下面两个链接来了解：\n\n1、[Vue的变化追踪和计算属性的区别等](http://cn.vuejs.org/guide/reactivity.html)\n\n2、[Vue 与 angular 及 react 等框架的对比](http://cn.vuejs.org/guide/comparison.html)\n\n3、第三点就是Vue提供了webpack的loader ----> [vue-loader]，使用它可以让项目的组件化思想更加清晰\n\n综上所述，这就是选用Vue的原因\n\n# npm 和 nodejs #\n\nnpm 的全称是 *nodejs包管理*，现在越来越多的项目(包)都可以通过npm来安装管理，nodejs是js运行在服务器端的平台，它使得js的能力进一步提高，我们还要使用nodejs配合 webpack 来完成热加载的功能。所以读者最好有nodejs的开发经验，如果有express的经验更好。\n\n# 让我们一步一步从零搭建这个项目 #\n\n首先新建一个目录，名为 myProject ，这是我们的项目目录。然后执行一些基本的步骤，比如 npm init 命令，在我们的项目中生成 package.json 文件，这几乎是必选的，因为我们的项目要有很多依赖，都是通过npm来管理的，而npm对于我们项目的管理，则是通过package.json文件：\n\n```$\nnpm init\n```\n\n执行npm init之后，会提示你填写一些项目的信息，一直回车默认就好了，或者直接执行 npm init -y 直接跳过询问步骤\n然后我们新建一个叫做 app 的目录，这个是我们页面模块的目录，再在app目录下建立一个index目录，假设这个是首页模块的目录，然后再在index目录下建立一个 index.html 文件和 index.js 文件，分别是首页入口html文件和主js文件，然后再在index目录下建立一个components目录，这个目录用作存放首页组件模块的目录，因为我们最终要实现组件化开发。这样，当你完成上面的步骤后，你的项目看上去应该是这样的：\n\n![项目结构](http://7xlolm.com1.z0.glb.clouddn.com/20160325b.jpg)\n\n接下来通过npm安装项目依赖项：\n\n```$\nnpm install\\\n  webpack webpack-dev-server\\\n  vue-loader vue-html-loader css-loader vue-style-loader vue-hot-reload-api\\\n  babel-loader babel-core babel-plugin-transform-runtime babel-preset-es2015\\\n  babel-runtime@5\\\n  --save-dev\n\nnpm install vue --save\n```\n\n这个时候，你的package.json文件看起来应该是这样的：\n\n```\n\"devDependencies\": {\n    \"babel-core\": \"^6.3.17\",\n    \"babel-loader\": \"^6.2.0\",\n    \"babel-plugin-transform-runtime\": \"^6.3.13\",\n    \"babel-preset-es2015\": \"^6.3.13\",\n    \"babel-runtime\": \"^5.8.34\",\n    \"css-loader\": \"^0.23.0\",\n    \"vue-hot-reload-api\": \"^1.2.2\",\n    \"vue-html-loader\": \"^1.0.0\",\n    \"vue-style-loader\": \"^1.0.0\",\n    \"vue-loader\": \"^7.2.0\",\n    \"webpack\": \"^1.12.9\",\n    \"webpack-dev-server\": \"^1.14.0\"\n  },\n  \"dependencies\": {\n    \"vue\": \"^1.0.13\"\n  },\n```\n\n我们安装了 babel 一系列包，用来解析ES6语法，因为我们使用ES6来开发项目，如果你不了解ES6语法，建议你看一看[阮老师的教程](http://es6.ruanyifeng.com/)，然后我们安装了一些loader包，比如css-loader/vue-loader等等，因为webpack是使用这些指定的loader去加载指定的文件的。\n\n另外我们还使用 npm install vue --save 命令安装了 vue ，这个就是我们要在项目中使用的vue.js，我们可以直接像开发nodejs应用一样，直接require('vue');即可，而不需要通过script标签引入，这一点在开发中很爽。\n\n安装完了依赖，编辑以下文件并保存到相应位置：\n\n1、index.html文件：\n\n```\n<!DOCTYPE html>\n<html lang=\"zh\">\n\t<head>\n\t\t<meta name=\"viewport\" content=\"width=device-width, height=device-height, initial-scale=1.0, user-scalable=no\">\n\t\t<meta charset=\"utf-8\">\n\t\t<title>首页</title>\n\t</head>\n\t<body>\n\t\t<!-- vue的组件以自定义标签的形式使用 -->\n\t\t<favlist></favlist>\n\t</body>\n</html>\n\n```\n\n2、index.js文件：\n\n```\nimport Vue from 'Vue'\nimport Favlist from './components/Favlist'\n\nnew Vue({\n\tel: 'body',\n\tcomponents: { Favlist }\n})\n```\n\n3、在components目录下新建一个 Favlist.vue 文件，作为我们的第一个组件：\n\n```\n<template>\n    <div v-for=\"n in 10\">div</div>\n</template>\n\n<script>\n    export default {\n        data () {\n            return {\n                msg: 'Hello World!'\n            }\n        }\n    }\n</script>\n\n<style>\n    html{\n        background: red;\n    }\n</style>\n\n```\n\n要看懂上面的代码，你需要了解vue.js，假如你看不懂也没关系，我们首先在index.html中使用了自定义标签（即组件），然后在index.js中引入了Vue和我们的Favlist.vue组件，Favlist.vue文件中，我们使用了基本的vue组件语法，最后，我们希望它运行起来，这个时候，我们就需要webpack了。\n\n在项目目录下新建 build 目录，用来存放我们的构建相关的代码文件等，然后在build目录下新建 webpack.config.js 这是我们的webpack配置文件，webpack需要通过读取你的配置，进行相应的操作，类似于gulpfile.js或者gruntfile.js等。\n\nwebpack.config.js\n\n```\n// nodejs 中的path模块\nvar path = require('path');\n\nmodule.exports = {\n    // 入口文件，path.resolve()方法，可以结合我们给定的两个参数最后生成绝对路径，最终指向的就是我们的index.js文件\n    entry: path.resolve(__dirname, '../app/index/index.js'),\n    // 输出配置\n    output: {\n        // 输出路径是 myProject/output/static\n        path: path.resolve(__dirname, '../output/static'),\n        publicPath: 'static/',\n        filename: '[name].[hash].js',\n        chunkFilename: '[id].[chunkhash].js'\n    },\n    module: {\n        \n        loaders: [\n            // 使用vue-loader 加载 .vue 结尾的文件\n            {\n                test: /\\.vue$/, \n                loader: 'vue'   \n            }\n        ]\n    }\n}\n```\n\n上例中，相信你已经看懂了我的配置，入口文件是index.js文件，配置了相应输出，然后使用 vue-loader 去加载 .vue 结尾的文件，接下来我们就可以构建项目了，我们可以在命令行中执行：\n\n```\nwebpack --display-modules --display-chunks --config build/webpack.config.js\n```\n\n通过webpack命令，并且通过 --config 选项指定了我们配置文件的位置是 'build/webpack.config.js'，并通过 --display-modules 和 --display-chunks 选项显示相应的信息。如果你执行上面的命令，可能得到下图的错误：\n\n![报错](http://7xlolm.com1.z0.glb.clouddn.com/20160325c.jpg)\n\n错误提示我们应该选择合适的loader去加载这个 './app/index/index.js' 这个文件，并且说不期望index.js文件中的标识符（Unexpected token），这是因为我们使用了ES6的语法 import 语句，所以我们要使用 babel-loader 去加载我们的js文件，在配置文件中添加一个loaders项目，如下：\n\n```\n// nodejs 中的path模块\nvar path = require('path');\n\nmodule.exports = {\n    // 入口文件，path.resolve()方法，可以结合我们给定的两个参数最后生成绝对路径，最终指向的就是我们的index.js文件\n    entry: path.resolve(__dirname, '../app/index/index.js'),\n    // 输出配置\n    output: {\n        // 输出路径是 myProject/output/static\n        path: path.resolve(__dirname, '../output/static'),\n        publicPath: 'static/',\n        filename: '[name].[hash].js',\n        chunkFilename: '[id].[chunkhash].js'\n    },\n    module: {\n        \n        loaders: [\n            // 使用vue-loader 加载 .vue 结尾的文件\n            {\n                test: /\\.vue$/, \n                loader: 'vue'   \n            },\n            {\n                test: /\\.js$/,\n                loader: 'babel?presets=es2015',\n                exclude: /node_modules/\n            }\n        ]\n    }\n}\n```\n\n现在再运行构建命令 ： 'webpack --display-modules --display-chunks --config build/webpack.config.js'\n\nsorry，不出意外，你应该得到如下错误：\n\n![错误](http://7xlolm.com1.z0.glb.clouddn.com/20160325d.jpg)\n\n它说没有发现 './components/Favlist' 模块，而我们明明有 ./components/Favlist.vue 文件，为什么它没发现呢？它瞎了？其实是这样的，当webpack试图去加载模块的时候，它默认是查找以 .js 结尾的文件的，它并不知道 .vue 结尾的文件是什么鬼玩意儿，所以我们要在配置文件中告诉webpack，遇到 .vue 结尾的也要去加载，添加 resolve 配置项，如下：\n\n```\n// nodejs 中的path模块\nvar path = require('path');\n\nmodule.exports = {\n    // 入口文件，path.resolve()方法，可以结合我们给定的两个参数最后生成绝对路径，最终指向的就是我们的index.js文件\n    entry: path.resolve(__dirname, '../app/index/index.js'),\n    // 输出配置\n    output: {\n        // 输出路径是 myProject/output/static\n        path: path.resolve(__dirname, '../output/static'),\n        publicPath: 'static/',\n        filename: '[name].[hash].js',\n        chunkFilename: '[id].[chunkhash].js'\n    },\n    resolve: {\n        extensions: ['', '.js', '.vue']\n    },\n    module: {\n        \n        loaders: [\n            // 使用vue-loader 加载 .vue 结尾的文件\n            {\n                test: /\\.vue$/, \n                loader: 'vue'   \n            },\n            {\n                test: /\\.js$/,\n                loader: 'babel?presets=es2015',\n                exclude: /node_modules/\n            }\n        ]\n    }\n}\n```\n\n这样，当我们去加载 './components/Favlist' 这样的模块时，webpack首先会查找 ./components/Favlist.js 如果没有发现Favlist.js文件就会继续查找 Favlist.vue 文件，现在再次运行构建命令，我们成功了，这时我们会在我们的输出目录中看到一个js文件：\n\n![输出](http://7xlolm.com1.z0.glb.clouddn.com/20160325e.jpg)\n\n之所以会这样输出，是因为我们的 webpack.config.js 文件中的输出配置中指定了相应的输出信息，这个时候，我们修改 index.html ，将输出的js文件引入：\n\n```\n<!DOCTYPE html>\n<html lang=\"zh\">\n\t<head>\n\t\t<meta name=\"viewport\" content=\"width=device-width, height=device-height, initial-scale=1.0, user-scalable=no\">\n\t\t<meta charset=\"utf-8\">\n\t\t<title>首页</title>\n\t</head>\n\t<body>\n\t\t<!-- vue的组件以自定义标签的形式使用 -->\n\t\t<favlist></favlist>\n\n\t\t<script src=\"../../output/static/main.ce853b65bcffc3b16328.js\"></script>\n\t</body>\n</html>\n```\n\n然后用浏览器打开这个页面，你可以看到你写的代码正确的执行了。\n\n那么问题来了，难道我们每次都要手动的引入输出的js文件吗？因为每次构建输出的js文件都带有 hash 值，如 main.ce853b65bcffc3b16328.js，就不能更智能一点吗？每次都自动写入？怎么会不可能，否则这东西还能火吗，要实现这个功能，我们就要使用webpack的插件了，[html-webpack-plugin](https://www.npmjs.com/package/html-webpack-plugin)插件，这个插件可以创建html文件，并自动将依赖写入html文件中。\n\n首先安装 html-webpack-plugin 插件：\n\n```\nnpm install html-webpack-plugin --save-dev\n```\n\n然后在修改配置项：\n\n```\n// nodejs 中的path模块\nvar path = require('path');\nvar HtmlWebpackPlugin = require('html-webpack-plugin')\n\nmodule.exports = {\n    // 入口文件，path.resolve()方法，可以结合我们给定的两个参数最后生成绝对路径，最终指向的就是我们的index.js文件\n    entry: path.resolve(__dirname, '../app/index/index.js'),\n    // 输出配置\n    output: {\n        // 输出路径是 myProject/output/static\n        path: path.resolve(__dirname, '../output/static'),\n        publicPath: 'static/',\n        filename: '[name].[hash].js',\n        chunkFilename: '[id].[chunkhash].js'\n    },\n    resolve: {\n        extensions: ['', '.js', '.vue']\n    },\n    module: {\n        \n        loaders: [\n            // 使用vue-loader 加载 .vue 结尾的文件\n            {\n                test: /\\.vue$/, \n                loader: 'vue'   \n            },\n            {\n                test: /\\.js$/,\n                loader: 'babel?presets=es2015',\n                exclude: /node_modules/\n            }\n        ]\n    },\n    plugins: [\n        new HtmlWebpackPlugin({\n            filename: '../index.html',\n            template: path.resolve(__dirname, '../app/index/index.html'),\n            inject: true\n        })\n    ]\n}\n```\n\n然后再次执行构建命令，成功之后，看你的输出目录，多出来一个index.html文件，双击它，代码正确执行，你可以打开这个文件查看一下，webpack自动帮我们引入了相应的文件。\n\n问题继续来了，难道每次我们都要构建之后才能查看运行的代码吗？那岂不是很没有效率，别担心，webpack提供了几种方式，进行热加载，在开发模式中，我们使用这种方式来提高效率，这里要介绍的，是使用 [webpack-dev-middleware](https://www.npmjs.com/package/webpack-dev-middleware)中间件和[webpack-hot-middleware](https://www.npmjs.com/package/webpack-hot-middleware)中间件，首先安装两个中间件：\n\n```\nnpm install webpack-dev-middleware webpack-hot-middleware --save-dev\n```\n\n另外，还要安装express，这是一个nodejs框架\n\n```\nnpm install express --save-dev\n```\n\n在开始之前，我先简单介绍一下这两个中间件，之所以叫做中间件，是因为nodejs的一个叫做express的框架中有中间件的概念，而这两个包要作为express中间件使用，所以称它们为中间件，那么他们能干什么呢？\n\n*<b>1、webpack-dev-middleware</b>*\n\n我们之前所面临的问题是，如果我们的代码改动了，我们要想看到浏览器的变化，需要先对项目进行构建，然后才能查看效果，这样对于开发效率来讲，简直就是不可忍受的一件事，试想我仅仅修改一个背景颜色就要构建一下项目，这尼玛坑爹啊，好在有[webpack-dev-middleware](https://www.npmjs.com/package/webpack-dev-middleware)中间件，它是对webpack一个简单的包装，它可以通过连接服务器服务那些从webpack发射出来的文件，它有一下几点好处：\n\n1、不会向硬盘写文件，而是在内存中，注意我们构建项目实际就是向硬盘写文件。\n\n2、当文件改变的时候，这个中间件不会再服务旧的包，你可以直接帅新浏览器就能看到最新的效果，这样你就不必等待构建的时间，所见即所得。\n\n下面我们在build目录中创建一个 dev-server.js 的文件，并写入一下内容：\n\n```\n// 引入必要的模块\nvar express = require('express')\nvar webpack = require('webpack')\nvar config = require('./webpack.config')\n\n// 创建一个express实例\nvar app = express()\n\n// 调用webpack并把配置传递过去\nvar compiler = webpack(config)\n\n// 使用 webpack-dev-middleware 中间件\nvar devMiddleware = require('webpack-dev-middleware')(compiler, {\n    publicPath: config.output.publicPath,\n    stats: {\n        colors: true,\n        chunks: false\n    }\n})\n\n// 注册中间件\napp.use(devMiddleware)\n\n// 监听 8888端口，开启服务器\napp.listen(8888, function (err) {\n    if (err) {\n        console.log(err)\n        return\n    }\n    console.log('Listening at http://localhost:8888')\n})\n```\n\n此时，我们在项目根目录运行下面的命令，开启服务：\n\n```\nnode build/dev-server.js\n```\n\n如果看到下图所示，证明你的服务成功开启了：\n\n![开启服务成功](http://7xlolm.com1.z0.glb.clouddn.com/20160325f.jpg)\n\n接下来打开浏览器，输入：\n\n```\nhttp://localhost:8888/app/index/index.html\n```\n\n回车，如果不出意外，你应该得到一个404，如下图：\n\n![404](http://7xlolm.com1.z0.glb.clouddn.com/20160325g.jpg)\n\n我们要对我们的 webpack.config.js 配置文件做两处修改：\n\n1、将 config.output.publicPath 修改为 '/'：\n\n```\noutput: {\n    // 输出路径是 myProject/output/static\n    path: path.resolve(__dirname, '../output/static'),\n    publicPath: '/',\n    filename: '[name].[hash].js',\n    chunkFilename: '[id].[chunkhash].js'\n},\n\n```\n\n2、将 plugins 中 HtmlWebpackPlugin 中的 filename 修改为 'app/index/index.html'\n\n```\nplugins: [\n    new HtmlWebpackPlugin({\n        filename: 'app/index/index.html',\n        template: path.resolve(__dirname, '../app/index/index.html'),\n        inject: true\n    })\n]\n```\n\n重启服务，再刷新页面，如果看到如下界面，证明你成功了：\n\n![成功](http://7xlolm.com1.z0.glb.clouddn.com/20160325h.jpg)\n\n但是这样开发模式下的确是成功了，可是我们直接修改了 webpack.config.js 文件，这就意味着当我们执行 构建命令 的时候，配置变了，那么我们的构建也跟着变了，所以，一个好的方式是，不去修改webpack.config.js文件，我们在build目录下新建一个 webpack.dev.conf.js文件，意思是开发模式下要读取的配置文件，并写入一下内容：\n\n```\nvar HtmlWebpackPlugin = require('html-webpack-plugin')\nvar path = require('path');\n// 引入基本配置\nvar config = require('./webpack.config');\n\nconfig.output.publicPath = '/';\n\nconfig.plugins = [\n    new HtmlWebpackPlugin({\n        filename: 'app/index/index.html',\n        template: path.resolve(__dirname, '../app/index/index.html'),\n        inject: true\n    })\n];\n\nmodule.exports = config;\n```\n\n这样，我们在dev环境下的配置文件中覆盖了基本配置文件，我们只需要在dev-server.js中将 \n\n```\nvar config = require('./webpack.config')\n```\n\n修改为：\n\n```\nvar config = require('./webpack.dev.conf')\n```\n\n即可，然后，重启服务，刷新浏览器，你应该得到同样的成功结果，而这一次当我们执行构建命令：\n\n```\nwebpack --display-modules --display-chunks --config build/webpack.config.js\n```\n\n并不会影响构建输出，因为我们没有直接修改webpack.config.js文件。\n\n现在我们已经使用 webpack-dev-middleware 搭建基本的开发环境了，但是我们并不满足，因为我们每次都要手动去刷新浏览器，所谓的热加载，意思就是说能够追踪我们代码的变化，并自动更新界面，甚至还能保留程序状态。要完成热加载，我们就需要使用另外一个中间件 *webpack-hot-middleware*\n\n\n*<b>2、webpack-hot-middleware</b>*\n\n[webpack-hot-middleware](https://www.npmjs.com/package/webpack-hot-middleware) 只配合 webpack-dev-middleware 使用，它能给你提供热加载。\n\n它的使用很简单，总共分4步：\n\n1、安装，我们上面已经安装过了\n2、在 webpack.dev.conf.js 配置文件中添加三个插件，如下：\n\n```\n\nvar HtmlWebpackPlugin = require('html-webpack-plugin')\nvar path = require('path');\nvar webpack = require('webpack');\n// 引入基本配置\nvar config = require('./webpack.config');\n\nconfig.output.publicPath = '/';\n\nconfig.plugins = [\n    // 添加三个插件\n    new webpack.optimize.OccurenceOrderPlugin(),\n    new webpack.HotModuleReplacementPlugin(),\n    new webpack.NoErrorsPlugin(),\n\n    new HtmlWebpackPlugin({\n        filename: 'app/index/index.html',\n        template: path.resolve(__dirname, '../app/index/index.html'),\n        inject: true\n    })\n];\n\nmodule.exports = config;\n```\n\n3、在 webpack.config.js 文件中入口配置中添加 'webpack-hot-middleware/client'，如下：\n\n```\nentry: ['webpack-hot-middleware/client', path.resolve(__dirname, '../app/index/index.js')],\n```\n\n4、在 dev-server.js 文件中使用插件\n\n```\n// 引入必要的模块\nvar express = require('express')\nvar webpack = require('webpack')\nvar config = require('./webpack.dev.conf')\n\n// 创建一个express实例\nvar app = express()\n\n// 调用webpack并把配置传递过去\nvar compiler = webpack(config)\n\n// 使用 webpack-dev-middleware 中间件\nvar devMiddleware = require('webpack-dev-middleware')(compiler, {\n    publicPath: config.output.publicPath,\n    stats: {\n        colors: true,\n        chunks: false\n    }\n})\n\n// 使用 webpack-hot-middleware 中间件\nvar hotMiddleware = require('webpack-hot-middleware')(compiler)\n\n// 注册中间件\napp.use(devMiddleware)\n// 注册中间件\napp.use(hotMiddleware)\n\n// 监听 8888端口，开启服务器\napp.listen(8888, function (err) {\n    if (err) {\n        console.log(err)\n        return\n    }\n    console.log('Listening at http://localhost:8888')\n})\n\n```\n\nok，现在重启的服务，然后修改 Favlist.vue 中的页面背景颜色为 '#000'：\n\n```\n<style>\n    html{\n        background: #000;\n    }\n</style>\n\n```\n\n然后查看你的浏览器，是不是你还没有刷新就已经得带改变了？\n\n那么这样就完美了吗？还没有，如果你细心，你会注意到，我们上面在第2步中修改了 webpack.config.js 这个基本配置文件，修改了入口配置，如下：\n\n```\nentry: ['webpack-hot-middleware/client', path.resolve(__dirname, '../app/index/index.js')],\n```\n\n这也会导致我们之前讨论过的问题，就是会影响构建，所以我们不要直接修改 webpack.config.js 文件，我们还是在 webpack.dev.conf.js 文件中配置，如下：\n\n```\n\nvar HtmlWebpackPlugin = require('html-webpack-plugin')\nvar path = require('path');\nvar webpack = require('webpack');\n// 引入基本配置\nvar config = require('./webpack.config');\n\nconfig.output.publicPath = '/';\n\nconfig.plugins = [\n    new webpack.optimize.OccurenceOrderPlugin(),\n    new webpack.HotModuleReplacementPlugin(),\n    new webpack.NoErrorsPlugin(),\n    new HtmlWebpackPlugin({\n        filename: 'app/index/index.html',\n        template: path.resolve(__dirname, '../app/index/index.html'),\n        inject: true\n    })\n];\n\n// 动态向入口配置中注入 webpack-hot-middleware/client\nvar devClient = 'webpack-hot-middleware/client';\nObject.keys(config.entry).forEach(function (name, i) {\n    var extras = [devClient]\n    config.entry[name] = extras.concat(config.entry[name])\n})\n\nmodule.exports = config;\n```\n\n但是我们还是要讲 webpack.config.js 文件中的入口配置修改为多入口配置的方式，这个修改不会影响构建，所以无所谓：\n\n```\nentry: {\n    index: path.resolve(__dirname, '../app/index/index.js')\n},\n```\n\n重启你的服务，刷新一下浏览器，然后修改 Favlist.vue 中的背景色为 green：\n\n```\n<style>\n    html{\n        background: green;\n    }\n</style>\n```\n\n再次查看浏览器，发现可以热加载。但是这样就结束了吗？还没有，不信你修改 index.html 文件，看看会不会热加载，实际上不会，你还是需要手动刷新页面，为了能够当 index.html 文件的改动也能够触发自动刷新，我们还需要做一些工作。\n\n*<b>第一步：在 dev-server.js 文件中监听html文件改变事件，修改后的 dev-server.js 文件如下：</b>*\n\n```\n// 引入必要的模块\nvar express = require('express')\nvar webpack = require('webpack')\nvar config = require('./webpack.dev.conf')\n\n// 创建一个express实例\nvar app = express()\n\n// 调用webpack并把配置传递过去\nvar compiler = webpack(config)\n\n// 使用 webpack-dev-middleware 中间件\nvar devMiddleware = require('webpack-dev-middleware')(compiler, {\n    publicPath: config.output.publicPath,\n    stats: {\n        colors: true,\n        chunks: false\n    }\n})\n\nvar hotMiddleware = require('webpack-hot-middleware')(compiler)\n\n// webpack插件，监听html文件改变事件\ncompiler.plugin('compilation', function (compilation) {\n    compilation.plugin('html-webpack-plugin-after-emit', function (data, cb) {\n        // 发布事件\n        hotMiddleware.publish({ action: 'reload' })\n        cb()\n    })\n})\n\n// 注册中间件\napp.use(devMiddleware)\n// 注册中间件\napp.use(hotMiddleware)\n\n// 监听 8888端口，开启服务器\napp.listen(8888, function (err) {\n    if (err) {\n        console.log(err)\n        return\n    }\n    console.log('Listening at http://localhost:8888')\n})\n\n```\n\n从上面的代码中可以看到，我们增加了如下代码：\n\n```\n// webpack插件，监听html文件改变事件\ncompiler.plugin('compilation', function (compilation) {\n    compilation.plugin('html-webpack-plugin-after-emit', function (data, cb) {\n        // 发布事件\n        hotMiddleware.publish({ action: 'reload' })\n        cb()\n    })\n})\n```\n\n这段代码可能你看不懂，因为这涉及到webpack插件的编写，读者可以参阅下面的连接：\n\n[webpack 插件doc1](https://github.com/webpack/docs/wiki/plugins)\n\n[webpack 插件doc2](https://github.com/webpack/docs/wiki/How-to-write-a-plugin)\n\n在这段代码中，我们监听了 'html-webpack-plugin-after-emit' 事件，那么这个事件是从哪里发射的呢？我们通过名字可知，这个事件应该和html-webpack-plugin这个插件有关，在npm搜索 [html-webpack-plugin](https://www.npmjs.com/package/html-webpack-plugin) 插件，在页面最底部我们可以发现如下图：\n\n![html-webpack-plugin可以发射事件](http://7xlolm.com1.z0.glb.clouddn.com/20160325i.jpg)\n\n我们可以看到，html-webpack-plugin 这个插件的确提供了几个可选的事件，下面也提供了使用方法，这样，我们就能够监听到html文件的变化，然后我们使用下面的代码发布一个事件：\n\n```\nhotMiddleware.publish({ action: 'reload' })\n```\n\n*<b>第二步：修改 webpack.dev.conf.js 文件如下：</b>*\n\n```\n\nvar HtmlWebpackPlugin = require('html-webpack-plugin')\nvar path = require('path');\nvar webpack = require('webpack');\n// 引入基本配置\nvar config = require('./webpack.config');\n\nconfig.output.publicPath = '/';\n\nconfig.plugins = [\n    new webpack.optimize.OccurenceOrderPlugin(),\n    new webpack.HotModuleReplacementPlugin(),\n    new webpack.NoErrorsPlugin(),\n    new HtmlWebpackPlugin({\n        filename: 'app/index/index.html',\n        template: path.resolve(__dirname, '../app/index/index.html'),\n        inject: true\n    })\n];\n\n// var devClient = 'webpack-hot-middleware/client';\nvar devClient = './build/dev-client';\nObject.keys(config.entry).forEach(function (name, i) {\n    var extras = [devClient]\n    config.entry[name] = extras.concat(config.entry[name])\n})\n\nmodule.exports = config;\n```\n\n我们修改了devClient变量，将 'webpack-hot-middleware/client' 替换成 './build/dev-client'，最终会导致，我们入口配置会变成下面这样：\n\n```\nentry: {\n    index: [\n        './build/dev-client',\n        path.resolve(__dirname, '../app/index/index.js')\n    ]\n},\n```\n\n*<b>第三步：新建 build/dev-client.js 文件，并编辑如下内容：</b>*\n\n```\nvar hotClient = require('webpack-hot-middleware/client')\n\n// 订阅事件，当 event.action === 'reload' 时执行页面刷新\nhotClient.subscribe(function (event) {\n    if (event.action === 'reload') {\n        window.location.reload()\n    }\n})\n\n```\n\n这里我们除了引入 'webpack-hot-middleware/client' 之外订阅了一个事件，当 event.action === 'reload' 时触发，还记得我们在 dev-server.js 中发布的事件吗：\n\n```\nhotMiddleware.publish({ action: 'reload' })\n```\n\n这样，当我们的html文件改变后，就可以监听的到，最终会执行页面刷新，而不需要我们手动刷新，现在重启服务，去尝试能否对html文件热加载吧。答案是yes。\n好了，开发环境终于搞定了，下面我们再来谈一谈生产环境，也就是构建输出，我们现在可以执行一下构建命令，看看输出的内容是什么，为了不必每次都要输入下面这条长命令：\n\n```\nwebpack --display-modules --display-chunks --config build/webpack.config.js\n```\n\n我们在 package.js 文件中添加 \"scripts\" 项，如下图：\n\n![npm](http://7xlolm.com1.z0.glb.clouddn.com/20160325m.jpg)\n\n这样，我们就可以通过执行下面命令来进行构建，同时我们还增加了一条开启开发服务器的命令：\n\n```\n// 构建\nnpm run build\n// 开启开发服务器\nnpm run dev\n```\n\n回过头来，我们执行构建命令： npm run build，查看输出内容，如下图：\n\n![输出内容](http://7xlolm.com1.z0.glb.clouddn.com/20160325n.jpg)\n\n现在我们只有一个js文件输出了，并没有css文件输出，在生产环境，我们希望css文件生成单独的文件，所以我们要使用 extract-text-webpack-plugin 插件，安装：\n\n```\nnpm install extract-text-webpack-plugin --save-dev\n```\n\n然后在build目录下新建 webpack.prod.conf.js 文件，顾名思义，这个使我们区别于开发环境，用于生产环境的配置文件，并编辑一下内容：\n\n```\n\nvar HtmlWebpackPlugin = require('html-webpack-plugin')\nvar ExtractTextPlugin = require('extract-text-webpack-plugin')\nvar path = require('path');\nvar webpack = require('webpack');\n// 引入基本配置\nvar config = require('./webpack.config');\n\nconfig.vue = {\n    loaders: {\n        css: ExtractTextPlugin.extract(\"css\")\n    }\n};\n\nconfig.plugins = [\n    // 提取css为单文件\n    new ExtractTextPlugin(\"../[name].[contenthash].css\"),\n\n    new HtmlWebpackPlugin({\n        filename: '../index.html',\n        template: path.resolve(__dirname, '../app/index/index.html'),\n        inject: true\n    })\n];\n\nmodule.exports = config;\n```\n\n上面的代码中，我们覆盖了 webpack.config.js 配置文件的 config.plugins 项，并且添加了 config.vue 项，补血药知道为什么，就是这么用的，如果一定要知道为什么也可以，这需要你多去了解vue以及vue-loader的工作原理，这里有连接[点击这里](http://vuejs.github.io/vue-loader/configurations/extract-css.html)\n然后修改 package.json 文件中的 script 项为如下：\n\n```\n\"scripts\": {\n    \"build\": \"webpack --display-modules --display-chunks --config build/webpack.prod.conf.js\",\n    \"dev\": \"node ./build/dev-server.js\"\n},\n```\n\n我们使用 webpack.prod.conf.js 为配置去构建，接下来执行：\n\n```\nnpm run build\n```\n\n查看你的输出内容，如下图，css文件未提取出来了：\n\n![css文件被提取](http://7xlolm.com1.z0.glb.clouddn.com/20160325l.jpg)\n\n另外我们还可以添加如下插件在我们的 webpack.prod.conf.js 文件中，作为生产环境使用：\n\n```\nconfig.plugins = [\n    new webpack.DefinePlugin({\n        'process.env': {\n            NODE_ENV: '\"production\"'\n        }\n    }),\n    // 压缩代码\n    new webpack.optimize.UglifyJsPlugin({\n        compress: {\n            warnings: false\n        }\n    }),\n    new webpack.optimize.OccurenceOrderPlugin(),\n    // 提取css为单文件\n    new ExtractTextPlugin(\"../[name].[contenthash].css\"),\n    new HtmlWebpackPlugin({\n        filename: '../index.html',\n        template: path.resolve(__dirname, '../app/index/index.html'),\n        inject: true\n    })\n];\n```\n\n大家可以搜索这些插件，了解他的作用，这篇文章要介绍的太多，所以我一一讲解了。\n\n到这里实际上搭建的已经差不多了，唯一要做的就是完善，比如公共模块的提取，如何加载图片，对于第一个问题，如何提取公共模块，我们可以使用 CommonsChunkPlugin 插件，在 webpack.prod.conf.js 文件中添加如下插件：\n\n```\nnew webpack.optimize.CommonsChunkPlugin({\n    name: 'vendors',\n    filename: 'vendors.js',\n}),\n```\n\n然后在 webpack.config.js 文件中配置入口文件：\n\n```\nentry: {\n    index: path.resolve(__dirname, '../app/index/index.js'),\n    vendors: [\n        'Vue'\n    ]\n},\n```\n\n上面代码的意思是，我们把Vue.js当做公共模块单独打包，你可以在这个数组中增加其他模块，一起作为公共模块打包成一个文件，我们执行构建命令，然后查看输出，如下图，成功提取：\n\n![提取公共模块](http://7xlolm.com1.z0.glb.clouddn.com/20160325u.jpg)\n\n对于加载图片的问题，我们知道，webpack的哲学是一切皆是模块，然后通过相应的loader去加载，所以加载图片，我们就需要使用到 url-loader，在webpack.config.js 文件中添加一个loader配置：\n\n```\nloaders: [\n    // 使用vue-loader 加载 .vue 结尾的文件\n    {\n        test: /\\.vue$/, \n        loader: 'vue'   \n    },\n    {\n        test: /\\.js$/,\n        loader: 'babel?presets=es2015',\n        exclude: /node_modules/\n    },\n    // 加载图片\n    {\n        test: /\\.(png|jpg|gif|svg)$/,\n        loader: 'url',\n        query: {\n            limit: 10000,\n            name: '[name].[ext]?[hash:7]'\n        }\n    }\n]\n```\n\n这样，当我们的css样式表文件中使用 url(xxxx.png)或者js中去require('xxxx.png')的时候，webpack就知道如何处理，另外url-loader的一个好处就是，以上面的配置来说，当我们的图片大小小于10000字节的时候，webpack会把图片转换成base64格式插入到代码中，从而减少http请求，另外，我们在这里谈到的任何一个loader都可以在npm中查找到，读者可以查询更多的loader了解并使用。\n\n\n\n\n","slug":"基于webpack和vue.js搭建的H5端框架(其实主要用于Hybrid开发H5端框架，但是依然能够作为纯web端使用)","published":1,"updated":"2016-06-06T03:38:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj669fskb001jewfcqw6da0a8","content":"<p>人类的发展得益于对追求不断的提升，在能活着的基础上是否要活得潇洒一点，技术的发展亦如是。在公司作为一个最最最最最最最底层的搬砖码农，经历了两个版本的铸(zhe)炼(mo)之后，我痛下决心今后一定要：…………..一定要和产品惺(shi)惺(bu)相(liang)惜(li)。</p>\n<a id=\"more\"></a>\n<h1 id=\"开始之前\"><a href=\"#开始之前\" class=\"headerlink\" title=\"开始之前\"></a>开始之前</h1><p>本文包含以下技术，文中尽量给与详细的描述，并且附上参考链接，读者可以深入学习：</p>\n<p>1、<a href=\"http://webpack.github.io/\" target=\"_blank\" rel=\"external\">webpack</a><br>2、<a href=\"http://cn.vuejs.org/\" target=\"_blank\" rel=\"external\">Vue.js</a><br>3、<a href=\"https://www.npmjs.com/\" target=\"_blank\" rel=\"external\">npm</a><br>4、nodejs —- 这个就不给连接了，因为上面的连接都是在你实践的过程中要去不断访问的<br>5、<a href=\"http://es6.ruanyifeng.com/#README\" target=\"_blank\" rel=\"external\">ES6语法</a></p>\n<p>另外，这套教程的代码都在我的github上，读者可以对照着代码来看，不过还是希望大家自己亲手搭建，体验这个过程，git地址：</p>\n<p><a href=\"https://github.com/HcySunYang/h5_frame\" target=\"_blank\" rel=\"external\">git地址</a></p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在对着产品高举中指怒发心中之愤后，真正能够解决问题的是自身上的改变，有句话说的好：你虽然改变不了全世界，但是你有机会改变你自己。秉承着“不听老人言，吃亏在眼前”的优良作风，我还是决定玩火自焚。</p>\n<h3 id=\"问题所在\"><a href=\"#问题所在\" class=\"headerlink\" title=\"问题所在\"></a>问题所在</h3><p>之前的项目总结为以下内容：</p>\n<blockquote>\n<p>1、AMD模块规范开发，使用requirejs实现，使用rjs打包，最终导致的结果是，输出的项目臃肿，肿的就像一坨狗不理……不忍直视<br>2、使用gulp进行打包，这一点貌似没有可吐槽的地方，毕竟都是被grunt折磨过来的……<br>3、数据的渲染使用模板引擎，这就意味着你要手动管理DOM，这样，你的业务代码参杂着你的数据处理、DOM管理，满屏幕的毛线……<br>4、模块化不足，虽然使用require进行了模块管理，但是大部分业务逻辑还是充斥在一个文件里，这与最近流行的组件化概念冰火不容，拒绝落后……<br>5、诸如 扩展性 、 维护性 我想早已不言而喻，不需赘述，再述就真TM是累赘了。</p>\n</blockquote>\n<p>新框架要解决的问题：</p>\n<blockquote>\n<p>1、要使构建输出的项目像你邻家小妹妹一样、瘦的皮包骨。（也许是营养不良）<br>2、要实现真正的模块化、组件化的开发方式，真正去解决维护难、扩展难的问题。（从此不怕产品汪）<br>3、业务逻辑专注数据处理，手动管理DOM的年代就像……像什么呢？（毕竟成人用品也越来越自动化了）<br>4、等等…….（其实好处无需赘述，来，往下看）</p>\n</blockquote>\n<p>为了达成以上目标，我们探讨一下解决方案：</p>\n<p><em><b>1、老项目的构建输出为什么臃肿？</b></em></p>\n<p>答：因为使用的是require的rjs进行构建打包的，了解rjs的都知道，它会把项目所有依赖都打包在一个文件里，如果项目中有很多页面依赖这个模块，那么rjs并不会把这个模块提取出来作为公共模块，所以就会有很多复制性的内容，所以项目自然臃肿。</p>\n<p><em>解决方案：</em>使用webpack配合相应的loader，来完成模块加载和构建的工作。</p>\n<p><em><b>2、老项目为什么模块化的不足？</b></em></p>\n<p>答：老项目的模块化，仅仅体现在js层面，解决了模块引用的问题，但在开发方式上，依然可以看做是过程式的，这样的结果就导致了项目的难扩展和难维护，让开发人员在与产品汪的对峙中，并不从容。</p>\n<p><em>解决方案：</em>Vue.js能够很好的解决组件化的问题，配合 Vue.js 官方提供的 <em>vue-loader</em> 能够很好的结合webpack做组件化的开发架构。</p>\n<p><em><b>3、如何避免手动管理DOM？</b></em></p>\n<p>答：如果你在做数据展示这一块的开发工作，相信你一定体会颇深，发送http请求到服务端，拿到返回的数据后手动渲染DOM至页面，这是最原始的开发方式，无非再加一个模板引擎之类的，但最终还是避免不了手动渲染，如果页面逻辑复杂，比如给你来一个翻页的功能，再来一个筛选项，估计你会觉得世界并不那么美好。</p>\n<p><em>解决方案：</em>MVVM模式能够很好的解决这个问题，而Vue.js的核心也是MVVM。</p>\n<h1 id=\"webpack\"><a href=\"#webpack\" class=\"headerlink\" title=\"webpack\"></a>webpack</h1><p>你肯定听说过webpack，如果直接对你描述什么是webpack你可能感受不到他的好处，那么在这之前，我相信你肯定使用过gulp或者grunt，如果你没使用过也可以，至少你要听说过并且知道gulp和grunt是干什么的，假如这个你还不清楚，那么你并不是一个合格的前端开发人员，这篇文章也不适合你，你可以从基础的地方慢慢学起。</p>\n<p>gulp和grunt对于每一个前端开发人员应该是不陌生的，它们为前端提供了自动化构建的能力，并且有自己的生态圈，有很多插件，使得我们告别刀耕火种的时代，但是它们并没有解决模块加载的问题，比如我们之前的项目是使用gulp构建的，但是模块化得工作还是要靠require和rjs来完成，而gulp除了完成一些其他任务之外，就变成了帮助我们免除手动执行命令的工具了，别无它用。</p>\n<p>而webpack就不同了，webpack的哲学是一切皆是模块，无论是js/css/sass/img/coffeejs/ttf….等等，webpack可以使用自定义的loader去把一切资源当做模块加载，这样就解决了模块依赖的问题，同时，利用插件还可以对项目进行优化，由于模块的加载和项目的构建优化都是通过webpack一个”人“来解决的，所以模块的加载和项目的构建优化并不是无机分离的，而是有机的结合在一起的，是一个组合的过程，这使得webpack在这方面能够完成的更出色，这也是webpack的优势所在。</p>\n<p>如果你看不懂上面的描述，没关系，你只需要知道一下几点：</p>\n<p>1、过去使用require和rjs等进行模块加载的方式，可以替换为webpack提供的指定loader去完成，你也可以自己开发加载特定资源的loader。<br>2、过去使用gulp和grunt完成项目构建优化的方式，可以替换成webpack提供的插件和特定的配置去完成。<br>3、由于模块的加载和项目的构建优化有机的结合，所以webpack能够更好的完成这项工作<br>4、并不是说有了webpack就淘汰的gulp等，有些特定的任务，还是要使用gulp去自定义完成的。但是不保证webpack的未来发展趋势会怎么样。</p>\n<p>最后，给大家分享一个官方的教程，这个教程的最开始有坑的地方，如果读者遇到了坑，可以在这里给我留言，我会为大家解答，不过总体来讲，这个教程适合入门，唯一不足的就是教程是英文的，英文的也不用怕，本人的英语没过四级，但是现在依然能够看得懂英文技术文章。教程链接：<a href=\"http://blog.madewithlove.be/post/webpack-your-bags/\" target=\"_blank\" rel=\"external\">http://blog.madewithlove.be/post/webpack-your-bags/</a></p>\n<h1 id=\"Vue-js\"><a href=\"#Vue-js\" class=\"headerlink\" title=\"Vue.js\"></a>Vue.js</h1><p><a href=\"http://cn.vuejs.org/\" target=\"_blank\" rel=\"external\">Vue.js</a>是一个MVVM模式的框架，如果读者有angular经验，一定能够很快入门Vue的，那么问题来了，为什么使用Vue而不用angular，<br>首先，Vue的体积小，轻量在移动端开发始终是一个不可忽略的话题，其次，Vue在实现上与angular有本质的区别，读者可以通过下面两个链接来了解：</p>\n<p>1、<a href=\"http://cn.vuejs.org/guide/reactivity.html\" target=\"_blank\" rel=\"external\">Vue的变化追踪和计算属性的区别等</a></p>\n<p>2、<a href=\"http://cn.vuejs.org/guide/comparison.html\" target=\"_blank\" rel=\"external\">Vue 与 angular 及 react 等框架的对比</a></p>\n<p>3、第三点就是Vue提供了webpack的loader —-&gt; [vue-loader]，使用它可以让项目的组件化思想更加清晰</p>\n<p>综上所述，这就是选用Vue的原因</p>\n<h1 id=\"npm-和-nodejs\"><a href=\"#npm-和-nodejs\" class=\"headerlink\" title=\"npm 和 nodejs\"></a>npm 和 nodejs</h1><p>npm 的全称是 <em>nodejs包管理</em>，现在越来越多的项目(包)都可以通过npm来安装管理，nodejs是js运行在服务器端的平台，它使得js的能力进一步提高，我们还要使用nodejs配合 webpack 来完成热加载的功能。所以读者最好有nodejs的开发经验，如果有express的经验更好。</p>\n<h1 id=\"让我们一步一步从零搭建这个项目\"><a href=\"#让我们一步一步从零搭建这个项目\" class=\"headerlink\" title=\"让我们一步一步从零搭建这个项目\"></a>让我们一步一步从零搭建这个项目</h1><p>首先新建一个目录，名为 myProject ，这是我们的项目目录。然后执行一些基本的步骤，比如 npm init 命令，在我们的项目中生成 package.json 文件，这几乎是必选的，因为我们的项目要有很多依赖，都是通过npm来管理的，而npm对于我们项目的管理，则是通过package.json文件：</p>\n<pre><code class=\"$\">npm init\n</code></pre>\n<p>执行npm init之后，会提示你填写一些项目的信息，一直回车默认就好了，或者直接执行 npm init -y 直接跳过询问步骤<br>然后我们新建一个叫做 app 的目录，这个是我们页面模块的目录，再在app目录下建立一个index目录，假设这个是首页模块的目录，然后再在index目录下建立一个 index.html 文件和 index.js 文件，分别是首页入口html文件和主js文件，然后再在index目录下建立一个components目录，这个目录用作存放首页组件模块的目录，因为我们最终要实现组件化开发。这样，当你完成上面的步骤后，你的项目看上去应该是这样的：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20160325b.jpg\" alt=\"项目结构\"></p>\n<p>接下来通过npm安装项目依赖项：</p>\n<pre><code class=\"$\">npm install\\\n  webpack webpack-dev-server\\\n  vue-loader vue-html-loader css-loader vue-style-loader vue-hot-reload-api\\\n  babel-loader babel-core babel-plugin-transform-runtime babel-preset-es2015\\\n  babel-runtime@5\\\n  --save-dev\n\nnpm install vue --save\n</code></pre>\n<p>这个时候，你的package.json文件看起来应该是这样的：</p>\n<pre><code>&quot;devDependencies&quot;: {\n    &quot;babel-core&quot;: &quot;^6.3.17&quot;,\n    &quot;babel-loader&quot;: &quot;^6.2.0&quot;,\n    &quot;babel-plugin-transform-runtime&quot;: &quot;^6.3.13&quot;,\n    &quot;babel-preset-es2015&quot;: &quot;^6.3.13&quot;,\n    &quot;babel-runtime&quot;: &quot;^5.8.34&quot;,\n    &quot;css-loader&quot;: &quot;^0.23.0&quot;,\n    &quot;vue-hot-reload-api&quot;: &quot;^1.2.2&quot;,\n    &quot;vue-html-loader&quot;: &quot;^1.0.0&quot;,\n    &quot;vue-style-loader&quot;: &quot;^1.0.0&quot;,\n    &quot;vue-loader&quot;: &quot;^7.2.0&quot;,\n    &quot;webpack&quot;: &quot;^1.12.9&quot;,\n    &quot;webpack-dev-server&quot;: &quot;^1.14.0&quot;\n  },\n  &quot;dependencies&quot;: {\n    &quot;vue&quot;: &quot;^1.0.13&quot;\n  },\n</code></pre><p>我们安装了 babel 一系列包，用来解析ES6语法，因为我们使用ES6来开发项目，如果你不了解ES6语法，建议你看一看<a href=\"http://es6.ruanyifeng.com/\" target=\"_blank\" rel=\"external\">阮老师的教程</a>，然后我们安装了一些loader包，比如css-loader/vue-loader等等，因为webpack是使用这些指定的loader去加载指定的文件的。</p>\n<p>另外我们还使用 npm install vue –save 命令安装了 vue ，这个就是我们要在项目中使用的vue.js，我们可以直接像开发nodejs应用一样，直接require(‘vue’);即可，而不需要通过script标签引入，这一点在开发中很爽。</p>\n<p>安装完了依赖，编辑以下文件并保存到相应位置：</p>\n<p>1、index.html文件：</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;zh&quot;&gt;\n    &lt;head&gt;\n        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, height=device-height, initial-scale=1.0, user-scalable=no&quot;&gt;\n        &lt;meta charset=&quot;utf-8&quot;&gt;\n        &lt;title&gt;首页&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;!-- vue的组件以自定义标签的形式使用 --&gt;\n        &lt;favlist&gt;&lt;/favlist&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>2、index.js文件：</p>\n<pre><code>import Vue from &#39;Vue&#39;\nimport Favlist from &#39;./components/Favlist&#39;\n\nnew Vue({\n    el: &#39;body&#39;,\n    components: { Favlist }\n})\n</code></pre><p>3、在components目录下新建一个 Favlist.vue 文件，作为我们的第一个组件：</p>\n<pre><code>&lt;template&gt;\n    &lt;div v-for=&quot;n in 10&quot;&gt;div&lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n    export default {\n        data () {\n            return {\n                msg: &#39;Hello World!&#39;\n            }\n        }\n    }\n&lt;/script&gt;\n\n&lt;style&gt;\n    html{\n        background: red;\n    }\n&lt;/style&gt;\n</code></pre><p>要看懂上面的代码，你需要了解vue.js，假如你看不懂也没关系，我们首先在index.html中使用了自定义标签（即组件），然后在index.js中引入了Vue和我们的Favlist.vue组件，Favlist.vue文件中，我们使用了基本的vue组件语法，最后，我们希望它运行起来，这个时候，我们就需要webpack了。</p>\n<p>在项目目录下新建 build 目录，用来存放我们的构建相关的代码文件等，然后在build目录下新建 webpack.config.js 这是我们的webpack配置文件，webpack需要通过读取你的配置，进行相应的操作，类似于gulpfile.js或者gruntfile.js等。</p>\n<p>webpack.config.js</p>\n<pre><code>// nodejs 中的path模块\nvar path = require(&#39;path&#39;);\n\nmodule.exports = {\n    // 入口文件，path.resolve()方法，可以结合我们给定的两个参数最后生成绝对路径，最终指向的就是我们的index.js文件\n    entry: path.resolve(__dirname, &#39;../app/index/index.js&#39;),\n    // 输出配置\n    output: {\n        // 输出路径是 myProject/output/static\n        path: path.resolve(__dirname, &#39;../output/static&#39;),\n        publicPath: &#39;static/&#39;,\n        filename: &#39;[name].[hash].js&#39;,\n        chunkFilename: &#39;[id].[chunkhash].js&#39;\n    },\n    module: {\n\n        loaders: [\n            // 使用vue-loader 加载 .vue 结尾的文件\n            {\n                test: /\\.vue$/, \n                loader: &#39;vue&#39;   \n            }\n        ]\n    }\n}\n</code></pre><p>上例中，相信你已经看懂了我的配置，入口文件是index.js文件，配置了相应输出，然后使用 vue-loader 去加载 .vue 结尾的文件，接下来我们就可以构建项目了，我们可以在命令行中执行：</p>\n<pre><code>webpack --display-modules --display-chunks --config build/webpack.config.js\n</code></pre><p>通过webpack命令，并且通过 –config 选项指定了我们配置文件的位置是 ‘build/webpack.config.js’，并通过 –display-modules 和 –display-chunks 选项显示相应的信息。如果你执行上面的命令，可能得到下图的错误：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20160325c.jpg\" alt=\"报错\"></p>\n<p>错误提示我们应该选择合适的loader去加载这个 ‘./app/index/index.js’ 这个文件，并且说不期望index.js文件中的标识符（Unexpected token），这是因为我们使用了ES6的语法 import 语句，所以我们要使用 babel-loader 去加载我们的js文件，在配置文件中添加一个loaders项目，如下：</p>\n<pre><code>// nodejs 中的path模块\nvar path = require(&#39;path&#39;);\n\nmodule.exports = {\n    // 入口文件，path.resolve()方法，可以结合我们给定的两个参数最后生成绝对路径，最终指向的就是我们的index.js文件\n    entry: path.resolve(__dirname, &#39;../app/index/index.js&#39;),\n    // 输出配置\n    output: {\n        // 输出路径是 myProject/output/static\n        path: path.resolve(__dirname, &#39;../output/static&#39;),\n        publicPath: &#39;static/&#39;,\n        filename: &#39;[name].[hash].js&#39;,\n        chunkFilename: &#39;[id].[chunkhash].js&#39;\n    },\n    module: {\n\n        loaders: [\n            // 使用vue-loader 加载 .vue 结尾的文件\n            {\n                test: /\\.vue$/, \n                loader: &#39;vue&#39;   \n            },\n            {\n                test: /\\.js$/,\n                loader: &#39;babel?presets=es2015&#39;,\n                exclude: /node_modules/\n            }\n        ]\n    }\n}\n</code></pre><p>现在再运行构建命令 ： ‘webpack –display-modules –display-chunks –config build/webpack.config.js’</p>\n<p>sorry，不出意外，你应该得到如下错误：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20160325d.jpg\" alt=\"错误\"></p>\n<p>它说没有发现 ‘./components/Favlist’ 模块，而我们明明有 ./components/Favlist.vue 文件，为什么它没发现呢？它瞎了？其实是这样的，当webpack试图去加载模块的时候，它默认是查找以 .js 结尾的文件的，它并不知道 .vue 结尾的文件是什么鬼玩意儿，所以我们要在配置文件中告诉webpack，遇到 .vue 结尾的也要去加载，添加 resolve 配置项，如下：</p>\n<pre><code>// nodejs 中的path模块\nvar path = require(&#39;path&#39;);\n\nmodule.exports = {\n    // 入口文件，path.resolve()方法，可以结合我们给定的两个参数最后生成绝对路径，最终指向的就是我们的index.js文件\n    entry: path.resolve(__dirname, &#39;../app/index/index.js&#39;),\n    // 输出配置\n    output: {\n        // 输出路径是 myProject/output/static\n        path: path.resolve(__dirname, &#39;../output/static&#39;),\n        publicPath: &#39;static/&#39;,\n        filename: &#39;[name].[hash].js&#39;,\n        chunkFilename: &#39;[id].[chunkhash].js&#39;\n    },\n    resolve: {\n        extensions: [&#39;&#39;, &#39;.js&#39;, &#39;.vue&#39;]\n    },\n    module: {\n\n        loaders: [\n            // 使用vue-loader 加载 .vue 结尾的文件\n            {\n                test: /\\.vue$/, \n                loader: &#39;vue&#39;   \n            },\n            {\n                test: /\\.js$/,\n                loader: &#39;babel?presets=es2015&#39;,\n                exclude: /node_modules/\n            }\n        ]\n    }\n}\n</code></pre><p>这样，当我们去加载 ‘./components/Favlist’ 这样的模块时，webpack首先会查找 ./components/Favlist.js 如果没有发现Favlist.js文件就会继续查找 Favlist.vue 文件，现在再次运行构建命令，我们成功了，这时我们会在我们的输出目录中看到一个js文件：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20160325e.jpg\" alt=\"输出\"></p>\n<p>之所以会这样输出，是因为我们的 webpack.config.js 文件中的输出配置中指定了相应的输出信息，这个时候，我们修改 index.html ，将输出的js文件引入：</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;zh&quot;&gt;\n    &lt;head&gt;\n        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, height=device-height, initial-scale=1.0, user-scalable=no&quot;&gt;\n        &lt;meta charset=&quot;utf-8&quot;&gt;\n        &lt;title&gt;首页&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;!-- vue的组件以自定义标签的形式使用 --&gt;\n        &lt;favlist&gt;&lt;/favlist&gt;\n\n        &lt;script src=&quot;../../output/static/main.ce853b65bcffc3b16328.js&quot;&gt;&lt;/script&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>然后用浏览器打开这个页面，你可以看到你写的代码正确的执行了。</p>\n<p>那么问题来了，难道我们每次都要手动的引入输出的js文件吗？因为每次构建输出的js文件都带有 hash 值，如 main.ce853b65bcffc3b16328.js，就不能更智能一点吗？每次都自动写入？怎么会不可能，否则这东西还能火吗，要实现这个功能，我们就要使用webpack的插件了，<a href=\"https://www.npmjs.com/package/html-webpack-plugin\" target=\"_blank\" rel=\"external\">html-webpack-plugin</a>插件，这个插件可以创建html文件，并自动将依赖写入html文件中。</p>\n<p>首先安装 html-webpack-plugin 插件：</p>\n<pre><code>npm install html-webpack-plugin --save-dev\n</code></pre><p>然后在修改配置项：</p>\n<pre><code>// nodejs 中的path模块\nvar path = require(&#39;path&#39;);\nvar HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)\n\nmodule.exports = {\n    // 入口文件，path.resolve()方法，可以结合我们给定的两个参数最后生成绝对路径，最终指向的就是我们的index.js文件\n    entry: path.resolve(__dirname, &#39;../app/index/index.js&#39;),\n    // 输出配置\n    output: {\n        // 输出路径是 myProject/output/static\n        path: path.resolve(__dirname, &#39;../output/static&#39;),\n        publicPath: &#39;static/&#39;,\n        filename: &#39;[name].[hash].js&#39;,\n        chunkFilename: &#39;[id].[chunkhash].js&#39;\n    },\n    resolve: {\n        extensions: [&#39;&#39;, &#39;.js&#39;, &#39;.vue&#39;]\n    },\n    module: {\n\n        loaders: [\n            // 使用vue-loader 加载 .vue 结尾的文件\n            {\n                test: /\\.vue$/, \n                loader: &#39;vue&#39;   \n            },\n            {\n                test: /\\.js$/,\n                loader: &#39;babel?presets=es2015&#39;,\n                exclude: /node_modules/\n            }\n        ]\n    },\n    plugins: [\n        new HtmlWebpackPlugin({\n            filename: &#39;../index.html&#39;,\n            template: path.resolve(__dirname, &#39;../app/index/index.html&#39;),\n            inject: true\n        })\n    ]\n}\n</code></pre><p>然后再次执行构建命令，成功之后，看你的输出目录，多出来一个index.html文件，双击它，代码正确执行，你可以打开这个文件查看一下，webpack自动帮我们引入了相应的文件。</p>\n<p>问题继续来了，难道每次我们都要构建之后才能查看运行的代码吗？那岂不是很没有效率，别担心，webpack提供了几种方式，进行热加载，在开发模式中，我们使用这种方式来提高效率，这里要介绍的，是使用 <a href=\"https://www.npmjs.com/package/webpack-dev-middleware\" target=\"_blank\" rel=\"external\">webpack-dev-middleware</a>中间件和<a href=\"https://www.npmjs.com/package/webpack-hot-middleware\" target=\"_blank\" rel=\"external\">webpack-hot-middleware</a>中间件，首先安装两个中间件：</p>\n<pre><code>npm install webpack-dev-middleware webpack-hot-middleware --save-dev\n</code></pre><p>另外，还要安装express，这是一个nodejs框架</p>\n<pre><code>npm install express --save-dev\n</code></pre><p>在开始之前，我先简单介绍一下这两个中间件，之所以叫做中间件，是因为nodejs的一个叫做express的框架中有中间件的概念，而这两个包要作为express中间件使用，所以称它们为中间件，那么他们能干什么呢？</p>\n<p><em><b>1、webpack-dev-middleware</b></em></p>\n<p>我们之前所面临的问题是，如果我们的代码改动了，我们要想看到浏览器的变化，需要先对项目进行构建，然后才能查看效果，这样对于开发效率来讲，简直就是不可忍受的一件事，试想我仅仅修改一个背景颜色就要构建一下项目，这尼玛坑爹啊，好在有<a href=\"https://www.npmjs.com/package/webpack-dev-middleware\" target=\"_blank\" rel=\"external\">webpack-dev-middleware</a>中间件，它是对webpack一个简单的包装，它可以通过连接服务器服务那些从webpack发射出来的文件，它有一下几点好处：</p>\n<p>1、不会向硬盘写文件，而是在内存中，注意我们构建项目实际就是向硬盘写文件。</p>\n<p>2、当文件改变的时候，这个中间件不会再服务旧的包，你可以直接帅新浏览器就能看到最新的效果，这样你就不必等待构建的时间，所见即所得。</p>\n<p>下面我们在build目录中创建一个 dev-server.js 的文件，并写入一下内容：</p>\n<pre><code>// 引入必要的模块\nvar express = require(&#39;express&#39;)\nvar webpack = require(&#39;webpack&#39;)\nvar config = require(&#39;./webpack.config&#39;)\n\n// 创建一个express实例\nvar app = express()\n\n// 调用webpack并把配置传递过去\nvar compiler = webpack(config)\n\n// 使用 webpack-dev-middleware 中间件\nvar devMiddleware = require(&#39;webpack-dev-middleware&#39;)(compiler, {\n    publicPath: config.output.publicPath,\n    stats: {\n        colors: true,\n        chunks: false\n    }\n})\n\n// 注册中间件\napp.use(devMiddleware)\n\n// 监听 8888端口，开启服务器\napp.listen(8888, function (err) {\n    if (err) {\n        console.log(err)\n        return\n    }\n    console.log(&#39;Listening at http://localhost:8888&#39;)\n})\n</code></pre><p>此时，我们在项目根目录运行下面的命令，开启服务：</p>\n<pre><code>node build/dev-server.js\n</code></pre><p>如果看到下图所示，证明你的服务成功开启了：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20160325f.jpg\" alt=\"开启服务成功\"></p>\n<p>接下来打开浏览器，输入：</p>\n<pre><code>http://localhost:8888/app/index/index.html\n</code></pre><p>回车，如果不出意外，你应该得到一个404，如下图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20160325g.jpg\" alt=\"404\"></p>\n<p>我们要对我们的 webpack.config.js 配置文件做两处修改：</p>\n<p>1、将 config.output.publicPath 修改为 ‘/‘：</p>\n<pre><code>output: {\n    // 输出路径是 myProject/output/static\n    path: path.resolve(__dirname, &#39;../output/static&#39;),\n    publicPath: &#39;/&#39;,\n    filename: &#39;[name].[hash].js&#39;,\n    chunkFilename: &#39;[id].[chunkhash].js&#39;\n},\n</code></pre><p>2、将 plugins 中 HtmlWebpackPlugin 中的 filename 修改为 ‘app/index/index.html’</p>\n<pre><code>plugins: [\n    new HtmlWebpackPlugin({\n        filename: &#39;app/index/index.html&#39;,\n        template: path.resolve(__dirname, &#39;../app/index/index.html&#39;),\n        inject: true\n    })\n]\n</code></pre><p>重启服务，再刷新页面，如果看到如下界面，证明你成功了：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20160325h.jpg\" alt=\"成功\"></p>\n<p>但是这样开发模式下的确是成功了，可是我们直接修改了 webpack.config.js 文件，这就意味着当我们执行 构建命令 的时候，配置变了，那么我们的构建也跟着变了，所以，一个好的方式是，不去修改webpack.config.js文件，我们在build目录下新建一个 webpack.dev.conf.js文件，意思是开发模式下要读取的配置文件，并写入一下内容：</p>\n<pre><code>var HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)\nvar path = require(&#39;path&#39;);\n// 引入基本配置\nvar config = require(&#39;./webpack.config&#39;);\n\nconfig.output.publicPath = &#39;/&#39;;\n\nconfig.plugins = [\n    new HtmlWebpackPlugin({\n        filename: &#39;app/index/index.html&#39;,\n        template: path.resolve(__dirname, &#39;../app/index/index.html&#39;),\n        inject: true\n    })\n];\n\nmodule.exports = config;\n</code></pre><p>这样，我们在dev环境下的配置文件中覆盖了基本配置文件，我们只需要在dev-server.js中将 </p>\n<pre><code>var config = require(&#39;./webpack.config&#39;)\n</code></pre><p>修改为：</p>\n<pre><code>var config = require(&#39;./webpack.dev.conf&#39;)\n</code></pre><p>即可，然后，重启服务，刷新浏览器，你应该得到同样的成功结果，而这一次当我们执行构建命令：</p>\n<pre><code>webpack --display-modules --display-chunks --config build/webpack.config.js\n</code></pre><p>并不会影响构建输出，因为我们没有直接修改webpack.config.js文件。</p>\n<p>现在我们已经使用 webpack-dev-middleware 搭建基本的开发环境了，但是我们并不满足，因为我们每次都要手动去刷新浏览器，所谓的热加载，意思就是说能够追踪我们代码的变化，并自动更新界面，甚至还能保留程序状态。要完成热加载，我们就需要使用另外一个中间件 <em>webpack-hot-middleware</em></p>\n<p><em><b>2、webpack-hot-middleware</b></em></p>\n<p><a href=\"https://www.npmjs.com/package/webpack-hot-middleware\" target=\"_blank\" rel=\"external\">webpack-hot-middleware</a> 只配合 webpack-dev-middleware 使用，它能给你提供热加载。</p>\n<p>它的使用很简单，总共分4步：</p>\n<p>1、安装，我们上面已经安装过了<br>2、在 webpack.dev.conf.js 配置文件中添加三个插件，如下：</p>\n<pre><code>\nvar HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)\nvar path = require(&#39;path&#39;);\nvar webpack = require(&#39;webpack&#39;);\n// 引入基本配置\nvar config = require(&#39;./webpack.config&#39;);\n\nconfig.output.publicPath = &#39;/&#39;;\n\nconfig.plugins = [\n    // 添加三个插件\n    new webpack.optimize.OccurenceOrderPlugin(),\n    new webpack.HotModuleReplacementPlugin(),\n    new webpack.NoErrorsPlugin(),\n\n    new HtmlWebpackPlugin({\n        filename: &#39;app/index/index.html&#39;,\n        template: path.resolve(__dirname, &#39;../app/index/index.html&#39;),\n        inject: true\n    })\n];\n\nmodule.exports = config;\n</code></pre><p>3、在 webpack.config.js 文件中入口配置中添加 ‘webpack-hot-middleware/client’，如下：</p>\n<pre><code>entry: [&#39;webpack-hot-middleware/client&#39;, path.resolve(__dirname, &#39;../app/index/index.js&#39;)],\n</code></pre><p>4、在 dev-server.js 文件中使用插件</p>\n<pre><code>// 引入必要的模块\nvar express = require(&#39;express&#39;)\nvar webpack = require(&#39;webpack&#39;)\nvar config = require(&#39;./webpack.dev.conf&#39;)\n\n// 创建一个express实例\nvar app = express()\n\n// 调用webpack并把配置传递过去\nvar compiler = webpack(config)\n\n// 使用 webpack-dev-middleware 中间件\nvar devMiddleware = require(&#39;webpack-dev-middleware&#39;)(compiler, {\n    publicPath: config.output.publicPath,\n    stats: {\n        colors: true,\n        chunks: false\n    }\n})\n\n// 使用 webpack-hot-middleware 中间件\nvar hotMiddleware = require(&#39;webpack-hot-middleware&#39;)(compiler)\n\n// 注册中间件\napp.use(devMiddleware)\n// 注册中间件\napp.use(hotMiddleware)\n\n// 监听 8888端口，开启服务器\napp.listen(8888, function (err) {\n    if (err) {\n        console.log(err)\n        return\n    }\n    console.log(&#39;Listening at http://localhost:8888&#39;)\n})\n</code></pre><p>ok，现在重启的服务，然后修改 Favlist.vue 中的页面背景颜色为 ‘#000’：</p>\n<pre><code>&lt;style&gt;\n    html{\n        background: #000;\n    }\n&lt;/style&gt;\n</code></pre><p>然后查看你的浏览器，是不是你还没有刷新就已经得带改变了？</p>\n<p>那么这样就完美了吗？还没有，如果你细心，你会注意到，我们上面在第2步中修改了 webpack.config.js 这个基本配置文件，修改了入口配置，如下：</p>\n<pre><code>entry: [&#39;webpack-hot-middleware/client&#39;, path.resolve(__dirname, &#39;../app/index/index.js&#39;)],\n</code></pre><p>这也会导致我们之前讨论过的问题，就是会影响构建，所以我们不要直接修改 webpack.config.js 文件，我们还是在 webpack.dev.conf.js 文件中配置，如下：</p>\n<pre><code>\nvar HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)\nvar path = require(&#39;path&#39;);\nvar webpack = require(&#39;webpack&#39;);\n// 引入基本配置\nvar config = require(&#39;./webpack.config&#39;);\n\nconfig.output.publicPath = &#39;/&#39;;\n\nconfig.plugins = [\n    new webpack.optimize.OccurenceOrderPlugin(),\n    new webpack.HotModuleReplacementPlugin(),\n    new webpack.NoErrorsPlugin(),\n    new HtmlWebpackPlugin({\n        filename: &#39;app/index/index.html&#39;,\n        template: path.resolve(__dirname, &#39;../app/index/index.html&#39;),\n        inject: true\n    })\n];\n\n// 动态向入口配置中注入 webpack-hot-middleware/client\nvar devClient = &#39;webpack-hot-middleware/client&#39;;\nObject.keys(config.entry).forEach(function (name, i) {\n    var extras = [devClient]\n    config.entry[name] = extras.concat(config.entry[name])\n})\n\nmodule.exports = config;\n</code></pre><p>但是我们还是要讲 webpack.config.js 文件中的入口配置修改为多入口配置的方式，这个修改不会影响构建，所以无所谓：</p>\n<pre><code>entry: {\n    index: path.resolve(__dirname, &#39;../app/index/index.js&#39;)\n},\n</code></pre><p>重启你的服务，刷新一下浏览器，然后修改 Favlist.vue 中的背景色为 green：</p>\n<pre><code>&lt;style&gt;\n    html{\n        background: green;\n    }\n&lt;/style&gt;\n</code></pre><p>再次查看浏览器，发现可以热加载。但是这样就结束了吗？还没有，不信你修改 index.html 文件，看看会不会热加载，实际上不会，你还是需要手动刷新页面，为了能够当 index.html 文件的改动也能够触发自动刷新，我们还需要做一些工作。</p>\n<p><em><b>第一步：在 dev-server.js 文件中监听html文件改变事件，修改后的 dev-server.js 文件如下：</b></em></p>\n<pre><code>// 引入必要的模块\nvar express = require(&#39;express&#39;)\nvar webpack = require(&#39;webpack&#39;)\nvar config = require(&#39;./webpack.dev.conf&#39;)\n\n// 创建一个express实例\nvar app = express()\n\n// 调用webpack并把配置传递过去\nvar compiler = webpack(config)\n\n// 使用 webpack-dev-middleware 中间件\nvar devMiddleware = require(&#39;webpack-dev-middleware&#39;)(compiler, {\n    publicPath: config.output.publicPath,\n    stats: {\n        colors: true,\n        chunks: false\n    }\n})\n\nvar hotMiddleware = require(&#39;webpack-hot-middleware&#39;)(compiler)\n\n// webpack插件，监听html文件改变事件\ncompiler.plugin(&#39;compilation&#39;, function (compilation) {\n    compilation.plugin(&#39;html-webpack-plugin-after-emit&#39;, function (data, cb) {\n        // 发布事件\n        hotMiddleware.publish({ action: &#39;reload&#39; })\n        cb()\n    })\n})\n\n// 注册中间件\napp.use(devMiddleware)\n// 注册中间件\napp.use(hotMiddleware)\n\n// 监听 8888端口，开启服务器\napp.listen(8888, function (err) {\n    if (err) {\n        console.log(err)\n        return\n    }\n    console.log(&#39;Listening at http://localhost:8888&#39;)\n})\n</code></pre><p>从上面的代码中可以看到，我们增加了如下代码：</p>\n<pre><code>// webpack插件，监听html文件改变事件\ncompiler.plugin(&#39;compilation&#39;, function (compilation) {\n    compilation.plugin(&#39;html-webpack-plugin-after-emit&#39;, function (data, cb) {\n        // 发布事件\n        hotMiddleware.publish({ action: &#39;reload&#39; })\n        cb()\n    })\n})\n</code></pre><p>这段代码可能你看不懂，因为这涉及到webpack插件的编写，读者可以参阅下面的连接：</p>\n<p><a href=\"https://github.com/webpack/docs/wiki/plugins\" target=\"_blank\" rel=\"external\">webpack 插件doc1</a></p>\n<p><a href=\"https://github.com/webpack/docs/wiki/How-to-write-a-plugin\" target=\"_blank\" rel=\"external\">webpack 插件doc2</a></p>\n<p>在这段代码中，我们监听了 ‘html-webpack-plugin-after-emit’ 事件，那么这个事件是从哪里发射的呢？我们通过名字可知，这个事件应该和html-webpack-plugin这个插件有关，在npm搜索 <a href=\"https://www.npmjs.com/package/html-webpack-plugin\" target=\"_blank\" rel=\"external\">html-webpack-plugin</a> 插件，在页面最底部我们可以发现如下图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20160325i.jpg\" alt=\"html-webpack-plugin可以发射事件\"></p>\n<p>我们可以看到，html-webpack-plugin 这个插件的确提供了几个可选的事件，下面也提供了使用方法，这样，我们就能够监听到html文件的变化，然后我们使用下面的代码发布一个事件：</p>\n<pre><code>hotMiddleware.publish({ action: &#39;reload&#39; })\n</code></pre><p><em><b>第二步：修改 webpack.dev.conf.js 文件如下：</b></em></p>\n<pre><code>\nvar HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)\nvar path = require(&#39;path&#39;);\nvar webpack = require(&#39;webpack&#39;);\n// 引入基本配置\nvar config = require(&#39;./webpack.config&#39;);\n\nconfig.output.publicPath = &#39;/&#39;;\n\nconfig.plugins = [\n    new webpack.optimize.OccurenceOrderPlugin(),\n    new webpack.HotModuleReplacementPlugin(),\n    new webpack.NoErrorsPlugin(),\n    new HtmlWebpackPlugin({\n        filename: &#39;app/index/index.html&#39;,\n        template: path.resolve(__dirname, &#39;../app/index/index.html&#39;),\n        inject: true\n    })\n];\n\n// var devClient = &#39;webpack-hot-middleware/client&#39;;\nvar devClient = &#39;./build/dev-client&#39;;\nObject.keys(config.entry).forEach(function (name, i) {\n    var extras = [devClient]\n    config.entry[name] = extras.concat(config.entry[name])\n})\n\nmodule.exports = config;\n</code></pre><p>我们修改了devClient变量，将 ‘webpack-hot-middleware/client’ 替换成 ‘./build/dev-client’，最终会导致，我们入口配置会变成下面这样：</p>\n<pre><code>entry: {\n    index: [\n        &#39;./build/dev-client&#39;,\n        path.resolve(__dirname, &#39;../app/index/index.js&#39;)\n    ]\n},\n</code></pre><p><em><b>第三步：新建 build/dev-client.js 文件，并编辑如下内容：</b></em></p>\n<pre><code>var hotClient = require(&#39;webpack-hot-middleware/client&#39;)\n\n// 订阅事件，当 event.action === &#39;reload&#39; 时执行页面刷新\nhotClient.subscribe(function (event) {\n    if (event.action === &#39;reload&#39;) {\n        window.location.reload()\n    }\n})\n</code></pre><p>这里我们除了引入 ‘webpack-hot-middleware/client’ 之外订阅了一个事件，当 event.action === ‘reload’ 时触发，还记得我们在 dev-server.js 中发布的事件吗：</p>\n<pre><code>hotMiddleware.publish({ action: &#39;reload&#39; })\n</code></pre><p>这样，当我们的html文件改变后，就可以监听的到，最终会执行页面刷新，而不需要我们手动刷新，现在重启服务，去尝试能否对html文件热加载吧。答案是yes。<br>好了，开发环境终于搞定了，下面我们再来谈一谈生产环境，也就是构建输出，我们现在可以执行一下构建命令，看看输出的内容是什么，为了不必每次都要输入下面这条长命令：</p>\n<pre><code>webpack --display-modules --display-chunks --config build/webpack.config.js\n</code></pre><p>我们在 package.js 文件中添加 “scripts” 项，如下图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20160325m.jpg\" alt=\"npm\"></p>\n<p>这样，我们就可以通过执行下面命令来进行构建，同时我们还增加了一条开启开发服务器的命令：</p>\n<pre><code>// 构建\nnpm run build\n// 开启开发服务器\nnpm run dev\n</code></pre><p>回过头来，我们执行构建命令： npm run build，查看输出内容，如下图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20160325n.jpg\" alt=\"输出内容\"></p>\n<p>现在我们只有一个js文件输出了，并没有css文件输出，在生产环境，我们希望css文件生成单独的文件，所以我们要使用 extract-text-webpack-plugin 插件，安装：</p>\n<pre><code>npm install extract-text-webpack-plugin --save-dev\n</code></pre><p>然后在build目录下新建 webpack.prod.conf.js 文件，顾名思义，这个使我们区别于开发环境，用于生产环境的配置文件，并编辑一下内容：</p>\n<pre><code>\nvar HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)\nvar ExtractTextPlugin = require(&#39;extract-text-webpack-plugin&#39;)\nvar path = require(&#39;path&#39;);\nvar webpack = require(&#39;webpack&#39;);\n// 引入基本配置\nvar config = require(&#39;./webpack.config&#39;);\n\nconfig.vue = {\n    loaders: {\n        css: ExtractTextPlugin.extract(&quot;css&quot;)\n    }\n};\n\nconfig.plugins = [\n    // 提取css为单文件\n    new ExtractTextPlugin(&quot;../[name].[contenthash].css&quot;),\n\n    new HtmlWebpackPlugin({\n        filename: &#39;../index.html&#39;,\n        template: path.resolve(__dirname, &#39;../app/index/index.html&#39;),\n        inject: true\n    })\n];\n\nmodule.exports = config;\n</code></pre><p>上面的代码中，我们覆盖了 webpack.config.js 配置文件的 config.plugins 项，并且添加了 config.vue 项，补血药知道为什么，就是这么用的，如果一定要知道为什么也可以，这需要你多去了解vue以及vue-loader的工作原理，这里有连接<a href=\"http://vuejs.github.io/vue-loader/configurations/extract-css.html\" target=\"_blank\" rel=\"external\">点击这里</a><br>然后修改 package.json 文件中的 script 项为如下：</p>\n<pre><code>&quot;scripts&quot;: {\n    &quot;build&quot;: &quot;webpack --display-modules --display-chunks --config build/webpack.prod.conf.js&quot;,\n    &quot;dev&quot;: &quot;node ./build/dev-server.js&quot;\n},\n</code></pre><p>我们使用 webpack.prod.conf.js 为配置去构建，接下来执行：</p>\n<pre><code>npm run build\n</code></pre><p>查看你的输出内容，如下图，css文件未提取出来了：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20160325l.jpg\" alt=\"css文件被提取\"></p>\n<p>另外我们还可以添加如下插件在我们的 webpack.prod.conf.js 文件中，作为生产环境使用：</p>\n<pre><code>config.plugins = [\n    new webpack.DefinePlugin({\n        &#39;process.env&#39;: {\n            NODE_ENV: &#39;&quot;production&quot;&#39;\n        }\n    }),\n    // 压缩代码\n    new webpack.optimize.UglifyJsPlugin({\n        compress: {\n            warnings: false\n        }\n    }),\n    new webpack.optimize.OccurenceOrderPlugin(),\n    // 提取css为单文件\n    new ExtractTextPlugin(&quot;../[name].[contenthash].css&quot;),\n    new HtmlWebpackPlugin({\n        filename: &#39;../index.html&#39;,\n        template: path.resolve(__dirname, &#39;../app/index/index.html&#39;),\n        inject: true\n    })\n];\n</code></pre><p>大家可以搜索这些插件，了解他的作用，这篇文章要介绍的太多，所以我一一讲解了。</p>\n<p>到这里实际上搭建的已经差不多了，唯一要做的就是完善，比如公共模块的提取，如何加载图片，对于第一个问题，如何提取公共模块，我们可以使用 CommonsChunkPlugin 插件，在 webpack.prod.conf.js 文件中添加如下插件：</p>\n<pre><code>new webpack.optimize.CommonsChunkPlugin({\n    name: &#39;vendors&#39;,\n    filename: &#39;vendors.js&#39;,\n}),\n</code></pre><p>然后在 webpack.config.js 文件中配置入口文件：</p>\n<pre><code>entry: {\n    index: path.resolve(__dirname, &#39;../app/index/index.js&#39;),\n    vendors: [\n        &#39;Vue&#39;\n    ]\n},\n</code></pre><p>上面代码的意思是，我们把Vue.js当做公共模块单独打包，你可以在这个数组中增加其他模块，一起作为公共模块打包成一个文件，我们执行构建命令，然后查看输出，如下图，成功提取：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20160325u.jpg\" alt=\"提取公共模块\"></p>\n<p>对于加载图片的问题，我们知道，webpack的哲学是一切皆是模块，然后通过相应的loader去加载，所以加载图片，我们就需要使用到 url-loader，在webpack.config.js 文件中添加一个loader配置：</p>\n<pre><code>loaders: [\n    // 使用vue-loader 加载 .vue 结尾的文件\n    {\n        test: /\\.vue$/, \n        loader: &#39;vue&#39;   \n    },\n    {\n        test: /\\.js$/,\n        loader: &#39;babel?presets=es2015&#39;,\n        exclude: /node_modules/\n    },\n    // 加载图片\n    {\n        test: /\\.(png|jpg|gif|svg)$/,\n        loader: &#39;url&#39;,\n        query: {\n            limit: 10000,\n            name: &#39;[name].[ext]?[hash:7]&#39;\n        }\n    }\n]\n</code></pre><p>这样，当我们的css样式表文件中使用 url(xxxx.png)或者js中去require(‘xxxx.png’)的时候，webpack就知道如何处理，另外url-loader的一个好处就是，以上面的配置来说，当我们的图片大小小于10000字节的时候，webpack会把图片转换成base64格式插入到代码中，从而减少http请求，另外，我们在这里谈到的任何一个loader都可以在npm中查找到，读者可以查询更多的loader了解并使用。</p>\n","site":{"data":{}},"excerpt":"<p>人类的发展得益于对追求不断的提升，在能活着的基础上是否要活得潇洒一点，技术的发展亦如是。在公司作为一个最最最最最最最底层的搬砖码农，经历了两个版本的铸(zhe)炼(mo)之后，我痛下决心今后一定要：…………..一定要和产品惺(shi)惺(bu)相(liang)惜(li)。</p>","more":"<h1 id=\"开始之前\"><a href=\"#开始之前\" class=\"headerlink\" title=\"开始之前\"></a>开始之前</h1><p>本文包含以下技术，文中尽量给与详细的描述，并且附上参考链接，读者可以深入学习：</p>\n<p>1、<a href=\"http://webpack.github.io/\" target=\"_blank\" rel=\"external\">webpack</a><br>2、<a href=\"http://cn.vuejs.org/\" target=\"_blank\" rel=\"external\">Vue.js</a><br>3、<a href=\"https://www.npmjs.com/\" target=\"_blank\" rel=\"external\">npm</a><br>4、nodejs —- 这个就不给连接了，因为上面的连接都是在你实践的过程中要去不断访问的<br>5、<a href=\"http://es6.ruanyifeng.com/#README\" target=\"_blank\" rel=\"external\">ES6语法</a></p>\n<p>另外，这套教程的代码都在我的github上，读者可以对照着代码来看，不过还是希望大家自己亲手搭建，体验这个过程，git地址：</p>\n<p><a href=\"https://github.com/HcySunYang/h5_frame\" target=\"_blank\" rel=\"external\">git地址</a></p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在对着产品高举中指怒发心中之愤后，真正能够解决问题的是自身上的改变，有句话说的好：你虽然改变不了全世界，但是你有机会改变你自己。秉承着“不听老人言，吃亏在眼前”的优良作风，我还是决定玩火自焚。</p>\n<h3 id=\"问题所在\"><a href=\"#问题所在\" class=\"headerlink\" title=\"问题所在\"></a>问题所在</h3><p>之前的项目总结为以下内容：</p>\n<blockquote>\n<p>1、AMD模块规范开发，使用requirejs实现，使用rjs打包，最终导致的结果是，输出的项目臃肿，肿的就像一坨狗不理……不忍直视<br>2、使用gulp进行打包，这一点貌似没有可吐槽的地方，毕竟都是被grunt折磨过来的……<br>3、数据的渲染使用模板引擎，这就意味着你要手动管理DOM，这样，你的业务代码参杂着你的数据处理、DOM管理，满屏幕的毛线……<br>4、模块化不足，虽然使用require进行了模块管理，但是大部分业务逻辑还是充斥在一个文件里，这与最近流行的组件化概念冰火不容，拒绝落后……<br>5、诸如 扩展性 、 维护性 我想早已不言而喻，不需赘述，再述就真TM是累赘了。</p>\n</blockquote>\n<p>新框架要解决的问题：</p>\n<blockquote>\n<p>1、要使构建输出的项目像你邻家小妹妹一样、瘦的皮包骨。（也许是营养不良）<br>2、要实现真正的模块化、组件化的开发方式，真正去解决维护难、扩展难的问题。（从此不怕产品汪）<br>3、业务逻辑专注数据处理，手动管理DOM的年代就像……像什么呢？（毕竟成人用品也越来越自动化了）<br>4、等等…….（其实好处无需赘述，来，往下看）</p>\n</blockquote>\n<p>为了达成以上目标，我们探讨一下解决方案：</p>\n<p><em><b>1、老项目的构建输出为什么臃肿？</b></em></p>\n<p>答：因为使用的是require的rjs进行构建打包的，了解rjs的都知道，它会把项目所有依赖都打包在一个文件里，如果项目中有很多页面依赖这个模块，那么rjs并不会把这个模块提取出来作为公共模块，所以就会有很多复制性的内容，所以项目自然臃肿。</p>\n<p><em>解决方案：</em>使用webpack配合相应的loader，来完成模块加载和构建的工作。</p>\n<p><em><b>2、老项目为什么模块化的不足？</b></em></p>\n<p>答：老项目的模块化，仅仅体现在js层面，解决了模块引用的问题，但在开发方式上，依然可以看做是过程式的，这样的结果就导致了项目的难扩展和难维护，让开发人员在与产品汪的对峙中，并不从容。</p>\n<p><em>解决方案：</em>Vue.js能够很好的解决组件化的问题，配合 Vue.js 官方提供的 <em>vue-loader</em> 能够很好的结合webpack做组件化的开发架构。</p>\n<p><em><b>3、如何避免手动管理DOM？</b></em></p>\n<p>答：如果你在做数据展示这一块的开发工作，相信你一定体会颇深，发送http请求到服务端，拿到返回的数据后手动渲染DOM至页面，这是最原始的开发方式，无非再加一个模板引擎之类的，但最终还是避免不了手动渲染，如果页面逻辑复杂，比如给你来一个翻页的功能，再来一个筛选项，估计你会觉得世界并不那么美好。</p>\n<p><em>解决方案：</em>MVVM模式能够很好的解决这个问题，而Vue.js的核心也是MVVM。</p>\n<h1 id=\"webpack\"><a href=\"#webpack\" class=\"headerlink\" title=\"webpack\"></a>webpack</h1><p>你肯定听说过webpack，如果直接对你描述什么是webpack你可能感受不到他的好处，那么在这之前，我相信你肯定使用过gulp或者grunt，如果你没使用过也可以，至少你要听说过并且知道gulp和grunt是干什么的，假如这个你还不清楚，那么你并不是一个合格的前端开发人员，这篇文章也不适合你，你可以从基础的地方慢慢学起。</p>\n<p>gulp和grunt对于每一个前端开发人员应该是不陌生的，它们为前端提供了自动化构建的能力，并且有自己的生态圈，有很多插件，使得我们告别刀耕火种的时代，但是它们并没有解决模块加载的问题，比如我们之前的项目是使用gulp构建的，但是模块化得工作还是要靠require和rjs来完成，而gulp除了完成一些其他任务之外，就变成了帮助我们免除手动执行命令的工具了，别无它用。</p>\n<p>而webpack就不同了，webpack的哲学是一切皆是模块，无论是js/css/sass/img/coffeejs/ttf….等等，webpack可以使用自定义的loader去把一切资源当做模块加载，这样就解决了模块依赖的问题，同时，利用插件还可以对项目进行优化，由于模块的加载和项目的构建优化都是通过webpack一个”人“来解决的，所以模块的加载和项目的构建优化并不是无机分离的，而是有机的结合在一起的，是一个组合的过程，这使得webpack在这方面能够完成的更出色，这也是webpack的优势所在。</p>\n<p>如果你看不懂上面的描述，没关系，你只需要知道一下几点：</p>\n<p>1、过去使用require和rjs等进行模块加载的方式，可以替换为webpack提供的指定loader去完成，你也可以自己开发加载特定资源的loader。<br>2、过去使用gulp和grunt完成项目构建优化的方式，可以替换成webpack提供的插件和特定的配置去完成。<br>3、由于模块的加载和项目的构建优化有机的结合，所以webpack能够更好的完成这项工作<br>4、并不是说有了webpack就淘汰的gulp等，有些特定的任务，还是要使用gulp去自定义完成的。但是不保证webpack的未来发展趋势会怎么样。</p>\n<p>最后，给大家分享一个官方的教程，这个教程的最开始有坑的地方，如果读者遇到了坑，可以在这里给我留言，我会为大家解答，不过总体来讲，这个教程适合入门，唯一不足的就是教程是英文的，英文的也不用怕，本人的英语没过四级，但是现在依然能够看得懂英文技术文章。教程链接：<a href=\"http://blog.madewithlove.be/post/webpack-your-bags/\" target=\"_blank\" rel=\"external\">http://blog.madewithlove.be/post/webpack-your-bags/</a></p>\n<h1 id=\"Vue-js\"><a href=\"#Vue-js\" class=\"headerlink\" title=\"Vue.js\"></a>Vue.js</h1><p><a href=\"http://cn.vuejs.org/\" target=\"_blank\" rel=\"external\">Vue.js</a>是一个MVVM模式的框架，如果读者有angular经验，一定能够很快入门Vue的，那么问题来了，为什么使用Vue而不用angular，<br>首先，Vue的体积小，轻量在移动端开发始终是一个不可忽略的话题，其次，Vue在实现上与angular有本质的区别，读者可以通过下面两个链接来了解：</p>\n<p>1、<a href=\"http://cn.vuejs.org/guide/reactivity.html\" target=\"_blank\" rel=\"external\">Vue的变化追踪和计算属性的区别等</a></p>\n<p>2、<a href=\"http://cn.vuejs.org/guide/comparison.html\" target=\"_blank\" rel=\"external\">Vue 与 angular 及 react 等框架的对比</a></p>\n<p>3、第三点就是Vue提供了webpack的loader —-&gt; [vue-loader]，使用它可以让项目的组件化思想更加清晰</p>\n<p>综上所述，这就是选用Vue的原因</p>\n<h1 id=\"npm-和-nodejs\"><a href=\"#npm-和-nodejs\" class=\"headerlink\" title=\"npm 和 nodejs\"></a>npm 和 nodejs</h1><p>npm 的全称是 <em>nodejs包管理</em>，现在越来越多的项目(包)都可以通过npm来安装管理，nodejs是js运行在服务器端的平台，它使得js的能力进一步提高，我们还要使用nodejs配合 webpack 来完成热加载的功能。所以读者最好有nodejs的开发经验，如果有express的经验更好。</p>\n<h1 id=\"让我们一步一步从零搭建这个项目\"><a href=\"#让我们一步一步从零搭建这个项目\" class=\"headerlink\" title=\"让我们一步一步从零搭建这个项目\"></a>让我们一步一步从零搭建这个项目</h1><p>首先新建一个目录，名为 myProject ，这是我们的项目目录。然后执行一些基本的步骤，比如 npm init 命令，在我们的项目中生成 package.json 文件，这几乎是必选的，因为我们的项目要有很多依赖，都是通过npm来管理的，而npm对于我们项目的管理，则是通过package.json文件：</p>\n<pre><code class=\"$\">npm init\n</code></pre>\n<p>执行npm init之后，会提示你填写一些项目的信息，一直回车默认就好了，或者直接执行 npm init -y 直接跳过询问步骤<br>然后我们新建一个叫做 app 的目录，这个是我们页面模块的目录，再在app目录下建立一个index目录，假设这个是首页模块的目录，然后再在index目录下建立一个 index.html 文件和 index.js 文件，分别是首页入口html文件和主js文件，然后再在index目录下建立一个components目录，这个目录用作存放首页组件模块的目录，因为我们最终要实现组件化开发。这样，当你完成上面的步骤后，你的项目看上去应该是这样的：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20160325b.jpg\" alt=\"项目结构\"></p>\n<p>接下来通过npm安装项目依赖项：</p>\n<pre><code class=\"$\">npm install\\\n  webpack webpack-dev-server\\\n  vue-loader vue-html-loader css-loader vue-style-loader vue-hot-reload-api\\\n  babel-loader babel-core babel-plugin-transform-runtime babel-preset-es2015\\\n  babel-runtime@5\\\n  --save-dev\n\nnpm install vue --save\n</code></pre>\n<p>这个时候，你的package.json文件看起来应该是这样的：</p>\n<pre><code>&quot;devDependencies&quot;: {\n    &quot;babel-core&quot;: &quot;^6.3.17&quot;,\n    &quot;babel-loader&quot;: &quot;^6.2.0&quot;,\n    &quot;babel-plugin-transform-runtime&quot;: &quot;^6.3.13&quot;,\n    &quot;babel-preset-es2015&quot;: &quot;^6.3.13&quot;,\n    &quot;babel-runtime&quot;: &quot;^5.8.34&quot;,\n    &quot;css-loader&quot;: &quot;^0.23.0&quot;,\n    &quot;vue-hot-reload-api&quot;: &quot;^1.2.2&quot;,\n    &quot;vue-html-loader&quot;: &quot;^1.0.0&quot;,\n    &quot;vue-style-loader&quot;: &quot;^1.0.0&quot;,\n    &quot;vue-loader&quot;: &quot;^7.2.0&quot;,\n    &quot;webpack&quot;: &quot;^1.12.9&quot;,\n    &quot;webpack-dev-server&quot;: &quot;^1.14.0&quot;\n  },\n  &quot;dependencies&quot;: {\n    &quot;vue&quot;: &quot;^1.0.13&quot;\n  },\n</code></pre><p>我们安装了 babel 一系列包，用来解析ES6语法，因为我们使用ES6来开发项目，如果你不了解ES6语法，建议你看一看<a href=\"http://es6.ruanyifeng.com/\" target=\"_blank\" rel=\"external\">阮老师的教程</a>，然后我们安装了一些loader包，比如css-loader/vue-loader等等，因为webpack是使用这些指定的loader去加载指定的文件的。</p>\n<p>另外我们还使用 npm install vue –save 命令安装了 vue ，这个就是我们要在项目中使用的vue.js，我们可以直接像开发nodejs应用一样，直接require(‘vue’);即可，而不需要通过script标签引入，这一点在开发中很爽。</p>\n<p>安装完了依赖，编辑以下文件并保存到相应位置：</p>\n<p>1、index.html文件：</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;zh&quot;&gt;\n    &lt;head&gt;\n        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, height=device-height, initial-scale=1.0, user-scalable=no&quot;&gt;\n        &lt;meta charset=&quot;utf-8&quot;&gt;\n        &lt;title&gt;首页&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;!-- vue的组件以自定义标签的形式使用 --&gt;\n        &lt;favlist&gt;&lt;/favlist&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>2、index.js文件：</p>\n<pre><code>import Vue from &#39;Vue&#39;\nimport Favlist from &#39;./components/Favlist&#39;\n\nnew Vue({\n    el: &#39;body&#39;,\n    components: { Favlist }\n})\n</code></pre><p>3、在components目录下新建一个 Favlist.vue 文件，作为我们的第一个组件：</p>\n<pre><code>&lt;template&gt;\n    &lt;div v-for=&quot;n in 10&quot;&gt;div&lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n    export default {\n        data () {\n            return {\n                msg: &#39;Hello World!&#39;\n            }\n        }\n    }\n&lt;/script&gt;\n\n&lt;style&gt;\n    html{\n        background: red;\n    }\n&lt;/style&gt;\n</code></pre><p>要看懂上面的代码，你需要了解vue.js，假如你看不懂也没关系，我们首先在index.html中使用了自定义标签（即组件），然后在index.js中引入了Vue和我们的Favlist.vue组件，Favlist.vue文件中，我们使用了基本的vue组件语法，最后，我们希望它运行起来，这个时候，我们就需要webpack了。</p>\n<p>在项目目录下新建 build 目录，用来存放我们的构建相关的代码文件等，然后在build目录下新建 webpack.config.js 这是我们的webpack配置文件，webpack需要通过读取你的配置，进行相应的操作，类似于gulpfile.js或者gruntfile.js等。</p>\n<p>webpack.config.js</p>\n<pre><code>// nodejs 中的path模块\nvar path = require(&#39;path&#39;);\n\nmodule.exports = {\n    // 入口文件，path.resolve()方法，可以结合我们给定的两个参数最后生成绝对路径，最终指向的就是我们的index.js文件\n    entry: path.resolve(__dirname, &#39;../app/index/index.js&#39;),\n    // 输出配置\n    output: {\n        // 输出路径是 myProject/output/static\n        path: path.resolve(__dirname, &#39;../output/static&#39;),\n        publicPath: &#39;static/&#39;,\n        filename: &#39;[name].[hash].js&#39;,\n        chunkFilename: &#39;[id].[chunkhash].js&#39;\n    },\n    module: {\n\n        loaders: [\n            // 使用vue-loader 加载 .vue 结尾的文件\n            {\n                test: /\\.vue$/, \n                loader: &#39;vue&#39;   \n            }\n        ]\n    }\n}\n</code></pre><p>上例中，相信你已经看懂了我的配置，入口文件是index.js文件，配置了相应输出，然后使用 vue-loader 去加载 .vue 结尾的文件，接下来我们就可以构建项目了，我们可以在命令行中执行：</p>\n<pre><code>webpack --display-modules --display-chunks --config build/webpack.config.js\n</code></pre><p>通过webpack命令，并且通过 –config 选项指定了我们配置文件的位置是 ‘build/webpack.config.js’，并通过 –display-modules 和 –display-chunks 选项显示相应的信息。如果你执行上面的命令，可能得到下图的错误：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20160325c.jpg\" alt=\"报错\"></p>\n<p>错误提示我们应该选择合适的loader去加载这个 ‘./app/index/index.js’ 这个文件，并且说不期望index.js文件中的标识符（Unexpected token），这是因为我们使用了ES6的语法 import 语句，所以我们要使用 babel-loader 去加载我们的js文件，在配置文件中添加一个loaders项目，如下：</p>\n<pre><code>// nodejs 中的path模块\nvar path = require(&#39;path&#39;);\n\nmodule.exports = {\n    // 入口文件，path.resolve()方法，可以结合我们给定的两个参数最后生成绝对路径，最终指向的就是我们的index.js文件\n    entry: path.resolve(__dirname, &#39;../app/index/index.js&#39;),\n    // 输出配置\n    output: {\n        // 输出路径是 myProject/output/static\n        path: path.resolve(__dirname, &#39;../output/static&#39;),\n        publicPath: &#39;static/&#39;,\n        filename: &#39;[name].[hash].js&#39;,\n        chunkFilename: &#39;[id].[chunkhash].js&#39;\n    },\n    module: {\n\n        loaders: [\n            // 使用vue-loader 加载 .vue 结尾的文件\n            {\n                test: /\\.vue$/, \n                loader: &#39;vue&#39;   \n            },\n            {\n                test: /\\.js$/,\n                loader: &#39;babel?presets=es2015&#39;,\n                exclude: /node_modules/\n            }\n        ]\n    }\n}\n</code></pre><p>现在再运行构建命令 ： ‘webpack –display-modules –display-chunks –config build/webpack.config.js’</p>\n<p>sorry，不出意外，你应该得到如下错误：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20160325d.jpg\" alt=\"错误\"></p>\n<p>它说没有发现 ‘./components/Favlist’ 模块，而我们明明有 ./components/Favlist.vue 文件，为什么它没发现呢？它瞎了？其实是这样的，当webpack试图去加载模块的时候，它默认是查找以 .js 结尾的文件的，它并不知道 .vue 结尾的文件是什么鬼玩意儿，所以我们要在配置文件中告诉webpack，遇到 .vue 结尾的也要去加载，添加 resolve 配置项，如下：</p>\n<pre><code>// nodejs 中的path模块\nvar path = require(&#39;path&#39;);\n\nmodule.exports = {\n    // 入口文件，path.resolve()方法，可以结合我们给定的两个参数最后生成绝对路径，最终指向的就是我们的index.js文件\n    entry: path.resolve(__dirname, &#39;../app/index/index.js&#39;),\n    // 输出配置\n    output: {\n        // 输出路径是 myProject/output/static\n        path: path.resolve(__dirname, &#39;../output/static&#39;),\n        publicPath: &#39;static/&#39;,\n        filename: &#39;[name].[hash].js&#39;,\n        chunkFilename: &#39;[id].[chunkhash].js&#39;\n    },\n    resolve: {\n        extensions: [&#39;&#39;, &#39;.js&#39;, &#39;.vue&#39;]\n    },\n    module: {\n\n        loaders: [\n            // 使用vue-loader 加载 .vue 结尾的文件\n            {\n                test: /\\.vue$/, \n                loader: &#39;vue&#39;   \n            },\n            {\n                test: /\\.js$/,\n                loader: &#39;babel?presets=es2015&#39;,\n                exclude: /node_modules/\n            }\n        ]\n    }\n}\n</code></pre><p>这样，当我们去加载 ‘./components/Favlist’ 这样的模块时，webpack首先会查找 ./components/Favlist.js 如果没有发现Favlist.js文件就会继续查找 Favlist.vue 文件，现在再次运行构建命令，我们成功了，这时我们会在我们的输出目录中看到一个js文件：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20160325e.jpg\" alt=\"输出\"></p>\n<p>之所以会这样输出，是因为我们的 webpack.config.js 文件中的输出配置中指定了相应的输出信息，这个时候，我们修改 index.html ，将输出的js文件引入：</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;zh&quot;&gt;\n    &lt;head&gt;\n        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, height=device-height, initial-scale=1.0, user-scalable=no&quot;&gt;\n        &lt;meta charset=&quot;utf-8&quot;&gt;\n        &lt;title&gt;首页&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;!-- vue的组件以自定义标签的形式使用 --&gt;\n        &lt;favlist&gt;&lt;/favlist&gt;\n\n        &lt;script src=&quot;../../output/static/main.ce853b65bcffc3b16328.js&quot;&gt;&lt;/script&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>然后用浏览器打开这个页面，你可以看到你写的代码正确的执行了。</p>\n<p>那么问题来了，难道我们每次都要手动的引入输出的js文件吗？因为每次构建输出的js文件都带有 hash 值，如 main.ce853b65bcffc3b16328.js，就不能更智能一点吗？每次都自动写入？怎么会不可能，否则这东西还能火吗，要实现这个功能，我们就要使用webpack的插件了，<a href=\"https://www.npmjs.com/package/html-webpack-plugin\" target=\"_blank\" rel=\"external\">html-webpack-plugin</a>插件，这个插件可以创建html文件，并自动将依赖写入html文件中。</p>\n<p>首先安装 html-webpack-plugin 插件：</p>\n<pre><code>npm install html-webpack-plugin --save-dev\n</code></pre><p>然后在修改配置项：</p>\n<pre><code>// nodejs 中的path模块\nvar path = require(&#39;path&#39;);\nvar HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)\n\nmodule.exports = {\n    // 入口文件，path.resolve()方法，可以结合我们给定的两个参数最后生成绝对路径，最终指向的就是我们的index.js文件\n    entry: path.resolve(__dirname, &#39;../app/index/index.js&#39;),\n    // 输出配置\n    output: {\n        // 输出路径是 myProject/output/static\n        path: path.resolve(__dirname, &#39;../output/static&#39;),\n        publicPath: &#39;static/&#39;,\n        filename: &#39;[name].[hash].js&#39;,\n        chunkFilename: &#39;[id].[chunkhash].js&#39;\n    },\n    resolve: {\n        extensions: [&#39;&#39;, &#39;.js&#39;, &#39;.vue&#39;]\n    },\n    module: {\n\n        loaders: [\n            // 使用vue-loader 加载 .vue 结尾的文件\n            {\n                test: /\\.vue$/, \n                loader: &#39;vue&#39;   \n            },\n            {\n                test: /\\.js$/,\n                loader: &#39;babel?presets=es2015&#39;,\n                exclude: /node_modules/\n            }\n        ]\n    },\n    plugins: [\n        new HtmlWebpackPlugin({\n            filename: &#39;../index.html&#39;,\n            template: path.resolve(__dirname, &#39;../app/index/index.html&#39;),\n            inject: true\n        })\n    ]\n}\n</code></pre><p>然后再次执行构建命令，成功之后，看你的输出目录，多出来一个index.html文件，双击它，代码正确执行，你可以打开这个文件查看一下，webpack自动帮我们引入了相应的文件。</p>\n<p>问题继续来了，难道每次我们都要构建之后才能查看运行的代码吗？那岂不是很没有效率，别担心，webpack提供了几种方式，进行热加载，在开发模式中，我们使用这种方式来提高效率，这里要介绍的，是使用 <a href=\"https://www.npmjs.com/package/webpack-dev-middleware\" target=\"_blank\" rel=\"external\">webpack-dev-middleware</a>中间件和<a href=\"https://www.npmjs.com/package/webpack-hot-middleware\" target=\"_blank\" rel=\"external\">webpack-hot-middleware</a>中间件，首先安装两个中间件：</p>\n<pre><code>npm install webpack-dev-middleware webpack-hot-middleware --save-dev\n</code></pre><p>另外，还要安装express，这是一个nodejs框架</p>\n<pre><code>npm install express --save-dev\n</code></pre><p>在开始之前，我先简单介绍一下这两个中间件，之所以叫做中间件，是因为nodejs的一个叫做express的框架中有中间件的概念，而这两个包要作为express中间件使用，所以称它们为中间件，那么他们能干什么呢？</p>\n<p><em><b>1、webpack-dev-middleware</b></em></p>\n<p>我们之前所面临的问题是，如果我们的代码改动了，我们要想看到浏览器的变化，需要先对项目进行构建，然后才能查看效果，这样对于开发效率来讲，简直就是不可忍受的一件事，试想我仅仅修改一个背景颜色就要构建一下项目，这尼玛坑爹啊，好在有<a href=\"https://www.npmjs.com/package/webpack-dev-middleware\" target=\"_blank\" rel=\"external\">webpack-dev-middleware</a>中间件，它是对webpack一个简单的包装，它可以通过连接服务器服务那些从webpack发射出来的文件，它有一下几点好处：</p>\n<p>1、不会向硬盘写文件，而是在内存中，注意我们构建项目实际就是向硬盘写文件。</p>\n<p>2、当文件改变的时候，这个中间件不会再服务旧的包，你可以直接帅新浏览器就能看到最新的效果，这样你就不必等待构建的时间，所见即所得。</p>\n<p>下面我们在build目录中创建一个 dev-server.js 的文件，并写入一下内容：</p>\n<pre><code>// 引入必要的模块\nvar express = require(&#39;express&#39;)\nvar webpack = require(&#39;webpack&#39;)\nvar config = require(&#39;./webpack.config&#39;)\n\n// 创建一个express实例\nvar app = express()\n\n// 调用webpack并把配置传递过去\nvar compiler = webpack(config)\n\n// 使用 webpack-dev-middleware 中间件\nvar devMiddleware = require(&#39;webpack-dev-middleware&#39;)(compiler, {\n    publicPath: config.output.publicPath,\n    stats: {\n        colors: true,\n        chunks: false\n    }\n})\n\n// 注册中间件\napp.use(devMiddleware)\n\n// 监听 8888端口，开启服务器\napp.listen(8888, function (err) {\n    if (err) {\n        console.log(err)\n        return\n    }\n    console.log(&#39;Listening at http://localhost:8888&#39;)\n})\n</code></pre><p>此时，我们在项目根目录运行下面的命令，开启服务：</p>\n<pre><code>node build/dev-server.js\n</code></pre><p>如果看到下图所示，证明你的服务成功开启了：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20160325f.jpg\" alt=\"开启服务成功\"></p>\n<p>接下来打开浏览器，输入：</p>\n<pre><code>http://localhost:8888/app/index/index.html\n</code></pre><p>回车，如果不出意外，你应该得到一个404，如下图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20160325g.jpg\" alt=\"404\"></p>\n<p>我们要对我们的 webpack.config.js 配置文件做两处修改：</p>\n<p>1、将 config.output.publicPath 修改为 ‘/‘：</p>\n<pre><code>output: {\n    // 输出路径是 myProject/output/static\n    path: path.resolve(__dirname, &#39;../output/static&#39;),\n    publicPath: &#39;/&#39;,\n    filename: &#39;[name].[hash].js&#39;,\n    chunkFilename: &#39;[id].[chunkhash].js&#39;\n},\n</code></pre><p>2、将 plugins 中 HtmlWebpackPlugin 中的 filename 修改为 ‘app/index/index.html’</p>\n<pre><code>plugins: [\n    new HtmlWebpackPlugin({\n        filename: &#39;app/index/index.html&#39;,\n        template: path.resolve(__dirname, &#39;../app/index/index.html&#39;),\n        inject: true\n    })\n]\n</code></pre><p>重启服务，再刷新页面，如果看到如下界面，证明你成功了：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20160325h.jpg\" alt=\"成功\"></p>\n<p>但是这样开发模式下的确是成功了，可是我们直接修改了 webpack.config.js 文件，这就意味着当我们执行 构建命令 的时候，配置变了，那么我们的构建也跟着变了，所以，一个好的方式是，不去修改webpack.config.js文件，我们在build目录下新建一个 webpack.dev.conf.js文件，意思是开发模式下要读取的配置文件，并写入一下内容：</p>\n<pre><code>var HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)\nvar path = require(&#39;path&#39;);\n// 引入基本配置\nvar config = require(&#39;./webpack.config&#39;);\n\nconfig.output.publicPath = &#39;/&#39;;\n\nconfig.plugins = [\n    new HtmlWebpackPlugin({\n        filename: &#39;app/index/index.html&#39;,\n        template: path.resolve(__dirname, &#39;../app/index/index.html&#39;),\n        inject: true\n    })\n];\n\nmodule.exports = config;\n</code></pre><p>这样，我们在dev环境下的配置文件中覆盖了基本配置文件，我们只需要在dev-server.js中将 </p>\n<pre><code>var config = require(&#39;./webpack.config&#39;)\n</code></pre><p>修改为：</p>\n<pre><code>var config = require(&#39;./webpack.dev.conf&#39;)\n</code></pre><p>即可，然后，重启服务，刷新浏览器，你应该得到同样的成功结果，而这一次当我们执行构建命令：</p>\n<pre><code>webpack --display-modules --display-chunks --config build/webpack.config.js\n</code></pre><p>并不会影响构建输出，因为我们没有直接修改webpack.config.js文件。</p>\n<p>现在我们已经使用 webpack-dev-middleware 搭建基本的开发环境了，但是我们并不满足，因为我们每次都要手动去刷新浏览器，所谓的热加载，意思就是说能够追踪我们代码的变化，并自动更新界面，甚至还能保留程序状态。要完成热加载，我们就需要使用另外一个中间件 <em>webpack-hot-middleware</em></p>\n<p><em><b>2、webpack-hot-middleware</b></em></p>\n<p><a href=\"https://www.npmjs.com/package/webpack-hot-middleware\" target=\"_blank\" rel=\"external\">webpack-hot-middleware</a> 只配合 webpack-dev-middleware 使用，它能给你提供热加载。</p>\n<p>它的使用很简单，总共分4步：</p>\n<p>1、安装，我们上面已经安装过了<br>2、在 webpack.dev.conf.js 配置文件中添加三个插件，如下：</p>\n<pre><code>\nvar HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)\nvar path = require(&#39;path&#39;);\nvar webpack = require(&#39;webpack&#39;);\n// 引入基本配置\nvar config = require(&#39;./webpack.config&#39;);\n\nconfig.output.publicPath = &#39;/&#39;;\n\nconfig.plugins = [\n    // 添加三个插件\n    new webpack.optimize.OccurenceOrderPlugin(),\n    new webpack.HotModuleReplacementPlugin(),\n    new webpack.NoErrorsPlugin(),\n\n    new HtmlWebpackPlugin({\n        filename: &#39;app/index/index.html&#39;,\n        template: path.resolve(__dirname, &#39;../app/index/index.html&#39;),\n        inject: true\n    })\n];\n\nmodule.exports = config;\n</code></pre><p>3、在 webpack.config.js 文件中入口配置中添加 ‘webpack-hot-middleware/client’，如下：</p>\n<pre><code>entry: [&#39;webpack-hot-middleware/client&#39;, path.resolve(__dirname, &#39;../app/index/index.js&#39;)],\n</code></pre><p>4、在 dev-server.js 文件中使用插件</p>\n<pre><code>// 引入必要的模块\nvar express = require(&#39;express&#39;)\nvar webpack = require(&#39;webpack&#39;)\nvar config = require(&#39;./webpack.dev.conf&#39;)\n\n// 创建一个express实例\nvar app = express()\n\n// 调用webpack并把配置传递过去\nvar compiler = webpack(config)\n\n// 使用 webpack-dev-middleware 中间件\nvar devMiddleware = require(&#39;webpack-dev-middleware&#39;)(compiler, {\n    publicPath: config.output.publicPath,\n    stats: {\n        colors: true,\n        chunks: false\n    }\n})\n\n// 使用 webpack-hot-middleware 中间件\nvar hotMiddleware = require(&#39;webpack-hot-middleware&#39;)(compiler)\n\n// 注册中间件\napp.use(devMiddleware)\n// 注册中间件\napp.use(hotMiddleware)\n\n// 监听 8888端口，开启服务器\napp.listen(8888, function (err) {\n    if (err) {\n        console.log(err)\n        return\n    }\n    console.log(&#39;Listening at http://localhost:8888&#39;)\n})\n</code></pre><p>ok，现在重启的服务，然后修改 Favlist.vue 中的页面背景颜色为 ‘#000’：</p>\n<pre><code>&lt;style&gt;\n    html{\n        background: #000;\n    }\n&lt;/style&gt;\n</code></pre><p>然后查看你的浏览器，是不是你还没有刷新就已经得带改变了？</p>\n<p>那么这样就完美了吗？还没有，如果你细心，你会注意到，我们上面在第2步中修改了 webpack.config.js 这个基本配置文件，修改了入口配置，如下：</p>\n<pre><code>entry: [&#39;webpack-hot-middleware/client&#39;, path.resolve(__dirname, &#39;../app/index/index.js&#39;)],\n</code></pre><p>这也会导致我们之前讨论过的问题，就是会影响构建，所以我们不要直接修改 webpack.config.js 文件，我们还是在 webpack.dev.conf.js 文件中配置，如下：</p>\n<pre><code>\nvar HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)\nvar path = require(&#39;path&#39;);\nvar webpack = require(&#39;webpack&#39;);\n// 引入基本配置\nvar config = require(&#39;./webpack.config&#39;);\n\nconfig.output.publicPath = &#39;/&#39;;\n\nconfig.plugins = [\n    new webpack.optimize.OccurenceOrderPlugin(),\n    new webpack.HotModuleReplacementPlugin(),\n    new webpack.NoErrorsPlugin(),\n    new HtmlWebpackPlugin({\n        filename: &#39;app/index/index.html&#39;,\n        template: path.resolve(__dirname, &#39;../app/index/index.html&#39;),\n        inject: true\n    })\n];\n\n// 动态向入口配置中注入 webpack-hot-middleware/client\nvar devClient = &#39;webpack-hot-middleware/client&#39;;\nObject.keys(config.entry).forEach(function (name, i) {\n    var extras = [devClient]\n    config.entry[name] = extras.concat(config.entry[name])\n})\n\nmodule.exports = config;\n</code></pre><p>但是我们还是要讲 webpack.config.js 文件中的入口配置修改为多入口配置的方式，这个修改不会影响构建，所以无所谓：</p>\n<pre><code>entry: {\n    index: path.resolve(__dirname, &#39;../app/index/index.js&#39;)\n},\n</code></pre><p>重启你的服务，刷新一下浏览器，然后修改 Favlist.vue 中的背景色为 green：</p>\n<pre><code>&lt;style&gt;\n    html{\n        background: green;\n    }\n&lt;/style&gt;\n</code></pre><p>再次查看浏览器，发现可以热加载。但是这样就结束了吗？还没有，不信你修改 index.html 文件，看看会不会热加载，实际上不会，你还是需要手动刷新页面，为了能够当 index.html 文件的改动也能够触发自动刷新，我们还需要做一些工作。</p>\n<p><em><b>第一步：在 dev-server.js 文件中监听html文件改变事件，修改后的 dev-server.js 文件如下：</b></em></p>\n<pre><code>// 引入必要的模块\nvar express = require(&#39;express&#39;)\nvar webpack = require(&#39;webpack&#39;)\nvar config = require(&#39;./webpack.dev.conf&#39;)\n\n// 创建一个express实例\nvar app = express()\n\n// 调用webpack并把配置传递过去\nvar compiler = webpack(config)\n\n// 使用 webpack-dev-middleware 中间件\nvar devMiddleware = require(&#39;webpack-dev-middleware&#39;)(compiler, {\n    publicPath: config.output.publicPath,\n    stats: {\n        colors: true,\n        chunks: false\n    }\n})\n\nvar hotMiddleware = require(&#39;webpack-hot-middleware&#39;)(compiler)\n\n// webpack插件，监听html文件改变事件\ncompiler.plugin(&#39;compilation&#39;, function (compilation) {\n    compilation.plugin(&#39;html-webpack-plugin-after-emit&#39;, function (data, cb) {\n        // 发布事件\n        hotMiddleware.publish({ action: &#39;reload&#39; })\n        cb()\n    })\n})\n\n// 注册中间件\napp.use(devMiddleware)\n// 注册中间件\napp.use(hotMiddleware)\n\n// 监听 8888端口，开启服务器\napp.listen(8888, function (err) {\n    if (err) {\n        console.log(err)\n        return\n    }\n    console.log(&#39;Listening at http://localhost:8888&#39;)\n})\n</code></pre><p>从上面的代码中可以看到，我们增加了如下代码：</p>\n<pre><code>// webpack插件，监听html文件改变事件\ncompiler.plugin(&#39;compilation&#39;, function (compilation) {\n    compilation.plugin(&#39;html-webpack-plugin-after-emit&#39;, function (data, cb) {\n        // 发布事件\n        hotMiddleware.publish({ action: &#39;reload&#39; })\n        cb()\n    })\n})\n</code></pre><p>这段代码可能你看不懂，因为这涉及到webpack插件的编写，读者可以参阅下面的连接：</p>\n<p><a href=\"https://github.com/webpack/docs/wiki/plugins\" target=\"_blank\" rel=\"external\">webpack 插件doc1</a></p>\n<p><a href=\"https://github.com/webpack/docs/wiki/How-to-write-a-plugin\" target=\"_blank\" rel=\"external\">webpack 插件doc2</a></p>\n<p>在这段代码中，我们监听了 ‘html-webpack-plugin-after-emit’ 事件，那么这个事件是从哪里发射的呢？我们通过名字可知，这个事件应该和html-webpack-plugin这个插件有关，在npm搜索 <a href=\"https://www.npmjs.com/package/html-webpack-plugin\" target=\"_blank\" rel=\"external\">html-webpack-plugin</a> 插件，在页面最底部我们可以发现如下图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20160325i.jpg\" alt=\"html-webpack-plugin可以发射事件\"></p>\n<p>我们可以看到，html-webpack-plugin 这个插件的确提供了几个可选的事件，下面也提供了使用方法，这样，我们就能够监听到html文件的变化，然后我们使用下面的代码发布一个事件：</p>\n<pre><code>hotMiddleware.publish({ action: &#39;reload&#39; })\n</code></pre><p><em><b>第二步：修改 webpack.dev.conf.js 文件如下：</b></em></p>\n<pre><code>\nvar HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)\nvar path = require(&#39;path&#39;);\nvar webpack = require(&#39;webpack&#39;);\n// 引入基本配置\nvar config = require(&#39;./webpack.config&#39;);\n\nconfig.output.publicPath = &#39;/&#39;;\n\nconfig.plugins = [\n    new webpack.optimize.OccurenceOrderPlugin(),\n    new webpack.HotModuleReplacementPlugin(),\n    new webpack.NoErrorsPlugin(),\n    new HtmlWebpackPlugin({\n        filename: &#39;app/index/index.html&#39;,\n        template: path.resolve(__dirname, &#39;../app/index/index.html&#39;),\n        inject: true\n    })\n];\n\n// var devClient = &#39;webpack-hot-middleware/client&#39;;\nvar devClient = &#39;./build/dev-client&#39;;\nObject.keys(config.entry).forEach(function (name, i) {\n    var extras = [devClient]\n    config.entry[name] = extras.concat(config.entry[name])\n})\n\nmodule.exports = config;\n</code></pre><p>我们修改了devClient变量，将 ‘webpack-hot-middleware/client’ 替换成 ‘./build/dev-client’，最终会导致，我们入口配置会变成下面这样：</p>\n<pre><code>entry: {\n    index: [\n        &#39;./build/dev-client&#39;,\n        path.resolve(__dirname, &#39;../app/index/index.js&#39;)\n    ]\n},\n</code></pre><p><em><b>第三步：新建 build/dev-client.js 文件，并编辑如下内容：</b></em></p>\n<pre><code>var hotClient = require(&#39;webpack-hot-middleware/client&#39;)\n\n// 订阅事件，当 event.action === &#39;reload&#39; 时执行页面刷新\nhotClient.subscribe(function (event) {\n    if (event.action === &#39;reload&#39;) {\n        window.location.reload()\n    }\n})\n</code></pre><p>这里我们除了引入 ‘webpack-hot-middleware/client’ 之外订阅了一个事件，当 event.action === ‘reload’ 时触发，还记得我们在 dev-server.js 中发布的事件吗：</p>\n<pre><code>hotMiddleware.publish({ action: &#39;reload&#39; })\n</code></pre><p>这样，当我们的html文件改变后，就可以监听的到，最终会执行页面刷新，而不需要我们手动刷新，现在重启服务，去尝试能否对html文件热加载吧。答案是yes。<br>好了，开发环境终于搞定了，下面我们再来谈一谈生产环境，也就是构建输出，我们现在可以执行一下构建命令，看看输出的内容是什么，为了不必每次都要输入下面这条长命令：</p>\n<pre><code>webpack --display-modules --display-chunks --config build/webpack.config.js\n</code></pre><p>我们在 package.js 文件中添加 “scripts” 项，如下图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20160325m.jpg\" alt=\"npm\"></p>\n<p>这样，我们就可以通过执行下面命令来进行构建，同时我们还增加了一条开启开发服务器的命令：</p>\n<pre><code>// 构建\nnpm run build\n// 开启开发服务器\nnpm run dev\n</code></pre><p>回过头来，我们执行构建命令： npm run build，查看输出内容，如下图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20160325n.jpg\" alt=\"输出内容\"></p>\n<p>现在我们只有一个js文件输出了，并没有css文件输出，在生产环境，我们希望css文件生成单独的文件，所以我们要使用 extract-text-webpack-plugin 插件，安装：</p>\n<pre><code>npm install extract-text-webpack-plugin --save-dev\n</code></pre><p>然后在build目录下新建 webpack.prod.conf.js 文件，顾名思义，这个使我们区别于开发环境，用于生产环境的配置文件，并编辑一下内容：</p>\n<pre><code>\nvar HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)\nvar ExtractTextPlugin = require(&#39;extract-text-webpack-plugin&#39;)\nvar path = require(&#39;path&#39;);\nvar webpack = require(&#39;webpack&#39;);\n// 引入基本配置\nvar config = require(&#39;./webpack.config&#39;);\n\nconfig.vue = {\n    loaders: {\n        css: ExtractTextPlugin.extract(&quot;css&quot;)\n    }\n};\n\nconfig.plugins = [\n    // 提取css为单文件\n    new ExtractTextPlugin(&quot;../[name].[contenthash].css&quot;),\n\n    new HtmlWebpackPlugin({\n        filename: &#39;../index.html&#39;,\n        template: path.resolve(__dirname, &#39;../app/index/index.html&#39;),\n        inject: true\n    })\n];\n\nmodule.exports = config;\n</code></pre><p>上面的代码中，我们覆盖了 webpack.config.js 配置文件的 config.plugins 项，并且添加了 config.vue 项，补血药知道为什么，就是这么用的，如果一定要知道为什么也可以，这需要你多去了解vue以及vue-loader的工作原理，这里有连接<a href=\"http://vuejs.github.io/vue-loader/configurations/extract-css.html\" target=\"_blank\" rel=\"external\">点击这里</a><br>然后修改 package.json 文件中的 script 项为如下：</p>\n<pre><code>&quot;scripts&quot;: {\n    &quot;build&quot;: &quot;webpack --display-modules --display-chunks --config build/webpack.prod.conf.js&quot;,\n    &quot;dev&quot;: &quot;node ./build/dev-server.js&quot;\n},\n</code></pre><p>我们使用 webpack.prod.conf.js 为配置去构建，接下来执行：</p>\n<pre><code>npm run build\n</code></pre><p>查看你的输出内容，如下图，css文件未提取出来了：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20160325l.jpg\" alt=\"css文件被提取\"></p>\n<p>另外我们还可以添加如下插件在我们的 webpack.prod.conf.js 文件中，作为生产环境使用：</p>\n<pre><code>config.plugins = [\n    new webpack.DefinePlugin({\n        &#39;process.env&#39;: {\n            NODE_ENV: &#39;&quot;production&quot;&#39;\n        }\n    }),\n    // 压缩代码\n    new webpack.optimize.UglifyJsPlugin({\n        compress: {\n            warnings: false\n        }\n    }),\n    new webpack.optimize.OccurenceOrderPlugin(),\n    // 提取css为单文件\n    new ExtractTextPlugin(&quot;../[name].[contenthash].css&quot;),\n    new HtmlWebpackPlugin({\n        filename: &#39;../index.html&#39;,\n        template: path.resolve(__dirname, &#39;../app/index/index.html&#39;),\n        inject: true\n    })\n];\n</code></pre><p>大家可以搜索这些插件，了解他的作用，这篇文章要介绍的太多，所以我一一讲解了。</p>\n<p>到这里实际上搭建的已经差不多了，唯一要做的就是完善，比如公共模块的提取，如何加载图片，对于第一个问题，如何提取公共模块，我们可以使用 CommonsChunkPlugin 插件，在 webpack.prod.conf.js 文件中添加如下插件：</p>\n<pre><code>new webpack.optimize.CommonsChunkPlugin({\n    name: &#39;vendors&#39;,\n    filename: &#39;vendors.js&#39;,\n}),\n</code></pre><p>然后在 webpack.config.js 文件中配置入口文件：</p>\n<pre><code>entry: {\n    index: path.resolve(__dirname, &#39;../app/index/index.js&#39;),\n    vendors: [\n        &#39;Vue&#39;\n    ]\n},\n</code></pre><p>上面代码的意思是，我们把Vue.js当做公共模块单独打包，你可以在这个数组中增加其他模块，一起作为公共模块打包成一个文件，我们执行构建命令，然后查看输出，如下图，成功提取：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20160325u.jpg\" alt=\"提取公共模块\"></p>\n<p>对于加载图片的问题，我们知道，webpack的哲学是一切皆是模块，然后通过相应的loader去加载，所以加载图片，我们就需要使用到 url-loader，在webpack.config.js 文件中添加一个loader配置：</p>\n<pre><code>loaders: [\n    // 使用vue-loader 加载 .vue 结尾的文件\n    {\n        test: /\\.vue$/, \n        loader: &#39;vue&#39;   \n    },\n    {\n        test: /\\.js$/,\n        loader: &#39;babel?presets=es2015&#39;,\n        exclude: /node_modules/\n    },\n    // 加载图片\n    {\n        test: /\\.(png|jpg|gif|svg)$/,\n        loader: &#39;url&#39;,\n        query: {\n            limit: 10000,\n            name: &#39;[name].[ext]?[hash:7]&#39;\n        }\n    }\n]\n</code></pre><p>这样，当我们的css样式表文件中使用 url(xxxx.png)或者js中去require(‘xxxx.png’)的时候，webpack就知道如何处理，另外url-loader的一个好处就是，以上面的配置来说，当我们的图片大小小于10000字节的时候，webpack会把图片转换成base64格式插入到代码中，从而减少http请求，另外，我们在这里谈到的任何一个loader都可以在npm中查找到，读者可以查询更多的loader了解并使用。</p>"},{"title":"JavaScript实现MVVM之我就是想监测一个普通对象的变化","date":"2016-04-28T02:51:17.000Z","_content":"\n我的博客始终都有一个特点，就是喜欢从0开始，努力让小白都能看的明白，即使看不明白，也能知道整体的来龙去脉，这篇博客依然秉承着这个风格。\n以MVVM模式为主线去实现的JavaScript框架非常流行，诸如 angular、Ember、Polymer、vue 等等，它们的一个特点就是数据的双向绑定。这对于小白来说就像变魔术一样，但无论对谁来讲，当你看到一个令你感兴趣的魔术，那么揭秘它总是能吸引你的眼球。\n这篇文章主要讲述MVVM实现中的一部分：如何监测数据的变化。\n\n<!-- more -->\n\n>注：本篇文章将生产出一个迷你库，代码托管在 [https://github.com/HcySunYang/jsonob](https://github.com/HcySunYang/jsonob)，由于本篇文章代码采用ES6编写，所以不能直接在浏览器下运行，读者在实践的时候可以采用该仓库的代码，clone仓库后：\n1、安装依赖\nnpm install\n2、构建项目\nnpm run build\n3、使用浏览器打开 test/index.html 查看运行结果\n\n那么接下来我们要做什么呢？我们会实现一个迷你库，这个库的作用是监测一个普通对象的变化，并作出相应的通知。库的使用方法大致如下：\n\n```\n// 定义一个变化通知的回调\nvar callback = function(newVal, oldVal){\n    alert(newVal + '----' + oldVal);\n};\n\n// 定义一个普通对象作为数据模型\nvar data = {\n    a: 200,\n    level1: {\n        b: 'str',\n        c: [1, 2, 3],\n        level2: {\n            d: 90\n        }\n    }\n}\n\n// 实例化一个监测对象，去监测数据，并在数据发生改变的时候作出反应\nvar j = new Jsonob(data, callback);\n```\n\n上面代码中，我们定义了一个 callback 回调函数，以及一个保存着普通json对象的变量 data ，最后实例化了一个 监测对象 ，对 data 进行变化监测，当变化发生的时候，执行给定的回调进行必要的变化通知，这样，我们通过一些手段就可以达到数据绑定的效果。\n\n## Object.defineProperty ##\n\nES5 描述了属性的特征，提出对象的每个属性都有特定的描述符，你也可以理解为那是属性的属性。。。。。\n\nES5把属性分成两种，一种是 数据属性， 一种是 访问器属性，我们可以使用 Object.defineProperty() 去定义一个数据属性或访问器属性。如下代码：\n\n```\nvar obj = {};\n\nobj.name = 'hcy';\n```\n\n上面的代码我们定义了一个对象，并给这个对象添加了一个属性 name，值为 'hcy'，我们也可以使用 Object.defineProperty() 来给对象定义属性，上面的代码等价于：\n\n```\nvar obj = {};\n\nObject.defineProperty(obj, 'name', {\n\tvalue: 'hcy',\t\t// 属性的值\n\twritable: true,\t\t// 是否可写\n\tenumerable: true,\t// 是否能够通过for in 枚举\n\tconfigurable: true\t// 是否可使用 delete删除\n})\n```\n\n这样我们就使用 Object.defineProperty 给对象定义了一个属性，这样的属性就是数据属性，我们也可以定义访问器属性：\n\n```\nvar obj = {};\n\nObject.defineProperty(obj, 'age', {\n\tget: function(){\n\t\treturn 20;\n\t},\n\tset: function(newVal){\n\t\tthis.age += 20;\n\t}\n})\n```\n\n访问器属性允许你定义一对儿 getter/setter ，当你读取属性值的时候底层会调用 get 方法，当你去设置属性值的时候，底层会调用 set 方法\n\n知道了这个就好办了，我们再回到最初的问题上面，如何检测一个普通对象的变化，我们可以这样做：\n\n> 遍历对象的属性，把对象的属性都使用 Object.defineProperty 转为  getter/setter ，这样，当我们修改一些值得时候，就会调用set方法，然后我们在set方法里面，回调通知，不就可以了吗，来看下面的代码：\n\n```\n// index.js\nconst OP = Object.prototype;\n\nexport class Jsonob{\n    constructor(obj, callback){\n        if(OP.toString.call(obj) !== '[object Object]'){\n            console.error('This parameter must be an object：' + obj);\n        }\n        this.$callback = callback;\n        this.observe(obj);\n    }\n    \n    observe(obj){\n        Object.keys(obj).forEach(function(key, index, keyArray){\n            var val = obj[key];\n            Object.defineProperty(obj, key, {\n                get: function(){\n                    return val;\n                },\n                set: (function(newVal){\n                    this.$callback(newVal);\n                }).bind(this)\n            });\n            \n            if(OP.toString.call(obj[key]) === '[object Object]'){\n                this.observe(obj[key]);\n            }\n            \n        }, this);\n        \n    }\n}\n```\n\n上面代码采用ES6编写，index.js文件中导出了一个 Jsonob 类，constructor构造函数中，我们保证了传入的对象是一个 {} 或 new Object() 生成的对象，接着缓存了回调函数，最后调用了原型下的 observe 方法。\n\nobserve方法是真正实现监测属性的方法，我们使用 Object.keys(obj).forEach 循环obj所有可枚举的属性，使用 Object.defineProperty 将属性转换为访问器属性，然后判断属性的值是否是一个对象，如果是对象的话再进行递归调用，这样一来，我们就能保证一个复杂的普通json对象中的属性以及值为对象的属性的属性都转换成访问器属性。\n\n最后，在 Object.defineProperty 的 set 方法中，我们调用了指定的回调，并将新值作为参数进行传递。\n\n接下来我们编写一个测试代码，去测试一下上面的代码是否可以正常使用，在index.html中（[读者可以clone文章开始阶段给出的仓库](https://github.com/HcySunYang/jsonob)），编写如下代码：\n\n```\n<html>\n    <head>\n        <meta charset=\"utf-8\" />\n    </head>\n    <body>\n        \n        <script src=\"../dist/jsonob.js\"></script>\n        <script>\n            var Jsonob = Jsonob.Jsonob;\n            \n            var callback = function(newVal){\n                alert(newVal);\n            };\n            \n            var data = {\n                a: 200,\n                level1: {\n                    b: 'str',\n                    c: [1, 2, 3],\n                    level2: {\n                        d: 90\n                    }\n                }\n            }\n            \n            var j = new Jsonob(data, callback);\n            \n            data.a = 250;\n            data.level1.b = 'sss';\n            data.level1.level2.d = 'msn';\n        </script>\n    </body>\n</html>\n```\n\n上面代码，很接近我们文章开头要实现的目标。我们定义了回调(callback)和数据模型(data)，在回调中我们使用 alert 函数弹出新值，然后创建了一个监测实例并把数据和回调作为参数传递过去，然后我们试着修改data对象相面的属性以及子属性，看看代码是否按照我们预期的工作，打开浏览器，如下图\n\n![弹窗1](http://7xlolm.com1.z0.glb.clouddn.com/20160428a.jpg)\n![弹窗2](http://7xlolm.com1.z0.glb.clouddn.com/b.jpg)\n![弹窗3](http://7xlolm.com1.z0.glb.clouddn.com/c.jpg)\n\n可以看弹出三个对话框，这说明我们的代码正常工作了，无论是data对象的属性，还是子属性的改变，都能够监测到变化，并执行我们指定的回调。\n\n这样就结束了吗？可能细心的朋友可能已经意识到了，我们在检测到变化并通知回调时，只传递了一个新值(newVal)，但有的时候我们也需要旧值，但是以现在的程序来看，我们还无法传递旧值，所以我们要想办法。大家仔细看上面 index.js 中forEach循环里面的代码，有这样一段：\n\n```\nvar val = obj[key];\nObject.defineProperty(obj, key, {\n    get: function(){\n        return val;\n    },\n    set: (function(newVal){\n        this.$callback(newVal);\n    }).bind(this)\n});\n```\n\n实际上，val 变量所存储的，就是旧值，我们不妨把上面的代码修改成下面这样：\n\n```\nvar oldVal = obj[key];\nObject.defineProperty(obj, key, {\n    get: function(){\n        return oldVal;\n    },\n    set: (function(newVal){\n        if(oldVal !== newVal){\n            if(OP.toString.call(newVal) === '[object Object]'){\n                this.observe(newVal);\n            }\n            this.$callback(newVal, oldVal);\n            oldVal = newVal;\n        }\n        \n    }).bind(this)\n});\n```\n\n我们将原来的 val 变量名字修改成 oldVal ，并在set方法中进行了更改判断，仅在值有更改的情况下去做一些事，当值有修改的时候，我们首先判断了新值是否是类似 {} 或 new Object() 形式的对象，如果是的话，我们要调用 this.observe 方法去监听一下新设置的值，然后在把旧值传递给回调函数之后更新一下旧值。\n\n接着修改 test/index.html 文件：\n\n```\n<html>\n    <head>\n        <meta charset=\"utf-8\" />\n    </head>\n    <body>\n        \n        <script src=\"../dist/jsonob.js\"></script>\n        <script>\n            var Jsonob = Jsonob.Jsonob;\n            \n            var callback = function(newVal, oldVal){\n                alert('新值：' + newVal + '----' + '旧值：' + oldVal);\n            };\n            \n            var data = {\n                a: 200,\n                level1: {\n                    b: 'str',\n                    c: [1, 2, 3],\n                    level2: {\n                        d: 90\n                    }\n                }\n            }\n            \n            var j = new Jsonob(data, callback);\n            \n            data.a = 250;\n            data.a = 260;\n        </script>\n    </body>\n</html>\n```\n\n我们在回调函数中接收了新值和旧值，在下面我们修改了 data.a 的值为 250，然后运行代码，查看浏览器的反馈：\n\n![alert1](http://7xlolm.com1.z0.glb.clouddn.com/20160428d.jpg)\n\n![alert1](http://7xlolm.com1.z0.glb.clouddn.com/20160428e.jpg)\n\n这样，我们完成了最最基本的普通对象变化监测库，接着，我们继续发现问题，我们回过头来看一下数据模型：\n\n```\nvar data = {\n    a: 200,\n    level1: {\n        b: 'str',\n        c: [1, 2, 3],\n        level2: {\n            d: 90\n        }\n    }\n}\n```\n\n我们可以发现， data.level1.c 的值为一个数组，数组在我们工作中肯定是一个非常常见的数据结构，当数组的元素发生改变的时候，也视为数据的改变，但遗憾的是，我们现在库还不能监测数组的变化，比如：\n\n```\ndata.level1.c.push(4);\n```\n\n我们向数组中push了一个元素，但是并不会触发改变。操作数组的方法有很多，比如：'push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse' 等等。那么我们如何在使用这些方法操作数组的时候能够监听到变化呢？有这样一个思路，看图：\n\n![当你定义一个数组实例的时候，实例、实例的__proto__属性、Array构造函数、原型之间的关系](http://7xlolm.com1.z0.glb.clouddn.com/20160501f.jpg)\n\n上图显示了，当你通过 var arr1 = [] 或者 var arr1 = new Array() 语句创建一个数组实例的时候，实例、实例的__proto__属性、Array构造函数以及Array原型四者之间的关系。我们可以很容的发现，数组实例的__proto__属性，是Array.prototype的引用，当我们使用 arr1.push() 语句操作数组的时候，是调用原型下的push方法，那么我们可不可以重写原型的这些数组方法，在这些重写的方法里面去监听变化呢？答案是可以的，但是在实现之前，我们先思考一个问题，我们到底要怎么重写，比如我们重写一个数组push方法，向数组栈中推入一个元素，难道我们要这样去重写吗：\n\n```\nArray.prototype.push = function(){\n    // 你的实现方式\n}\n```\n\n然后再一次实现其他的数组方法：\n\n```\nArray.prototype.pop = function(){\n    // 你的实现方式\n}\nArray.prototype.shift = function(){\n    // 你的实现方式\n}\n...\n```\n\n这种实现是最不应该考虑的，暂且不说能不能全部实现的与原生无异，即使你实现的与原生方法在使用方式上一模一样，并且不影响其他代码的运行，那么在性能上，可能就与原生差很多了，我们可以在上面 数组实例以及数组构造函数和原型之间的关系图 中思考解决方案，我们可不可以在原型链中加一层，如下：\n\n![思路](http://7xlolm.com1.z0.glb.clouddn.com/20160501g.jpg)\n\n如上图所示，我们在 arr1.__proto__ 与 Array.prototype 之间的链条中添加了一环 fakePrototype (假的原型)，我们的思路是，在使用 push 等数组方法的时候，调用的是 fakePrototype 上的push方法，然后在 fakePrototype 方法中简介再去调用真正的Array原型上的 push 方法，同时监听变化，这样，我们很容易就能实现，完整代码如下：\n\n```\n/*\n *  Object 原型\n */\nconst OP = Object.prototype;\n/*\n *  需要重写的数组方法 OAR 是 overrideArrayMethod 的缩写\n */\nconst OAM = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];\n\nexport class Jsonob{\n    constructor(obj, callback){\n        if(OP.toString.call(obj) !== '[object Object]'){\n            console.error('This parameter must be an object：' + obj);\n        }\n        this.$callback = callback;\n        this.observe(obj);\n    }\n    \n    observe(obj){\n        // 如果发现 监测的对象是数组的话就要调用 overrideArrayProto 方法\n        if(OP.toString.call(obj) === '[object Array]'){\n            this.overrideArrayProto(obj);\n        }\n        Object.keys(obj).forEach(function(key, index, keyArray){\n            var oldVal = obj[key];\n            Object.defineProperty(obj, key, {\n                get: function(){\n                    return oldVal;\n                },\n                set: (function(newVal){\n                    if(oldVal !== newVal){\n                        if(OP.toString.call(newVal) === '[object Object]' || OP.toString.call(newVal) === '[object Array]'){\n                            this.observe(newVal);\n                        }\n                        this.$callback(newVal, oldVal);\n                        oldVal = newVal;\n                    }\n                    \n                }).bind(this)\n            });\n            \n            if(OP.toString.call(obj[key]) === '[object Object]' || OP.toString.call(obj[key]) === '[object Array]'){\n                this.observe(obj[key]);\n            }\n            \n        }, this);\n        \n    }\n    \n    overrideArrayProto(array){\n            // 保存原始 Array 原型\n        var originalProto = Array.prototype,\n            // 通过 Object.create 方法创建一个对象，该对象的原型就是Array.prototype\n            overrideProto = Object.create(Array.prototype),\n            self = this,\n            result;\n        // 遍历要重写的数组方法\n        Object.keys(OAM).forEach(function(key, index, array){\n            var method = OAM[index],\n                oldArray = [];\n            // 使用 Object.defineProperty 给 overrideProto 添加属性，属性的名称是对应的数组函数名，值是函数\n            Object.defineProperty(overrideProto, method, {\n                value: function(){\n                    oldArray = this.slice(0);\n                    \n                    var arg = [].slice.apply(arguments);\n                    // 调用原始 原型 的数组方法\n                    result = originalProto[method].apply(this, arg);\n                    // 对新的数组进行监测\n                    self.observe(this);\n                    // 执行回调\n                    self.$callback(this, oldArray);\n                    \n                    return result;\n                },\n                writable: true,\n                enumerable: false,\n                configurable: true\n            });\n        }, this);\n        \n        // 最后 让该数组实例的 __proto__ 属性指向 假的原型 overrideProto\n        array.__proto__ = overrideProto;\n        \n    }\n}\n```\n我们新增加了 overrideArrayProto 方法，并且在程序的最上面定义了一个常量 OAM ，用来定义要重写的数组方法，同时在 observe 方法中添加了对数组的判断，我们也允许了对数组的监听。接下来我们详细介绍一下 overrideArrayProto 方法。\n\n顾名思义，overrideArrayProto 这个方法是重写了 Array 的原型，在 overrideArrayProto 方法中，我们首先保存了数组的原始原型，然后创建了一个假的原型，然后遍历需要重新的数组方法，并将这些方法挂载到 overrideProto 上，我们可以看到，在挂载到 overrideProto 上的这些数组方法的里面，我们调用了原始的数组原型上的数组方法，最后，我们让数组实例的 __proto__ 属性指向 overrideProto，这样，我们就实现了上图中的思路。并且完成了想要达到的效果，接下来我们可以使用我们已经重写了的数组方法去操作数组，查看能不能监测到变化：\n\n```\nvar callback = function(newVal, oldVal){\n    alert('新值：' + newVal + '----' + '旧值：' + oldVal);\n};\n\nvar data = {\n    a: 200,\n    level1: {\n        b: 'str',\n        c: [{w: 90}, 2, 3],\n        level2: {\n            d: 90\n        }\n    }\n}\n\nvar j = new Jsonob(data, callback);\n\ndata.level1.c.push(4);\n```\n\n在浏览器中可以看到，我们的代码按照预期运行了：\n\n![图1](http://7xlolm.com1.z0.glb.clouddn.com/20160501h.jpg)\n\n直到现在，我们可以几乎完美的监测到数据对象的变化了，并且能够知道变化前后的旧值与新值，那么这样就结束了吗？当然不是，我们可以回顾一下当我们修改数据对象的时候，我们的确能够获取到新值和旧值，但是也仅此而已，我们并不知道修改的是哪个属性，但是能够知道修改的哪个属性对于我们是相当重要的。\n\n比如MVVM中，当数据对象改变时，要去更新模板，而模板到数据之间的关系，是通过数据对象下的某个字段名称进行绑定的，举个简单的例子，比如我们有如下模板：\n\n```\n<div id=\"box\">\n    <div>{{name}}</div>\n    <div>{{age}}</div>\n    <div>{{sex}}</div>\n</div>\n```\n\n然后我们有如下数据：\n\n```\nvar data = {\n    name : 'hcy',\n    age : 20,\n    sex : '男'\n}\n```\n\n最后我们通过 viewModule 简历模板和数据的关系：\n\n```\nnew Jsonob(document.getElementById('box'), data);\n```\n\n那么当我们的数据模型data中的某个属性改变的时候，比如 data.name = 'fuck'，如若我们不知道改变的字段名称，那么我们就无法得知要刷新哪部分模板，我们只能对模板进行完全更新，这并不是一个好的设计，性能会很差，所以回到我们最初的问题，当数据对象发生改变的时候，我们得知变化的属性的名称是很必要的，但是现在我们的 Jsonob 库还不能完成这样的任务，所以我们要进一步完善。\n\n在完善之前，我们要提出一个路径的概念，所谓路径，就是变化的字段的路径，比如有如下数据模型：\n\n```\nvar data = {\n    a : {\n        b : {\n            c : 'hcy'\n        }\n    }\n}\n```\n\n那么字段 a 的路径就是用 data.a ，b 的路径就是 data.a.b，c 的路径就是 data.a.b.c。有的时候我们也可以用数组或者字符串来表述路径，至于用什么来表述路径并不重要，重要的是我们能够获取到路径，比如用数组表述路径可以这样：\n\n1、 a 的路径是 ['data', 'a']\n1、 b 的路径是 ['data', 'a', 'b']\n1、 c 的路径是 ['data', 'a', 'b', 'c']\n\n有了路径的概念后，我们就可以继续完善 Jsonob 库了，我们在存储路径的时候选择的是数组表示，用数组存储路径，我们修改Jsonob库代码，修改了 observe 方法和 overrideArrayProto 方法，如下图，我做了所有修改的标注：\n\n![修改observe方法](http://7xlolm.com1.z0.glb.clouddn.com/20160501n.jpg)\n\n![修改overrideArrayProto方法](http://7xlolm.com1.z0.glb.clouddn.com/20160501m.jpg)\n\n最后，让我们再次尝试修改一切数组属性：\n\n```\nvar callback = function(newVal, oldVal, path){\n    alert('新值：' + newVal + '----' + '旧值：' + oldVal + '----路径：' + path);\n};\n\nvar data = {\n    a: 200,\n    level1: {\n        b: 'str',\n        c: [{w: 90}, 2, 3],\n        level2: {\n            d: 90\n        }\n    }\n}\n\nvar j = new Jsonob(data, callback);\n\ndata.level1.c.push(4);              // 向数组 data.level1.c 中push一个元素\ndata.level1.c[0].w = 100;           // 修改数组 data.level1.c[0].w 的值\ndata.level1.b = 'sss';              // 修改 data.level1.b 的值\ndata.level1.level2.d = 'msn';       // 修改 data.level1.level2.d 的值\n```\n\n我们修改了四个属性的值，然后我们在回调函数中接收了 path 参数，这样当数据模型变化的时候，我们不仅能够获取到新旧值，还能够知道是哪个属性发生了变化，这样我们就可以相应的做一些其他的事情，比如MVVM中的更新关联的视图，就可以做到了。最后我们刷新浏览器来产看弹出框：\n\n![一](http://7xlolm.com1.z0.glb.clouddn.com/20160501aa.jpg)\n\n![二](http://7xlolm.com1.z0.glb.clouddn.com/20160501ab.jpg)\n\n![三](http://7xlolm.com1.z0.glb.clouddn.com/20160501ac.jpg)\n\n![四](http://7xlolm.com1.z0.glb.clouddn.com/20160501ad.jpg)\n\n图中我用红色圈标出了变化属性的路径，由于我们的路径是数组标示的，所以看上去是以逗号“,”隔开的，现在，我们就算完成了这个迷你库，相信读者也有自己的实现思路，笔者水平有限，如果哪里有欠缺还希望大家指正，共同进步。\n\n\n\n","source":"_posts/2016/04/28/JavaScript实现MVVM之我就是想监测一个普通对象的变化.md","raw":"title: JavaScript实现MVVM之我就是想监测一个普通对象的变化\ndate: 2016-04-28 10:51:17\ncategories:\n- WebFrontEnd\ntags:\n- 框架\n- MVVM\n- observe\n---\n\n我的博客始终都有一个特点，就是喜欢从0开始，努力让小白都能看的明白，即使看不明白，也能知道整体的来龙去脉，这篇博客依然秉承着这个风格。\n以MVVM模式为主线去实现的JavaScript框架非常流行，诸如 angular、Ember、Polymer、vue 等等，它们的一个特点就是数据的双向绑定。这对于小白来说就像变魔术一样，但无论对谁来讲，当你看到一个令你感兴趣的魔术，那么揭秘它总是能吸引你的眼球。\n这篇文章主要讲述MVVM实现中的一部分：如何监测数据的变化。\n\n<!-- more -->\n\n>注：本篇文章将生产出一个迷你库，代码托管在 [https://github.com/HcySunYang/jsonob](https://github.com/HcySunYang/jsonob)，由于本篇文章代码采用ES6编写，所以不能直接在浏览器下运行，读者在实践的时候可以采用该仓库的代码，clone仓库后：\n1、安装依赖\nnpm install\n2、构建项目\nnpm run build\n3、使用浏览器打开 test/index.html 查看运行结果\n\n那么接下来我们要做什么呢？我们会实现一个迷你库，这个库的作用是监测一个普通对象的变化，并作出相应的通知。库的使用方法大致如下：\n\n```\n// 定义一个变化通知的回调\nvar callback = function(newVal, oldVal){\n    alert(newVal + '----' + oldVal);\n};\n\n// 定义一个普通对象作为数据模型\nvar data = {\n    a: 200,\n    level1: {\n        b: 'str',\n        c: [1, 2, 3],\n        level2: {\n            d: 90\n        }\n    }\n}\n\n// 实例化一个监测对象，去监测数据，并在数据发生改变的时候作出反应\nvar j = new Jsonob(data, callback);\n```\n\n上面代码中，我们定义了一个 callback 回调函数，以及一个保存着普通json对象的变量 data ，最后实例化了一个 监测对象 ，对 data 进行变化监测，当变化发生的时候，执行给定的回调进行必要的变化通知，这样，我们通过一些手段就可以达到数据绑定的效果。\n\n## Object.defineProperty ##\n\nES5 描述了属性的特征，提出对象的每个属性都有特定的描述符，你也可以理解为那是属性的属性。。。。。\n\nES5把属性分成两种，一种是 数据属性， 一种是 访问器属性，我们可以使用 Object.defineProperty() 去定义一个数据属性或访问器属性。如下代码：\n\n```\nvar obj = {};\n\nobj.name = 'hcy';\n```\n\n上面的代码我们定义了一个对象，并给这个对象添加了一个属性 name，值为 'hcy'，我们也可以使用 Object.defineProperty() 来给对象定义属性，上面的代码等价于：\n\n```\nvar obj = {};\n\nObject.defineProperty(obj, 'name', {\n\tvalue: 'hcy',\t\t// 属性的值\n\twritable: true,\t\t// 是否可写\n\tenumerable: true,\t// 是否能够通过for in 枚举\n\tconfigurable: true\t// 是否可使用 delete删除\n})\n```\n\n这样我们就使用 Object.defineProperty 给对象定义了一个属性，这样的属性就是数据属性，我们也可以定义访问器属性：\n\n```\nvar obj = {};\n\nObject.defineProperty(obj, 'age', {\n\tget: function(){\n\t\treturn 20;\n\t},\n\tset: function(newVal){\n\t\tthis.age += 20;\n\t}\n})\n```\n\n访问器属性允许你定义一对儿 getter/setter ，当你读取属性值的时候底层会调用 get 方法，当你去设置属性值的时候，底层会调用 set 方法\n\n知道了这个就好办了，我们再回到最初的问题上面，如何检测一个普通对象的变化，我们可以这样做：\n\n> 遍历对象的属性，把对象的属性都使用 Object.defineProperty 转为  getter/setter ，这样，当我们修改一些值得时候，就会调用set方法，然后我们在set方法里面，回调通知，不就可以了吗，来看下面的代码：\n\n```\n// index.js\nconst OP = Object.prototype;\n\nexport class Jsonob{\n    constructor(obj, callback){\n        if(OP.toString.call(obj) !== '[object Object]'){\n            console.error('This parameter must be an object：' + obj);\n        }\n        this.$callback = callback;\n        this.observe(obj);\n    }\n    \n    observe(obj){\n        Object.keys(obj).forEach(function(key, index, keyArray){\n            var val = obj[key];\n            Object.defineProperty(obj, key, {\n                get: function(){\n                    return val;\n                },\n                set: (function(newVal){\n                    this.$callback(newVal);\n                }).bind(this)\n            });\n            \n            if(OP.toString.call(obj[key]) === '[object Object]'){\n                this.observe(obj[key]);\n            }\n            \n        }, this);\n        \n    }\n}\n```\n\n上面代码采用ES6编写，index.js文件中导出了一个 Jsonob 类，constructor构造函数中，我们保证了传入的对象是一个 {} 或 new Object() 生成的对象，接着缓存了回调函数，最后调用了原型下的 observe 方法。\n\nobserve方法是真正实现监测属性的方法，我们使用 Object.keys(obj).forEach 循环obj所有可枚举的属性，使用 Object.defineProperty 将属性转换为访问器属性，然后判断属性的值是否是一个对象，如果是对象的话再进行递归调用，这样一来，我们就能保证一个复杂的普通json对象中的属性以及值为对象的属性的属性都转换成访问器属性。\n\n最后，在 Object.defineProperty 的 set 方法中，我们调用了指定的回调，并将新值作为参数进行传递。\n\n接下来我们编写一个测试代码，去测试一下上面的代码是否可以正常使用，在index.html中（[读者可以clone文章开始阶段给出的仓库](https://github.com/HcySunYang/jsonob)），编写如下代码：\n\n```\n<html>\n    <head>\n        <meta charset=\"utf-8\" />\n    </head>\n    <body>\n        \n        <script src=\"../dist/jsonob.js\"></script>\n        <script>\n            var Jsonob = Jsonob.Jsonob;\n            \n            var callback = function(newVal){\n                alert(newVal);\n            };\n            \n            var data = {\n                a: 200,\n                level1: {\n                    b: 'str',\n                    c: [1, 2, 3],\n                    level2: {\n                        d: 90\n                    }\n                }\n            }\n            \n            var j = new Jsonob(data, callback);\n            \n            data.a = 250;\n            data.level1.b = 'sss';\n            data.level1.level2.d = 'msn';\n        </script>\n    </body>\n</html>\n```\n\n上面代码，很接近我们文章开头要实现的目标。我们定义了回调(callback)和数据模型(data)，在回调中我们使用 alert 函数弹出新值，然后创建了一个监测实例并把数据和回调作为参数传递过去，然后我们试着修改data对象相面的属性以及子属性，看看代码是否按照我们预期的工作，打开浏览器，如下图\n\n![弹窗1](http://7xlolm.com1.z0.glb.clouddn.com/20160428a.jpg)\n![弹窗2](http://7xlolm.com1.z0.glb.clouddn.com/b.jpg)\n![弹窗3](http://7xlolm.com1.z0.glb.clouddn.com/c.jpg)\n\n可以看弹出三个对话框，这说明我们的代码正常工作了，无论是data对象的属性，还是子属性的改变，都能够监测到变化，并执行我们指定的回调。\n\n这样就结束了吗？可能细心的朋友可能已经意识到了，我们在检测到变化并通知回调时，只传递了一个新值(newVal)，但有的时候我们也需要旧值，但是以现在的程序来看，我们还无法传递旧值，所以我们要想办法。大家仔细看上面 index.js 中forEach循环里面的代码，有这样一段：\n\n```\nvar val = obj[key];\nObject.defineProperty(obj, key, {\n    get: function(){\n        return val;\n    },\n    set: (function(newVal){\n        this.$callback(newVal);\n    }).bind(this)\n});\n```\n\n实际上，val 变量所存储的，就是旧值，我们不妨把上面的代码修改成下面这样：\n\n```\nvar oldVal = obj[key];\nObject.defineProperty(obj, key, {\n    get: function(){\n        return oldVal;\n    },\n    set: (function(newVal){\n        if(oldVal !== newVal){\n            if(OP.toString.call(newVal) === '[object Object]'){\n                this.observe(newVal);\n            }\n            this.$callback(newVal, oldVal);\n            oldVal = newVal;\n        }\n        \n    }).bind(this)\n});\n```\n\n我们将原来的 val 变量名字修改成 oldVal ，并在set方法中进行了更改判断，仅在值有更改的情况下去做一些事，当值有修改的时候，我们首先判断了新值是否是类似 {} 或 new Object() 形式的对象，如果是的话，我们要调用 this.observe 方法去监听一下新设置的值，然后在把旧值传递给回调函数之后更新一下旧值。\n\n接着修改 test/index.html 文件：\n\n```\n<html>\n    <head>\n        <meta charset=\"utf-8\" />\n    </head>\n    <body>\n        \n        <script src=\"../dist/jsonob.js\"></script>\n        <script>\n            var Jsonob = Jsonob.Jsonob;\n            \n            var callback = function(newVal, oldVal){\n                alert('新值：' + newVal + '----' + '旧值：' + oldVal);\n            };\n            \n            var data = {\n                a: 200,\n                level1: {\n                    b: 'str',\n                    c: [1, 2, 3],\n                    level2: {\n                        d: 90\n                    }\n                }\n            }\n            \n            var j = new Jsonob(data, callback);\n            \n            data.a = 250;\n            data.a = 260;\n        </script>\n    </body>\n</html>\n```\n\n我们在回调函数中接收了新值和旧值，在下面我们修改了 data.a 的值为 250，然后运行代码，查看浏览器的反馈：\n\n![alert1](http://7xlolm.com1.z0.glb.clouddn.com/20160428d.jpg)\n\n![alert1](http://7xlolm.com1.z0.glb.clouddn.com/20160428e.jpg)\n\n这样，我们完成了最最基本的普通对象变化监测库，接着，我们继续发现问题，我们回过头来看一下数据模型：\n\n```\nvar data = {\n    a: 200,\n    level1: {\n        b: 'str',\n        c: [1, 2, 3],\n        level2: {\n            d: 90\n        }\n    }\n}\n```\n\n我们可以发现， data.level1.c 的值为一个数组，数组在我们工作中肯定是一个非常常见的数据结构，当数组的元素发生改变的时候，也视为数据的改变，但遗憾的是，我们现在库还不能监测数组的变化，比如：\n\n```\ndata.level1.c.push(4);\n```\n\n我们向数组中push了一个元素，但是并不会触发改变。操作数组的方法有很多，比如：'push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse' 等等。那么我们如何在使用这些方法操作数组的时候能够监听到变化呢？有这样一个思路，看图：\n\n![当你定义一个数组实例的时候，实例、实例的__proto__属性、Array构造函数、原型之间的关系](http://7xlolm.com1.z0.glb.clouddn.com/20160501f.jpg)\n\n上图显示了，当你通过 var arr1 = [] 或者 var arr1 = new Array() 语句创建一个数组实例的时候，实例、实例的__proto__属性、Array构造函数以及Array原型四者之间的关系。我们可以很容的发现，数组实例的__proto__属性，是Array.prototype的引用，当我们使用 arr1.push() 语句操作数组的时候，是调用原型下的push方法，那么我们可不可以重写原型的这些数组方法，在这些重写的方法里面去监听变化呢？答案是可以的，但是在实现之前，我们先思考一个问题，我们到底要怎么重写，比如我们重写一个数组push方法，向数组栈中推入一个元素，难道我们要这样去重写吗：\n\n```\nArray.prototype.push = function(){\n    // 你的实现方式\n}\n```\n\n然后再一次实现其他的数组方法：\n\n```\nArray.prototype.pop = function(){\n    // 你的实现方式\n}\nArray.prototype.shift = function(){\n    // 你的实现方式\n}\n...\n```\n\n这种实现是最不应该考虑的，暂且不说能不能全部实现的与原生无异，即使你实现的与原生方法在使用方式上一模一样，并且不影响其他代码的运行，那么在性能上，可能就与原生差很多了，我们可以在上面 数组实例以及数组构造函数和原型之间的关系图 中思考解决方案，我们可不可以在原型链中加一层，如下：\n\n![思路](http://7xlolm.com1.z0.glb.clouddn.com/20160501g.jpg)\n\n如上图所示，我们在 arr1.__proto__ 与 Array.prototype 之间的链条中添加了一环 fakePrototype (假的原型)，我们的思路是，在使用 push 等数组方法的时候，调用的是 fakePrototype 上的push方法，然后在 fakePrototype 方法中简介再去调用真正的Array原型上的 push 方法，同时监听变化，这样，我们很容易就能实现，完整代码如下：\n\n```\n/*\n *  Object 原型\n */\nconst OP = Object.prototype;\n/*\n *  需要重写的数组方法 OAR 是 overrideArrayMethod 的缩写\n */\nconst OAM = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];\n\nexport class Jsonob{\n    constructor(obj, callback){\n        if(OP.toString.call(obj) !== '[object Object]'){\n            console.error('This parameter must be an object：' + obj);\n        }\n        this.$callback = callback;\n        this.observe(obj);\n    }\n    \n    observe(obj){\n        // 如果发现 监测的对象是数组的话就要调用 overrideArrayProto 方法\n        if(OP.toString.call(obj) === '[object Array]'){\n            this.overrideArrayProto(obj);\n        }\n        Object.keys(obj).forEach(function(key, index, keyArray){\n            var oldVal = obj[key];\n            Object.defineProperty(obj, key, {\n                get: function(){\n                    return oldVal;\n                },\n                set: (function(newVal){\n                    if(oldVal !== newVal){\n                        if(OP.toString.call(newVal) === '[object Object]' || OP.toString.call(newVal) === '[object Array]'){\n                            this.observe(newVal);\n                        }\n                        this.$callback(newVal, oldVal);\n                        oldVal = newVal;\n                    }\n                    \n                }).bind(this)\n            });\n            \n            if(OP.toString.call(obj[key]) === '[object Object]' || OP.toString.call(obj[key]) === '[object Array]'){\n                this.observe(obj[key]);\n            }\n            \n        }, this);\n        \n    }\n    \n    overrideArrayProto(array){\n            // 保存原始 Array 原型\n        var originalProto = Array.prototype,\n            // 通过 Object.create 方法创建一个对象，该对象的原型就是Array.prototype\n            overrideProto = Object.create(Array.prototype),\n            self = this,\n            result;\n        // 遍历要重写的数组方法\n        Object.keys(OAM).forEach(function(key, index, array){\n            var method = OAM[index],\n                oldArray = [];\n            // 使用 Object.defineProperty 给 overrideProto 添加属性，属性的名称是对应的数组函数名，值是函数\n            Object.defineProperty(overrideProto, method, {\n                value: function(){\n                    oldArray = this.slice(0);\n                    \n                    var arg = [].slice.apply(arguments);\n                    // 调用原始 原型 的数组方法\n                    result = originalProto[method].apply(this, arg);\n                    // 对新的数组进行监测\n                    self.observe(this);\n                    // 执行回调\n                    self.$callback(this, oldArray);\n                    \n                    return result;\n                },\n                writable: true,\n                enumerable: false,\n                configurable: true\n            });\n        }, this);\n        \n        // 最后 让该数组实例的 __proto__ 属性指向 假的原型 overrideProto\n        array.__proto__ = overrideProto;\n        \n    }\n}\n```\n我们新增加了 overrideArrayProto 方法，并且在程序的最上面定义了一个常量 OAM ，用来定义要重写的数组方法，同时在 observe 方法中添加了对数组的判断，我们也允许了对数组的监听。接下来我们详细介绍一下 overrideArrayProto 方法。\n\n顾名思义，overrideArrayProto 这个方法是重写了 Array 的原型，在 overrideArrayProto 方法中，我们首先保存了数组的原始原型，然后创建了一个假的原型，然后遍历需要重新的数组方法，并将这些方法挂载到 overrideProto 上，我们可以看到，在挂载到 overrideProto 上的这些数组方法的里面，我们调用了原始的数组原型上的数组方法，最后，我们让数组实例的 __proto__ 属性指向 overrideProto，这样，我们就实现了上图中的思路。并且完成了想要达到的效果，接下来我们可以使用我们已经重写了的数组方法去操作数组，查看能不能监测到变化：\n\n```\nvar callback = function(newVal, oldVal){\n    alert('新值：' + newVal + '----' + '旧值：' + oldVal);\n};\n\nvar data = {\n    a: 200,\n    level1: {\n        b: 'str',\n        c: [{w: 90}, 2, 3],\n        level2: {\n            d: 90\n        }\n    }\n}\n\nvar j = new Jsonob(data, callback);\n\ndata.level1.c.push(4);\n```\n\n在浏览器中可以看到，我们的代码按照预期运行了：\n\n![图1](http://7xlolm.com1.z0.glb.clouddn.com/20160501h.jpg)\n\n直到现在，我们可以几乎完美的监测到数据对象的变化了，并且能够知道变化前后的旧值与新值，那么这样就结束了吗？当然不是，我们可以回顾一下当我们修改数据对象的时候，我们的确能够获取到新值和旧值，但是也仅此而已，我们并不知道修改的是哪个属性，但是能够知道修改的哪个属性对于我们是相当重要的。\n\n比如MVVM中，当数据对象改变时，要去更新模板，而模板到数据之间的关系，是通过数据对象下的某个字段名称进行绑定的，举个简单的例子，比如我们有如下模板：\n\n```\n<div id=\"box\">\n    <div>{{name}}</div>\n    <div>{{age}}</div>\n    <div>{{sex}}</div>\n</div>\n```\n\n然后我们有如下数据：\n\n```\nvar data = {\n    name : 'hcy',\n    age : 20,\n    sex : '男'\n}\n```\n\n最后我们通过 viewModule 简历模板和数据的关系：\n\n```\nnew Jsonob(document.getElementById('box'), data);\n```\n\n那么当我们的数据模型data中的某个属性改变的时候，比如 data.name = 'fuck'，如若我们不知道改变的字段名称，那么我们就无法得知要刷新哪部分模板，我们只能对模板进行完全更新，这并不是一个好的设计，性能会很差，所以回到我们最初的问题，当数据对象发生改变的时候，我们得知变化的属性的名称是很必要的，但是现在我们的 Jsonob 库还不能完成这样的任务，所以我们要进一步完善。\n\n在完善之前，我们要提出一个路径的概念，所谓路径，就是变化的字段的路径，比如有如下数据模型：\n\n```\nvar data = {\n    a : {\n        b : {\n            c : 'hcy'\n        }\n    }\n}\n```\n\n那么字段 a 的路径就是用 data.a ，b 的路径就是 data.a.b，c 的路径就是 data.a.b.c。有的时候我们也可以用数组或者字符串来表述路径，至于用什么来表述路径并不重要，重要的是我们能够获取到路径，比如用数组表述路径可以这样：\n\n1、 a 的路径是 ['data', 'a']\n1、 b 的路径是 ['data', 'a', 'b']\n1、 c 的路径是 ['data', 'a', 'b', 'c']\n\n有了路径的概念后，我们就可以继续完善 Jsonob 库了，我们在存储路径的时候选择的是数组表示，用数组存储路径，我们修改Jsonob库代码，修改了 observe 方法和 overrideArrayProto 方法，如下图，我做了所有修改的标注：\n\n![修改observe方法](http://7xlolm.com1.z0.glb.clouddn.com/20160501n.jpg)\n\n![修改overrideArrayProto方法](http://7xlolm.com1.z0.glb.clouddn.com/20160501m.jpg)\n\n最后，让我们再次尝试修改一切数组属性：\n\n```\nvar callback = function(newVal, oldVal, path){\n    alert('新值：' + newVal + '----' + '旧值：' + oldVal + '----路径：' + path);\n};\n\nvar data = {\n    a: 200,\n    level1: {\n        b: 'str',\n        c: [{w: 90}, 2, 3],\n        level2: {\n            d: 90\n        }\n    }\n}\n\nvar j = new Jsonob(data, callback);\n\ndata.level1.c.push(4);              // 向数组 data.level1.c 中push一个元素\ndata.level1.c[0].w = 100;           // 修改数组 data.level1.c[0].w 的值\ndata.level1.b = 'sss';              // 修改 data.level1.b 的值\ndata.level1.level2.d = 'msn';       // 修改 data.level1.level2.d 的值\n```\n\n我们修改了四个属性的值，然后我们在回调函数中接收了 path 参数，这样当数据模型变化的时候，我们不仅能够获取到新旧值，还能够知道是哪个属性发生了变化，这样我们就可以相应的做一些其他的事情，比如MVVM中的更新关联的视图，就可以做到了。最后我们刷新浏览器来产看弹出框：\n\n![一](http://7xlolm.com1.z0.glb.clouddn.com/20160501aa.jpg)\n\n![二](http://7xlolm.com1.z0.glb.clouddn.com/20160501ab.jpg)\n\n![三](http://7xlolm.com1.z0.glb.clouddn.com/20160501ac.jpg)\n\n![四](http://7xlolm.com1.z0.glb.clouddn.com/20160501ad.jpg)\n\n图中我用红色圈标出了变化属性的路径，由于我们的路径是数组标示的，所以看上去是以逗号“,”隔开的，现在，我们就算完成了这个迷你库，相信读者也有自己的实现思路，笔者水平有限，如果哪里有欠缺还希望大家指正，共同进步。\n\n\n\n","slug":"JavaScript实现MVVM之我就是想监测一个普通对象的变化","published":1,"updated":"2016-05-16T11:31:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj669fskd001newfct4icfw84","content":"<p>我的博客始终都有一个特点，就是喜欢从0开始，努力让小白都能看的明白，即使看不明白，也能知道整体的来龙去脉，这篇博客依然秉承着这个风格。<br>以MVVM模式为主线去实现的JavaScript框架非常流行，诸如 angular、Ember、Polymer、vue 等等，它们的一个特点就是数据的双向绑定。这对于小白来说就像变魔术一样，但无论对谁来讲，当你看到一个令你感兴趣的魔术，那么揭秘它总是能吸引你的眼球。<br>这篇文章主要讲述MVVM实现中的一部分：如何监测数据的变化。</p>\n<a id=\"more\"></a>\n<blockquote>\n<p>注：本篇文章将生产出一个迷你库，代码托管在 <a href=\"https://github.com/HcySunYang/jsonob\" target=\"_blank\" rel=\"external\">https://github.com/HcySunYang/jsonob</a>，由于本篇文章代码采用ES6编写，所以不能直接在浏览器下运行，读者在实践的时候可以采用该仓库的代码，clone仓库后：<br>1、安装依赖<br>npm install<br>2、构建项目<br>npm run build<br>3、使用浏览器打开 test/index.html 查看运行结果</p>\n</blockquote>\n<p>那么接下来我们要做什么呢？我们会实现一个迷你库，这个库的作用是监测一个普通对象的变化，并作出相应的通知。库的使用方法大致如下：</p>\n<pre><code>// 定义一个变化通知的回调\nvar callback = function(newVal, oldVal){\n    alert(newVal + &#39;----&#39; + oldVal);\n};\n\n// 定义一个普通对象作为数据模型\nvar data = {\n    a: 200,\n    level1: {\n        b: &#39;str&#39;,\n        c: [1, 2, 3],\n        level2: {\n            d: 90\n        }\n    }\n}\n\n// 实例化一个监测对象，去监测数据，并在数据发生改变的时候作出反应\nvar j = new Jsonob(data, callback);\n</code></pre><p>上面代码中，我们定义了一个 callback 回调函数，以及一个保存着普通json对象的变量 data ，最后实例化了一个 监测对象 ，对 data 进行变化监测，当变化发生的时候，执行给定的回调进行必要的变化通知，这样，我们通过一些手段就可以达到数据绑定的效果。</p>\n<h2 id=\"Object-defineProperty\"><a href=\"#Object-defineProperty\" class=\"headerlink\" title=\"Object.defineProperty\"></a>Object.defineProperty</h2><p>ES5 描述了属性的特征，提出对象的每个属性都有特定的描述符，你也可以理解为那是属性的属性。。。。。</p>\n<p>ES5把属性分成两种，一种是 数据属性， 一种是 访问器属性，我们可以使用 Object.defineProperty() 去定义一个数据属性或访问器属性。如下代码：</p>\n<pre><code>var obj = {};\n\nobj.name = &#39;hcy&#39;;\n</code></pre><p>上面的代码我们定义了一个对象，并给这个对象添加了一个属性 name，值为 ‘hcy’，我们也可以使用 Object.defineProperty() 来给对象定义属性，上面的代码等价于：</p>\n<pre><code>var obj = {};\n\nObject.defineProperty(obj, &#39;name&#39;, {\n    value: &#39;hcy&#39;,        // 属性的值\n    writable: true,        // 是否可写\n    enumerable: true,    // 是否能够通过for in 枚举\n    configurable: true    // 是否可使用 delete删除\n})\n</code></pre><p>这样我们就使用 Object.defineProperty 给对象定义了一个属性，这样的属性就是数据属性，我们也可以定义访问器属性：</p>\n<pre><code>var obj = {};\n\nObject.defineProperty(obj, &#39;age&#39;, {\n    get: function(){\n        return 20;\n    },\n    set: function(newVal){\n        this.age += 20;\n    }\n})\n</code></pre><p>访问器属性允许你定义一对儿 getter/setter ，当你读取属性值的时候底层会调用 get 方法，当你去设置属性值的时候，底层会调用 set 方法</p>\n<p>知道了这个就好办了，我们再回到最初的问题上面，如何检测一个普通对象的变化，我们可以这样做：</p>\n<blockquote>\n<p>遍历对象的属性，把对象的属性都使用 Object.defineProperty 转为  getter/setter ，这样，当我们修改一些值得时候，就会调用set方法，然后我们在set方法里面，回调通知，不就可以了吗，来看下面的代码：</p>\n</blockquote>\n<pre><code>// index.js\nconst OP = Object.prototype;\n\nexport class Jsonob{\n    constructor(obj, callback){\n        if(OP.toString.call(obj) !== &#39;[object Object]&#39;){\n            console.error(&#39;This parameter must be an object：&#39; + obj);\n        }\n        this.$callback = callback;\n        this.observe(obj);\n    }\n\n    observe(obj){\n        Object.keys(obj).forEach(function(key, index, keyArray){\n            var val = obj[key];\n            Object.defineProperty(obj, key, {\n                get: function(){\n                    return val;\n                },\n                set: (function(newVal){\n                    this.$callback(newVal);\n                }).bind(this)\n            });\n\n            if(OP.toString.call(obj[key]) === &#39;[object Object]&#39;){\n                this.observe(obj[key]);\n            }\n\n        }, this);\n\n    }\n}\n</code></pre><p>上面代码采用ES6编写，index.js文件中导出了一个 Jsonob 类，constructor构造函数中，我们保证了传入的对象是一个 {} 或 new Object() 生成的对象，接着缓存了回调函数，最后调用了原型下的 observe 方法。</p>\n<p>observe方法是真正实现监测属性的方法，我们使用 Object.keys(obj).forEach 循环obj所有可枚举的属性，使用 Object.defineProperty 将属性转换为访问器属性，然后判断属性的值是否是一个对象，如果是对象的话再进行递归调用，这样一来，我们就能保证一个复杂的普通json对象中的属性以及值为对象的属性的属性都转换成访问器属性。</p>\n<p>最后，在 Object.defineProperty 的 set 方法中，我们调用了指定的回调，并将新值作为参数进行传递。</p>\n<p>接下来我们编写一个测试代码，去测试一下上面的代码是否可以正常使用，在index.html中（<a href=\"https://github.com/HcySunYang/jsonob\" target=\"_blank\" rel=\"external\">读者可以clone文章开始阶段给出的仓库</a>），编写如下代码：</p>\n<pre><code>&lt;html&gt;\n    &lt;head&gt;\n        &lt;meta charset=&quot;utf-8&quot; /&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n\n        &lt;script src=&quot;../dist/jsonob.js&quot;&gt;&lt;/script&gt;\n        &lt;script&gt;\n            var Jsonob = Jsonob.Jsonob;\n\n            var callback = function(newVal){\n                alert(newVal);\n            };\n\n            var data = {\n                a: 200,\n                level1: {\n                    b: &#39;str&#39;,\n                    c: [1, 2, 3],\n                    level2: {\n                        d: 90\n                    }\n                }\n            }\n\n            var j = new Jsonob(data, callback);\n\n            data.a = 250;\n            data.level1.b = &#39;sss&#39;;\n            data.level1.level2.d = &#39;msn&#39;;\n        &lt;/script&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>上面代码，很接近我们文章开头要实现的目标。我们定义了回调(callback)和数据模型(data)，在回调中我们使用 alert 函数弹出新值，然后创建了一个监测实例并把数据和回调作为参数传递过去，然后我们试着修改data对象相面的属性以及子属性，看看代码是否按照我们预期的工作，打开浏览器，如下图</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20160428a.jpg\" alt=\"弹窗1\"><br><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/b.jpg\" alt=\"弹窗2\"><br><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/c.jpg\" alt=\"弹窗3\"></p>\n<p>可以看弹出三个对话框，这说明我们的代码正常工作了，无论是data对象的属性，还是子属性的改变，都能够监测到变化，并执行我们指定的回调。</p>\n<p>这样就结束了吗？可能细心的朋友可能已经意识到了，我们在检测到变化并通知回调时，只传递了一个新值(newVal)，但有的时候我们也需要旧值，但是以现在的程序来看，我们还无法传递旧值，所以我们要想办法。大家仔细看上面 index.js 中forEach循环里面的代码，有这样一段：</p>\n<pre><code>var val = obj[key];\nObject.defineProperty(obj, key, {\n    get: function(){\n        return val;\n    },\n    set: (function(newVal){\n        this.$callback(newVal);\n    }).bind(this)\n});\n</code></pre><p>实际上，val 变量所存储的，就是旧值，我们不妨把上面的代码修改成下面这样：</p>\n<pre><code>var oldVal = obj[key];\nObject.defineProperty(obj, key, {\n    get: function(){\n        return oldVal;\n    },\n    set: (function(newVal){\n        if(oldVal !== newVal){\n            if(OP.toString.call(newVal) === &#39;[object Object]&#39;){\n                this.observe(newVal);\n            }\n            this.$callback(newVal, oldVal);\n            oldVal = newVal;\n        }\n\n    }).bind(this)\n});\n</code></pre><p>我们将原来的 val 变量名字修改成 oldVal ，并在set方法中进行了更改判断，仅在值有更改的情况下去做一些事，当值有修改的时候，我们首先判断了新值是否是类似 {} 或 new Object() 形式的对象，如果是的话，我们要调用 this.observe 方法去监听一下新设置的值，然后在把旧值传递给回调函数之后更新一下旧值。</p>\n<p>接着修改 test/index.html 文件：</p>\n<pre><code>&lt;html&gt;\n    &lt;head&gt;\n        &lt;meta charset=&quot;utf-8&quot; /&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n\n        &lt;script src=&quot;../dist/jsonob.js&quot;&gt;&lt;/script&gt;\n        &lt;script&gt;\n            var Jsonob = Jsonob.Jsonob;\n\n            var callback = function(newVal, oldVal){\n                alert(&#39;新值：&#39; + newVal + &#39;----&#39; + &#39;旧值：&#39; + oldVal);\n            };\n\n            var data = {\n                a: 200,\n                level1: {\n                    b: &#39;str&#39;,\n                    c: [1, 2, 3],\n                    level2: {\n                        d: 90\n                    }\n                }\n            }\n\n            var j = new Jsonob(data, callback);\n\n            data.a = 250;\n            data.a = 260;\n        &lt;/script&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>我们在回调函数中接收了新值和旧值，在下面我们修改了 data.a 的值为 250，然后运行代码，查看浏览器的反馈：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20160428d.jpg\" alt=\"alert1\"></p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20160428e.jpg\" alt=\"alert1\"></p>\n<p>这样，我们完成了最最基本的普通对象变化监测库，接着，我们继续发现问题，我们回过头来看一下数据模型：</p>\n<pre><code>var data = {\n    a: 200,\n    level1: {\n        b: &#39;str&#39;,\n        c: [1, 2, 3],\n        level2: {\n            d: 90\n        }\n    }\n}\n</code></pre><p>我们可以发现， data.level1.c 的值为一个数组，数组在我们工作中肯定是一个非常常见的数据结构，当数组的元素发生改变的时候，也视为数据的改变，但遗憾的是，我们现在库还不能监测数组的变化，比如：</p>\n<pre><code>data.level1.c.push(4);\n</code></pre><p>我们向数组中push了一个元素，但是并不会触发改变。操作数组的方法有很多，比如：’push’, ‘pop’, ‘shift’, ‘unshift’, ‘splice’, ‘sort’, ‘reverse’ 等等。那么我们如何在使用这些方法操作数组的时候能够监听到变化呢？有这样一个思路，看图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20160501f.jpg\" alt=\"当你定义一个数组实例的时候，实例、实例的__proto__属性、Array构造函数、原型之间的关系\"></p>\n<p>上图显示了，当你通过 var arr1 = [] 或者 var arr1 = new Array() 语句创建一个数组实例的时候，实例、实例的<strong>proto</strong>属性、Array构造函数以及Array原型四者之间的关系。我们可以很容的发现，数组实例的<strong>proto</strong>属性，是Array.prototype的引用，当我们使用 arr1.push() 语句操作数组的时候，是调用原型下的push方法，那么我们可不可以重写原型的这些数组方法，在这些重写的方法里面去监听变化呢？答案是可以的，但是在实现之前，我们先思考一个问题，我们到底要怎么重写，比如我们重写一个数组push方法，向数组栈中推入一个元素，难道我们要这样去重写吗：</p>\n<pre><code>Array.prototype.push = function(){\n    // 你的实现方式\n}\n</code></pre><p>然后再一次实现其他的数组方法：</p>\n<pre><code>Array.prototype.pop = function(){\n    // 你的实现方式\n}\nArray.prototype.shift = function(){\n    // 你的实现方式\n}\n...\n</code></pre><p>这种实现是最不应该考虑的，暂且不说能不能全部实现的与原生无异，即使你实现的与原生方法在使用方式上一模一样，并且不影响其他代码的运行，那么在性能上，可能就与原生差很多了，我们可以在上面 数组实例以及数组构造函数和原型之间的关系图 中思考解决方案，我们可不可以在原型链中加一层，如下：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20160501g.jpg\" alt=\"思路\"></p>\n<p>如上图所示，我们在 arr1.<strong>proto</strong> 与 Array.prototype 之间的链条中添加了一环 fakePrototype (假的原型)，我们的思路是，在使用 push 等数组方法的时候，调用的是 fakePrototype 上的push方法，然后在 fakePrototype 方法中简介再去调用真正的Array原型上的 push 方法，同时监听变化，这样，我们很容易就能实现，完整代码如下：</p>\n<pre><code>/*\n *  Object 原型\n */\nconst OP = Object.prototype;\n/*\n *  需要重写的数组方法 OAR 是 overrideArrayMethod 的缩写\n */\nconst OAM = [&#39;push&#39;, &#39;pop&#39;, &#39;shift&#39;, &#39;unshift&#39;, &#39;splice&#39;, &#39;sort&#39;, &#39;reverse&#39;];\n\nexport class Jsonob{\n    constructor(obj, callback){\n        if(OP.toString.call(obj) !== &#39;[object Object]&#39;){\n            console.error(&#39;This parameter must be an object：&#39; + obj);\n        }\n        this.$callback = callback;\n        this.observe(obj);\n    }\n\n    observe(obj){\n        // 如果发现 监测的对象是数组的话就要调用 overrideArrayProto 方法\n        if(OP.toString.call(obj) === &#39;[object Array]&#39;){\n            this.overrideArrayProto(obj);\n        }\n        Object.keys(obj).forEach(function(key, index, keyArray){\n            var oldVal = obj[key];\n            Object.defineProperty(obj, key, {\n                get: function(){\n                    return oldVal;\n                },\n                set: (function(newVal){\n                    if(oldVal !== newVal){\n                        if(OP.toString.call(newVal) === &#39;[object Object]&#39; || OP.toString.call(newVal) === &#39;[object Array]&#39;){\n                            this.observe(newVal);\n                        }\n                        this.$callback(newVal, oldVal);\n                        oldVal = newVal;\n                    }\n\n                }).bind(this)\n            });\n\n            if(OP.toString.call(obj[key]) === &#39;[object Object]&#39; || OP.toString.call(obj[key]) === &#39;[object Array]&#39;){\n                this.observe(obj[key]);\n            }\n\n        }, this);\n\n    }\n\n    overrideArrayProto(array){\n            // 保存原始 Array 原型\n        var originalProto = Array.prototype,\n            // 通过 Object.create 方法创建一个对象，该对象的原型就是Array.prototype\n            overrideProto = Object.create(Array.prototype),\n            self = this,\n            result;\n        // 遍历要重写的数组方法\n        Object.keys(OAM).forEach(function(key, index, array){\n            var method = OAM[index],\n                oldArray = [];\n            // 使用 Object.defineProperty 给 overrideProto 添加属性，属性的名称是对应的数组函数名，值是函数\n            Object.defineProperty(overrideProto, method, {\n                value: function(){\n                    oldArray = this.slice(0);\n\n                    var arg = [].slice.apply(arguments);\n                    // 调用原始 原型 的数组方法\n                    result = originalProto[method].apply(this, arg);\n                    // 对新的数组进行监测\n                    self.observe(this);\n                    // 执行回调\n                    self.$callback(this, oldArray);\n\n                    return result;\n                },\n                writable: true,\n                enumerable: false,\n                configurable: true\n            });\n        }, this);\n\n        // 最后 让该数组实例的 __proto__ 属性指向 假的原型 overrideProto\n        array.__proto__ = overrideProto;\n\n    }\n}\n</code></pre><p>我们新增加了 overrideArrayProto 方法，并且在程序的最上面定义了一个常量 OAM ，用来定义要重写的数组方法，同时在 observe 方法中添加了对数组的判断，我们也允许了对数组的监听。接下来我们详细介绍一下 overrideArrayProto 方法。</p>\n<p>顾名思义，overrideArrayProto 这个方法是重写了 Array 的原型，在 overrideArrayProto 方法中，我们首先保存了数组的原始原型，然后创建了一个假的原型，然后遍历需要重新的数组方法，并将这些方法挂载到 overrideProto 上，我们可以看到，在挂载到 overrideProto 上的这些数组方法的里面，我们调用了原始的数组原型上的数组方法，最后，我们让数组实例的 <strong>proto</strong> 属性指向 overrideProto，这样，我们就实现了上图中的思路。并且完成了想要达到的效果，接下来我们可以使用我们已经重写了的数组方法去操作数组，查看能不能监测到变化：</p>\n<pre><code>var callback = function(newVal, oldVal){\n    alert(&#39;新值：&#39; + newVal + &#39;----&#39; + &#39;旧值：&#39; + oldVal);\n};\n\nvar data = {\n    a: 200,\n    level1: {\n        b: &#39;str&#39;,\n        c: [{w: 90}, 2, 3],\n        level2: {\n            d: 90\n        }\n    }\n}\n\nvar j = new Jsonob(data, callback);\n\ndata.level1.c.push(4);\n</code></pre><p>在浏览器中可以看到，我们的代码按照预期运行了：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20160501h.jpg\" alt=\"图1\"></p>\n<p>直到现在，我们可以几乎完美的监测到数据对象的变化了，并且能够知道变化前后的旧值与新值，那么这样就结束了吗？当然不是，我们可以回顾一下当我们修改数据对象的时候，我们的确能够获取到新值和旧值，但是也仅此而已，我们并不知道修改的是哪个属性，但是能够知道修改的哪个属性对于我们是相当重要的。</p>\n<p>比如MVVM中，当数据对象改变时，要去更新模板，而模板到数据之间的关系，是通过数据对象下的某个字段名称进行绑定的，举个简单的例子，比如我们有如下模板：</p>\n<pre><code>&lt;div id=&quot;box&quot;&gt;\n    &lt;div&gt;{{name}}&lt;/div&gt;\n    &lt;div&gt;{{age}}&lt;/div&gt;\n    &lt;div&gt;{{sex}}&lt;/div&gt;\n&lt;/div&gt;\n</code></pre><p>然后我们有如下数据：</p>\n<pre><code>var data = {\n    name : &#39;hcy&#39;,\n    age : 20,\n    sex : &#39;男&#39;\n}\n</code></pre><p>最后我们通过 viewModule 简历模板和数据的关系：</p>\n<pre><code>new Jsonob(document.getElementById(&#39;box&#39;), data);\n</code></pre><p>那么当我们的数据模型data中的某个属性改变的时候，比如 data.name = ‘fuck’，如若我们不知道改变的字段名称，那么我们就无法得知要刷新哪部分模板，我们只能对模板进行完全更新，这并不是一个好的设计，性能会很差，所以回到我们最初的问题，当数据对象发生改变的时候，我们得知变化的属性的名称是很必要的，但是现在我们的 Jsonob 库还不能完成这样的任务，所以我们要进一步完善。</p>\n<p>在完善之前，我们要提出一个路径的概念，所谓路径，就是变化的字段的路径，比如有如下数据模型：</p>\n<pre><code>var data = {\n    a : {\n        b : {\n            c : &#39;hcy&#39;\n        }\n    }\n}\n</code></pre><p>那么字段 a 的路径就是用 data.a ，b 的路径就是 data.a.b，c 的路径就是 data.a.b.c。有的时候我们也可以用数组或者字符串来表述路径，至于用什么来表述路径并不重要，重要的是我们能够获取到路径，比如用数组表述路径可以这样：</p>\n<p>1、 a 的路径是 [‘data’, ‘a’]<br>1、 b 的路径是 [‘data’, ‘a’, ‘b’]<br>1、 c 的路径是 [‘data’, ‘a’, ‘b’, ‘c’]</p>\n<p>有了路径的概念后，我们就可以继续完善 Jsonob 库了，我们在存储路径的时候选择的是数组表示，用数组存储路径，我们修改Jsonob库代码，修改了 observe 方法和 overrideArrayProto 方法，如下图，我做了所有修改的标注：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20160501n.jpg\" alt=\"修改observe方法\"></p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20160501m.jpg\" alt=\"修改overrideArrayProto方法\"></p>\n<p>最后，让我们再次尝试修改一切数组属性：</p>\n<pre><code>var callback = function(newVal, oldVal, path){\n    alert(&#39;新值：&#39; + newVal + &#39;----&#39; + &#39;旧值：&#39; + oldVal + &#39;----路径：&#39; + path);\n};\n\nvar data = {\n    a: 200,\n    level1: {\n        b: &#39;str&#39;,\n        c: [{w: 90}, 2, 3],\n        level2: {\n            d: 90\n        }\n    }\n}\n\nvar j = new Jsonob(data, callback);\n\ndata.level1.c.push(4);              // 向数组 data.level1.c 中push一个元素\ndata.level1.c[0].w = 100;           // 修改数组 data.level1.c[0].w 的值\ndata.level1.b = &#39;sss&#39;;              // 修改 data.level1.b 的值\ndata.level1.level2.d = &#39;msn&#39;;       // 修改 data.level1.level2.d 的值\n</code></pre><p>我们修改了四个属性的值，然后我们在回调函数中接收了 path 参数，这样当数据模型变化的时候，我们不仅能够获取到新旧值，还能够知道是哪个属性发生了变化，这样我们就可以相应的做一些其他的事情，比如MVVM中的更新关联的视图，就可以做到了。最后我们刷新浏览器来产看弹出框：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20160501aa.jpg\" alt=\"一\"></p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20160501ab.jpg\" alt=\"二\"></p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20160501ac.jpg\" alt=\"三\"></p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20160501ad.jpg\" alt=\"四\"></p>\n<p>图中我用红色圈标出了变化属性的路径，由于我们的路径是数组标示的，所以看上去是以逗号“,”隔开的，现在，我们就算完成了这个迷你库，相信读者也有自己的实现思路，笔者水平有限，如果哪里有欠缺还希望大家指正，共同进步。</p>\n","site":{"data":{}},"excerpt":"<p>我的博客始终都有一个特点，就是喜欢从0开始，努力让小白都能看的明白，即使看不明白，也能知道整体的来龙去脉，这篇博客依然秉承着这个风格。<br>以MVVM模式为主线去实现的JavaScript框架非常流行，诸如 angular、Ember、Polymer、vue 等等，它们的一个特点就是数据的双向绑定。这对于小白来说就像变魔术一样，但无论对谁来讲，当你看到一个令你感兴趣的魔术，那么揭秘它总是能吸引你的眼球。<br>这篇文章主要讲述MVVM实现中的一部分：如何监测数据的变化。</p>","more":"<blockquote>\n<p>注：本篇文章将生产出一个迷你库，代码托管在 <a href=\"https://github.com/HcySunYang/jsonob\" target=\"_blank\" rel=\"external\">https://github.com/HcySunYang/jsonob</a>，由于本篇文章代码采用ES6编写，所以不能直接在浏览器下运行，读者在实践的时候可以采用该仓库的代码，clone仓库后：<br>1、安装依赖<br>npm install<br>2、构建项目<br>npm run build<br>3、使用浏览器打开 test/index.html 查看运行结果</p>\n</blockquote>\n<p>那么接下来我们要做什么呢？我们会实现一个迷你库，这个库的作用是监测一个普通对象的变化，并作出相应的通知。库的使用方法大致如下：</p>\n<pre><code>// 定义一个变化通知的回调\nvar callback = function(newVal, oldVal){\n    alert(newVal + &#39;----&#39; + oldVal);\n};\n\n// 定义一个普通对象作为数据模型\nvar data = {\n    a: 200,\n    level1: {\n        b: &#39;str&#39;,\n        c: [1, 2, 3],\n        level2: {\n            d: 90\n        }\n    }\n}\n\n// 实例化一个监测对象，去监测数据，并在数据发生改变的时候作出反应\nvar j = new Jsonob(data, callback);\n</code></pre><p>上面代码中，我们定义了一个 callback 回调函数，以及一个保存着普通json对象的变量 data ，最后实例化了一个 监测对象 ，对 data 进行变化监测，当变化发生的时候，执行给定的回调进行必要的变化通知，这样，我们通过一些手段就可以达到数据绑定的效果。</p>\n<h2 id=\"Object-defineProperty\"><a href=\"#Object-defineProperty\" class=\"headerlink\" title=\"Object.defineProperty\"></a>Object.defineProperty</h2><p>ES5 描述了属性的特征，提出对象的每个属性都有特定的描述符，你也可以理解为那是属性的属性。。。。。</p>\n<p>ES5把属性分成两种，一种是 数据属性， 一种是 访问器属性，我们可以使用 Object.defineProperty() 去定义一个数据属性或访问器属性。如下代码：</p>\n<pre><code>var obj = {};\n\nobj.name = &#39;hcy&#39;;\n</code></pre><p>上面的代码我们定义了一个对象，并给这个对象添加了一个属性 name，值为 ‘hcy’，我们也可以使用 Object.defineProperty() 来给对象定义属性，上面的代码等价于：</p>\n<pre><code>var obj = {};\n\nObject.defineProperty(obj, &#39;name&#39;, {\n    value: &#39;hcy&#39;,        // 属性的值\n    writable: true,        // 是否可写\n    enumerable: true,    // 是否能够通过for in 枚举\n    configurable: true    // 是否可使用 delete删除\n})\n</code></pre><p>这样我们就使用 Object.defineProperty 给对象定义了一个属性，这样的属性就是数据属性，我们也可以定义访问器属性：</p>\n<pre><code>var obj = {};\n\nObject.defineProperty(obj, &#39;age&#39;, {\n    get: function(){\n        return 20;\n    },\n    set: function(newVal){\n        this.age += 20;\n    }\n})\n</code></pre><p>访问器属性允许你定义一对儿 getter/setter ，当你读取属性值的时候底层会调用 get 方法，当你去设置属性值的时候，底层会调用 set 方法</p>\n<p>知道了这个就好办了，我们再回到最初的问题上面，如何检测一个普通对象的变化，我们可以这样做：</p>\n<blockquote>\n<p>遍历对象的属性，把对象的属性都使用 Object.defineProperty 转为  getter/setter ，这样，当我们修改一些值得时候，就会调用set方法，然后我们在set方法里面，回调通知，不就可以了吗，来看下面的代码：</p>\n</blockquote>\n<pre><code>// index.js\nconst OP = Object.prototype;\n\nexport class Jsonob{\n    constructor(obj, callback){\n        if(OP.toString.call(obj) !== &#39;[object Object]&#39;){\n            console.error(&#39;This parameter must be an object：&#39; + obj);\n        }\n        this.$callback = callback;\n        this.observe(obj);\n    }\n\n    observe(obj){\n        Object.keys(obj).forEach(function(key, index, keyArray){\n            var val = obj[key];\n            Object.defineProperty(obj, key, {\n                get: function(){\n                    return val;\n                },\n                set: (function(newVal){\n                    this.$callback(newVal);\n                }).bind(this)\n            });\n\n            if(OP.toString.call(obj[key]) === &#39;[object Object]&#39;){\n                this.observe(obj[key]);\n            }\n\n        }, this);\n\n    }\n}\n</code></pre><p>上面代码采用ES6编写，index.js文件中导出了一个 Jsonob 类，constructor构造函数中，我们保证了传入的对象是一个 {} 或 new Object() 生成的对象，接着缓存了回调函数，最后调用了原型下的 observe 方法。</p>\n<p>observe方法是真正实现监测属性的方法，我们使用 Object.keys(obj).forEach 循环obj所有可枚举的属性，使用 Object.defineProperty 将属性转换为访问器属性，然后判断属性的值是否是一个对象，如果是对象的话再进行递归调用，这样一来，我们就能保证一个复杂的普通json对象中的属性以及值为对象的属性的属性都转换成访问器属性。</p>\n<p>最后，在 Object.defineProperty 的 set 方法中，我们调用了指定的回调，并将新值作为参数进行传递。</p>\n<p>接下来我们编写一个测试代码，去测试一下上面的代码是否可以正常使用，在index.html中（<a href=\"https://github.com/HcySunYang/jsonob\" target=\"_blank\" rel=\"external\">读者可以clone文章开始阶段给出的仓库</a>），编写如下代码：</p>\n<pre><code>&lt;html&gt;\n    &lt;head&gt;\n        &lt;meta charset=&quot;utf-8&quot; /&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n\n        &lt;script src=&quot;../dist/jsonob.js&quot;&gt;&lt;/script&gt;\n        &lt;script&gt;\n            var Jsonob = Jsonob.Jsonob;\n\n            var callback = function(newVal){\n                alert(newVal);\n            };\n\n            var data = {\n                a: 200,\n                level1: {\n                    b: &#39;str&#39;,\n                    c: [1, 2, 3],\n                    level2: {\n                        d: 90\n                    }\n                }\n            }\n\n            var j = new Jsonob(data, callback);\n\n            data.a = 250;\n            data.level1.b = &#39;sss&#39;;\n            data.level1.level2.d = &#39;msn&#39;;\n        &lt;/script&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>上面代码，很接近我们文章开头要实现的目标。我们定义了回调(callback)和数据模型(data)，在回调中我们使用 alert 函数弹出新值，然后创建了一个监测实例并把数据和回调作为参数传递过去，然后我们试着修改data对象相面的属性以及子属性，看看代码是否按照我们预期的工作，打开浏览器，如下图</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20160428a.jpg\" alt=\"弹窗1\"><br><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/b.jpg\" alt=\"弹窗2\"><br><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/c.jpg\" alt=\"弹窗3\"></p>\n<p>可以看弹出三个对话框，这说明我们的代码正常工作了，无论是data对象的属性，还是子属性的改变，都能够监测到变化，并执行我们指定的回调。</p>\n<p>这样就结束了吗？可能细心的朋友可能已经意识到了，我们在检测到变化并通知回调时，只传递了一个新值(newVal)，但有的时候我们也需要旧值，但是以现在的程序来看，我们还无法传递旧值，所以我们要想办法。大家仔细看上面 index.js 中forEach循环里面的代码，有这样一段：</p>\n<pre><code>var val = obj[key];\nObject.defineProperty(obj, key, {\n    get: function(){\n        return val;\n    },\n    set: (function(newVal){\n        this.$callback(newVal);\n    }).bind(this)\n});\n</code></pre><p>实际上，val 变量所存储的，就是旧值，我们不妨把上面的代码修改成下面这样：</p>\n<pre><code>var oldVal = obj[key];\nObject.defineProperty(obj, key, {\n    get: function(){\n        return oldVal;\n    },\n    set: (function(newVal){\n        if(oldVal !== newVal){\n            if(OP.toString.call(newVal) === &#39;[object Object]&#39;){\n                this.observe(newVal);\n            }\n            this.$callback(newVal, oldVal);\n            oldVal = newVal;\n        }\n\n    }).bind(this)\n});\n</code></pre><p>我们将原来的 val 变量名字修改成 oldVal ，并在set方法中进行了更改判断，仅在值有更改的情况下去做一些事，当值有修改的时候，我们首先判断了新值是否是类似 {} 或 new Object() 形式的对象，如果是的话，我们要调用 this.observe 方法去监听一下新设置的值，然后在把旧值传递给回调函数之后更新一下旧值。</p>\n<p>接着修改 test/index.html 文件：</p>\n<pre><code>&lt;html&gt;\n    &lt;head&gt;\n        &lt;meta charset=&quot;utf-8&quot; /&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n\n        &lt;script src=&quot;../dist/jsonob.js&quot;&gt;&lt;/script&gt;\n        &lt;script&gt;\n            var Jsonob = Jsonob.Jsonob;\n\n            var callback = function(newVal, oldVal){\n                alert(&#39;新值：&#39; + newVal + &#39;----&#39; + &#39;旧值：&#39; + oldVal);\n            };\n\n            var data = {\n                a: 200,\n                level1: {\n                    b: &#39;str&#39;,\n                    c: [1, 2, 3],\n                    level2: {\n                        d: 90\n                    }\n                }\n            }\n\n            var j = new Jsonob(data, callback);\n\n            data.a = 250;\n            data.a = 260;\n        &lt;/script&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>我们在回调函数中接收了新值和旧值，在下面我们修改了 data.a 的值为 250，然后运行代码，查看浏览器的反馈：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20160428d.jpg\" alt=\"alert1\"></p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20160428e.jpg\" alt=\"alert1\"></p>\n<p>这样，我们完成了最最基本的普通对象变化监测库，接着，我们继续发现问题，我们回过头来看一下数据模型：</p>\n<pre><code>var data = {\n    a: 200,\n    level1: {\n        b: &#39;str&#39;,\n        c: [1, 2, 3],\n        level2: {\n            d: 90\n        }\n    }\n}\n</code></pre><p>我们可以发现， data.level1.c 的值为一个数组，数组在我们工作中肯定是一个非常常见的数据结构，当数组的元素发生改变的时候，也视为数据的改变，但遗憾的是，我们现在库还不能监测数组的变化，比如：</p>\n<pre><code>data.level1.c.push(4);\n</code></pre><p>我们向数组中push了一个元素，但是并不会触发改变。操作数组的方法有很多，比如：’push’, ‘pop’, ‘shift’, ‘unshift’, ‘splice’, ‘sort’, ‘reverse’ 等等。那么我们如何在使用这些方法操作数组的时候能够监听到变化呢？有这样一个思路，看图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20160501f.jpg\" alt=\"当你定义一个数组实例的时候，实例、实例的__proto__属性、Array构造函数、原型之间的关系\"></p>\n<p>上图显示了，当你通过 var arr1 = [] 或者 var arr1 = new Array() 语句创建一个数组实例的时候，实例、实例的<strong>proto</strong>属性、Array构造函数以及Array原型四者之间的关系。我们可以很容的发现，数组实例的<strong>proto</strong>属性，是Array.prototype的引用，当我们使用 arr1.push() 语句操作数组的时候，是调用原型下的push方法，那么我们可不可以重写原型的这些数组方法，在这些重写的方法里面去监听变化呢？答案是可以的，但是在实现之前，我们先思考一个问题，我们到底要怎么重写，比如我们重写一个数组push方法，向数组栈中推入一个元素，难道我们要这样去重写吗：</p>\n<pre><code>Array.prototype.push = function(){\n    // 你的实现方式\n}\n</code></pre><p>然后再一次实现其他的数组方法：</p>\n<pre><code>Array.prototype.pop = function(){\n    // 你的实现方式\n}\nArray.prototype.shift = function(){\n    // 你的实现方式\n}\n...\n</code></pre><p>这种实现是最不应该考虑的，暂且不说能不能全部实现的与原生无异，即使你实现的与原生方法在使用方式上一模一样，并且不影响其他代码的运行，那么在性能上，可能就与原生差很多了，我们可以在上面 数组实例以及数组构造函数和原型之间的关系图 中思考解决方案，我们可不可以在原型链中加一层，如下：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20160501g.jpg\" alt=\"思路\"></p>\n<p>如上图所示，我们在 arr1.<strong>proto</strong> 与 Array.prototype 之间的链条中添加了一环 fakePrototype (假的原型)，我们的思路是，在使用 push 等数组方法的时候，调用的是 fakePrototype 上的push方法，然后在 fakePrototype 方法中简介再去调用真正的Array原型上的 push 方法，同时监听变化，这样，我们很容易就能实现，完整代码如下：</p>\n<pre><code>/*\n *  Object 原型\n */\nconst OP = Object.prototype;\n/*\n *  需要重写的数组方法 OAR 是 overrideArrayMethod 的缩写\n */\nconst OAM = [&#39;push&#39;, &#39;pop&#39;, &#39;shift&#39;, &#39;unshift&#39;, &#39;splice&#39;, &#39;sort&#39;, &#39;reverse&#39;];\n\nexport class Jsonob{\n    constructor(obj, callback){\n        if(OP.toString.call(obj) !== &#39;[object Object]&#39;){\n            console.error(&#39;This parameter must be an object：&#39; + obj);\n        }\n        this.$callback = callback;\n        this.observe(obj);\n    }\n\n    observe(obj){\n        // 如果发现 监测的对象是数组的话就要调用 overrideArrayProto 方法\n        if(OP.toString.call(obj) === &#39;[object Array]&#39;){\n            this.overrideArrayProto(obj);\n        }\n        Object.keys(obj).forEach(function(key, index, keyArray){\n            var oldVal = obj[key];\n            Object.defineProperty(obj, key, {\n                get: function(){\n                    return oldVal;\n                },\n                set: (function(newVal){\n                    if(oldVal !== newVal){\n                        if(OP.toString.call(newVal) === &#39;[object Object]&#39; || OP.toString.call(newVal) === &#39;[object Array]&#39;){\n                            this.observe(newVal);\n                        }\n                        this.$callback(newVal, oldVal);\n                        oldVal = newVal;\n                    }\n\n                }).bind(this)\n            });\n\n            if(OP.toString.call(obj[key]) === &#39;[object Object]&#39; || OP.toString.call(obj[key]) === &#39;[object Array]&#39;){\n                this.observe(obj[key]);\n            }\n\n        }, this);\n\n    }\n\n    overrideArrayProto(array){\n            // 保存原始 Array 原型\n        var originalProto = Array.prototype,\n            // 通过 Object.create 方法创建一个对象，该对象的原型就是Array.prototype\n            overrideProto = Object.create(Array.prototype),\n            self = this,\n            result;\n        // 遍历要重写的数组方法\n        Object.keys(OAM).forEach(function(key, index, array){\n            var method = OAM[index],\n                oldArray = [];\n            // 使用 Object.defineProperty 给 overrideProto 添加属性，属性的名称是对应的数组函数名，值是函数\n            Object.defineProperty(overrideProto, method, {\n                value: function(){\n                    oldArray = this.slice(0);\n\n                    var arg = [].slice.apply(arguments);\n                    // 调用原始 原型 的数组方法\n                    result = originalProto[method].apply(this, arg);\n                    // 对新的数组进行监测\n                    self.observe(this);\n                    // 执行回调\n                    self.$callback(this, oldArray);\n\n                    return result;\n                },\n                writable: true,\n                enumerable: false,\n                configurable: true\n            });\n        }, this);\n\n        // 最后 让该数组实例的 __proto__ 属性指向 假的原型 overrideProto\n        array.__proto__ = overrideProto;\n\n    }\n}\n</code></pre><p>我们新增加了 overrideArrayProto 方法，并且在程序的最上面定义了一个常量 OAM ，用来定义要重写的数组方法，同时在 observe 方法中添加了对数组的判断，我们也允许了对数组的监听。接下来我们详细介绍一下 overrideArrayProto 方法。</p>\n<p>顾名思义，overrideArrayProto 这个方法是重写了 Array 的原型，在 overrideArrayProto 方法中，我们首先保存了数组的原始原型，然后创建了一个假的原型，然后遍历需要重新的数组方法，并将这些方法挂载到 overrideProto 上，我们可以看到，在挂载到 overrideProto 上的这些数组方法的里面，我们调用了原始的数组原型上的数组方法，最后，我们让数组实例的 <strong>proto</strong> 属性指向 overrideProto，这样，我们就实现了上图中的思路。并且完成了想要达到的效果，接下来我们可以使用我们已经重写了的数组方法去操作数组，查看能不能监测到变化：</p>\n<pre><code>var callback = function(newVal, oldVal){\n    alert(&#39;新值：&#39; + newVal + &#39;----&#39; + &#39;旧值：&#39; + oldVal);\n};\n\nvar data = {\n    a: 200,\n    level1: {\n        b: &#39;str&#39;,\n        c: [{w: 90}, 2, 3],\n        level2: {\n            d: 90\n        }\n    }\n}\n\nvar j = new Jsonob(data, callback);\n\ndata.level1.c.push(4);\n</code></pre><p>在浏览器中可以看到，我们的代码按照预期运行了：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20160501h.jpg\" alt=\"图1\"></p>\n<p>直到现在，我们可以几乎完美的监测到数据对象的变化了，并且能够知道变化前后的旧值与新值，那么这样就结束了吗？当然不是，我们可以回顾一下当我们修改数据对象的时候，我们的确能够获取到新值和旧值，但是也仅此而已，我们并不知道修改的是哪个属性，但是能够知道修改的哪个属性对于我们是相当重要的。</p>\n<p>比如MVVM中，当数据对象改变时，要去更新模板，而模板到数据之间的关系，是通过数据对象下的某个字段名称进行绑定的，举个简单的例子，比如我们有如下模板：</p>\n<pre><code>&lt;div id=&quot;box&quot;&gt;\n    &lt;div&gt;{{name}}&lt;/div&gt;\n    &lt;div&gt;{{age}}&lt;/div&gt;\n    &lt;div&gt;{{sex}}&lt;/div&gt;\n&lt;/div&gt;\n</code></pre><p>然后我们有如下数据：</p>\n<pre><code>var data = {\n    name : &#39;hcy&#39;,\n    age : 20,\n    sex : &#39;男&#39;\n}\n</code></pre><p>最后我们通过 viewModule 简历模板和数据的关系：</p>\n<pre><code>new Jsonob(document.getElementById(&#39;box&#39;), data);\n</code></pre><p>那么当我们的数据模型data中的某个属性改变的时候，比如 data.name = ‘fuck’，如若我们不知道改变的字段名称，那么我们就无法得知要刷新哪部分模板，我们只能对模板进行完全更新，这并不是一个好的设计，性能会很差，所以回到我们最初的问题，当数据对象发生改变的时候，我们得知变化的属性的名称是很必要的，但是现在我们的 Jsonob 库还不能完成这样的任务，所以我们要进一步完善。</p>\n<p>在完善之前，我们要提出一个路径的概念，所谓路径，就是变化的字段的路径，比如有如下数据模型：</p>\n<pre><code>var data = {\n    a : {\n        b : {\n            c : &#39;hcy&#39;\n        }\n    }\n}\n</code></pre><p>那么字段 a 的路径就是用 data.a ，b 的路径就是 data.a.b，c 的路径就是 data.a.b.c。有的时候我们也可以用数组或者字符串来表述路径，至于用什么来表述路径并不重要，重要的是我们能够获取到路径，比如用数组表述路径可以这样：</p>\n<p>1、 a 的路径是 [‘data’, ‘a’]<br>1、 b 的路径是 [‘data’, ‘a’, ‘b’]<br>1、 c 的路径是 [‘data’, ‘a’, ‘b’, ‘c’]</p>\n<p>有了路径的概念后，我们就可以继续完善 Jsonob 库了，我们在存储路径的时候选择的是数组表示，用数组存储路径，我们修改Jsonob库代码，修改了 observe 方法和 overrideArrayProto 方法，如下图，我做了所有修改的标注：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20160501n.jpg\" alt=\"修改observe方法\"></p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20160501m.jpg\" alt=\"修改overrideArrayProto方法\"></p>\n<p>最后，让我们再次尝试修改一切数组属性：</p>\n<pre><code>var callback = function(newVal, oldVal, path){\n    alert(&#39;新值：&#39; + newVal + &#39;----&#39; + &#39;旧值：&#39; + oldVal + &#39;----路径：&#39; + path);\n};\n\nvar data = {\n    a: 200,\n    level1: {\n        b: &#39;str&#39;,\n        c: [{w: 90}, 2, 3],\n        level2: {\n            d: 90\n        }\n    }\n}\n\nvar j = new Jsonob(data, callback);\n\ndata.level1.c.push(4);              // 向数组 data.level1.c 中push一个元素\ndata.level1.c[0].w = 100;           // 修改数组 data.level1.c[0].w 的值\ndata.level1.b = &#39;sss&#39;;              // 修改 data.level1.b 的值\ndata.level1.level2.d = &#39;msn&#39;;       // 修改 data.level1.level2.d 的值\n</code></pre><p>我们修改了四个属性的值，然后我们在回调函数中接收了 path 参数，这样当数据模型变化的时候，我们不仅能够获取到新旧值，还能够知道是哪个属性发生了变化，这样我们就可以相应的做一些其他的事情，比如MVVM中的更新关联的视图，就可以做到了。最后我们刷新浏览器来产看弹出框：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20160501aa.jpg\" alt=\"一\"></p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20160501ab.jpg\" alt=\"二\"></p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20160501ac.jpg\" alt=\"三\"></p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/20160501ad.jpg\" alt=\"四\"></p>\n<p>图中我用红色圈标出了变化属性的路径，由于我们的路径是数组标示的，所以看上去是以逗号“,”隔开的，现在，我们就算完成了这个迷你库，相信读者也有自己的实现思路，笔者水平有限，如果哪里有欠缺还希望大家指正，共同进步。</p>"},{"title":"js Worker API 在倒计时中的使用","date":"2016-07-11T09:33:17.000Z","_content":"\n在做开发的时候，倒计时的需求是很常见的，比如订单待提交和待支付都会有倒计时，市面上的兼职软件在领取任务后都会有倒计时，登录注册中获取验证码的时候也会有倒计时，有的页面只有一个倒计时，而有的页面作为列表页，列表中的每一项都会有倒计时，今天就来聊聊 Worker API 在js倒计时中的使用，以及为什么要使用 Worker 来做倒计时\n\n<!-- more -->\n\n# setInterval 或 setTimeout 的问题 #\n\n当提到js的倒计时功能时，我想你第一个想到的可能就是 setInterval 这个东东，这个东西在做PC页面的时候并没有什么问题，至少我现在还没遇到什么问题，而当你在移动页面中使用它来做倒计时的时候，就会出问题了，具体来说，是在做ios中的移动页面开发的时候，问题就尤为明显了，我们有以下代码：\n\n```\n<body>\n\n    <div id=\"box\">60</div>\n\n    <script>\n\n    var box = document.getElementById('box');\n    var num = 60;\n\n    var T = setInterval(function(){\n        \n        box.innerHTML = --num;\n        if(num <= 0){\n            clearInterval(T);\n        }\n\n    }, 1000);\n        \n    </script>\n</body>\n```\n\n上面的代码很简单，就是一个60秒的倒计时程序，我们使用 setInterval 来完成，这段代码在PC中可以正常运行，在Android中也可以正常运行，但是拿到ios中，就会有一个问题，来看图：\n\n![时间停止](http://7xlolm.com1.z0.glb.clouddn.com/201607114.gif)\n\n上图中，当倒计时走到37的时候，用手拖动页面，这个时候js代码会被阻塞，导致倒计时不在执行，这个现象很常见，比如当你和朋友玩微信的时候，互相发送自定义表情的gif图的时候，当你滚动聊天界面时，你会发现gif图也会静止，这个问题是ios系统机制的问题，我们没办法从根本上解决，但这并不是最关键的，大家可以发现，在倒计时走到37的时候，用手指操作页面大概有两三面的时间，按正常来讲，时间应该倒计时到 35秒或者34秒，但是图中很清楚的可以看到，在手指停止操作后，时间却从37秒继续倒计时，走到了36秒，这就与时间的倒计时时间造成了差距，假如倒计时的页面很长，比如一个列表页，那么用户在滑动查看页面信心的时候，会造成更多的倒计时延迟，这在一些要求比较精准的倒计时应用中，简直是不允许出现的，虽然后端也会做一层校验。\n\n这个就是我们要说的问题，与其说是 setInterval 或者 setTimeout 的问题，倒不如说是 ios 系统的问题，那么有办法解决这个问题吗？这就是我们要谈到的 Worker API。\n\n# Worker API #\n\nweb Worker API 允许 JavaScript 在后台运行，浏览器实现 Worker API 的方式有很多，每个浏览器厂家可能不尽相同，他们可以使用现线程或后台进程等，这使得 js 代码不被UI线程阻塞，二者互不影响，特别是面对计算量比较大的任务的时候，会给应用程序带来性能上的提升。\n\nweb Worker API 的使用很简单，大家可以自行查询相关书籍或博客。相信聪明的你10分钟就能搞定。\n\n# 使用 Worker 解决问题 #\n\n我们的思路是，将倒计时的计算放到一个单独的文件里，使用 Worder 去执行这个文件，是不是就可以了呢？\n\n新建一个 countdown.js 文件：\n\n```\nself.onmessage = function(event){\n\tvar num = event.data;\n\n\tvar T = setInterval(function(){\n\t\t\n        self.postMessage(--num);\n        if(num <= 0){\n            clearInterval(T);\n            self.close();\n        }\n\n    }, 1000);\n}\n```\n\n上面的代码很简单，在 countdown.js 中，由于这个js文件是由 Worker 来在后台执行的文件，所以这个文件内代码的 self 指向的就是 Worker 对象。我们通过 onmessage 时间接收来自页面的倒计时数值，然后原封不动的把之前的倒计时代码拷贝过来，唯一不同的就是使用 self.close() 语句来关闭 Worker。\n\n然后修改之前的页面文件如下：\n\n```\n<body>\n\n    <div id=\"box\">60</div>\n\n    <script>\n\n    var box = document.getElementById('box');\n\n    var w = new Worker('countdown.js');\n\n    w.postMessage(60);\n\n    w.onmessage = function(event){\n        box.innerHTML = event.data;\n    }\n        \n    </script>\n</body>\n```\n\n在PC中刷新你的页面，可以看到依然正确工作，之后再拿到ios中做之前gif图同样的操作，如下图：\n\n![倒计时继续](http://7xlolm.com1.z0.glb.clouddn.com/2016071144.gif)\n\n我们可以看到，在55秒的时候开始拖动页面，这个时候倒计时停止了，不过，当我们放手之后，倒计时会立刻恢复到正常应该到达的时刻，而不会产生任何误差和延迟，这样，我们就比较完美的解决了这个问题。\n\n# 需要注意的地方 #\n\n在列表页面中，可能会有很多个倒计时，并且每个倒计时的开始时间不尽相同，但切记不要通过循环去 new 很多个 Worker 出来，这样可能会导致应用卡死，特别是如果在做 Hybrid App 中的 H5 页面时，可能会造成闪退，所以你只能 new 一个 Worker 对象出来，然后使用这一个 Worker 对象去做所有列表时间的倒计时，然后在更新视图中使用循环去更新，这样就不会有问题了，另外一个需要注意的是，有些Android机型中的webview不支持 web Worker 。这个时候仅仅去使用 setInterval 就可以了，因为在Android中不存在ios中那种阻塞的情况。\n\n以上就是这篇博客的内容，希望对大家有所帮助 = =。\n\n","source":"_posts/2016/07/11/js-Worker-API-在倒计时中的使用.md","raw":"title: js Worker API 在倒计时中的使用\ndate: 2016-07-11 17:33:17\ncategories:\n- WebFrontEnd\ntags:\n- Worker\n---\n\n在做开发的时候，倒计时的需求是很常见的，比如订单待提交和待支付都会有倒计时，市面上的兼职软件在领取任务后都会有倒计时，登录注册中获取验证码的时候也会有倒计时，有的页面只有一个倒计时，而有的页面作为列表页，列表中的每一项都会有倒计时，今天就来聊聊 Worker API 在js倒计时中的使用，以及为什么要使用 Worker 来做倒计时\n\n<!-- more -->\n\n# setInterval 或 setTimeout 的问题 #\n\n当提到js的倒计时功能时，我想你第一个想到的可能就是 setInterval 这个东东，这个东西在做PC页面的时候并没有什么问题，至少我现在还没遇到什么问题，而当你在移动页面中使用它来做倒计时的时候，就会出问题了，具体来说，是在做ios中的移动页面开发的时候，问题就尤为明显了，我们有以下代码：\n\n```\n<body>\n\n    <div id=\"box\">60</div>\n\n    <script>\n\n    var box = document.getElementById('box');\n    var num = 60;\n\n    var T = setInterval(function(){\n        \n        box.innerHTML = --num;\n        if(num <= 0){\n            clearInterval(T);\n        }\n\n    }, 1000);\n        \n    </script>\n</body>\n```\n\n上面的代码很简单，就是一个60秒的倒计时程序，我们使用 setInterval 来完成，这段代码在PC中可以正常运行，在Android中也可以正常运行，但是拿到ios中，就会有一个问题，来看图：\n\n![时间停止](http://7xlolm.com1.z0.glb.clouddn.com/201607114.gif)\n\n上图中，当倒计时走到37的时候，用手拖动页面，这个时候js代码会被阻塞，导致倒计时不在执行，这个现象很常见，比如当你和朋友玩微信的时候，互相发送自定义表情的gif图的时候，当你滚动聊天界面时，你会发现gif图也会静止，这个问题是ios系统机制的问题，我们没办法从根本上解决，但这并不是最关键的，大家可以发现，在倒计时走到37的时候，用手指操作页面大概有两三面的时间，按正常来讲，时间应该倒计时到 35秒或者34秒，但是图中很清楚的可以看到，在手指停止操作后，时间却从37秒继续倒计时，走到了36秒，这就与时间的倒计时时间造成了差距，假如倒计时的页面很长，比如一个列表页，那么用户在滑动查看页面信心的时候，会造成更多的倒计时延迟，这在一些要求比较精准的倒计时应用中，简直是不允许出现的，虽然后端也会做一层校验。\n\n这个就是我们要说的问题，与其说是 setInterval 或者 setTimeout 的问题，倒不如说是 ios 系统的问题，那么有办法解决这个问题吗？这就是我们要谈到的 Worker API。\n\n# Worker API #\n\nweb Worker API 允许 JavaScript 在后台运行，浏览器实现 Worker API 的方式有很多，每个浏览器厂家可能不尽相同，他们可以使用现线程或后台进程等，这使得 js 代码不被UI线程阻塞，二者互不影响，特别是面对计算量比较大的任务的时候，会给应用程序带来性能上的提升。\n\nweb Worker API 的使用很简单，大家可以自行查询相关书籍或博客。相信聪明的你10分钟就能搞定。\n\n# 使用 Worker 解决问题 #\n\n我们的思路是，将倒计时的计算放到一个单独的文件里，使用 Worder 去执行这个文件，是不是就可以了呢？\n\n新建一个 countdown.js 文件：\n\n```\nself.onmessage = function(event){\n\tvar num = event.data;\n\n\tvar T = setInterval(function(){\n\t\t\n        self.postMessage(--num);\n        if(num <= 0){\n            clearInterval(T);\n            self.close();\n        }\n\n    }, 1000);\n}\n```\n\n上面的代码很简单，在 countdown.js 中，由于这个js文件是由 Worker 来在后台执行的文件，所以这个文件内代码的 self 指向的就是 Worker 对象。我们通过 onmessage 时间接收来自页面的倒计时数值，然后原封不动的把之前的倒计时代码拷贝过来，唯一不同的就是使用 self.close() 语句来关闭 Worker。\n\n然后修改之前的页面文件如下：\n\n```\n<body>\n\n    <div id=\"box\">60</div>\n\n    <script>\n\n    var box = document.getElementById('box');\n\n    var w = new Worker('countdown.js');\n\n    w.postMessage(60);\n\n    w.onmessage = function(event){\n        box.innerHTML = event.data;\n    }\n        \n    </script>\n</body>\n```\n\n在PC中刷新你的页面，可以看到依然正确工作，之后再拿到ios中做之前gif图同样的操作，如下图：\n\n![倒计时继续](http://7xlolm.com1.z0.glb.clouddn.com/2016071144.gif)\n\n我们可以看到，在55秒的时候开始拖动页面，这个时候倒计时停止了，不过，当我们放手之后，倒计时会立刻恢复到正常应该到达的时刻，而不会产生任何误差和延迟，这样，我们就比较完美的解决了这个问题。\n\n# 需要注意的地方 #\n\n在列表页面中，可能会有很多个倒计时，并且每个倒计时的开始时间不尽相同，但切记不要通过循环去 new 很多个 Worker 出来，这样可能会导致应用卡死，特别是如果在做 Hybrid App 中的 H5 页面时，可能会造成闪退，所以你只能 new 一个 Worker 对象出来，然后使用这一个 Worker 对象去做所有列表时间的倒计时，然后在更新视图中使用循环去更新，这样就不会有问题了，另外一个需要注意的是，有些Android机型中的webview不支持 web Worker 。这个时候仅仅去使用 setInterval 就可以了，因为在Android中不存在ios中那种阻塞的情况。\n\n以上就是这篇博客的内容，希望对大家有所帮助 = =。\n\n","slug":"js-Worker-API-在倒计时中的使用","published":1,"updated":"2016-07-11T11:04:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj669fskf001qewfc7ody61y6","content":"<p>在做开发的时候，倒计时的需求是很常见的，比如订单待提交和待支付都会有倒计时，市面上的兼职软件在领取任务后都会有倒计时，登录注册中获取验证码的时候也会有倒计时，有的页面只有一个倒计时，而有的页面作为列表页，列表中的每一项都会有倒计时，今天就来聊聊 Worker API 在js倒计时中的使用，以及为什么要使用 Worker 来做倒计时</p>\n<a id=\"more\"></a>\n<h1 id=\"setInterval-或-setTimeout-的问题\"><a href=\"#setInterval-或-setTimeout-的问题\" class=\"headerlink\" title=\"setInterval 或 setTimeout 的问题\"></a>setInterval 或 setTimeout 的问题</h1><p>当提到js的倒计时功能时，我想你第一个想到的可能就是 setInterval 这个东东，这个东西在做PC页面的时候并没有什么问题，至少我现在还没遇到什么问题，而当你在移动页面中使用它来做倒计时的时候，就会出问题了，具体来说，是在做ios中的移动页面开发的时候，问题就尤为明显了，我们有以下代码：</p>\n<pre><code>&lt;body&gt;\n\n    &lt;div id=&quot;box&quot;&gt;60&lt;/div&gt;\n\n    &lt;script&gt;\n\n    var box = document.getElementById(&#39;box&#39;);\n    var num = 60;\n\n    var T = setInterval(function(){\n\n        box.innerHTML = --num;\n        if(num &lt;= 0){\n            clearInterval(T);\n        }\n\n    }, 1000);\n\n    &lt;/script&gt;\n&lt;/body&gt;\n</code></pre><p>上面的代码很简单，就是一个60秒的倒计时程序，我们使用 setInterval 来完成，这段代码在PC中可以正常运行，在Android中也可以正常运行，但是拿到ios中，就会有一个问题，来看图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201607114.gif\" alt=\"时间停止\"></p>\n<p>上图中，当倒计时走到37的时候，用手拖动页面，这个时候js代码会被阻塞，导致倒计时不在执行，这个现象很常见，比如当你和朋友玩微信的时候，互相发送自定义表情的gif图的时候，当你滚动聊天界面时，你会发现gif图也会静止，这个问题是ios系统机制的问题，我们没办法从根本上解决，但这并不是最关键的，大家可以发现，在倒计时走到37的时候，用手指操作页面大概有两三面的时间，按正常来讲，时间应该倒计时到 35秒或者34秒，但是图中很清楚的可以看到，在手指停止操作后，时间却从37秒继续倒计时，走到了36秒，这就与时间的倒计时时间造成了差距，假如倒计时的页面很长，比如一个列表页，那么用户在滑动查看页面信心的时候，会造成更多的倒计时延迟，这在一些要求比较精准的倒计时应用中，简直是不允许出现的，虽然后端也会做一层校验。</p>\n<p>这个就是我们要说的问题，与其说是 setInterval 或者 setTimeout 的问题，倒不如说是 ios 系统的问题，那么有办法解决这个问题吗？这就是我们要谈到的 Worker API。</p>\n<h1 id=\"Worker-API\"><a href=\"#Worker-API\" class=\"headerlink\" title=\"Worker API\"></a>Worker API</h1><p>web Worker API 允许 JavaScript 在后台运行，浏览器实现 Worker API 的方式有很多，每个浏览器厂家可能不尽相同，他们可以使用现线程或后台进程等，这使得 js 代码不被UI线程阻塞，二者互不影响，特别是面对计算量比较大的任务的时候，会给应用程序带来性能上的提升。</p>\n<p>web Worker API 的使用很简单，大家可以自行查询相关书籍或博客。相信聪明的你10分钟就能搞定。</p>\n<h1 id=\"使用-Worker-解决问题\"><a href=\"#使用-Worker-解决问题\" class=\"headerlink\" title=\"使用 Worker 解决问题\"></a>使用 Worker 解决问题</h1><p>我们的思路是，将倒计时的计算放到一个单独的文件里，使用 Worder 去执行这个文件，是不是就可以了呢？</p>\n<p>新建一个 countdown.js 文件：</p>\n<pre><code>self.onmessage = function(event){\n    var num = event.data;\n\n    var T = setInterval(function(){\n\n        self.postMessage(--num);\n        if(num &lt;= 0){\n            clearInterval(T);\n            self.close();\n        }\n\n    }, 1000);\n}\n</code></pre><p>上面的代码很简单，在 countdown.js 中，由于这个js文件是由 Worker 来在后台执行的文件，所以这个文件内代码的 self 指向的就是 Worker 对象。我们通过 onmessage 时间接收来自页面的倒计时数值，然后原封不动的把之前的倒计时代码拷贝过来，唯一不同的就是使用 self.close() 语句来关闭 Worker。</p>\n<p>然后修改之前的页面文件如下：</p>\n<pre><code>&lt;body&gt;\n\n    &lt;div id=&quot;box&quot;&gt;60&lt;/div&gt;\n\n    &lt;script&gt;\n\n    var box = document.getElementById(&#39;box&#39;);\n\n    var w = new Worker(&#39;countdown.js&#39;);\n\n    w.postMessage(60);\n\n    w.onmessage = function(event){\n        box.innerHTML = event.data;\n    }\n\n    &lt;/script&gt;\n&lt;/body&gt;\n</code></pre><p>在PC中刷新你的页面，可以看到依然正确工作，之后再拿到ios中做之前gif图同样的操作，如下图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/2016071144.gif\" alt=\"倒计时继续\"></p>\n<p>我们可以看到，在55秒的时候开始拖动页面，这个时候倒计时停止了，不过，当我们放手之后，倒计时会立刻恢复到正常应该到达的时刻，而不会产生任何误差和延迟，这样，我们就比较完美的解决了这个问题。</p>\n<h1 id=\"需要注意的地方\"><a href=\"#需要注意的地方\" class=\"headerlink\" title=\"需要注意的地方\"></a>需要注意的地方</h1><p>在列表页面中，可能会有很多个倒计时，并且每个倒计时的开始时间不尽相同，但切记不要通过循环去 new 很多个 Worker 出来，这样可能会导致应用卡死，特别是如果在做 Hybrid App 中的 H5 页面时，可能会造成闪退，所以你只能 new 一个 Worker 对象出来，然后使用这一个 Worker 对象去做所有列表时间的倒计时，然后在更新视图中使用循环去更新，这样就不会有问题了，另外一个需要注意的是，有些Android机型中的webview不支持 web Worker 。这个时候仅仅去使用 setInterval 就可以了，因为在Android中不存在ios中那种阻塞的情况。</p>\n<p>以上就是这篇博客的内容，希望对大家有所帮助 = =。</p>\n","site":{"data":{}},"excerpt":"<p>在做开发的时候，倒计时的需求是很常见的，比如订单待提交和待支付都会有倒计时，市面上的兼职软件在领取任务后都会有倒计时，登录注册中获取验证码的时候也会有倒计时，有的页面只有一个倒计时，而有的页面作为列表页，列表中的每一项都会有倒计时，今天就来聊聊 Worker API 在js倒计时中的使用，以及为什么要使用 Worker 来做倒计时</p>","more":"<h1 id=\"setInterval-或-setTimeout-的问题\"><a href=\"#setInterval-或-setTimeout-的问题\" class=\"headerlink\" title=\"setInterval 或 setTimeout 的问题\"></a>setInterval 或 setTimeout 的问题</h1><p>当提到js的倒计时功能时，我想你第一个想到的可能就是 setInterval 这个东东，这个东西在做PC页面的时候并没有什么问题，至少我现在还没遇到什么问题，而当你在移动页面中使用它来做倒计时的时候，就会出问题了，具体来说，是在做ios中的移动页面开发的时候，问题就尤为明显了，我们有以下代码：</p>\n<pre><code>&lt;body&gt;\n\n    &lt;div id=&quot;box&quot;&gt;60&lt;/div&gt;\n\n    &lt;script&gt;\n\n    var box = document.getElementById(&#39;box&#39;);\n    var num = 60;\n\n    var T = setInterval(function(){\n\n        box.innerHTML = --num;\n        if(num &lt;= 0){\n            clearInterval(T);\n        }\n\n    }, 1000);\n\n    &lt;/script&gt;\n&lt;/body&gt;\n</code></pre><p>上面的代码很简单，就是一个60秒的倒计时程序，我们使用 setInterval 来完成，这段代码在PC中可以正常运行，在Android中也可以正常运行，但是拿到ios中，就会有一个问题，来看图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/201607114.gif\" alt=\"时间停止\"></p>\n<p>上图中，当倒计时走到37的时候，用手拖动页面，这个时候js代码会被阻塞，导致倒计时不在执行，这个现象很常见，比如当你和朋友玩微信的时候，互相发送自定义表情的gif图的时候，当你滚动聊天界面时，你会发现gif图也会静止，这个问题是ios系统机制的问题，我们没办法从根本上解决，但这并不是最关键的，大家可以发现，在倒计时走到37的时候，用手指操作页面大概有两三面的时间，按正常来讲，时间应该倒计时到 35秒或者34秒，但是图中很清楚的可以看到，在手指停止操作后，时间却从37秒继续倒计时，走到了36秒，这就与时间的倒计时时间造成了差距，假如倒计时的页面很长，比如一个列表页，那么用户在滑动查看页面信心的时候，会造成更多的倒计时延迟，这在一些要求比较精准的倒计时应用中，简直是不允许出现的，虽然后端也会做一层校验。</p>\n<p>这个就是我们要说的问题，与其说是 setInterval 或者 setTimeout 的问题，倒不如说是 ios 系统的问题，那么有办法解决这个问题吗？这就是我们要谈到的 Worker API。</p>\n<h1 id=\"Worker-API\"><a href=\"#Worker-API\" class=\"headerlink\" title=\"Worker API\"></a>Worker API</h1><p>web Worker API 允许 JavaScript 在后台运行，浏览器实现 Worker API 的方式有很多，每个浏览器厂家可能不尽相同，他们可以使用现线程或后台进程等，这使得 js 代码不被UI线程阻塞，二者互不影响，特别是面对计算量比较大的任务的时候，会给应用程序带来性能上的提升。</p>\n<p>web Worker API 的使用很简单，大家可以自行查询相关书籍或博客。相信聪明的你10分钟就能搞定。</p>\n<h1 id=\"使用-Worker-解决问题\"><a href=\"#使用-Worker-解决问题\" class=\"headerlink\" title=\"使用 Worker 解决问题\"></a>使用 Worker 解决问题</h1><p>我们的思路是，将倒计时的计算放到一个单独的文件里，使用 Worder 去执行这个文件，是不是就可以了呢？</p>\n<p>新建一个 countdown.js 文件：</p>\n<pre><code>self.onmessage = function(event){\n    var num = event.data;\n\n    var T = setInterval(function(){\n\n        self.postMessage(--num);\n        if(num &lt;= 0){\n            clearInterval(T);\n            self.close();\n        }\n\n    }, 1000);\n}\n</code></pre><p>上面的代码很简单，在 countdown.js 中，由于这个js文件是由 Worker 来在后台执行的文件，所以这个文件内代码的 self 指向的就是 Worker 对象。我们通过 onmessage 时间接收来自页面的倒计时数值，然后原封不动的把之前的倒计时代码拷贝过来，唯一不同的就是使用 self.close() 语句来关闭 Worker。</p>\n<p>然后修改之前的页面文件如下：</p>\n<pre><code>&lt;body&gt;\n\n    &lt;div id=&quot;box&quot;&gt;60&lt;/div&gt;\n\n    &lt;script&gt;\n\n    var box = document.getElementById(&#39;box&#39;);\n\n    var w = new Worker(&#39;countdown.js&#39;);\n\n    w.postMessage(60);\n\n    w.onmessage = function(event){\n        box.innerHTML = event.data;\n    }\n\n    &lt;/script&gt;\n&lt;/body&gt;\n</code></pre><p>在PC中刷新你的页面，可以看到依然正确工作，之后再拿到ios中做之前gif图同样的操作，如下图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/2016071144.gif\" alt=\"倒计时继续\"></p>\n<p>我们可以看到，在55秒的时候开始拖动页面，这个时候倒计时停止了，不过，当我们放手之后，倒计时会立刻恢复到正常应该到达的时刻，而不会产生任何误差和延迟，这样，我们就比较完美的解决了这个问题。</p>\n<h1 id=\"需要注意的地方\"><a href=\"#需要注意的地方\" class=\"headerlink\" title=\"需要注意的地方\"></a>需要注意的地方</h1><p>在列表页面中，可能会有很多个倒计时，并且每个倒计时的开始时间不尽相同，但切记不要通过循环去 new 很多个 Worker 出来，这样可能会导致应用卡死，特别是如果在做 Hybrid App 中的 H5 页面时，可能会造成闪退，所以你只能 new 一个 Worker 对象出来，然后使用这一个 Worker 对象去做所有列表时间的倒计时，然后在更新视图中使用循环去更新，这样就不会有问题了，另外一个需要注意的是，有些Android机型中的webview不支持 web Worker 。这个时候仅仅去使用 setInterval 就可以了，因为在Android中不存在ios中那种阻塞的情况。</p>\n<p>以上就是这篇博客的内容，希望对大家有所帮助 = =。</p>"},{"title":"使用weinre调试移动端页面","date":"2016-08-13T03:39:03.000Z","_content":"\nweinre 的使用很简单，weinre 的使用很简单，weinre 的使用很简单，三遍够了。\n\n<!-- more -->\n\n\n# 使用 weinre 调试移动页面\n\n## 安装 weinre \n\n```\nnpm install -g weinre\n```\n\n## 启动服务\n\n```\nweinre --httpPort 8080 --boundHost -all-\n```\n\n指定端口号，当服务启动成功之后，根据提示，在浏览器中打开相应地址：\n\n![提示](http://7xlolm.com1.z0.glb.clouddn.com/gitblog1.pic.jpg)\n\n## 浏览器查看\n\n我的ip是 192.168.45.166，你应该输入你的ip地址：\n\n![查看](http://7xlolm.com1.z0.glb.clouddn.com/gitblog3.pic_hd.jpg)\n\n这里有三个链接需要注意的地方\n\n第一个链接(即\thttp://192.168.45.166:8080/client/#anonymous)：\n\n此链接将启动weinre客户端页面，也就是调试器本身。点击此链接将带您进入远程控制面板\n\n第二个连接(即http://192.168.45.166:8080/doc/)：\n\n当然就是文档的连接啦\n\n第三个连接(即http://192.168.45.166:8080/target/target-script-min.js#anonymous)\n\n这个连接，是一个js脚本，是你要在需要调试的页面引入的一段js脚本：\n\n```\n// ip地址要换成你的ip哦\n<script src=\"http://192.168.45.166:8080/target/target-script-min.js#anonymous\"></script>\n```\n\n## 调试\n\n服务启动了，也在你的页面中引入上述脚本了，那么接下来就可以点击上述第一个链接跳转到调试器页面了：\n\n![调试](http://7xlolm.com1.z0.glb.clouddn.com/4.pic_hd.jpg)\n\n\n\n\n\n","source":"_posts/2016/08/13/使用weinre调试移动端页面.md","raw":"title: 使用weinre调试移动端页面\ndate: 2016-08-13 11:39:03\ncategories:\n- WebFrontEnd\ntags:\n- debug\n- 移动调试\n---\n\nweinre 的使用很简单，weinre 的使用很简单，weinre 的使用很简单，三遍够了。\n\n<!-- more -->\n\n\n# 使用 weinre 调试移动页面\n\n## 安装 weinre \n\n```\nnpm install -g weinre\n```\n\n## 启动服务\n\n```\nweinre --httpPort 8080 --boundHost -all-\n```\n\n指定端口号，当服务启动成功之后，根据提示，在浏览器中打开相应地址：\n\n![提示](http://7xlolm.com1.z0.glb.clouddn.com/gitblog1.pic.jpg)\n\n## 浏览器查看\n\n我的ip是 192.168.45.166，你应该输入你的ip地址：\n\n![查看](http://7xlolm.com1.z0.glb.clouddn.com/gitblog3.pic_hd.jpg)\n\n这里有三个链接需要注意的地方\n\n第一个链接(即\thttp://192.168.45.166:8080/client/#anonymous)：\n\n此链接将启动weinre客户端页面，也就是调试器本身。点击此链接将带您进入远程控制面板\n\n第二个连接(即http://192.168.45.166:8080/doc/)：\n\n当然就是文档的连接啦\n\n第三个连接(即http://192.168.45.166:8080/target/target-script-min.js#anonymous)\n\n这个连接，是一个js脚本，是你要在需要调试的页面引入的一段js脚本：\n\n```\n// ip地址要换成你的ip哦\n<script src=\"http://192.168.45.166:8080/target/target-script-min.js#anonymous\"></script>\n```\n\n## 调试\n\n服务启动了，也在你的页面中引入上述脚本了，那么接下来就可以点击上述第一个链接跳转到调试器页面了：\n\n![调试](http://7xlolm.com1.z0.glb.clouddn.com/4.pic_hd.jpg)\n\n\n\n\n\n","slug":"使用weinre调试移动端页面","published":1,"updated":"2016-08-13T03:41:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj669fskh001tewfcvc5imurp","content":"<p>weinre 的使用很简单，weinre 的使用很简单，weinre 的使用很简单，三遍够了。</p>\n<a id=\"more\"></a>\n<h1 id=\"使用-weinre-调试移动页面\"><a href=\"#使用-weinre-调试移动页面\" class=\"headerlink\" title=\"使用 weinre 调试移动页面\"></a>使用 weinre 调试移动页面</h1><h2 id=\"安装-weinre\"><a href=\"#安装-weinre\" class=\"headerlink\" title=\"安装 weinre\"></a>安装 weinre</h2><pre><code>npm install -g weinre\n</code></pre><h2 id=\"启动服务\"><a href=\"#启动服务\" class=\"headerlink\" title=\"启动服务\"></a>启动服务</h2><pre><code>weinre --httpPort 8080 --boundHost -all-\n</code></pre><p>指定端口号，当服务启动成功之后，根据提示，在浏览器中打开相应地址：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/gitblog1.pic.jpg\" alt=\"提示\"></p>\n<h2 id=\"浏览器查看\"><a href=\"#浏览器查看\" class=\"headerlink\" title=\"浏览器查看\"></a>浏览器查看</h2><p>我的ip是 192.168.45.166，你应该输入你的ip地址：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/gitblog3.pic_hd.jpg\" alt=\"查看\"></p>\n<p>这里有三个链接需要注意的地方</p>\n<p>第一个链接(即    <a href=\"http://192.168.45.166:8080/client/#anonymous)：\" target=\"_blank\" rel=\"external\">http://192.168.45.166:8080/client/#anonymous)：</a></p>\n<p>此链接将启动weinre客户端页面，也就是调试器本身。点击此链接将带您进入远程控制面板</p>\n<p>第二个连接(即<a href=\"http://192.168.45.166:8080/doc/)：\" target=\"_blank\" rel=\"external\">http://192.168.45.166:8080/doc/)：</a></p>\n<p>当然就是文档的连接啦</p>\n<p>第三个连接(即<a href=\"http://192.168.45.166:8080/target/target-script-min.js#anonymous\" target=\"_blank\" rel=\"external\">http://192.168.45.166:8080/target/target-script-min.js#anonymous</a>)</p>\n<p>这个连接，是一个js脚本，是你要在需要调试的页面引入的一段js脚本：</p>\n<pre><code>// ip地址要换成你的ip哦\n&lt;script src=&quot;http://192.168.45.166:8080/target/target-script-min.js#anonymous&quot;&gt;&lt;/script&gt;\n</code></pre><h2 id=\"调试\"><a href=\"#调试\" class=\"headerlink\" title=\"调试\"></a>调试</h2><p>服务启动了，也在你的页面中引入上述脚本了，那么接下来就可以点击上述第一个链接跳转到调试器页面了：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/4.pic_hd.jpg\" alt=\"调试\"></p>\n","site":{"data":{}},"excerpt":"<p>weinre 的使用很简单，weinre 的使用很简单，weinre 的使用很简单，三遍够了。</p>","more":"<h1 id=\"使用-weinre-调试移动页面\"><a href=\"#使用-weinre-调试移动页面\" class=\"headerlink\" title=\"使用 weinre 调试移动页面\"></a>使用 weinre 调试移动页面</h1><h2 id=\"安装-weinre\"><a href=\"#安装-weinre\" class=\"headerlink\" title=\"安装 weinre\"></a>安装 weinre</h2><pre><code>npm install -g weinre\n</code></pre><h2 id=\"启动服务\"><a href=\"#启动服务\" class=\"headerlink\" title=\"启动服务\"></a>启动服务</h2><pre><code>weinre --httpPort 8080 --boundHost -all-\n</code></pre><p>指定端口号，当服务启动成功之后，根据提示，在浏览器中打开相应地址：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/gitblog1.pic.jpg\" alt=\"提示\"></p>\n<h2 id=\"浏览器查看\"><a href=\"#浏览器查看\" class=\"headerlink\" title=\"浏览器查看\"></a>浏览器查看</h2><p>我的ip是 192.168.45.166，你应该输入你的ip地址：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/gitblog3.pic_hd.jpg\" alt=\"查看\"></p>\n<p>这里有三个链接需要注意的地方</p>\n<p>第一个链接(即    <a href=\"http://192.168.45.166:8080/client/#anonymous)：\" target=\"_blank\" rel=\"external\">http://192.168.45.166:8080/client/#anonymous)：</a></p>\n<p>此链接将启动weinre客户端页面，也就是调试器本身。点击此链接将带您进入远程控制面板</p>\n<p>第二个连接(即<a href=\"http://192.168.45.166:8080/doc/)：\" target=\"_blank\" rel=\"external\">http://192.168.45.166:8080/doc/)：</a></p>\n<p>当然就是文档的连接啦</p>\n<p>第三个连接(即<a href=\"http://192.168.45.166:8080/target/target-script-min.js#anonymous\" target=\"_blank\" rel=\"external\">http://192.168.45.166:8080/target/target-script-min.js#anonymous</a>)</p>\n<p>这个连接，是一个js脚本，是你要在需要调试的页面引入的一段js脚本：</p>\n<pre><code>// ip地址要换成你的ip哦\n&lt;script src=&quot;http://192.168.45.166:8080/target/target-script-min.js#anonymous&quot;&gt;&lt;/script&gt;\n</code></pre><h2 id=\"调试\"><a href=\"#调试\" class=\"headerlink\" title=\"调试\"></a>调试</h2><p>服务启动了，也在你的页面中引入上述脚本了，那么接下来就可以点击上述第一个链接跳转到调试器页面了：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/4.pic_hd.jpg\" alt=\"调试\"></p>"},{"title":"Vue2.1.7源码学习","date":"2017-03-03T03:17:21.000Z","_content":"\n原本文章的名字叫做《源码解析》，不过后来想想，还是用“源码学习”来的合适一点，在没有彻底掌握源码中的每一个字母之前，“解析”就有点标题党了。建议在看这篇文章之前，最好打开2.1.7的源码对照着看，这样可能更容易理解。另外本人水平有限，文中有错误或不妥的地方望大家多多指正共同成长。\n\n补充：Vue 2.2 刚刚发布，作为一个系列文章的第一篇，本篇文章主要从Vue代码的组织，Vue构造函数的还原，原型的设计，以及参数选项的处理和已经被写烂了的数据绑定与如何使用 Virtual DOM 更新视图入手。从整体的大方向观察框架，这么看来 `V2.1.7` 对于理解 `V2.2` 的代码不会有太大的影响。该系列文章的后续文章，都会从最新的源码入手，并对改动的地方做相应的提示。\n\n<!-- more -->\n\n很久之前写过一篇文章：[JavaScript实现MVVM之我就是想监测一个普通对象的变化](http://hcysun.me/2016/04/28/JavaScript%E5%AE%9E%E7%8E%B0MVVM%E4%B9%8B%E6%88%91%E5%B0%B1%E6%98%AF%E6%83%B3%E7%9B%91%E6%B5%8B%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8F%98%E5%8C%96/)，文章开头提到了我写博客的风格，还是那句话，只写努力让小白，甚至是小学生都能看明白的文章。这不免会导致对于某些同学来说这篇文章有些墨迹，所以大家根据自己的喜好，可以详细的看，也可以跳跃着看。\n\n## <span style=\"color: #ff6600;\">一、从了解一个开源项目入手<span>\n\n要看一个项目的源码，不要一上来就看，先去了解一下项目本身的元数据和依赖，除此之外最好也了解一下 PR 规则，Issue Reporting 规则等等。特别是“前端”开源项目，我们在看源码之前第一个想到的应该是：`package.json`文件。\n\n在 `package.json` 文件中，我们最应该关注的就是 `scripts` 字段和 `devDependencies` 以及 `dependencies` 字段，通过 `scripts` 字段我们可以知道项目中定义的脚本命令，通过 `devDependencies` 和 `dependencies` 字段我们可以了解项目的依赖情况。\n\n了解了这些之后，如果有依赖我们就 `npm install` 安装依赖就ok了。\n\n除了 `package.json` 之外，我们还要阅读项目的贡献规则文档，了解如何开始，一个好的开源项目肯定会包含这部分内容的，Vue也不例外：[https://github.com/vuejs/vue/blob/dev/.github/CONTRIBUTING.md](https://github.com/vuejs/vue/blob/dev/.github/CONTRIBUTING.md)，在这个文档里说明了一些行为准则，PR指南，Issue Reporting 指南，Development Setup 以及 项目结构。通过阅读这些内容，我们可以了解项目如何开始，如何开发以及目录的说明，下面是对重要目录和文件的简单介绍，这些内容你都可以去自己阅读获取：\n\n```\n├── build --------------------------------- 构建相关的文件，一般情况下我们不需要动\n├── dist ---------------------------------- 构建后文件的输出目录\n├── examples ------------------------------ 存放一些使用Vue开发的应用案例\n├── flow ---------------------------------- 类型声明，使用开源项目 [Flow](https://flowtype.org/)\n├── package.json -------------------------- 不解释\n├── test ---------------------------------- 包含所有测试文件\n├── src ----------------------------------- 这个是我们最应该关注的目录，包含了源码\n│   ├── entries --------------------------- 包含了不同的构建或包的入口文件\n│   │   ├── web-runtime.js ---------------- 运行时构建的入口，输出 dist/vue.common.js 文件，不包含模板(template)到render函数的编译器，所以不支持 `template` 选项，我们使用vue默认导出的就是这个运行时的版本。大家使用的时候要注意\n│   │   ├── web-runtime-with-compiler.js -- 独立构建版本的入口，输出 dist/vue.js，它包含模板(template)到render函数的编译器\n│   │   ├── web-compiler.js --------------- vue-template-compiler 包的入口文件\n│   │   ├── web-server-renderer.js -------- vue-server-renderer 包的入口文件\n│   ├── compiler -------------------------- 编译器代码的存放目录，将 template 编译为 render 函数\n│   │   ├── parser ------------------------ 存放将模板字符串转换成元素抽象语法树的代码\n│   │   ├── codegen ----------------------- 存放从抽象语法树(AST)生成render函数的代码\n│   │   ├── optimizer.js ------------------ 分析静态树，优化vdom渲染\n│   ├── core ------------------------------ 存放通用的，平台无关的代码\n│   │   ├── observer ---------------------- 反应系统，包含数据观测的核心代码\n│   │   ├── vdom -------------------------- 包含虚拟DOM创建(creation)和打补丁(patching)的代码\n│   │   ├── instance ---------------------- 包含Vue构造函数设计相关的代码\n│   │   ├── global-api -------------------- 包含给Vue构造函数挂载全局方法(静态方法)或属性的代码\n│   │   ├── components -------------------- 包含抽象出来的通用组件\n│   ├── server ---------------------------- 包含服务端渲染(server-side rendering)的相关代码\n│   ├── platforms ------------------------- 包含平台特有的相关代码\n│   ├── sfc ------------------------------- 包含单文件组件(.vue文件)的解析逻辑，用于vue-template-compiler包\n│   ├── shared ---------------------------- 包含整个代码库通用的代码\n```\n\n大概了解了重要目录和文件之后，我们就可以查看 [Development Setup](https://github.com/vuejs/vue/blob/dev/.github/CONTRIBUTING.md#development-setup) 中的常用命令部分，来了解如何开始这个项目了，我们可以看到这样的介绍：\n\n```\n# watch and auto re-build dist/vue.js\n$ npm run dev\n\n# watch and auto re-run unit tests in Chrome\n$ npm run dev:test\n```\n\n现在，我们只需要运行 `npm run dev` 即可监测文件变化并自动重新构建输出 dist/vue.js，然后运行 `npm run dev:test` 来测试。不过为了方便，我会在 `examples` 目录新建一个例子，然后引用 dist/vue.js 这样，我们可以直接拿这个例子一边改Vue源码一边看自己写的代码想怎么玩怎么玩。\n\n## <span style=\"color: #ff6600;\">二、看源码的小提示</span>\n\n在真正步入源码世界之前，我想简单说一说看源码的技巧：\n\n### *注重大体框架，从宏观到微观*\n\n当你看一个项目代码的时候，最好是能找到一条主线，先把大体流程结构摸清楚，再深入到细节，逐项击破，拿Vue举个栗子：假如你已经知道Vue中数据状态改变后会采用virtual DOM的方式更新DOM，这个时候，如果你不了解virtual DOM，那么听我一句“暂且不要去研究内部具体实现，因为这会是你丧失主线”，而你仅仅需要知道virtual DOM分为三个步骤：\n\n>一、createElement(): 用 JavaScript对象(虚拟树) 描述 真实DOM对象(真实树)\n>二、diff(oldNode, newNode) : 对比新旧两个虚拟树的区别，收集差异\n>三、patch() : 将差异应用到真实DOM树\n\n有的时候 第二步 可能与 第三步 合并成一步(Vue 中的patch就是这样)，除此之外，还比如 `src/compiler/codegen` 内的代码，可能你不知道他写了什么，直接去看它会让你很痛苦，但是你只需要知道 codegen 是用来将抽象语法树(AST)生成render函数的就OK了，也就是生成类似下面这样的代码：\n\n```js\nfunction anonymous() {\n\twith(this){return _c('p',{attrs:{\"id\":\"app\"}},[_v(\"\\n      \"+_s(a)+\"\\n      \"),_c('my-com')])}\n}\n```\n\n当我们知道了一个东西存在，且知道它存在的目的，那么我们就很容易抓住这条主线，这个系列的第一篇文章就是围绕大体主线展开的。了解大体之后，我们就知道了每部分内容都是做什么的，比如 codegen 是生成类似上面贴出的代码所示的函数的，那么再去看codegen下的代码时，目的性就会更强，就更容易理解。\n\n## <span style=\"color: #ff6600;\">三、Vue 的构造函数是什么样的<span>\n\nbalabala一大堆，开始来干货吧。我们要做的第一件事就是搞清楚 Vue 构造函数到底是什么样子的。\n\n我们知道，我们要使用 `new` 操作符来调用 `Vue`，那么也就是说 `Vue` 应该是一个构造函数，所以我们第一件要做的事儿就是把构造函数先扒的一清二楚，如何寻找 `Vue` 构造函数呢？当然是从 entry 开始啦，还记的我们运行 `npm run dev` 命令后，会输出 `dist/vue.js` 吗，那么我们就去看看 `npm run dev` 干了什么：\n\n```\n\"dev\": \"TARGET=web-full-dev rollup -w -c build/config.js\",\n```\n\n首先将 TARGET 得值设置为 'web-full-dev'，然后，然后，然后如果你不了解 rollup 就应该简单去看一下啦......，简单的说就是一个JavaScript模块打包器，你可以把它简单的理解为和 webpack 一样，只不过它有他的优势，比如 Tree-shaking (webpack2也有)，但同样，在某些场景它也有他的劣势。。。废话不多说，其中 `-w` 就是watch，`-c` 就是指定配置文件为 `build/config.js` ，我们打开这个配置文件看一看：\n\n```js\n// 引入依赖，定义 banner\n...\n\n// builds 对象\nconst builds = {\n\t...\n\t// Runtime+compiler development build (Browser)\n\t'web-full-dev': {\n\t    entry: path.resolve(__dirname, '../src/entries/web-runtime-with-compiler.js'),\n\t    dest: path.resolve(__dirname, '../dist/vue.js'),\n\t    format: 'umd',\n\t    env: 'development',\n\t    alias: { he: './entity-decoder' },\n\t    banner\n\t},\n\t...\n}\n\n// 生成配置的方法\nfunction genConfig(opts){\n\t...\n}\n\nif (process.env.TARGET) {\n  module.exports = genConfig(builds[process.env.TARGET])\n} else {\n  exports.getBuild = name => genConfig(builds[name])\n  exports.getAllBuilds = () => Object.keys(builds).map(name => genConfig(builds[name]))\n}\n```\n\n上面的代码是简化过的，当我们运行 `npm run dev` 的时候 `process.env.TARGET` 的值等于 'web-full-dev'，所以\n\n```js\nmodule.exports = genConfig(builds[process.env.TARGET])\n```\n\n这句代码相当于：\n\n```js\nmodule.exports = genConfig({\n    entry: path.resolve(__dirname, '../src/entries/web-runtime-with-compiler.js'),\n    dest: path.resolve(__dirname, '../dist/vue.js'),\n    format: 'umd',\n    env: 'development',\n    alias: { he: './entity-decoder' },\n    banner\n})\n```\n\n最终，genConfig 函数返回一个 config 对象，这个config对象就是Rollup的配置对象。那么我们就不难看到，入口文件是：\n\n```\nsrc/entries/web-runtime-with-compiler.js\n```\n\n我们打开这个文件，不要忘了我们的主题，我们在寻找Vue构造函数，所以当我们看到这个文件的第一行代码是：\n\n```js\nimport Vue from './web-runtime'\n```\n\n这个时候，你就应该知道，这个文件暂时与你无缘，你应该打开 `web-runtime.js` 文件，不过当你打开这个文件时，你发现第一行是这样的：\n\n```js\nimport Vue from 'core/index'\n```\n\n依照此思路，最终我们寻找到Vue构造函数的位置应该是在 `src/core/instance/index.js` 文件中，其实我们猜也猜得到，上面介绍目录的时候说过：instance 是存放Vue构造函数设计相关代码的目录。总结一下，我们寻找的过程是这样的：\n\n![寻找 Vue 构造函数路线](http://7xlolm.com1.z0.glb.clouddn.com/vueimg2BD0DCC6-D689-4809-93D3-2F979E8F8C0C.png)\n\n我们回头看一看 `src/core/instance/index.js` 文件，很简单：\n\n```js\nimport { initMixin } from './init'\nimport { stateMixin } from './state'\nimport { renderMixin } from './render'\nimport { eventsMixin } from './events'\nimport { lifecycleMixin } from './lifecycle'\nimport { warn } from '../util/index'\n\nfunction Vue (options) {\n  if (process.env.NODE_ENV !== 'production' &&\n    !(this instanceof Vue)) {\n    warn('Vue is a constructor and should be called with the `new` keyword')\n  }\n  this._init(options)\n}\n\ninitMixin(Vue)\nstateMixin(Vue)\neventsMixin(Vue)\nlifecycleMixin(Vue)\nrenderMixin(Vue)\n\nexport default Vue\n```\n\n引入依赖，定义 Vue 构造函数，然后以Vue构造函数为参数，调用了五个方法，最后导出 Vue。这五个方法分别来自五个文件：`init.js` `state.js` `render.js` `events.js` 以及 `lifecycle.js`。\n\n打开这五个文件，找到相应的方法，你会发现，这些方法的作用，就是在 Vue 的原型 prototype 上挂载方法或属性，经历了这五个方法后的Vue会变成这样：\n\n```js\n// initMixin(Vue)\tsrc/core/instance/init.js **************************************************\nVue.prototype._init = function (options?: Object) {}\n\n// stateMixin(Vue)\tsrc/core/instance/state.js **************************************************\nVue.prototype.$data\nVue.prototype.$set = set\nVue.prototype.$delete = del\nVue.prototype.$watch = function(){}\n\n// renderMixin(Vue)\tsrc/core/instance/render.js **************************************************\nVue.prototype.$nextTick = function (fn: Function) {}\nVue.prototype._render = function (): VNode {}\nVue.prototype._s = _toString\nVue.prototype._v = createTextVNode\nVue.prototype._n = toNumber\nVue.prototype._e = createEmptyVNode\nVue.prototype._q = looseEqual\nVue.prototype._i = looseIndexOf\nVue.prototype._m = function(){}\nVue.prototype._o = function(){}\nVue.prototype._f = function resolveFilter (id) {}\nVue.prototype._l = function(){}\nVue.prototype._t = function(){}\nVue.prototype._b = function(){}\nVue.prototype._k = function(){}\n\n// eventsMixin(Vue)\tsrc/core/instance/events.js **************************************************\nVue.prototype.$on = function (event: string, fn: Function): Component {}\nVue.prototype.$once = function (event: string, fn: Function): Component {}\nVue.prototype.$off = function (event?: string, fn?: Function): Component {}\nVue.prototype.$emit = function (event: string): Component {}\n\n// lifecycleMixin(Vue)\tsrc/core/instance/lifecycle.js **************************************************\nVue.prototype._mount = function(){}\nVue.prototype._update = function (vnode: VNode, hydrating?: boolean) {}\nVue.prototype._updateFromParent = function(){}\nVue.prototype.$forceUpdate = function () {}\nVue.prototype.$destroy = function () {}\n```\n\n这样就结束了吗？并没有，根据我们之前寻找 Vue 的路线，这只是刚刚开始，我们追溯路线往回走，那么下一个处理 Vue 构造函数的应该是 `src/core/index.js` 文件，我们打开它：\n\n```js\nimport Vue from './instance/index'\nimport { initGlobalAPI } from './global-api/index'\nimport { isServerRendering } from 'core/util/env'\n\ninitGlobalAPI(Vue)\n\nObject.defineProperty(Vue.prototype, '$isServer', {\n  get: isServerRendering\n})\n\nVue.version = '__VERSION__'\n\nexport default Vue\n```\n\n这个文件也很简单，从 instance/index 中导入已经在原型上挂载了方法和属性后的 Vue，然后导入 `initGlobalAPI` 和 `isServerRendering`，之后将Vue作为参数传给  `initGlobalAPI` ，最后又在 `Vue.prototype` 上挂载了 `$isServer` ，在 `Vue` 上挂载了 `version` 属性。\n\n`initGlobalAPI` 的作用是在 `Vue` 构造函数上挂载静态属性和方法，`Vue` 在经过 `initGlobalAPI` 之后，会变成这样：\n\n```js\n// src/core/index.js / src/core/global-api/index.js\nVue.config\nVue.util = util\nVue.set = set\nVue.delete = del\nVue.nextTick = util.nextTick\nVue.options = {\n    components: {\n        KeepAlive\n    },\n    directives: {},\n    filters: {},\n    _base: Vue\n}\nVue.use\nVue.mixin\nVue.cid = 0\nVue.extend\nVue.component = function(){}\nVue.directive = function(){}\nVue.filter = function(){}\n\nVue.prototype.$isServer\nVue.version = '__VERSION__'\n```\n\n其中，稍微复杂一点的就是 `Vue.options`，大家稍微分析分析就会知道他的确长成那个样子。下一个就是 `web-runtime.js` 文件了，`web-runtime.js` 文件主要做了三件事儿：\n\n> 1、覆盖 `Vue.config` 的属性，将其设置为平台特有的一些方法\n> 2、`Vue.options.directives` 和 `Vue.options.components` 安装平台特有的指令和组件\n> 3、在 `Vue.prototype` 上定义 `__patch__` 和 `$mount`\n\n经过 `web-runtime.js` 文件之后，`Vue` 变成下面这个样子：\n\n```js\n// 安装平台特定的utils\nVue.config.isUnknownElement = isUnknownElement\nVue.config.isReservedTag = isReservedTag\nVue.config.getTagNamespace = getTagNamespace\nVue.config.mustUseProp = mustUseProp\n// 安装平台特定的 指令 和 组件\nVue.options = {\n    components: {\n        KeepAlive,\n        Transition,\n        TransitionGroup\n    },\n    directives: {\n        model,\n        show\n    },\n    filters: {},\n    _base: Vue\n}\nVue.prototype.__patch__\nVue.prototype.$mount\n```\n\n这里大家要注意的是 `Vue.options` 的变化。另外这里的 `$mount` 方法很简单：\n\n```js\nVue.prototype.$mount = function (\n  el?: string | Element,\n  hydrating?: boolean\n): Component {\n  el = el && inBrowser ? query(el) : undefined\n  return this._mount(el, hydrating)\n}\n```\n\n首先根据是否是浏览器环境决定要不要 `query(el)` 获取元素，然后将 `el` 作为参数传递给 `this._mount()`。\n\n最后一个处理 Vue 的文件就是入口文件 `web-runtime-with-compiler.js` 了，该文件做了两件事：\n\n1、缓存来自 `web-runtime.js` 文件的 `$mount` 函数\n\n```js\nconst mount = Vue.prototype.$mount\n```\n\n然后覆盖覆盖了 `Vue.prototype.$mount`\n\n2、在 Vue 上挂载 `compile`\n\n```js\nVue.compile = compileToFunctions\n```\n\ncompileToFunctions 函数的作用，就是将模板 `template` 编译为render函数。\n\n至此，我们算是还原了 Vue 构造函数，总结一下：\n\n> 1、`Vue.prototype` 下的属性和方法的挂载主要是在 `src/core/instance` 目录中的代码处理的\n\n> 2、`Vue` 下的静态属性和方法的挂载主要是在 `src/core/global-api` 目录下的代码处理的\n\n> 3、`web-runtime.js` 主要是添加web平台特有的配置、组件和指令，`web-runtime-with-compiler.js` 给Vue的 `$mount` 方法添加 `compiler` 编译器，支持 `template`。\n\n## <span style=\"color: #ff6600;\">四、一个贯穿始终的例子</span>\n\n在了解了 `Vue` 构造函数的设计之后，接下来，我们一个贯穿始终的例子就要登场了，掌声有请：\n\n```js\nlet v = new Vue({\n\tel: '#app',\n\tdata: {\n\t\ta: 1,\n\t\tb: [1, 2, 3]\n\t}\n})\n```\n\n好吧，我承认这段代码你家没满月的孩子都会写了。这段代码就是我们贯穿始终的例子，它就是这篇文章的主线，在后续的讲解中，都会以这段代码为例，当讲到必要的地方，会为其添加选项，比如讲计算属性的时候当然要加上一个 `computed` 属性了。不过在最开始，我只传递了两个选项 `el` 以及 `data`，“我们看看接下来会发生什么，让我们拭目以待“ ---- NBA球星在接受采访时最喜欢说这句话。\n\n*当我们按照例子那样编码使用Vue的时候，Vue都做了什么？*\n\n想要知道Vue都干了什么，我们就要找到 Vue 初始化程序，查看 Vue 构造函数：\n\n```js\nfunction Vue (options) {\n  if (process.env.NODE_ENV !== 'production' &&\n    !(this instanceof Vue)) {\n    warn('Vue is a constructor and should be called with the `new` keyword')\n  }\n  this._init(options)\n}\n```\n\n我们发现，`_init()` 方法就是Vue调用的第一个方法，然后将我们的参数 `options` 透传了过去。在调用 `_init()` 之前，还做了一个安全模式的处理，告诉开发者必须使用 `new` 操作符调用 Vue。根据之前我们的整理，`_init()` 方法应该是在 `src/core/instance/init.js` 文件中定义的，我们打开这个文件查看 `_init()` 方法：\n\n```js\n  Vue.prototype._init = function (options?: Object) {\n    const vm: Component = this\n    // a uid\n    vm._uid = uid++\n    // a flag to avoid this being observed\n    vm._isVue = true\n    // merge options\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options)\n    } else {\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      )\n    }\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      initProxy(vm)\n    } else {\n      vm._renderProxy = vm\n    }\n\n    // expose real self\n    vm._self = vm\n    initLifecycle(vm)\n    initEvents(vm)\n    callHook(vm, 'beforeCreate')\n    initState(vm)\n    callHook(vm, 'created')\n    initRender(vm)\n  }\n```\n\n`_init()` 方法在一开始的时候，在 `this` 对象上定义了两个属性：`_uid` 和 `_isVue`，然后判断有没有定义 `options._isComponent`，在使用 Vue 开发项目的时候，我们是不会使用 `_isComponent` 选项的，这个选项是 Vue 内部使用的，按照本节开头的例子，这里会走 `else` 分支，也就是这段代码：\n\n```js\n  vm.$options = mergeOptions(\n    resolveConstructorOptions(vm.constructor),\n    options || {},\n    vm\n  )\n```\n\n这样 `Vue` 第一步所做的事情就来了：<span style=\"color: red;\">*使用策略对象合并参数选项*</span>\n\n可以发现，Vue使用 `mergeOptions` 来处理我们调用Vue时传入的参数选项(options)，然后将返回值赋值给 `this.$options` (vm === this)，传给 `mergeOptions` 方法三个参数，我们分别来看一看，首先是：`resolveConstructorOptions(vm.constructor)`，我们查看一下这个方法：\n\n```js\nexport function resolveConstructorOptions (Ctor: Class<Component>) {\n  let options = Ctor.options\n  if (Ctor.super) {\n    const superOptions = Ctor.super.options\n    const cachedSuperOptions = Ctor.superOptions\n    const extendOptions = Ctor.extendOptions\n    if (superOptions !== cachedSuperOptions) {\n      // super option changed\n      Ctor.superOptions = superOptions\n      extendOptions.render = options.render\n      extendOptions.staticRenderFns = options.staticRenderFns\n      extendOptions._scopeId = options._scopeId\n      options = Ctor.options = mergeOptions(superOptions, extendOptions)\n      if (options.name) {\n        options.components[options.name] = Ctor\n      }\n    }\n  }\n  return options\n}\n```\n\n这个方法接收一个参数 `Ctor`，通过传入的 `vm.constructor` 我们可以知道，其实就是 `Vue` 构造函数本身。所以下面这句代码：\n\n```js\nlet options = Ctor.options\n```\n\n相当于：\n\n```js\nlet options = Vue.options\n```\n\n大家还记得 `Vue.options` 吗？在寻找Vue构造函数一节里，我们整理了 `Vue.options` 应该长成下面这个样子：\n\n```js\nVue.options = {\n    components: {\n        KeepAlive,\n        Transition,\n        TransitionGroup\n    },\n    directives: {\n        model,\n        show\n    },\n    filters: {},\n    _base: Vue\n}\n```\n\n之后判断是否定义了 `Vue.super` ，这个是用来处理继承的，我们后续再讲，在本例中，`resolveConstructorOptions` 方法直接返回了 `Vue.options`。也就是说，传递给 `mergeOptions` 方法的第一个参数就是 `Vue.options`。\n\n传给 `mergeOptions` 方法的第二个参数是我们调用Vue构造函数时的参数选项，第三个参数是 `vm` 也就是 `this` 对象，按照本节开头的例子那样使用 Vue，最终运行的代码应该如下：\n\n```js\n  vm.$options = mergeOptions(\n  \t// Vue.options\n    {\n\t    components: {\n\t        KeepAlive,\n\t        Transition,\n\t        TransitionGroup\n\t    },\n\t    directives: {\n\t        model,\n\t        show\n\t    },\n\t    filters: {},\n\t    _base: Vue\n\t},\n\t// 调用Vue构造函数时传入的参数选项 options\n    {\n    \tel: '#app',\n\t\tdata: {\n\t\t\ta: 1,\n\t\t\tb: [1, 2, 3]\n\t\t}\n    },\n    // this\n    vm\n  )\n```\n\n了解了这些，我们就可以看看 `mergeOptions` 到底做了些什么了，根据引用寻找到 `mergeOptions` 应该是在 `src/core/util/options.js` 文件中定义的。这个文件第一次看可能会头大，下面是我处理后的简略展示，大家看上去应该更容易理解了：\n\n```js\n// 1、引用依赖\nimport Vue from '../instance/index'\n其他引用...\n\n// 2、合并父子选项值为最终值的策略对象，此时 strats 是一个空对象，因为 config.optionMergeStrategies = Object.create(null)\nconst strats = config.optionMergeStrategies\n// 3、在 strats 对象上定义与参数选项名称相同的方法\nstrats.el = \nstrats.propsData = function (parent, child, vm, key){}\nstrats.data = function (parentVal, childVal, vm)\n\nconfig._lifecycleHooks.forEach(hook => {\n  strats[hook] = mergeHook\n})\n\nconfig._assetTypes.forEach(function (type) {\n  strats[type + 's'] = mergeAssets\n})\n\nstrats.watch = function (parentVal, childVal)\n\nstrats.props =\nstrats.methods =\nstrats.computed = function (parentVal: ?Object, childVal: ?Object)\n// 默认的合并策略，如果有 `childVal` 则返回 `childVal` 没有则返回 `parentVal`\nconst defaultStrat = function (parentVal: any, childVal: any): any {\n  return childVal === undefined\n    ? parentVal\n    : childVal\n}\n\n// 4、mergeOptions 中根据参数选项调用同名的策略方法进行合并处理\nexport function mergeOptions (\n  parent: Object,\n  child: Object,\n  vm?: Component\n): Object {\n\n  // 其他代码\n  ...\n\n  const options = {}\n  let key\n  for (key in parent) {\n    mergeField(key)\n  }\n  for (key in child) {\n    if (!hasOwn(parent, key)) {\n      mergeField(key)\n    }\n  }\n  function mergeField (key) {\n    const strat = strats[key] || defaultStrat\n    options[key] = strat(parent[key], child[key], vm, key)\n  }\n  return options\n\t\n}\n\n```\n\n上面的代码中，我省略了一些工具函数，例如 `mergeHook` 和 `mergeAssets` 等等，唯一需要注意的是这段代码：\n\n```js\nconfig._lifecycleHooks.forEach(hook => {\n  strats[hook] = mergeHook\n})\n\nconfig._assetTypes.forEach(function (type) {\n  strats[type + 's'] = mergeAssets\n})\n```\n\n`config` 对象引用自 `src/core/config.js` 文件，最终的结果就是在 `strats` 下添加了相应的生命周期选项的合并策略函数为 `mergeHook`，添加指令(directives)、组件(components)、过滤器(filters)等选项的合并策略函数为 `mergeAssets`。\n\n这样看来就清晰多了，拿我们贯穿本文的例子来说：\n\n```js\nlet v = new Vue({\n\tel: '#app',\n\tdata: {\n\t\ta: 1,\n\t\tb: [1, 2, 3]\n\t}\n})\n```\n\n其中 `el` 选项会使用 `defaultStrat` 默认策略函数处理，`data` 选项则会使用 `strats.data` 策略函数处理，并且根据 `strats.data` 中的逻辑，`strats.data` 方法最终会返回一个函数：`mergedInstanceDataFn`。\n\n这里就不详细的讲解每一个策略函数的内容了，后续都会讲到，这里我们还是抓住主线理清思路为主，只需要知道Vue在处理选项的时候，使用了一个策略对象对父子选项进行合并。并将最终的值赋值给实例下的 `$options` 属性即：`this.$options`，那么我们继续查看 `_init()` 方法在合并完选项之后，又做了什么：\n\n合并完选项之后，Vue 第二部做的事情就来了：<span style=\"color: red;\">*初始化工作与Vue实例对象的设计*</span>\n\n前面讲了 Vue 构造函数的设计，并且整理了 *Vue原型属性与方法* 和 *Vue静态属性与方法*，而 Vue 实例对象就是通过构造函数创造出来的，让我们来看一看 Vue 实例对象是如何设计的，下面的代码是 `_init()` 方法合并完选项之后的代码：\n\n```js\n\t/* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      initProxy(vm)\n    } else {\n      vm._renderProxy = vm\n    }\n\n    // expose real self\n\tvm._self = vm\n    initLifecycle(vm)\n    initEvents(vm)\n    callHook(vm, 'beforeCreate')\n    initState(vm)\n    callHook(vm, 'created')\n    initRender(vm)\n```\n\n根据上面的代码，在生产环境下会为实例添加两个属性，并且属性值都为实例本身：\n\n```js\nvm._renderProxy = vm\nvm._self = vm\n```\n\n然后，调用了四个 `init*` 方法分别为：`initLifecycle`、`initEvents`、`initState`、`initRender`，且在 `initState` 前后分别回调了生命周期钩子 `beforeCreate` 和 `created`，而 `initRender` 是在 `created` 钩子执行之后执行的，看到这里，也就明白了为什么 created 的时候不能操作DOM了。因为这个时候还没有渲染真正的DOM元素到文档中。`created` 仅仅代表数据状态的初始化完成。\n\n根据四个 `init*` 方法的引用关系打开对应的文件查看对应的方法，我们发现，这些方法是在处理Vue实例对象，以及做一些初始化的工作，类似整理Vue构造函数一样，我同样针对Vue实例做了属性和方法的整理，如下：\n\n```js\n// 在 Vue.prototype._init 中添加的属性 \t\t**********************************************************\nthis._uid = uid++\nthis._isVue = true\nthis.$options = {\n    components,\n    directives,\n    filters,\n    _base,\n    el,\n    data: mergedInstanceDataFn()\n}\nthis._renderProxy = this\nthis._self = this\n\n// 在 initLifecycle 中添加的属性\t\t**********************************************************\nthis.$parent = parent\nthis.$root = parent ? parent.$root : this\n \nthis.$children = []\nthis.$refs = {}\n\nthis._watcher = null\nthis._inactive = false\nthis._isMounted = false\nthis._isDestroyed = false\nthis._isBeingDestroyed = false\n\n// 在 initEvents\t 中添加的属性\t \t**********************************************************\nthis._events = {}\nthis._updateListeners = function(){}\n\n// 在 initState 中添加的属性\t\t**********************************************************\nthis._watchers = []\n    // initData\n    this._data\n\n// 在 initRender\t 中添加的属性 \t**********************************************************\nthis.$vnode = null // the placeholder node in parent tree\nthis._vnode = null // the root of the child tree\nthis._staticTrees = null\nthis.$slots\nthis.$scopedSlots\nthis._c\nthis.$createElement\n```\n\n以上就是一个Vue实例所包含的属性和方法，除此之外要注意的是，在 `initEvents` 中除了添加属性之外，如果有 `vm.$options._parentListeners` 还要调用 `vm._updateListeners()` 方法，在 `initState` 中又调用了一些其他init方法，如下：\n\n```js\nexport function initState (vm: Component) {\n  vm._watchers = []\n  initProps(vm)\n  initMethods(vm)\n  initData(vm)\n  initComputed(vm)\n  initWatch(vm)\n}\n```\n\n最后在 `initRender` 中如果有 `vm.$options.el` 还要调用 `vm.$mount(vm.$options.el)`，如下：\n\n```js\n  if (vm.$options.el) {\n    vm.$mount(vm.$options.el)\n  }\n```\n\n这就是为什么如果不传递 `el` 选项就需要手动 mount 的原因了。\n\n那么我们依照我们本节开头的的例子，以及初始化的先后顺序来逐一看一看都发生了什么。我们将 `initState` 中的 `init*` 方法展开来看，执行顺序应该是这样的（从上到下的顺序执行）：\n\n```\ninitLifecycle(vm)\ninitEvents(vm)\ncallHook(vm, 'beforeCreate')\ninitProps(vm)\ninitMethods(vm)\ninitData(vm)\ninitComputed(vm)\ninitWatch(vm)\ncallHook(vm, 'created')\ninitRender(vm)\n```\n\n首先是 `initLifecycle`，这个函数的作用就是在实例上添加一些属性，然后是 `initEvents`，由于 `vm.$options._parentListeners` 的值为 `undefined` 所以也仅仅是在实例上添加属性， `vm._updateListeners(listeners)` 并不会执行，由于我们只传递了 `el` 和 `data`，所以 `initProps`、`initMethods`、`initComputed`、`initWatch` 这四个方法什么都不会做，只有 `initData` 会执行。最后是 `initRender`，除了在实例上添加一些属性外，由于我们传递了 `el` 选项，所以会执行 `vm.$mount(vm.$options.el)`。\n\n综上所述：按照我们的例子那样写，初始化工作只包含两个主要内容即：`initData` 和 `initRender`。\n\n## <span style=\"color: #ff6600;\">五、通过`initData`看Vue的数据响应系统</span>\n\nVue的数据响应系统包含三个部分：`Observer`、`Dep`、`Watcher`。关于数据响应系统的内容真的已经被文章讲烂了，所以我就简单的说一下，力求大家能理解就ok，我们还是先看一下 `initData` 中的代码：\n\n```\nfunction initData (vm: Component) {\n  let data = vm.$options.data\n  data = vm._data = typeof data === 'function'\n    ? data.call(vm)\n    : data || {}\n  if (!isPlainObject(data)) {\n    data = {}\n    process.env.NODE_ENV !== 'production' && warn(\n      'data functions should return an object:\\n' +\n      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',\n      vm\n    )\n  }\n  // proxy data on instance\n  const keys = Object.keys(data)\n  const props = vm.$options.props\n  let i = keys.length\n  while (i--) {\n    if (props && hasOwn(props, keys[i])) {\n      process.env.NODE_ENV !== 'production' && warn(\n        `The data property \"${keys[i]}\" is already declared as a prop. ` +\n        `Use prop default value instead.`,\n        vm\n      )\n    } else {\n      proxy(vm, keys[i])\n    }\n  }\n  // observe data\n  observe(data)\n  data.__ob__ && data.__ob__.vmCount++\n}\n```\n\n首先，先拿到 data 数据：`let data = vm.$options.data`，大家还记得此时 `vm.$options.data` 的值应该是通过 `mergeOptions` 合并处理后的 `mergedInstanceDataFn` 函数吗？所以在得到 data 后，它又判断了 data 的数据类型是不是 'function'，最终的结果是：data 还是我们传入的数据选项的 data，即：\n\n```\ndata: {\n\ta: 1,\n\tb: [1, 2, 3]\n}\n```\n\n然后在实例对象上定义 `_data` 属性，该属性与 `data` 是相同的引用。\n\n然后是一个 `while` 循环，循环的目的是在实例对象上对数据进行代理，这样我们就能通过 `this.a` 来访问 `data.a` 了，代码的处理是在 `proxy` 函数中，该函数非常简单，仅仅是在实例对象上设置与 `data` 属性同名的访问器属性，然后使用 `_data` 做数据劫持，如下：\n\n```\nfunction proxy (vm: Component, key: string) {\n  if (!isReserved(key)) {\n    Object.defineProperty(vm, key, {\n      configurable: true,\n      enumerable: true,\n      get: function proxyGetter () {\n        return vm._data[key]\n      },\n      set: function proxySetter (val) {\n        vm._data[key] = val\n      }\n    })\n  }\n}\n```\n\n做完数据的代理，就正式进入响应系统，\n\n```\nobserve(data)\n```\n\n我们说过，数据响应系统主要包含三部分：`Observer`、`Dep`、`Watcher`，代码分别存放在：`observer/index.js`、`observer/dep.js` 以及 `observer/watcher.js` 文件中，这回我们换一种方式，我们先不看其源码，大家先跟着我的思路来思考，最后回头再去看代码，你会有一种：”奥，不过如此“的感觉。\n\n假如，我们有如下代码：\n\n```js\nvar data = {\n    a: 1,\n    b: {\n        c: 2\n    }\n}\n\nobserver(data)\n\nnew Watch('a', () => {\n    alert(9)\n})\nnew Watch('a', () => {\n    alert(90)\n})\nnew Watch('b.c', () => {\n    alert(80)\n})\n```\n\n这段代码目的是，首先定义一个数据对象 `data`，然后通过 observer 对其进行观测，之后定义了三个观察者，当数据有变化时，执行相应的方法，这个功能使用Vue的实现原来要如何去实现？其实就是在问 `observer` 怎么写？`Watch` 构造函数又怎么写？接下来我们逐一实现。\n\n首先，observer 的作用是：将数据对象data的属性转换为访问器属性：\n\n```\nclass Observer {\n    constructor (data) {\n        this.walk(data)\n    }\n    walk (data) {\n        // 遍历 data 对象属性，调用 defineReactive 方法\n        let keys = Object.keys(data)\n        for(let i = 0; i < keys.length; i++){\n            defineReactive(data, keys[i], data[keys[i]])\n        }\n    }\n}\n\n// defineReactive方法仅仅将data的属性转换为访问器属性\nfunction defineReactive (data, key, val) {\n\t// 递归观测子属性\n    observer(val)\n\n    Object.defineProperty(data, key, {\n        enumerable: true,\n        configurable: true,\n        get: function () {\n            return val\n        },\n        set: function (newVal) {\n            if(val === newVal){\n                return\n            }\n            // 对新值进行观测\n            observer(newVal)\n        }\n    })\n}\n\n// observer 方法首先判断data是不是纯JavaScript对象，如果是，调用 Observer 类进行观测\nfunction observer (data) {\n    if(Object.prototype.toString.call(data) !== '[object Object]') {\n        return\n    }\n    new Observer(data)\n}\n```\n\n上面的代码中，我们定义了 observer 方法，该方法检测了数据data是不是纯JavaScript对象，如果是就调用 `Observer` 类，并将 `data` 作为参数透传。在 `Observer` 类中，我们使用 `walk` 方法对数据data的属性循环调用 `defineReactive` 方法，`defineReactive` 方法很简单，仅仅是将数据data的属性转为访问器属性，并对数据进行递归观测，否则只能观测数据data的直属子属性。这样我们的第一步工作就完成了，当我们修改或者获取data属性值的时候，通过 `get` 和 `set` 即能获取到通知。\n\n我们继续往下看，来看一下 `Watch`：\n\n```\nnew Watch('a', () => {\n    alert(9)\n})\n```\n\n现在的问题是，`Watch` 要怎么和 `observer` 关联？？？？？？？我们看看 `Watch` 它知道些什么，通过上面调用 `Watch` 的方式，传递给 `Watch` 两个参数，一个是 'a' 我们可以称其为表达式，另外一个是回调函数。所以我们目前只能写出这样的代码：\n\n```\nclass Watch {\n    constructor (exp, fn) {\n        this.exp = exp\n        this.fn = fn\n    }\n}\n```\n\n那么要怎么关联呢，大家看下面的代码会发生什么：\n\n```\nclass Watch {\n    constructor (exp, fn) {\n        this.exp = exp\n        this.fn = fn\n        data[exp]\n    }\n}\n```\n\n多了一句 `data[exp]`，这句话是在干什么？是不是在获取 `data` 下某个属性的值，比如 exp 为 'a' 的话，那么 `data[exp]` 就相当于在获取 `data.a` 的值，那这会放生什么？大家不要忘了，此时数据 `data` 下的属性已经是访问器属性了，所以这么做的结果会直接触发对应属性的 `get` 函数，这样我们就成功的和 `observer` 产生了关联，但这样还不够，我们还是没有达到目的，不过我们已经无限接近了，我们继续思考看一下可不可以这样：\n\n> 既然在 `Watch` 中对表达式求值，能够触发 `observer` 的 `get`，那么可不可以在 `get` 中收集 `Watch` 中函数呢？\n\n答案是可以的，不过这个时候我们就需要 `Dep` 出场了，它是一个依赖收集器。我们的思路是：`data` 下的每一个属性都有一个唯一的 `Dep` 对象，在 `get` 中收集仅针对该属性的依赖，然后在 `set` 方法中触发所有收集的依赖，这样就搞定了，看如下代码：\n\n```\nclass Dep {\n    constructor () {\n        this.subs = []\n    }\n    addSub () {\n        this.subs.push(Dep.target)\n    }\n    notify () {\n        for(let i = 0; i < this.subs.length; i++){\n            this.subs[i].fn()\n        }\n    }\n}\nDep.target = null\nfunction pushTarget(watch){\n    Dep.target = watch\n}\n\nclass Watch {\n    constructor (exp, fn) {\n        this.exp = exp\n        this.fn = fn\n        pushTarget(this)\n        data[exp]\n    }\n}\n```\n\n上面的代码中，我们在 `Watch` 中增加了 `pushTarget(this)`，可以发现，这句代码的作用是将 `Dep.target` 的值设置为该Watch对象。在 `pushTarget` 之后我们才对表达式进行求值，接着，我们修改 `defineReactive` 代码如下\n\n```\nfunction defineReactive (data, key, val) {\n    observer(val)\n    let dep = new Dep()\t\t// 新增\n    Object.defineProperty(data, key, {\n        enumerable: true,\n        configurable: true,\n        get: function () {\n            dep.addSub()\t// 新增\n            return val\n        },\n        set: function (newVal) {\n            if(val === newVal){\n                return\n            }\n            observer(newVal)\n            dep.notify()\t// 新增\n        }\n    })\n}\n```\n\n如标注，新增了三句代码，我们知道，`Watch` 中对表达式求值会触发 `get` 方法，我们在 `get` 方法中调用了 `dep.addSub`，也就执行了这句代码：`this.subs.push(Dep.target)`，由于在这句代码执行之前，`Dep.target` 的值已经被设置为一个 `Watch` 对象了，所以最终结果就是收集了一个 `Watch` 对象，然后在 `set` 方法中我们调用了 `dep.notify`，所以当data属性值变化的时候，就会通过 `dep.notify` 循环调用所有收集的Watch对象中的回调函数：\n\n```\nnotify () {\n    for(let i = 0; i < this.subs.length; i++){\n        this.subs[i].fn()\n    }\n}\n```\n\n这样 `observer`、`Dep`、`Watch` 三者就联系成为一个有机的整体，实现了我们最初的目标，完整的代码可以戳这里：[observer-dep-watch](https://github.com/HcySunYang/observer-dep-watch)。这里还给大家挖了个坑，因为我们没有处理对数组的观测，由于比较复杂并且这又不是我们讨论的重点，如果大家想了解可以戳我的这篇文章：[JavaScript实现MVVM之我就是想监测一个普通对象的变化](http://hcysun.me/2016/04/28/JavaScript%E5%AE%9E%E7%8E%B0MVVM%E4%B9%8B%E6%88%91%E5%B0%B1%E6%98%AF%E6%83%B3%E7%9B%91%E6%B5%8B%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8F%98%E5%8C%96/)，另外，在 Watch 中对表达式求值的时候也只做了直接子属性的求值，所以如果 exp 的值为 'a.b' 的时候，就不可以用了，Vue的做法是使用 `.` 分割表达式字符串为数组，然后遍历一下对其进行求值，大家可以查看其源码。如下：\n\n```\n/**\n * Parse simple path.\n */\nconst bailRE = /[^\\w.$]/\nexport function parsePath (path: string): any {\n  if (bailRE.test(path)) {\n    return\n  } else {\n    const segments = path.split('.')\n    return function (obj) {\n      for (let i = 0; i < segments.length; i++) {\n        if (!obj) return\n        obj = obj[segments[i]]\n      }\n      return obj\n    }\n  }\n}\n```\n\nVue 的求值代码是在 `src/core/util/lang.js` 文件中 `parsePath` 函数中实现的。总结一下Vue的依赖收集过程应该是这样的：\n\n![Vue的依赖收集过程](http://7xlolm.com1.z0.glb.clouddn.com/vueimgdep.png)\n\n实际上，Vue并没有直接在 `get` 中调用 `addSub`，而是调用的 `dep.depend`，目的是将当前的 dep 对象收集到 watch 对象中，如果要完整的流程，应该是这样的：（大家注意数据的每一个字段都拥有自己的 `dep` 对象和 `get` 方法。）\n\n![Vue完整的收集依赖的流程](http://7xlolm.com1.z0.glb.clouddn.com/all.png)\n\n这样 Vue 就建立了一套数据响应系统，之前我们说过，按照我们的例子那样写，初始化工作只包含两个主要内容即：`initData` 和 `initRender`。现在 `initData` 我们分析完了，接下来看一看 `initRender`\n\n## <span style=\"color: #ff6600;\">六、通过`initRender`看Vue的 render(渲染) 与 re-render(重新渲染)</span>\n\n在 `initRender` 方法中，因为我们的例子中传递了 `el` 选项，所以下面的代码会执行：\n\n```\n  if (vm.$options.el) {\n    vm.$mount(vm.$options.el)\n  }\n```\n\n这里，调用了 `$mount` 方法，在还原Vue构造函数的时候，我们整理过所有的方法，其中 `$mount` 方法在两个地方出现过：\n\n1、在 `web-runtime.js` 文件中：\n\n```\nVue.prototype.$mount = function (\n  el?: string | Element,\n  hydrating?: boolean\n): Component {\n  el = el && inBrowser ? query(el) : undefined\n  return this._mount(el, hydrating)\n}\n```\n\n它的作用是通过 `el` 获取相应的DOM元素，然后调用 `lifecycle.js` 文件中的 `_mount` 方法。\n\n2、在 `web-runtime-with-compiler.js` 文件中：\n\n```\n// 缓存了来自 web-runtime.js 的 $mount 方法\nconst mount = Vue.prototype.$mount\n// 重写 $mount 方法\nVue.prototype.$mount = function (\n  el?: string | Element,\n  hydrating?: boolean\n): Component {\n  // 根据 el 获取相应的DOM元素\n  el = el && query(el)\n  // 不允许你将 el 挂载到 html 标签或者 body 标签\n  if (el === document.body || el === document.documentElement) {\n    process.env.NODE_ENV !== 'production' && warn(\n      `Do not mount Vue to <html> or <body> - mount to normal elements instead.`\n    )\n    return this\n  }\n\n  const options = this.$options\n  // 如果我们没有写 render 选项，那么就尝试将 template 或者 el 转化为 render 函数\n  if (!options.render) {\n    let template = options.template\n    if (template) {\n      if (typeof template === 'string') {\n        if (template.charAt(0) === '#') {\n          template = idToTemplate(template)\n          /* istanbul ignore if */\n          if (process.env.NODE_ENV !== 'production' && !template) {\n            warn(\n              `Template element not found or is empty: ${options.template}`,\n              this\n            )\n          }\n        }\n      } else if (template.nodeType) {\n        template = template.innerHTML\n      } else {\n        if (process.env.NODE_ENV !== 'production') {\n          warn('invalid template option:' + template, this)\n        }\n        return this\n      }\n    } else if (el) {\n      template = getOuterHTML(el)\n    }\n    if (template) {\n      const { render, staticRenderFns } = compileToFunctions(template, {\n        warn,\n        shouldDecodeNewlines,\n        delimiters: options.delimiters\n      }, this)\n      options.render = render\n      options.staticRenderFns = staticRenderFns\n    }\n  }\n  // 调用已经缓存下来的 web-runtime.js 文件中的 $mount 方法\n  return mount.call(this, el, hydrating)\n}\n```\n\n分析一下可知 `web-runtime-with-compiler.js` 的逻辑如下：\n\n1、缓存来自 `web-runtime.js` 文件的 `$mount` 方法\n\n2、判断有没有传递 `render` 选项，如果有直接调用来自 `web-runtime.js` 文件的 $mount 方法\n\n3、如果没有传递 `render` 选项，那么查看有没有 `template` 选项，如果有就使用 `compileToFunctions` 函数根据其内容编译成 `render` 函数\n\n4、如果没有 `template` 选项，那么查看有没有 `el` 选项，如果有就使用 `compileToFunctions` 函数将其内容(template = getOuterHTML(el))编译成 `render` 函数\n\n5、将编译成的 `render` 函数挂载到 `this.$options` 属性下，并调用缓存下来的 `web-runtime.js` 文件中的 $mount 方法\n\n简单的用一张图表示 `mount` 方法的调用关系，从上至下调用：\n\n![mount调用关系](http://7xlolm.com1.z0.glb.clouddn.com/vueimgmount.png)\n\n不过不管怎样，我们发现这些步骤的最终目的是生成 `render` 函数，然后再调用 `lifecycle.js` 文件中的 `_mount` 方法，我们看看这个方法做了什么事情，查看 `_mount` 方法的代码，这是简化过得：\n\n```\n  Vue.prototype._mount = function (\n    el?: Element | void,\n    hydrating?: boolean\n  ): Component {\n    const vm: Component = this\n\n    // 在Vue实例对象上添加 $el 属性，指向挂载点元素\n    vm.$el = el\n\n    // 触发 beforeMount 生命周期钩子\n    callHook(vm, 'beforeMount')\n\n    vm._watcher = new Watcher(vm, () => {\n      vm._update(vm._render(), hydrating)\n    }, noop)\n\n    // 如果是第一次mount则触发 mounted 生命周期钩子\n    if (vm.$vnode == null) {\n      vm._isMounted = true\n      callHook(vm, 'mounted')\n    }\n    return vm\n  }\n```\n\n上面的代码很简单，该注释的都注释了，唯一需要看的就是这段代码：\n\n```\nvm._watcher = new Watcher(vm, () => {\n  vm._update(vm._render(), hydrating)\n}, noop)\n```\n\n看上去很眼熟有没有？我们平时使用Vue都是这样使用 watch的：\n\n```\nthis.$watch('a', (newVal, oldVal) => {\n\t\n})\n// 或者\nthis.$watch(function(){\n\treturn this.a + this.b\n}, (newVal, oldVal) => {\n\t\n})\n```\n\n第一个参数是 表达式或者函数，第二个参数是回调函数，第三个参数是可选的选项。原理是 `Watch` 内部对表达式求值或者对函数求值从而触发数据的 `get` 方法收集依赖。可是 `_mount` 方法中使用 `Watcher` 的时候第一个参数 `vm` 是什么鬼。我们不妨去看看源码中 `$watch` 函数是如何实现的，根据之前还原Vue构造函数中所整理的内容可知：`$warch` 方法是在 `src/core/instance/state.js` 文件中的 `stateMixin` 方法中定义的，源码如下：\n\n```\n  Vue.prototype.$watch = function (\n    expOrFn: string | Function,\n    cb: Function,\n    options?: Object\n  ): Function {\n    const vm: Component = this\n    options = options || {}\n    options.user = true\n    const watcher = new Watcher(vm, expOrFn, cb, options)\n    if (options.immediate) {\n      cb.call(vm, watcher.value)\n    }\n    return function unwatchFn () {\n      watcher.teardown()\n    }\n  }\n```\n\n我们可以发现，`$warch` 其实是对 `Watcher` 的一个封装，内部的 `Watcher` 的第一个参数实际上也是 `vm` 即：Vue实例对象，这一点我们可以在 `Watcher` 的源码中得到验证，代开 `observer/watcher.js` 文件查看：\n\n```js\nexport default class Watcher {\n\n  constructor (\n    vm: Component,\n    expOrFn: string | Function,\n    cb: Function,\n    options?: Object = {}\n  ) {\n    \n  }\n}\n```\n\n可以发现真正的 `Watcher` 第一个参数实际上就是 `vm`。第二个参数是表达式或者函数，然后以此类推，所以现在再来看 `_mount` 中的这段代码：\n\n```\nvm._watcher = new Watcher(vm, () => {\n  vm._update(vm._render(), hydrating)\n}, noop)\n```\n\n忽略第一个参数 `vm`，也就说，`Watcher` 内部应该对第二个参数求值，也就是运行这个函数：\n\n```\n() => {\n  vm._update(vm._render(), hydrating)\n}\n```\n\n所以 `vm._render()` 函数被第一个执行，该函数在 `src/core/instance/render.js` 中，该方法中的代码很多，下面是简化过的：\n\n```\n  Vue.prototype._render = function (): VNode {\n    const vm: Component = this\n    // 解构出 $options 中的 render 函数\n    const {\n      render,\n      staticRenderFns,\n      _parentVnode\n    } = vm.$options\n    ...\n\n    let vnode\n    try {\n      // 运行 render 函数\n      vnode = render.call(vm._renderProxy, vm.$createElement)\n    } catch (e) {\n      ...\n    }\n    \n    // set parent\n    vnode.parent = _parentVnode\n    return vnode\n  }\n```\n\n`_render` 方法首先从 `vm.$options` 中解构出 `render` 函数，大家应该记得：`vm.$options.render` 方法是在 `web-runtime-with-compiler.js` 文件中通过 `compileToFunctions` 方法将 `template` 或 `el` 编译而来的。解构出 `render` 函数后，接下来便执行了该方法：\n\n```\nvnode = render.call(vm._renderProxy, vm.$createElement)\n```\n\n其中使用 `call` 指定了 `render` 函数的作用域环境为 `vm._renderProxy`，这个属性在我们整理实例对象的时候知道，他是在 `Vue.prototype._init` 方法中被添加的，即：`vm._renderProxy = vm`，其实就是Vue实例对象本身，然后传递了一个参数：`vm.$createElement`。那么 `render` 函数到底是干什么的呢？让我们根据上面那句代码猜一猜，我们已经知道 `render` 函数是从 `template` 或 `el` 编译而来的，如果没错的话应该是返回一个虚拟DOM对象。我们不妨使用 `console.log` 打印一下 `render` 函数，当我们的模板这样编写时：\n\n```\n<ul id=\"app\">\n  <li>{{a}}</li>\n</ul>\n```\n\n打印的 `render` 函数如下：\n\n![render函数1](http://7xlolm.com1.z0.glb.clouddn.com/vueimgr2.png)\n\n我们修改模板为：\n\n```\n<ul id=\"app\">\n  <li v-for=\"i in b\">{{a}}</li>\n</ul>\n```\n\n打印出来的 `render` 函数如下：\n\n![render函数2](http://7xlolm.com1.z0.glb.clouddn.com/vueimgr3.png)\n\n其实了解Vue2.x版本的同学都知道，Vue提供了 `render` 选项，作为 `template` 的代替方案，同时为JavaScript提供了完全编程的能力，下面两种编写模板的方式实际是等价的：\n\n```js\n// 方案一：\nnew Vue({\n\tel: '#app',\n\tdata: {\n\t\ta: 1\n\t},\n\ttemplate: '<ul><li>{{a}}</li><li>{{a}}</li></ul>'\n})\n\n// 方案二：\nnew Vue({\n\tel: '#app',\n\trender: function (createElement) {\n\t\tcreateElement('ul', [\n\t\t\tcreateElement('li', this.a),\n\t\t\tcreateElement('li', this.a)\n\t\t])\n\t}\n})\n```\n\n现在我们再来看我们打印的 `render` 函数：\n\n```\nfunction anonymous() {\n\twith(this){\n\t\treturn _c('ul', { \n\t\t\tattrs: {\"id\": \"app\"}\n\t\t},[\n\t\t\t_c('li', [_v(_s(a))])\n\t\t])\n\t}\n}\n```\n\n是不是与我们自己写 `render` 函数很像？因为 render 函数的作用域被绑定到了Vue实例，即：`render.call(vm._renderProxy, vm.$createElement)`，所以上面代码中 `_c`、`_v`、`_s` 以及变量 `a`相当于Vue实例下的方法和变量。大家还记得诸如 `_c`、`_v`、`_s` 这样的方法在哪里定义的吗？我们在整理Vue构造函数的时候知道，他们在 `src/core/instance/render.js` 文件中的 `renderMixin` 方法中定义，除了这些之外还有诸如：`_l`、 `_m`、 `_o` 等等。其中 `_l` 就在我们使用 `v-for` 指令的时候出现了。所以现在大家知道为什么这些方法都被定义在 `render.js` 文件中了吧，因为他们就是为了构造出 `render` 函数而存在的。\n\n现在我们已经知道了 `render` 函数的长相，也知道了 `render` 函数的作用域是Vue实例本身即：`this`(或`vm`)。那么当我们执行 `render` 函数时，其中的变量如：`a`，就相当于：`this.a`，我们知道这是在求值，所以 `_mount` 中的这段代码：\n\n```\nvm._watcher = new Watcher(vm, () => {\n  vm._update(vm._render(), hydrating)\n}, noop)\n```\n\n当 `vm._render` 执行的时候，所依赖的变量就会被求值，并被收集为依赖。按照Vue中 `watcher.js` 的逻辑，当依赖的变量有变化时不仅仅回调函数被执行，实际上还要重新求值，即还要执行一遍：\n\n```\n() => {\n  vm._update(vm._render(), hydrating)\n}\n```\n\n这实际上就做到了 `re-render`，因为 `vm._update` 就是文章开头所说的虚拟DOM中的最后一步：`patch`\n\n`vm_render` 方法最终返回一个 `vnode` 对象，即虚拟DOM，然后作为 `vm_update` 的第一个参数传递了过去，我们看一下 `vm_update` 的逻辑，在 `src/core/instance/lifecycle.js` 文件中有这么一段代码：\n\n```js\n    if (!prevVnode) {\n      // initial render\n      vm.$el = vm.__patch__(\n        vm.$el, vnode, hydrating, false /* removeOnly */,\n        vm.$options._parentElm,\n        vm.$options._refElm\n      )\n    } else {\n      // updates\n      vm.$el = vm.__patch__(prevVnode, vnode)\n    }\n```\n\n如果还没有 `prevVnode` 说明是首次渲染，直接创建真实DOM。如果已经有了 `prevVnode` 说明不是首次渲染，那么就采用 `patch` 算法进行必要的DOM操作。这就是Vue更新DOM的逻辑。只不过我们没有将 virtual DOM 内部的实现。\n\n现在我们来好好理理思路，当我们写如下代码时：\n\n```\nnew Vue({\n\tel: '#app',\n\tdata: {\n\t\ta: 1,\n\t\tb: [1, 2, 3]\n\t}\n})\n```\n\nVue 所做的事：\n\n> 1、构建数据响应系统，使用 `Observer` 将数据data转换为访问器属性；将 `el` 编译为 `render` 函数，`render` 函数返回值为虚拟DOM\n\n> 2、在 `_mount` 中对 `_update` 求值，而 `_update` 又会对 `render` 求值，`render` 内部又会对依赖的变量求值，收集为被求值的变量的依赖，当变量改变时，`_update` 又会重新执行一遍，从而做到 `re-render`。\n\n用一张详细一点的图表示就是这样的：\n\n![详细流程](http://7xlolm.com1.z0.glb.clouddn.com/vueimgdetail.png)\n\n到此，我们从大体流程，挑着重点的走了一遍Vue，但是还有很多细节我们没有提及，比如：\n\n1、将模板转为 `render` 函数的时候，实际是先生成的抽象语法树（AST），再将抽象语法树转成的 `render` 函数，而且这一整套的代码我们也没有提及，因为他在复杂了，其实这部分内容就是在完正则。\n\n2、我们也没有详细的讲 Virtual DOM 的实现原理，网上已经有文章讲了，大家可以搜一搜\n\n3、我们的例子中仅仅传递了 `el` ，`data` 选项，大家知道 Vue 支持的选项很多，比如我们都没有讲到，但都是触类旁通的，比如你搞清楚了 `data` 选项再去看 `computed` 选项或者 `props` 选项就会很容易，比如你知道了 `Watcher` 的工作机制再去看 `watch` 选项就会很容易。\n\n本篇文章作为Vue源码的启蒙文章，也许还有很多缺陷，全当抛砖引玉了。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/2017/03/03/Vue源码学习.md","raw":"title: Vue2.1.7源码学习\ndate: 2017-03-03 11:17:21\ncategories:\n- WebFrontEnd\ntags:\n- 源码\n- Vue\n---\n\n原本文章的名字叫做《源码解析》，不过后来想想，还是用“源码学习”来的合适一点，在没有彻底掌握源码中的每一个字母之前，“解析”就有点标题党了。建议在看这篇文章之前，最好打开2.1.7的源码对照着看，这样可能更容易理解。另外本人水平有限，文中有错误或不妥的地方望大家多多指正共同成长。\n\n补充：Vue 2.2 刚刚发布，作为一个系列文章的第一篇，本篇文章主要从Vue代码的组织，Vue构造函数的还原，原型的设计，以及参数选项的处理和已经被写烂了的数据绑定与如何使用 Virtual DOM 更新视图入手。从整体的大方向观察框架，这么看来 `V2.1.7` 对于理解 `V2.2` 的代码不会有太大的影响。该系列文章的后续文章，都会从最新的源码入手，并对改动的地方做相应的提示。\n\n<!-- more -->\n\n很久之前写过一篇文章：[JavaScript实现MVVM之我就是想监测一个普通对象的变化](http://hcysun.me/2016/04/28/JavaScript%E5%AE%9E%E7%8E%B0MVVM%E4%B9%8B%E6%88%91%E5%B0%B1%E6%98%AF%E6%83%B3%E7%9B%91%E6%B5%8B%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8F%98%E5%8C%96/)，文章开头提到了我写博客的风格，还是那句话，只写努力让小白，甚至是小学生都能看明白的文章。这不免会导致对于某些同学来说这篇文章有些墨迹，所以大家根据自己的喜好，可以详细的看，也可以跳跃着看。\n\n## <span style=\"color: #ff6600;\">一、从了解一个开源项目入手<span>\n\n要看一个项目的源码，不要一上来就看，先去了解一下项目本身的元数据和依赖，除此之外最好也了解一下 PR 规则，Issue Reporting 规则等等。特别是“前端”开源项目，我们在看源码之前第一个想到的应该是：`package.json`文件。\n\n在 `package.json` 文件中，我们最应该关注的就是 `scripts` 字段和 `devDependencies` 以及 `dependencies` 字段，通过 `scripts` 字段我们可以知道项目中定义的脚本命令，通过 `devDependencies` 和 `dependencies` 字段我们可以了解项目的依赖情况。\n\n了解了这些之后，如果有依赖我们就 `npm install` 安装依赖就ok了。\n\n除了 `package.json` 之外，我们还要阅读项目的贡献规则文档，了解如何开始，一个好的开源项目肯定会包含这部分内容的，Vue也不例外：[https://github.com/vuejs/vue/blob/dev/.github/CONTRIBUTING.md](https://github.com/vuejs/vue/blob/dev/.github/CONTRIBUTING.md)，在这个文档里说明了一些行为准则，PR指南，Issue Reporting 指南，Development Setup 以及 项目结构。通过阅读这些内容，我们可以了解项目如何开始，如何开发以及目录的说明，下面是对重要目录和文件的简单介绍，这些内容你都可以去自己阅读获取：\n\n```\n├── build --------------------------------- 构建相关的文件，一般情况下我们不需要动\n├── dist ---------------------------------- 构建后文件的输出目录\n├── examples ------------------------------ 存放一些使用Vue开发的应用案例\n├── flow ---------------------------------- 类型声明，使用开源项目 [Flow](https://flowtype.org/)\n├── package.json -------------------------- 不解释\n├── test ---------------------------------- 包含所有测试文件\n├── src ----------------------------------- 这个是我们最应该关注的目录，包含了源码\n│   ├── entries --------------------------- 包含了不同的构建或包的入口文件\n│   │   ├── web-runtime.js ---------------- 运行时构建的入口，输出 dist/vue.common.js 文件，不包含模板(template)到render函数的编译器，所以不支持 `template` 选项，我们使用vue默认导出的就是这个运行时的版本。大家使用的时候要注意\n│   │   ├── web-runtime-with-compiler.js -- 独立构建版本的入口，输出 dist/vue.js，它包含模板(template)到render函数的编译器\n│   │   ├── web-compiler.js --------------- vue-template-compiler 包的入口文件\n│   │   ├── web-server-renderer.js -------- vue-server-renderer 包的入口文件\n│   ├── compiler -------------------------- 编译器代码的存放目录，将 template 编译为 render 函数\n│   │   ├── parser ------------------------ 存放将模板字符串转换成元素抽象语法树的代码\n│   │   ├── codegen ----------------------- 存放从抽象语法树(AST)生成render函数的代码\n│   │   ├── optimizer.js ------------------ 分析静态树，优化vdom渲染\n│   ├── core ------------------------------ 存放通用的，平台无关的代码\n│   │   ├── observer ---------------------- 反应系统，包含数据观测的核心代码\n│   │   ├── vdom -------------------------- 包含虚拟DOM创建(creation)和打补丁(patching)的代码\n│   │   ├── instance ---------------------- 包含Vue构造函数设计相关的代码\n│   │   ├── global-api -------------------- 包含给Vue构造函数挂载全局方法(静态方法)或属性的代码\n│   │   ├── components -------------------- 包含抽象出来的通用组件\n│   ├── server ---------------------------- 包含服务端渲染(server-side rendering)的相关代码\n│   ├── platforms ------------------------- 包含平台特有的相关代码\n│   ├── sfc ------------------------------- 包含单文件组件(.vue文件)的解析逻辑，用于vue-template-compiler包\n│   ├── shared ---------------------------- 包含整个代码库通用的代码\n```\n\n大概了解了重要目录和文件之后，我们就可以查看 [Development Setup](https://github.com/vuejs/vue/blob/dev/.github/CONTRIBUTING.md#development-setup) 中的常用命令部分，来了解如何开始这个项目了，我们可以看到这样的介绍：\n\n```\n# watch and auto re-build dist/vue.js\n$ npm run dev\n\n# watch and auto re-run unit tests in Chrome\n$ npm run dev:test\n```\n\n现在，我们只需要运行 `npm run dev` 即可监测文件变化并自动重新构建输出 dist/vue.js，然后运行 `npm run dev:test` 来测试。不过为了方便，我会在 `examples` 目录新建一个例子，然后引用 dist/vue.js 这样，我们可以直接拿这个例子一边改Vue源码一边看自己写的代码想怎么玩怎么玩。\n\n## <span style=\"color: #ff6600;\">二、看源码的小提示</span>\n\n在真正步入源码世界之前，我想简单说一说看源码的技巧：\n\n### *注重大体框架，从宏观到微观*\n\n当你看一个项目代码的时候，最好是能找到一条主线，先把大体流程结构摸清楚，再深入到细节，逐项击破，拿Vue举个栗子：假如你已经知道Vue中数据状态改变后会采用virtual DOM的方式更新DOM，这个时候，如果你不了解virtual DOM，那么听我一句“暂且不要去研究内部具体实现，因为这会是你丧失主线”，而你仅仅需要知道virtual DOM分为三个步骤：\n\n>一、createElement(): 用 JavaScript对象(虚拟树) 描述 真实DOM对象(真实树)\n>二、diff(oldNode, newNode) : 对比新旧两个虚拟树的区别，收集差异\n>三、patch() : 将差异应用到真实DOM树\n\n有的时候 第二步 可能与 第三步 合并成一步(Vue 中的patch就是这样)，除此之外，还比如 `src/compiler/codegen` 内的代码，可能你不知道他写了什么，直接去看它会让你很痛苦，但是你只需要知道 codegen 是用来将抽象语法树(AST)生成render函数的就OK了，也就是生成类似下面这样的代码：\n\n```js\nfunction anonymous() {\n\twith(this){return _c('p',{attrs:{\"id\":\"app\"}},[_v(\"\\n      \"+_s(a)+\"\\n      \"),_c('my-com')])}\n}\n```\n\n当我们知道了一个东西存在，且知道它存在的目的，那么我们就很容易抓住这条主线，这个系列的第一篇文章就是围绕大体主线展开的。了解大体之后，我们就知道了每部分内容都是做什么的，比如 codegen 是生成类似上面贴出的代码所示的函数的，那么再去看codegen下的代码时，目的性就会更强，就更容易理解。\n\n## <span style=\"color: #ff6600;\">三、Vue 的构造函数是什么样的<span>\n\nbalabala一大堆，开始来干货吧。我们要做的第一件事就是搞清楚 Vue 构造函数到底是什么样子的。\n\n我们知道，我们要使用 `new` 操作符来调用 `Vue`，那么也就是说 `Vue` 应该是一个构造函数，所以我们第一件要做的事儿就是把构造函数先扒的一清二楚，如何寻找 `Vue` 构造函数呢？当然是从 entry 开始啦，还记的我们运行 `npm run dev` 命令后，会输出 `dist/vue.js` 吗，那么我们就去看看 `npm run dev` 干了什么：\n\n```\n\"dev\": \"TARGET=web-full-dev rollup -w -c build/config.js\",\n```\n\n首先将 TARGET 得值设置为 'web-full-dev'，然后，然后，然后如果你不了解 rollup 就应该简单去看一下啦......，简单的说就是一个JavaScript模块打包器，你可以把它简单的理解为和 webpack 一样，只不过它有他的优势，比如 Tree-shaking (webpack2也有)，但同样，在某些场景它也有他的劣势。。。废话不多说，其中 `-w` 就是watch，`-c` 就是指定配置文件为 `build/config.js` ，我们打开这个配置文件看一看：\n\n```js\n// 引入依赖，定义 banner\n...\n\n// builds 对象\nconst builds = {\n\t...\n\t// Runtime+compiler development build (Browser)\n\t'web-full-dev': {\n\t    entry: path.resolve(__dirname, '../src/entries/web-runtime-with-compiler.js'),\n\t    dest: path.resolve(__dirname, '../dist/vue.js'),\n\t    format: 'umd',\n\t    env: 'development',\n\t    alias: { he: './entity-decoder' },\n\t    banner\n\t},\n\t...\n}\n\n// 生成配置的方法\nfunction genConfig(opts){\n\t...\n}\n\nif (process.env.TARGET) {\n  module.exports = genConfig(builds[process.env.TARGET])\n} else {\n  exports.getBuild = name => genConfig(builds[name])\n  exports.getAllBuilds = () => Object.keys(builds).map(name => genConfig(builds[name]))\n}\n```\n\n上面的代码是简化过的，当我们运行 `npm run dev` 的时候 `process.env.TARGET` 的值等于 'web-full-dev'，所以\n\n```js\nmodule.exports = genConfig(builds[process.env.TARGET])\n```\n\n这句代码相当于：\n\n```js\nmodule.exports = genConfig({\n    entry: path.resolve(__dirname, '../src/entries/web-runtime-with-compiler.js'),\n    dest: path.resolve(__dirname, '../dist/vue.js'),\n    format: 'umd',\n    env: 'development',\n    alias: { he: './entity-decoder' },\n    banner\n})\n```\n\n最终，genConfig 函数返回一个 config 对象，这个config对象就是Rollup的配置对象。那么我们就不难看到，入口文件是：\n\n```\nsrc/entries/web-runtime-with-compiler.js\n```\n\n我们打开这个文件，不要忘了我们的主题，我们在寻找Vue构造函数，所以当我们看到这个文件的第一行代码是：\n\n```js\nimport Vue from './web-runtime'\n```\n\n这个时候，你就应该知道，这个文件暂时与你无缘，你应该打开 `web-runtime.js` 文件，不过当你打开这个文件时，你发现第一行是这样的：\n\n```js\nimport Vue from 'core/index'\n```\n\n依照此思路，最终我们寻找到Vue构造函数的位置应该是在 `src/core/instance/index.js` 文件中，其实我们猜也猜得到，上面介绍目录的时候说过：instance 是存放Vue构造函数设计相关代码的目录。总结一下，我们寻找的过程是这样的：\n\n![寻找 Vue 构造函数路线](http://7xlolm.com1.z0.glb.clouddn.com/vueimg2BD0DCC6-D689-4809-93D3-2F979E8F8C0C.png)\n\n我们回头看一看 `src/core/instance/index.js` 文件，很简单：\n\n```js\nimport { initMixin } from './init'\nimport { stateMixin } from './state'\nimport { renderMixin } from './render'\nimport { eventsMixin } from './events'\nimport { lifecycleMixin } from './lifecycle'\nimport { warn } from '../util/index'\n\nfunction Vue (options) {\n  if (process.env.NODE_ENV !== 'production' &&\n    !(this instanceof Vue)) {\n    warn('Vue is a constructor and should be called with the `new` keyword')\n  }\n  this._init(options)\n}\n\ninitMixin(Vue)\nstateMixin(Vue)\neventsMixin(Vue)\nlifecycleMixin(Vue)\nrenderMixin(Vue)\n\nexport default Vue\n```\n\n引入依赖，定义 Vue 构造函数，然后以Vue构造函数为参数，调用了五个方法，最后导出 Vue。这五个方法分别来自五个文件：`init.js` `state.js` `render.js` `events.js` 以及 `lifecycle.js`。\n\n打开这五个文件，找到相应的方法，你会发现，这些方法的作用，就是在 Vue 的原型 prototype 上挂载方法或属性，经历了这五个方法后的Vue会变成这样：\n\n```js\n// initMixin(Vue)\tsrc/core/instance/init.js **************************************************\nVue.prototype._init = function (options?: Object) {}\n\n// stateMixin(Vue)\tsrc/core/instance/state.js **************************************************\nVue.prototype.$data\nVue.prototype.$set = set\nVue.prototype.$delete = del\nVue.prototype.$watch = function(){}\n\n// renderMixin(Vue)\tsrc/core/instance/render.js **************************************************\nVue.prototype.$nextTick = function (fn: Function) {}\nVue.prototype._render = function (): VNode {}\nVue.prototype._s = _toString\nVue.prototype._v = createTextVNode\nVue.prototype._n = toNumber\nVue.prototype._e = createEmptyVNode\nVue.prototype._q = looseEqual\nVue.prototype._i = looseIndexOf\nVue.prototype._m = function(){}\nVue.prototype._o = function(){}\nVue.prototype._f = function resolveFilter (id) {}\nVue.prototype._l = function(){}\nVue.prototype._t = function(){}\nVue.prototype._b = function(){}\nVue.prototype._k = function(){}\n\n// eventsMixin(Vue)\tsrc/core/instance/events.js **************************************************\nVue.prototype.$on = function (event: string, fn: Function): Component {}\nVue.prototype.$once = function (event: string, fn: Function): Component {}\nVue.prototype.$off = function (event?: string, fn?: Function): Component {}\nVue.prototype.$emit = function (event: string): Component {}\n\n// lifecycleMixin(Vue)\tsrc/core/instance/lifecycle.js **************************************************\nVue.prototype._mount = function(){}\nVue.prototype._update = function (vnode: VNode, hydrating?: boolean) {}\nVue.prototype._updateFromParent = function(){}\nVue.prototype.$forceUpdate = function () {}\nVue.prototype.$destroy = function () {}\n```\n\n这样就结束了吗？并没有，根据我们之前寻找 Vue 的路线，这只是刚刚开始，我们追溯路线往回走，那么下一个处理 Vue 构造函数的应该是 `src/core/index.js` 文件，我们打开它：\n\n```js\nimport Vue from './instance/index'\nimport { initGlobalAPI } from './global-api/index'\nimport { isServerRendering } from 'core/util/env'\n\ninitGlobalAPI(Vue)\n\nObject.defineProperty(Vue.prototype, '$isServer', {\n  get: isServerRendering\n})\n\nVue.version = '__VERSION__'\n\nexport default Vue\n```\n\n这个文件也很简单，从 instance/index 中导入已经在原型上挂载了方法和属性后的 Vue，然后导入 `initGlobalAPI` 和 `isServerRendering`，之后将Vue作为参数传给  `initGlobalAPI` ，最后又在 `Vue.prototype` 上挂载了 `$isServer` ，在 `Vue` 上挂载了 `version` 属性。\n\n`initGlobalAPI` 的作用是在 `Vue` 构造函数上挂载静态属性和方法，`Vue` 在经过 `initGlobalAPI` 之后，会变成这样：\n\n```js\n// src/core/index.js / src/core/global-api/index.js\nVue.config\nVue.util = util\nVue.set = set\nVue.delete = del\nVue.nextTick = util.nextTick\nVue.options = {\n    components: {\n        KeepAlive\n    },\n    directives: {},\n    filters: {},\n    _base: Vue\n}\nVue.use\nVue.mixin\nVue.cid = 0\nVue.extend\nVue.component = function(){}\nVue.directive = function(){}\nVue.filter = function(){}\n\nVue.prototype.$isServer\nVue.version = '__VERSION__'\n```\n\n其中，稍微复杂一点的就是 `Vue.options`，大家稍微分析分析就会知道他的确长成那个样子。下一个就是 `web-runtime.js` 文件了，`web-runtime.js` 文件主要做了三件事儿：\n\n> 1、覆盖 `Vue.config` 的属性，将其设置为平台特有的一些方法\n> 2、`Vue.options.directives` 和 `Vue.options.components` 安装平台特有的指令和组件\n> 3、在 `Vue.prototype` 上定义 `__patch__` 和 `$mount`\n\n经过 `web-runtime.js` 文件之后，`Vue` 变成下面这个样子：\n\n```js\n// 安装平台特定的utils\nVue.config.isUnknownElement = isUnknownElement\nVue.config.isReservedTag = isReservedTag\nVue.config.getTagNamespace = getTagNamespace\nVue.config.mustUseProp = mustUseProp\n// 安装平台特定的 指令 和 组件\nVue.options = {\n    components: {\n        KeepAlive,\n        Transition,\n        TransitionGroup\n    },\n    directives: {\n        model,\n        show\n    },\n    filters: {},\n    _base: Vue\n}\nVue.prototype.__patch__\nVue.prototype.$mount\n```\n\n这里大家要注意的是 `Vue.options` 的变化。另外这里的 `$mount` 方法很简单：\n\n```js\nVue.prototype.$mount = function (\n  el?: string | Element,\n  hydrating?: boolean\n): Component {\n  el = el && inBrowser ? query(el) : undefined\n  return this._mount(el, hydrating)\n}\n```\n\n首先根据是否是浏览器环境决定要不要 `query(el)` 获取元素，然后将 `el` 作为参数传递给 `this._mount()`。\n\n最后一个处理 Vue 的文件就是入口文件 `web-runtime-with-compiler.js` 了，该文件做了两件事：\n\n1、缓存来自 `web-runtime.js` 文件的 `$mount` 函数\n\n```js\nconst mount = Vue.prototype.$mount\n```\n\n然后覆盖覆盖了 `Vue.prototype.$mount`\n\n2、在 Vue 上挂载 `compile`\n\n```js\nVue.compile = compileToFunctions\n```\n\ncompileToFunctions 函数的作用，就是将模板 `template` 编译为render函数。\n\n至此，我们算是还原了 Vue 构造函数，总结一下：\n\n> 1、`Vue.prototype` 下的属性和方法的挂载主要是在 `src/core/instance` 目录中的代码处理的\n\n> 2、`Vue` 下的静态属性和方法的挂载主要是在 `src/core/global-api` 目录下的代码处理的\n\n> 3、`web-runtime.js` 主要是添加web平台特有的配置、组件和指令，`web-runtime-with-compiler.js` 给Vue的 `$mount` 方法添加 `compiler` 编译器，支持 `template`。\n\n## <span style=\"color: #ff6600;\">四、一个贯穿始终的例子</span>\n\n在了解了 `Vue` 构造函数的设计之后，接下来，我们一个贯穿始终的例子就要登场了，掌声有请：\n\n```js\nlet v = new Vue({\n\tel: '#app',\n\tdata: {\n\t\ta: 1,\n\t\tb: [1, 2, 3]\n\t}\n})\n```\n\n好吧，我承认这段代码你家没满月的孩子都会写了。这段代码就是我们贯穿始终的例子，它就是这篇文章的主线，在后续的讲解中，都会以这段代码为例，当讲到必要的地方，会为其添加选项，比如讲计算属性的时候当然要加上一个 `computed` 属性了。不过在最开始，我只传递了两个选项 `el` 以及 `data`，“我们看看接下来会发生什么，让我们拭目以待“ ---- NBA球星在接受采访时最喜欢说这句话。\n\n*当我们按照例子那样编码使用Vue的时候，Vue都做了什么？*\n\n想要知道Vue都干了什么，我们就要找到 Vue 初始化程序，查看 Vue 构造函数：\n\n```js\nfunction Vue (options) {\n  if (process.env.NODE_ENV !== 'production' &&\n    !(this instanceof Vue)) {\n    warn('Vue is a constructor and should be called with the `new` keyword')\n  }\n  this._init(options)\n}\n```\n\n我们发现，`_init()` 方法就是Vue调用的第一个方法，然后将我们的参数 `options` 透传了过去。在调用 `_init()` 之前，还做了一个安全模式的处理，告诉开发者必须使用 `new` 操作符调用 Vue。根据之前我们的整理，`_init()` 方法应该是在 `src/core/instance/init.js` 文件中定义的，我们打开这个文件查看 `_init()` 方法：\n\n```js\n  Vue.prototype._init = function (options?: Object) {\n    const vm: Component = this\n    // a uid\n    vm._uid = uid++\n    // a flag to avoid this being observed\n    vm._isVue = true\n    // merge options\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options)\n    } else {\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      )\n    }\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      initProxy(vm)\n    } else {\n      vm._renderProxy = vm\n    }\n\n    // expose real self\n    vm._self = vm\n    initLifecycle(vm)\n    initEvents(vm)\n    callHook(vm, 'beforeCreate')\n    initState(vm)\n    callHook(vm, 'created')\n    initRender(vm)\n  }\n```\n\n`_init()` 方法在一开始的时候，在 `this` 对象上定义了两个属性：`_uid` 和 `_isVue`，然后判断有没有定义 `options._isComponent`，在使用 Vue 开发项目的时候，我们是不会使用 `_isComponent` 选项的，这个选项是 Vue 内部使用的，按照本节开头的例子，这里会走 `else` 分支，也就是这段代码：\n\n```js\n  vm.$options = mergeOptions(\n    resolveConstructorOptions(vm.constructor),\n    options || {},\n    vm\n  )\n```\n\n这样 `Vue` 第一步所做的事情就来了：<span style=\"color: red;\">*使用策略对象合并参数选项*</span>\n\n可以发现，Vue使用 `mergeOptions` 来处理我们调用Vue时传入的参数选项(options)，然后将返回值赋值给 `this.$options` (vm === this)，传给 `mergeOptions` 方法三个参数，我们分别来看一看，首先是：`resolveConstructorOptions(vm.constructor)`，我们查看一下这个方法：\n\n```js\nexport function resolveConstructorOptions (Ctor: Class<Component>) {\n  let options = Ctor.options\n  if (Ctor.super) {\n    const superOptions = Ctor.super.options\n    const cachedSuperOptions = Ctor.superOptions\n    const extendOptions = Ctor.extendOptions\n    if (superOptions !== cachedSuperOptions) {\n      // super option changed\n      Ctor.superOptions = superOptions\n      extendOptions.render = options.render\n      extendOptions.staticRenderFns = options.staticRenderFns\n      extendOptions._scopeId = options._scopeId\n      options = Ctor.options = mergeOptions(superOptions, extendOptions)\n      if (options.name) {\n        options.components[options.name] = Ctor\n      }\n    }\n  }\n  return options\n}\n```\n\n这个方法接收一个参数 `Ctor`，通过传入的 `vm.constructor` 我们可以知道，其实就是 `Vue` 构造函数本身。所以下面这句代码：\n\n```js\nlet options = Ctor.options\n```\n\n相当于：\n\n```js\nlet options = Vue.options\n```\n\n大家还记得 `Vue.options` 吗？在寻找Vue构造函数一节里，我们整理了 `Vue.options` 应该长成下面这个样子：\n\n```js\nVue.options = {\n    components: {\n        KeepAlive,\n        Transition,\n        TransitionGroup\n    },\n    directives: {\n        model,\n        show\n    },\n    filters: {},\n    _base: Vue\n}\n```\n\n之后判断是否定义了 `Vue.super` ，这个是用来处理继承的，我们后续再讲，在本例中，`resolveConstructorOptions` 方法直接返回了 `Vue.options`。也就是说，传递给 `mergeOptions` 方法的第一个参数就是 `Vue.options`。\n\n传给 `mergeOptions` 方法的第二个参数是我们调用Vue构造函数时的参数选项，第三个参数是 `vm` 也就是 `this` 对象，按照本节开头的例子那样使用 Vue，最终运行的代码应该如下：\n\n```js\n  vm.$options = mergeOptions(\n  \t// Vue.options\n    {\n\t    components: {\n\t        KeepAlive,\n\t        Transition,\n\t        TransitionGroup\n\t    },\n\t    directives: {\n\t        model,\n\t        show\n\t    },\n\t    filters: {},\n\t    _base: Vue\n\t},\n\t// 调用Vue构造函数时传入的参数选项 options\n    {\n    \tel: '#app',\n\t\tdata: {\n\t\t\ta: 1,\n\t\t\tb: [1, 2, 3]\n\t\t}\n    },\n    // this\n    vm\n  )\n```\n\n了解了这些，我们就可以看看 `mergeOptions` 到底做了些什么了，根据引用寻找到 `mergeOptions` 应该是在 `src/core/util/options.js` 文件中定义的。这个文件第一次看可能会头大，下面是我处理后的简略展示，大家看上去应该更容易理解了：\n\n```js\n// 1、引用依赖\nimport Vue from '../instance/index'\n其他引用...\n\n// 2、合并父子选项值为最终值的策略对象，此时 strats 是一个空对象，因为 config.optionMergeStrategies = Object.create(null)\nconst strats = config.optionMergeStrategies\n// 3、在 strats 对象上定义与参数选项名称相同的方法\nstrats.el = \nstrats.propsData = function (parent, child, vm, key){}\nstrats.data = function (parentVal, childVal, vm)\n\nconfig._lifecycleHooks.forEach(hook => {\n  strats[hook] = mergeHook\n})\n\nconfig._assetTypes.forEach(function (type) {\n  strats[type + 's'] = mergeAssets\n})\n\nstrats.watch = function (parentVal, childVal)\n\nstrats.props =\nstrats.methods =\nstrats.computed = function (parentVal: ?Object, childVal: ?Object)\n// 默认的合并策略，如果有 `childVal` 则返回 `childVal` 没有则返回 `parentVal`\nconst defaultStrat = function (parentVal: any, childVal: any): any {\n  return childVal === undefined\n    ? parentVal\n    : childVal\n}\n\n// 4、mergeOptions 中根据参数选项调用同名的策略方法进行合并处理\nexport function mergeOptions (\n  parent: Object,\n  child: Object,\n  vm?: Component\n): Object {\n\n  // 其他代码\n  ...\n\n  const options = {}\n  let key\n  for (key in parent) {\n    mergeField(key)\n  }\n  for (key in child) {\n    if (!hasOwn(parent, key)) {\n      mergeField(key)\n    }\n  }\n  function mergeField (key) {\n    const strat = strats[key] || defaultStrat\n    options[key] = strat(parent[key], child[key], vm, key)\n  }\n  return options\n\t\n}\n\n```\n\n上面的代码中，我省略了一些工具函数，例如 `mergeHook` 和 `mergeAssets` 等等，唯一需要注意的是这段代码：\n\n```js\nconfig._lifecycleHooks.forEach(hook => {\n  strats[hook] = mergeHook\n})\n\nconfig._assetTypes.forEach(function (type) {\n  strats[type + 's'] = mergeAssets\n})\n```\n\n`config` 对象引用自 `src/core/config.js` 文件，最终的结果就是在 `strats` 下添加了相应的生命周期选项的合并策略函数为 `mergeHook`，添加指令(directives)、组件(components)、过滤器(filters)等选项的合并策略函数为 `mergeAssets`。\n\n这样看来就清晰多了，拿我们贯穿本文的例子来说：\n\n```js\nlet v = new Vue({\n\tel: '#app',\n\tdata: {\n\t\ta: 1,\n\t\tb: [1, 2, 3]\n\t}\n})\n```\n\n其中 `el` 选项会使用 `defaultStrat` 默认策略函数处理，`data` 选项则会使用 `strats.data` 策略函数处理，并且根据 `strats.data` 中的逻辑，`strats.data` 方法最终会返回一个函数：`mergedInstanceDataFn`。\n\n这里就不详细的讲解每一个策略函数的内容了，后续都会讲到，这里我们还是抓住主线理清思路为主，只需要知道Vue在处理选项的时候，使用了一个策略对象对父子选项进行合并。并将最终的值赋值给实例下的 `$options` 属性即：`this.$options`，那么我们继续查看 `_init()` 方法在合并完选项之后，又做了什么：\n\n合并完选项之后，Vue 第二部做的事情就来了：<span style=\"color: red;\">*初始化工作与Vue实例对象的设计*</span>\n\n前面讲了 Vue 构造函数的设计，并且整理了 *Vue原型属性与方法* 和 *Vue静态属性与方法*，而 Vue 实例对象就是通过构造函数创造出来的，让我们来看一看 Vue 实例对象是如何设计的，下面的代码是 `_init()` 方法合并完选项之后的代码：\n\n```js\n\t/* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      initProxy(vm)\n    } else {\n      vm._renderProxy = vm\n    }\n\n    // expose real self\n\tvm._self = vm\n    initLifecycle(vm)\n    initEvents(vm)\n    callHook(vm, 'beforeCreate')\n    initState(vm)\n    callHook(vm, 'created')\n    initRender(vm)\n```\n\n根据上面的代码，在生产环境下会为实例添加两个属性，并且属性值都为实例本身：\n\n```js\nvm._renderProxy = vm\nvm._self = vm\n```\n\n然后，调用了四个 `init*` 方法分别为：`initLifecycle`、`initEvents`、`initState`、`initRender`，且在 `initState` 前后分别回调了生命周期钩子 `beforeCreate` 和 `created`，而 `initRender` 是在 `created` 钩子执行之后执行的，看到这里，也就明白了为什么 created 的时候不能操作DOM了。因为这个时候还没有渲染真正的DOM元素到文档中。`created` 仅仅代表数据状态的初始化完成。\n\n根据四个 `init*` 方法的引用关系打开对应的文件查看对应的方法，我们发现，这些方法是在处理Vue实例对象，以及做一些初始化的工作，类似整理Vue构造函数一样，我同样针对Vue实例做了属性和方法的整理，如下：\n\n```js\n// 在 Vue.prototype._init 中添加的属性 \t\t**********************************************************\nthis._uid = uid++\nthis._isVue = true\nthis.$options = {\n    components,\n    directives,\n    filters,\n    _base,\n    el,\n    data: mergedInstanceDataFn()\n}\nthis._renderProxy = this\nthis._self = this\n\n// 在 initLifecycle 中添加的属性\t\t**********************************************************\nthis.$parent = parent\nthis.$root = parent ? parent.$root : this\n \nthis.$children = []\nthis.$refs = {}\n\nthis._watcher = null\nthis._inactive = false\nthis._isMounted = false\nthis._isDestroyed = false\nthis._isBeingDestroyed = false\n\n// 在 initEvents\t 中添加的属性\t \t**********************************************************\nthis._events = {}\nthis._updateListeners = function(){}\n\n// 在 initState 中添加的属性\t\t**********************************************************\nthis._watchers = []\n    // initData\n    this._data\n\n// 在 initRender\t 中添加的属性 \t**********************************************************\nthis.$vnode = null // the placeholder node in parent tree\nthis._vnode = null // the root of the child tree\nthis._staticTrees = null\nthis.$slots\nthis.$scopedSlots\nthis._c\nthis.$createElement\n```\n\n以上就是一个Vue实例所包含的属性和方法，除此之外要注意的是，在 `initEvents` 中除了添加属性之外，如果有 `vm.$options._parentListeners` 还要调用 `vm._updateListeners()` 方法，在 `initState` 中又调用了一些其他init方法，如下：\n\n```js\nexport function initState (vm: Component) {\n  vm._watchers = []\n  initProps(vm)\n  initMethods(vm)\n  initData(vm)\n  initComputed(vm)\n  initWatch(vm)\n}\n```\n\n最后在 `initRender` 中如果有 `vm.$options.el` 还要调用 `vm.$mount(vm.$options.el)`，如下：\n\n```js\n  if (vm.$options.el) {\n    vm.$mount(vm.$options.el)\n  }\n```\n\n这就是为什么如果不传递 `el` 选项就需要手动 mount 的原因了。\n\n那么我们依照我们本节开头的的例子，以及初始化的先后顺序来逐一看一看都发生了什么。我们将 `initState` 中的 `init*` 方法展开来看，执行顺序应该是这样的（从上到下的顺序执行）：\n\n```\ninitLifecycle(vm)\ninitEvents(vm)\ncallHook(vm, 'beforeCreate')\ninitProps(vm)\ninitMethods(vm)\ninitData(vm)\ninitComputed(vm)\ninitWatch(vm)\ncallHook(vm, 'created')\ninitRender(vm)\n```\n\n首先是 `initLifecycle`，这个函数的作用就是在实例上添加一些属性，然后是 `initEvents`，由于 `vm.$options._parentListeners` 的值为 `undefined` 所以也仅仅是在实例上添加属性， `vm._updateListeners(listeners)` 并不会执行，由于我们只传递了 `el` 和 `data`，所以 `initProps`、`initMethods`、`initComputed`、`initWatch` 这四个方法什么都不会做，只有 `initData` 会执行。最后是 `initRender`，除了在实例上添加一些属性外，由于我们传递了 `el` 选项，所以会执行 `vm.$mount(vm.$options.el)`。\n\n综上所述：按照我们的例子那样写，初始化工作只包含两个主要内容即：`initData` 和 `initRender`。\n\n## <span style=\"color: #ff6600;\">五、通过`initData`看Vue的数据响应系统</span>\n\nVue的数据响应系统包含三个部分：`Observer`、`Dep`、`Watcher`。关于数据响应系统的内容真的已经被文章讲烂了，所以我就简单的说一下，力求大家能理解就ok，我们还是先看一下 `initData` 中的代码：\n\n```\nfunction initData (vm: Component) {\n  let data = vm.$options.data\n  data = vm._data = typeof data === 'function'\n    ? data.call(vm)\n    : data || {}\n  if (!isPlainObject(data)) {\n    data = {}\n    process.env.NODE_ENV !== 'production' && warn(\n      'data functions should return an object:\\n' +\n      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',\n      vm\n    )\n  }\n  // proxy data on instance\n  const keys = Object.keys(data)\n  const props = vm.$options.props\n  let i = keys.length\n  while (i--) {\n    if (props && hasOwn(props, keys[i])) {\n      process.env.NODE_ENV !== 'production' && warn(\n        `The data property \"${keys[i]}\" is already declared as a prop. ` +\n        `Use prop default value instead.`,\n        vm\n      )\n    } else {\n      proxy(vm, keys[i])\n    }\n  }\n  // observe data\n  observe(data)\n  data.__ob__ && data.__ob__.vmCount++\n}\n```\n\n首先，先拿到 data 数据：`let data = vm.$options.data`，大家还记得此时 `vm.$options.data` 的值应该是通过 `mergeOptions` 合并处理后的 `mergedInstanceDataFn` 函数吗？所以在得到 data 后，它又判断了 data 的数据类型是不是 'function'，最终的结果是：data 还是我们传入的数据选项的 data，即：\n\n```\ndata: {\n\ta: 1,\n\tb: [1, 2, 3]\n}\n```\n\n然后在实例对象上定义 `_data` 属性，该属性与 `data` 是相同的引用。\n\n然后是一个 `while` 循环，循环的目的是在实例对象上对数据进行代理，这样我们就能通过 `this.a` 来访问 `data.a` 了，代码的处理是在 `proxy` 函数中，该函数非常简单，仅仅是在实例对象上设置与 `data` 属性同名的访问器属性，然后使用 `_data` 做数据劫持，如下：\n\n```\nfunction proxy (vm: Component, key: string) {\n  if (!isReserved(key)) {\n    Object.defineProperty(vm, key, {\n      configurable: true,\n      enumerable: true,\n      get: function proxyGetter () {\n        return vm._data[key]\n      },\n      set: function proxySetter (val) {\n        vm._data[key] = val\n      }\n    })\n  }\n}\n```\n\n做完数据的代理，就正式进入响应系统，\n\n```\nobserve(data)\n```\n\n我们说过，数据响应系统主要包含三部分：`Observer`、`Dep`、`Watcher`，代码分别存放在：`observer/index.js`、`observer/dep.js` 以及 `observer/watcher.js` 文件中，这回我们换一种方式，我们先不看其源码，大家先跟着我的思路来思考，最后回头再去看代码，你会有一种：”奥，不过如此“的感觉。\n\n假如，我们有如下代码：\n\n```js\nvar data = {\n    a: 1,\n    b: {\n        c: 2\n    }\n}\n\nobserver(data)\n\nnew Watch('a', () => {\n    alert(9)\n})\nnew Watch('a', () => {\n    alert(90)\n})\nnew Watch('b.c', () => {\n    alert(80)\n})\n```\n\n这段代码目的是，首先定义一个数据对象 `data`，然后通过 observer 对其进行观测，之后定义了三个观察者，当数据有变化时，执行相应的方法，这个功能使用Vue的实现原来要如何去实现？其实就是在问 `observer` 怎么写？`Watch` 构造函数又怎么写？接下来我们逐一实现。\n\n首先，observer 的作用是：将数据对象data的属性转换为访问器属性：\n\n```\nclass Observer {\n    constructor (data) {\n        this.walk(data)\n    }\n    walk (data) {\n        // 遍历 data 对象属性，调用 defineReactive 方法\n        let keys = Object.keys(data)\n        for(let i = 0; i < keys.length; i++){\n            defineReactive(data, keys[i], data[keys[i]])\n        }\n    }\n}\n\n// defineReactive方法仅仅将data的属性转换为访问器属性\nfunction defineReactive (data, key, val) {\n\t// 递归观测子属性\n    observer(val)\n\n    Object.defineProperty(data, key, {\n        enumerable: true,\n        configurable: true,\n        get: function () {\n            return val\n        },\n        set: function (newVal) {\n            if(val === newVal){\n                return\n            }\n            // 对新值进行观测\n            observer(newVal)\n        }\n    })\n}\n\n// observer 方法首先判断data是不是纯JavaScript对象，如果是，调用 Observer 类进行观测\nfunction observer (data) {\n    if(Object.prototype.toString.call(data) !== '[object Object]') {\n        return\n    }\n    new Observer(data)\n}\n```\n\n上面的代码中，我们定义了 observer 方法，该方法检测了数据data是不是纯JavaScript对象，如果是就调用 `Observer` 类，并将 `data` 作为参数透传。在 `Observer` 类中，我们使用 `walk` 方法对数据data的属性循环调用 `defineReactive` 方法，`defineReactive` 方法很简单，仅仅是将数据data的属性转为访问器属性，并对数据进行递归观测，否则只能观测数据data的直属子属性。这样我们的第一步工作就完成了，当我们修改或者获取data属性值的时候，通过 `get` 和 `set` 即能获取到通知。\n\n我们继续往下看，来看一下 `Watch`：\n\n```\nnew Watch('a', () => {\n    alert(9)\n})\n```\n\n现在的问题是，`Watch` 要怎么和 `observer` 关联？？？？？？？我们看看 `Watch` 它知道些什么，通过上面调用 `Watch` 的方式，传递给 `Watch` 两个参数，一个是 'a' 我们可以称其为表达式，另外一个是回调函数。所以我们目前只能写出这样的代码：\n\n```\nclass Watch {\n    constructor (exp, fn) {\n        this.exp = exp\n        this.fn = fn\n    }\n}\n```\n\n那么要怎么关联呢，大家看下面的代码会发生什么：\n\n```\nclass Watch {\n    constructor (exp, fn) {\n        this.exp = exp\n        this.fn = fn\n        data[exp]\n    }\n}\n```\n\n多了一句 `data[exp]`，这句话是在干什么？是不是在获取 `data` 下某个属性的值，比如 exp 为 'a' 的话，那么 `data[exp]` 就相当于在获取 `data.a` 的值，那这会放生什么？大家不要忘了，此时数据 `data` 下的属性已经是访问器属性了，所以这么做的结果会直接触发对应属性的 `get` 函数，这样我们就成功的和 `observer` 产生了关联，但这样还不够，我们还是没有达到目的，不过我们已经无限接近了，我们继续思考看一下可不可以这样：\n\n> 既然在 `Watch` 中对表达式求值，能够触发 `observer` 的 `get`，那么可不可以在 `get` 中收集 `Watch` 中函数呢？\n\n答案是可以的，不过这个时候我们就需要 `Dep` 出场了，它是一个依赖收集器。我们的思路是：`data` 下的每一个属性都有一个唯一的 `Dep` 对象，在 `get` 中收集仅针对该属性的依赖，然后在 `set` 方法中触发所有收集的依赖，这样就搞定了，看如下代码：\n\n```\nclass Dep {\n    constructor () {\n        this.subs = []\n    }\n    addSub () {\n        this.subs.push(Dep.target)\n    }\n    notify () {\n        for(let i = 0; i < this.subs.length; i++){\n            this.subs[i].fn()\n        }\n    }\n}\nDep.target = null\nfunction pushTarget(watch){\n    Dep.target = watch\n}\n\nclass Watch {\n    constructor (exp, fn) {\n        this.exp = exp\n        this.fn = fn\n        pushTarget(this)\n        data[exp]\n    }\n}\n```\n\n上面的代码中，我们在 `Watch` 中增加了 `pushTarget(this)`，可以发现，这句代码的作用是将 `Dep.target` 的值设置为该Watch对象。在 `pushTarget` 之后我们才对表达式进行求值，接着，我们修改 `defineReactive` 代码如下\n\n```\nfunction defineReactive (data, key, val) {\n    observer(val)\n    let dep = new Dep()\t\t// 新增\n    Object.defineProperty(data, key, {\n        enumerable: true,\n        configurable: true,\n        get: function () {\n            dep.addSub()\t// 新增\n            return val\n        },\n        set: function (newVal) {\n            if(val === newVal){\n                return\n            }\n            observer(newVal)\n            dep.notify()\t// 新增\n        }\n    })\n}\n```\n\n如标注，新增了三句代码，我们知道，`Watch` 中对表达式求值会触发 `get` 方法，我们在 `get` 方法中调用了 `dep.addSub`，也就执行了这句代码：`this.subs.push(Dep.target)`，由于在这句代码执行之前，`Dep.target` 的值已经被设置为一个 `Watch` 对象了，所以最终结果就是收集了一个 `Watch` 对象，然后在 `set` 方法中我们调用了 `dep.notify`，所以当data属性值变化的时候，就会通过 `dep.notify` 循环调用所有收集的Watch对象中的回调函数：\n\n```\nnotify () {\n    for(let i = 0; i < this.subs.length; i++){\n        this.subs[i].fn()\n    }\n}\n```\n\n这样 `observer`、`Dep`、`Watch` 三者就联系成为一个有机的整体，实现了我们最初的目标，完整的代码可以戳这里：[observer-dep-watch](https://github.com/HcySunYang/observer-dep-watch)。这里还给大家挖了个坑，因为我们没有处理对数组的观测，由于比较复杂并且这又不是我们讨论的重点，如果大家想了解可以戳我的这篇文章：[JavaScript实现MVVM之我就是想监测一个普通对象的变化](http://hcysun.me/2016/04/28/JavaScript%E5%AE%9E%E7%8E%B0MVVM%E4%B9%8B%E6%88%91%E5%B0%B1%E6%98%AF%E6%83%B3%E7%9B%91%E6%B5%8B%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8F%98%E5%8C%96/)，另外，在 Watch 中对表达式求值的时候也只做了直接子属性的求值，所以如果 exp 的值为 'a.b' 的时候，就不可以用了，Vue的做法是使用 `.` 分割表达式字符串为数组，然后遍历一下对其进行求值，大家可以查看其源码。如下：\n\n```\n/**\n * Parse simple path.\n */\nconst bailRE = /[^\\w.$]/\nexport function parsePath (path: string): any {\n  if (bailRE.test(path)) {\n    return\n  } else {\n    const segments = path.split('.')\n    return function (obj) {\n      for (let i = 0; i < segments.length; i++) {\n        if (!obj) return\n        obj = obj[segments[i]]\n      }\n      return obj\n    }\n  }\n}\n```\n\nVue 的求值代码是在 `src/core/util/lang.js` 文件中 `parsePath` 函数中实现的。总结一下Vue的依赖收集过程应该是这样的：\n\n![Vue的依赖收集过程](http://7xlolm.com1.z0.glb.clouddn.com/vueimgdep.png)\n\n实际上，Vue并没有直接在 `get` 中调用 `addSub`，而是调用的 `dep.depend`，目的是将当前的 dep 对象收集到 watch 对象中，如果要完整的流程，应该是这样的：（大家注意数据的每一个字段都拥有自己的 `dep` 对象和 `get` 方法。）\n\n![Vue完整的收集依赖的流程](http://7xlolm.com1.z0.glb.clouddn.com/all.png)\n\n这样 Vue 就建立了一套数据响应系统，之前我们说过，按照我们的例子那样写，初始化工作只包含两个主要内容即：`initData` 和 `initRender`。现在 `initData` 我们分析完了，接下来看一看 `initRender`\n\n## <span style=\"color: #ff6600;\">六、通过`initRender`看Vue的 render(渲染) 与 re-render(重新渲染)</span>\n\n在 `initRender` 方法中，因为我们的例子中传递了 `el` 选项，所以下面的代码会执行：\n\n```\n  if (vm.$options.el) {\n    vm.$mount(vm.$options.el)\n  }\n```\n\n这里，调用了 `$mount` 方法，在还原Vue构造函数的时候，我们整理过所有的方法，其中 `$mount` 方法在两个地方出现过：\n\n1、在 `web-runtime.js` 文件中：\n\n```\nVue.prototype.$mount = function (\n  el?: string | Element,\n  hydrating?: boolean\n): Component {\n  el = el && inBrowser ? query(el) : undefined\n  return this._mount(el, hydrating)\n}\n```\n\n它的作用是通过 `el` 获取相应的DOM元素，然后调用 `lifecycle.js` 文件中的 `_mount` 方法。\n\n2、在 `web-runtime-with-compiler.js` 文件中：\n\n```\n// 缓存了来自 web-runtime.js 的 $mount 方法\nconst mount = Vue.prototype.$mount\n// 重写 $mount 方法\nVue.prototype.$mount = function (\n  el?: string | Element,\n  hydrating?: boolean\n): Component {\n  // 根据 el 获取相应的DOM元素\n  el = el && query(el)\n  // 不允许你将 el 挂载到 html 标签或者 body 标签\n  if (el === document.body || el === document.documentElement) {\n    process.env.NODE_ENV !== 'production' && warn(\n      `Do not mount Vue to <html> or <body> - mount to normal elements instead.`\n    )\n    return this\n  }\n\n  const options = this.$options\n  // 如果我们没有写 render 选项，那么就尝试将 template 或者 el 转化为 render 函数\n  if (!options.render) {\n    let template = options.template\n    if (template) {\n      if (typeof template === 'string') {\n        if (template.charAt(0) === '#') {\n          template = idToTemplate(template)\n          /* istanbul ignore if */\n          if (process.env.NODE_ENV !== 'production' && !template) {\n            warn(\n              `Template element not found or is empty: ${options.template}`,\n              this\n            )\n          }\n        }\n      } else if (template.nodeType) {\n        template = template.innerHTML\n      } else {\n        if (process.env.NODE_ENV !== 'production') {\n          warn('invalid template option:' + template, this)\n        }\n        return this\n      }\n    } else if (el) {\n      template = getOuterHTML(el)\n    }\n    if (template) {\n      const { render, staticRenderFns } = compileToFunctions(template, {\n        warn,\n        shouldDecodeNewlines,\n        delimiters: options.delimiters\n      }, this)\n      options.render = render\n      options.staticRenderFns = staticRenderFns\n    }\n  }\n  // 调用已经缓存下来的 web-runtime.js 文件中的 $mount 方法\n  return mount.call(this, el, hydrating)\n}\n```\n\n分析一下可知 `web-runtime-with-compiler.js` 的逻辑如下：\n\n1、缓存来自 `web-runtime.js` 文件的 `$mount` 方法\n\n2、判断有没有传递 `render` 选项，如果有直接调用来自 `web-runtime.js` 文件的 $mount 方法\n\n3、如果没有传递 `render` 选项，那么查看有没有 `template` 选项，如果有就使用 `compileToFunctions` 函数根据其内容编译成 `render` 函数\n\n4、如果没有 `template` 选项，那么查看有没有 `el` 选项，如果有就使用 `compileToFunctions` 函数将其内容(template = getOuterHTML(el))编译成 `render` 函数\n\n5、将编译成的 `render` 函数挂载到 `this.$options` 属性下，并调用缓存下来的 `web-runtime.js` 文件中的 $mount 方法\n\n简单的用一张图表示 `mount` 方法的调用关系，从上至下调用：\n\n![mount调用关系](http://7xlolm.com1.z0.glb.clouddn.com/vueimgmount.png)\n\n不过不管怎样，我们发现这些步骤的最终目的是生成 `render` 函数，然后再调用 `lifecycle.js` 文件中的 `_mount` 方法，我们看看这个方法做了什么事情，查看 `_mount` 方法的代码，这是简化过得：\n\n```\n  Vue.prototype._mount = function (\n    el?: Element | void,\n    hydrating?: boolean\n  ): Component {\n    const vm: Component = this\n\n    // 在Vue实例对象上添加 $el 属性，指向挂载点元素\n    vm.$el = el\n\n    // 触发 beforeMount 生命周期钩子\n    callHook(vm, 'beforeMount')\n\n    vm._watcher = new Watcher(vm, () => {\n      vm._update(vm._render(), hydrating)\n    }, noop)\n\n    // 如果是第一次mount则触发 mounted 生命周期钩子\n    if (vm.$vnode == null) {\n      vm._isMounted = true\n      callHook(vm, 'mounted')\n    }\n    return vm\n  }\n```\n\n上面的代码很简单，该注释的都注释了，唯一需要看的就是这段代码：\n\n```\nvm._watcher = new Watcher(vm, () => {\n  vm._update(vm._render(), hydrating)\n}, noop)\n```\n\n看上去很眼熟有没有？我们平时使用Vue都是这样使用 watch的：\n\n```\nthis.$watch('a', (newVal, oldVal) => {\n\t\n})\n// 或者\nthis.$watch(function(){\n\treturn this.a + this.b\n}, (newVal, oldVal) => {\n\t\n})\n```\n\n第一个参数是 表达式或者函数，第二个参数是回调函数，第三个参数是可选的选项。原理是 `Watch` 内部对表达式求值或者对函数求值从而触发数据的 `get` 方法收集依赖。可是 `_mount` 方法中使用 `Watcher` 的时候第一个参数 `vm` 是什么鬼。我们不妨去看看源码中 `$watch` 函数是如何实现的，根据之前还原Vue构造函数中所整理的内容可知：`$warch` 方法是在 `src/core/instance/state.js` 文件中的 `stateMixin` 方法中定义的，源码如下：\n\n```\n  Vue.prototype.$watch = function (\n    expOrFn: string | Function,\n    cb: Function,\n    options?: Object\n  ): Function {\n    const vm: Component = this\n    options = options || {}\n    options.user = true\n    const watcher = new Watcher(vm, expOrFn, cb, options)\n    if (options.immediate) {\n      cb.call(vm, watcher.value)\n    }\n    return function unwatchFn () {\n      watcher.teardown()\n    }\n  }\n```\n\n我们可以发现，`$warch` 其实是对 `Watcher` 的一个封装，内部的 `Watcher` 的第一个参数实际上也是 `vm` 即：Vue实例对象，这一点我们可以在 `Watcher` 的源码中得到验证，代开 `observer/watcher.js` 文件查看：\n\n```js\nexport default class Watcher {\n\n  constructor (\n    vm: Component,\n    expOrFn: string | Function,\n    cb: Function,\n    options?: Object = {}\n  ) {\n    \n  }\n}\n```\n\n可以发现真正的 `Watcher` 第一个参数实际上就是 `vm`。第二个参数是表达式或者函数，然后以此类推，所以现在再来看 `_mount` 中的这段代码：\n\n```\nvm._watcher = new Watcher(vm, () => {\n  vm._update(vm._render(), hydrating)\n}, noop)\n```\n\n忽略第一个参数 `vm`，也就说，`Watcher` 内部应该对第二个参数求值，也就是运行这个函数：\n\n```\n() => {\n  vm._update(vm._render(), hydrating)\n}\n```\n\n所以 `vm._render()` 函数被第一个执行，该函数在 `src/core/instance/render.js` 中，该方法中的代码很多，下面是简化过的：\n\n```\n  Vue.prototype._render = function (): VNode {\n    const vm: Component = this\n    // 解构出 $options 中的 render 函数\n    const {\n      render,\n      staticRenderFns,\n      _parentVnode\n    } = vm.$options\n    ...\n\n    let vnode\n    try {\n      // 运行 render 函数\n      vnode = render.call(vm._renderProxy, vm.$createElement)\n    } catch (e) {\n      ...\n    }\n    \n    // set parent\n    vnode.parent = _parentVnode\n    return vnode\n  }\n```\n\n`_render` 方法首先从 `vm.$options` 中解构出 `render` 函数，大家应该记得：`vm.$options.render` 方法是在 `web-runtime-with-compiler.js` 文件中通过 `compileToFunctions` 方法将 `template` 或 `el` 编译而来的。解构出 `render` 函数后，接下来便执行了该方法：\n\n```\nvnode = render.call(vm._renderProxy, vm.$createElement)\n```\n\n其中使用 `call` 指定了 `render` 函数的作用域环境为 `vm._renderProxy`，这个属性在我们整理实例对象的时候知道，他是在 `Vue.prototype._init` 方法中被添加的，即：`vm._renderProxy = vm`，其实就是Vue实例对象本身，然后传递了一个参数：`vm.$createElement`。那么 `render` 函数到底是干什么的呢？让我们根据上面那句代码猜一猜，我们已经知道 `render` 函数是从 `template` 或 `el` 编译而来的，如果没错的话应该是返回一个虚拟DOM对象。我们不妨使用 `console.log` 打印一下 `render` 函数，当我们的模板这样编写时：\n\n```\n<ul id=\"app\">\n  <li>{{a}}</li>\n</ul>\n```\n\n打印的 `render` 函数如下：\n\n![render函数1](http://7xlolm.com1.z0.glb.clouddn.com/vueimgr2.png)\n\n我们修改模板为：\n\n```\n<ul id=\"app\">\n  <li v-for=\"i in b\">{{a}}</li>\n</ul>\n```\n\n打印出来的 `render` 函数如下：\n\n![render函数2](http://7xlolm.com1.z0.glb.clouddn.com/vueimgr3.png)\n\n其实了解Vue2.x版本的同学都知道，Vue提供了 `render` 选项，作为 `template` 的代替方案，同时为JavaScript提供了完全编程的能力，下面两种编写模板的方式实际是等价的：\n\n```js\n// 方案一：\nnew Vue({\n\tel: '#app',\n\tdata: {\n\t\ta: 1\n\t},\n\ttemplate: '<ul><li>{{a}}</li><li>{{a}}</li></ul>'\n})\n\n// 方案二：\nnew Vue({\n\tel: '#app',\n\trender: function (createElement) {\n\t\tcreateElement('ul', [\n\t\t\tcreateElement('li', this.a),\n\t\t\tcreateElement('li', this.a)\n\t\t])\n\t}\n})\n```\n\n现在我们再来看我们打印的 `render` 函数：\n\n```\nfunction anonymous() {\n\twith(this){\n\t\treturn _c('ul', { \n\t\t\tattrs: {\"id\": \"app\"}\n\t\t},[\n\t\t\t_c('li', [_v(_s(a))])\n\t\t])\n\t}\n}\n```\n\n是不是与我们自己写 `render` 函数很像？因为 render 函数的作用域被绑定到了Vue实例，即：`render.call(vm._renderProxy, vm.$createElement)`，所以上面代码中 `_c`、`_v`、`_s` 以及变量 `a`相当于Vue实例下的方法和变量。大家还记得诸如 `_c`、`_v`、`_s` 这样的方法在哪里定义的吗？我们在整理Vue构造函数的时候知道，他们在 `src/core/instance/render.js` 文件中的 `renderMixin` 方法中定义，除了这些之外还有诸如：`_l`、 `_m`、 `_o` 等等。其中 `_l` 就在我们使用 `v-for` 指令的时候出现了。所以现在大家知道为什么这些方法都被定义在 `render.js` 文件中了吧，因为他们就是为了构造出 `render` 函数而存在的。\n\n现在我们已经知道了 `render` 函数的长相，也知道了 `render` 函数的作用域是Vue实例本身即：`this`(或`vm`)。那么当我们执行 `render` 函数时，其中的变量如：`a`，就相当于：`this.a`，我们知道这是在求值，所以 `_mount` 中的这段代码：\n\n```\nvm._watcher = new Watcher(vm, () => {\n  vm._update(vm._render(), hydrating)\n}, noop)\n```\n\n当 `vm._render` 执行的时候，所依赖的变量就会被求值，并被收集为依赖。按照Vue中 `watcher.js` 的逻辑，当依赖的变量有变化时不仅仅回调函数被执行，实际上还要重新求值，即还要执行一遍：\n\n```\n() => {\n  vm._update(vm._render(), hydrating)\n}\n```\n\n这实际上就做到了 `re-render`，因为 `vm._update` 就是文章开头所说的虚拟DOM中的最后一步：`patch`\n\n`vm_render` 方法最终返回一个 `vnode` 对象，即虚拟DOM，然后作为 `vm_update` 的第一个参数传递了过去，我们看一下 `vm_update` 的逻辑，在 `src/core/instance/lifecycle.js` 文件中有这么一段代码：\n\n```js\n    if (!prevVnode) {\n      // initial render\n      vm.$el = vm.__patch__(\n        vm.$el, vnode, hydrating, false /* removeOnly */,\n        vm.$options._parentElm,\n        vm.$options._refElm\n      )\n    } else {\n      // updates\n      vm.$el = vm.__patch__(prevVnode, vnode)\n    }\n```\n\n如果还没有 `prevVnode` 说明是首次渲染，直接创建真实DOM。如果已经有了 `prevVnode` 说明不是首次渲染，那么就采用 `patch` 算法进行必要的DOM操作。这就是Vue更新DOM的逻辑。只不过我们没有将 virtual DOM 内部的实现。\n\n现在我们来好好理理思路，当我们写如下代码时：\n\n```\nnew Vue({\n\tel: '#app',\n\tdata: {\n\t\ta: 1,\n\t\tb: [1, 2, 3]\n\t}\n})\n```\n\nVue 所做的事：\n\n> 1、构建数据响应系统，使用 `Observer` 将数据data转换为访问器属性；将 `el` 编译为 `render` 函数，`render` 函数返回值为虚拟DOM\n\n> 2、在 `_mount` 中对 `_update` 求值，而 `_update` 又会对 `render` 求值，`render` 内部又会对依赖的变量求值，收集为被求值的变量的依赖，当变量改变时，`_update` 又会重新执行一遍，从而做到 `re-render`。\n\n用一张详细一点的图表示就是这样的：\n\n![详细流程](http://7xlolm.com1.z0.glb.clouddn.com/vueimgdetail.png)\n\n到此，我们从大体流程，挑着重点的走了一遍Vue，但是还有很多细节我们没有提及，比如：\n\n1、将模板转为 `render` 函数的时候，实际是先生成的抽象语法树（AST），再将抽象语法树转成的 `render` 函数，而且这一整套的代码我们也没有提及，因为他在复杂了，其实这部分内容就是在完正则。\n\n2、我们也没有详细的讲 Virtual DOM 的实现原理，网上已经有文章讲了，大家可以搜一搜\n\n3、我们的例子中仅仅传递了 `el` ，`data` 选项，大家知道 Vue 支持的选项很多，比如我们都没有讲到，但都是触类旁通的，比如你搞清楚了 `data` 选项再去看 `computed` 选项或者 `props` 选项就会很容易，比如你知道了 `Watcher` 的工作机制再去看 `watch` 选项就会很容易。\n\n本篇文章作为Vue源码的启蒙文章，也许还有很多缺陷，全当抛砖引玉了。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Vue源码学习","published":1,"updated":"2017-05-09T10:54:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj669fskj001vewfc2eldvdp7","content":"<p>原本文章的名字叫做《源码解析》，不过后来想想，还是用“源码学习”来的合适一点，在没有彻底掌握源码中的每一个字母之前，“解析”就有点标题党了。建议在看这篇文章之前，最好打开2.1.7的源码对照着看，这样可能更容易理解。另外本人水平有限，文中有错误或不妥的地方望大家多多指正共同成长。</p>\n<p>补充：Vue 2.2 刚刚发布，作为一个系列文章的第一篇，本篇文章主要从Vue代码的组织，Vue构造函数的还原，原型的设计，以及参数选项的处理和已经被写烂了的数据绑定与如何使用 Virtual DOM 更新视图入手。从整体的大方向观察框架，这么看来 <code>V2.1.7</code> 对于理解 <code>V2.2</code> 的代码不会有太大的影响。该系列文章的后续文章，都会从最新的源码入手，并对改动的地方做相应的提示。</p>\n<a id=\"more\"></a>\n<p>很久之前写过一篇文章：<a href=\"http://hcysun.me/2016/04/28/JavaScript%E5%AE%9E%E7%8E%B0MVVM%E4%B9%8B%E6%88%91%E5%B0%B1%E6%98%AF%E6%83%B3%E7%9B%91%E6%B5%8B%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8F%98%E5%8C%96/\">JavaScript实现MVVM之我就是想监测一个普通对象的变化</a>，文章开头提到了我写博客的风格，还是那句话，只写努力让小白，甚至是小学生都能看明白的文章。这不免会导致对于某些同学来说这篇文章有些墨迹，所以大家根据自己的喜好，可以详细的看，也可以跳跃着看。</p>\n<h2 id=\"一、从了解一个开源项目入手\"><a href=\"#一、从了解一个开源项目入手\" class=\"headerlink\" title=\"一、从了解一个开源项目入手\"></a><span style=\"color: #ff6600;\">一、从了解一个开源项目入手<span></span></span></h2><p>要看一个项目的源码，不要一上来就看，先去了解一下项目本身的元数据和依赖，除此之外最好也了解一下 PR 规则，Issue Reporting 规则等等。特别是“前端”开源项目，我们在看源码之前第一个想到的应该是：<code>package.json</code>文件。</p>\n<p>在 <code>package.json</code> 文件中，我们最应该关注的就是 <code>scripts</code> 字段和 <code>devDependencies</code> 以及 <code>dependencies</code> 字段，通过 <code>scripts</code> 字段我们可以知道项目中定义的脚本命令，通过 <code>devDependencies</code> 和 <code>dependencies</code> 字段我们可以了解项目的依赖情况。</p>\n<p>了解了这些之后，如果有依赖我们就 <code>npm install</code> 安装依赖就ok了。</p>\n<p>除了 <code>package.json</code> 之外，我们还要阅读项目的贡献规则文档，了解如何开始，一个好的开源项目肯定会包含这部分内容的，Vue也不例外：<a href=\"https://github.com/vuejs/vue/blob/dev/.github/CONTRIBUTING.md\" target=\"_blank\" rel=\"external\">https://github.com/vuejs/vue/blob/dev/.github/CONTRIBUTING.md</a>，在这个文档里说明了一些行为准则，PR指南，Issue Reporting 指南，Development Setup 以及 项目结构。通过阅读这些内容，我们可以了解项目如何开始，如何开发以及目录的说明，下面是对重要目录和文件的简单介绍，这些内容你都可以去自己阅读获取：</p>\n<pre><code>├── build --------------------------------- 构建相关的文件，一般情况下我们不需要动\n├── dist ---------------------------------- 构建后文件的输出目录\n├── examples ------------------------------ 存放一些使用Vue开发的应用案例\n├── flow ---------------------------------- 类型声明，使用开源项目 [Flow](https://flowtype.org/)\n├── package.json -------------------------- 不解释\n├── test ---------------------------------- 包含所有测试文件\n├── src ----------------------------------- 这个是我们最应该关注的目录，包含了源码\n│   ├── entries --------------------------- 包含了不同的构建或包的入口文件\n│   │   ├── web-runtime.js ---------------- 运行时构建的入口，输出 dist/vue.common.js 文件，不包含模板(template)到render函数的编译器，所以不支持 `template` 选项，我们使用vue默认导出的就是这个运行时的版本。大家使用的时候要注意\n│   │   ├── web-runtime-with-compiler.js -- 独立构建版本的入口，输出 dist/vue.js，它包含模板(template)到render函数的编译器\n│   │   ├── web-compiler.js --------------- vue-template-compiler 包的入口文件\n│   │   ├── web-server-renderer.js -------- vue-server-renderer 包的入口文件\n│   ├── compiler -------------------------- 编译器代码的存放目录，将 template 编译为 render 函数\n│   │   ├── parser ------------------------ 存放将模板字符串转换成元素抽象语法树的代码\n│   │   ├── codegen ----------------------- 存放从抽象语法树(AST)生成render函数的代码\n│   │   ├── optimizer.js ------------------ 分析静态树，优化vdom渲染\n│   ├── core ------------------------------ 存放通用的，平台无关的代码\n│   │   ├── observer ---------------------- 反应系统，包含数据观测的核心代码\n│   │   ├── vdom -------------------------- 包含虚拟DOM创建(creation)和打补丁(patching)的代码\n│   │   ├── instance ---------------------- 包含Vue构造函数设计相关的代码\n│   │   ├── global-api -------------------- 包含给Vue构造函数挂载全局方法(静态方法)或属性的代码\n│   │   ├── components -------------------- 包含抽象出来的通用组件\n│   ├── server ---------------------------- 包含服务端渲染(server-side rendering)的相关代码\n│   ├── platforms ------------------------- 包含平台特有的相关代码\n│   ├── sfc ------------------------------- 包含单文件组件(.vue文件)的解析逻辑，用于vue-template-compiler包\n│   ├── shared ---------------------------- 包含整个代码库通用的代码\n</code></pre><p>大概了解了重要目录和文件之后，我们就可以查看 <a href=\"https://github.com/vuejs/vue/blob/dev/.github/CONTRIBUTING.md#development-setup\" target=\"_blank\" rel=\"external\">Development Setup</a> 中的常用命令部分，来了解如何开始这个项目了，我们可以看到这样的介绍：</p>\n<pre><code># watch and auto re-build dist/vue.js\n$ npm run dev\n\n# watch and auto re-run unit tests in Chrome\n$ npm run dev:test\n</code></pre><p>现在，我们只需要运行 <code>npm run dev</code> 即可监测文件变化并自动重新构建输出 dist/vue.js，然后运行 <code>npm run dev:test</code> 来测试。不过为了方便，我会在 <code>examples</code> 目录新建一个例子，然后引用 dist/vue.js 这样，我们可以直接拿这个例子一边改Vue源码一边看自己写的代码想怎么玩怎么玩。</p>\n<h2 id=\"二、看源码的小提示\"><a href=\"#二、看源码的小提示\" class=\"headerlink\" title=\"二、看源码的小提示\"></a><span style=\"color: #ff6600;\">二、看源码的小提示</span></h2><p>在真正步入源码世界之前，我想简单说一说看源码的技巧：</p>\n<h3 id=\"注重大体框架，从宏观到微观\"><a href=\"#注重大体框架，从宏观到微观\" class=\"headerlink\" title=\"注重大体框架，从宏观到微观\"></a><em>注重大体框架，从宏观到微观</em></h3><p>当你看一个项目代码的时候，最好是能找到一条主线，先把大体流程结构摸清楚，再深入到细节，逐项击破，拿Vue举个栗子：假如你已经知道Vue中数据状态改变后会采用virtual DOM的方式更新DOM，这个时候，如果你不了解virtual DOM，那么听我一句“暂且不要去研究内部具体实现，因为这会是你丧失主线”，而你仅仅需要知道virtual DOM分为三个步骤：</p>\n<blockquote>\n<p>一、createElement(): 用 JavaScript对象(虚拟树) 描述 真实DOM对象(真实树)<br>二、diff(oldNode, newNode) : 对比新旧两个虚拟树的区别，收集差异<br>三、patch() : 将差异应用到真实DOM树</p>\n</blockquote>\n<p>有的时候 第二步 可能与 第三步 合并成一步(Vue 中的patch就是这样)，除此之外，还比如 <code>src/compiler/codegen</code> 内的代码，可能你不知道他写了什么，直接去看它会让你很痛苦，但是你只需要知道 codegen 是用来将抽象语法树(AST)生成render函数的就OK了，也就是生成类似下面这样的代码：</p>\n<pre><code class=\"js\">function anonymous() {\n    with(this){return _c(&#39;p&#39;,{attrs:{&quot;id&quot;:&quot;app&quot;}},[_v(&quot;\\n      &quot;+_s(a)+&quot;\\n      &quot;),_c(&#39;my-com&#39;)])}\n}\n</code></pre>\n<p>当我们知道了一个东西存在，且知道它存在的目的，那么我们就很容易抓住这条主线，这个系列的第一篇文章就是围绕大体主线展开的。了解大体之后，我们就知道了每部分内容都是做什么的，比如 codegen 是生成类似上面贴出的代码所示的函数的，那么再去看codegen下的代码时，目的性就会更强，就更容易理解。</p>\n<h2 id=\"三、Vue-的构造函数是什么样的\"><a href=\"#三、Vue-的构造函数是什么样的\" class=\"headerlink\" title=\"三、Vue 的构造函数是什么样的\"></a><span style=\"color: #ff6600;\">三、Vue 的构造函数是什么样的<span></span></span></h2><p>balabala一大堆，开始来干货吧。我们要做的第一件事就是搞清楚 Vue 构造函数到底是什么样子的。</p>\n<p>我们知道，我们要使用 <code>new</code> 操作符来调用 <code>Vue</code>，那么也就是说 <code>Vue</code> 应该是一个构造函数，所以我们第一件要做的事儿就是把构造函数先扒的一清二楚，如何寻找 <code>Vue</code> 构造函数呢？当然是从 entry 开始啦，还记的我们运行 <code>npm run dev</code> 命令后，会输出 <code>dist/vue.js</code> 吗，那么我们就去看看 <code>npm run dev</code> 干了什么：</p>\n<pre><code>&quot;dev&quot;: &quot;TARGET=web-full-dev rollup -w -c build/config.js&quot;,\n</code></pre><p>首先将 TARGET 得值设置为 ‘web-full-dev’，然后，然后，然后如果你不了解 rollup 就应该简单去看一下啦……，简单的说就是一个JavaScript模块打包器，你可以把它简单的理解为和 webpack 一样，只不过它有他的优势，比如 Tree-shaking (webpack2也有)，但同样，在某些场景它也有他的劣势。。。废话不多说，其中 <code>-w</code> 就是watch，<code>-c</code> 就是指定配置文件为 <code>build/config.js</code> ，我们打开这个配置文件看一看：</p>\n<pre><code class=\"js\">// 引入依赖，定义 banner\n...\n\n// builds 对象\nconst builds = {\n    ...\n    // Runtime+compiler development build (Browser)\n    &#39;web-full-dev&#39;: {\n        entry: path.resolve(__dirname, &#39;../src/entries/web-runtime-with-compiler.js&#39;),\n        dest: path.resolve(__dirname, &#39;../dist/vue.js&#39;),\n        format: &#39;umd&#39;,\n        env: &#39;development&#39;,\n        alias: { he: &#39;./entity-decoder&#39; },\n        banner\n    },\n    ...\n}\n\n// 生成配置的方法\nfunction genConfig(opts){\n    ...\n}\n\nif (process.env.TARGET) {\n  module.exports = genConfig(builds[process.env.TARGET])\n} else {\n  exports.getBuild = name =&gt; genConfig(builds[name])\n  exports.getAllBuilds = () =&gt; Object.keys(builds).map(name =&gt; genConfig(builds[name]))\n}\n</code></pre>\n<p>上面的代码是简化过的，当我们运行 <code>npm run dev</code> 的时候 <code>process.env.TARGET</code> 的值等于 ‘web-full-dev’，所以</p>\n<pre><code class=\"js\">module.exports = genConfig(builds[process.env.TARGET])\n</code></pre>\n<p>这句代码相当于：</p>\n<pre><code class=\"js\">module.exports = genConfig({\n    entry: path.resolve(__dirname, &#39;../src/entries/web-runtime-with-compiler.js&#39;),\n    dest: path.resolve(__dirname, &#39;../dist/vue.js&#39;),\n    format: &#39;umd&#39;,\n    env: &#39;development&#39;,\n    alias: { he: &#39;./entity-decoder&#39; },\n    banner\n})\n</code></pre>\n<p>最终，genConfig 函数返回一个 config 对象，这个config对象就是Rollup的配置对象。那么我们就不难看到，入口文件是：</p>\n<pre><code>src/entries/web-runtime-with-compiler.js\n</code></pre><p>我们打开这个文件，不要忘了我们的主题，我们在寻找Vue构造函数，所以当我们看到这个文件的第一行代码是：</p>\n<pre><code class=\"js\">import Vue from &#39;./web-runtime&#39;\n</code></pre>\n<p>这个时候，你就应该知道，这个文件暂时与你无缘，你应该打开 <code>web-runtime.js</code> 文件，不过当你打开这个文件时，你发现第一行是这样的：</p>\n<pre><code class=\"js\">import Vue from &#39;core/index&#39;\n</code></pre>\n<p>依照此思路，最终我们寻找到Vue构造函数的位置应该是在 <code>src/core/instance/index.js</code> 文件中，其实我们猜也猜得到，上面介绍目录的时候说过：instance 是存放Vue构造函数设计相关代码的目录。总结一下，我们寻找的过程是这样的：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/vueimg2BD0DCC6-D689-4809-93D3-2F979E8F8C0C.png\" alt=\"寻找 Vue 构造函数路线\"></p>\n<p>我们回头看一看 <code>src/core/instance/index.js</code> 文件，很简单：</p>\n<pre><code class=\"js\">import { initMixin } from &#39;./init&#39;\nimport { stateMixin } from &#39;./state&#39;\nimport { renderMixin } from &#39;./render&#39;\nimport { eventsMixin } from &#39;./events&#39;\nimport { lifecycleMixin } from &#39;./lifecycle&#39;\nimport { warn } from &#39;../util/index&#39;\n\nfunction Vue (options) {\n  if (process.env.NODE_ENV !== &#39;production&#39; &amp;&amp;\n    !(this instanceof Vue)) {\n    warn(&#39;Vue is a constructor and should be called with the `new` keyword&#39;)\n  }\n  this._init(options)\n}\n\ninitMixin(Vue)\nstateMixin(Vue)\neventsMixin(Vue)\nlifecycleMixin(Vue)\nrenderMixin(Vue)\n\nexport default Vue\n</code></pre>\n<p>引入依赖，定义 Vue 构造函数，然后以Vue构造函数为参数，调用了五个方法，最后导出 Vue。这五个方法分别来自五个文件：<code>init.js</code> <code>state.js</code> <code>render.js</code> <code>events.js</code> 以及 <code>lifecycle.js</code>。</p>\n<p>打开这五个文件，找到相应的方法，你会发现，这些方法的作用，就是在 Vue 的原型 prototype 上挂载方法或属性，经历了这五个方法后的Vue会变成这样：</p>\n<pre><code class=\"js\">// initMixin(Vue)    src/core/instance/init.js **************************************************\nVue.prototype._init = function (options?: Object) {}\n\n// stateMixin(Vue)    src/core/instance/state.js **************************************************\nVue.prototype.$data\nVue.prototype.$set = set\nVue.prototype.$delete = del\nVue.prototype.$watch = function(){}\n\n// renderMixin(Vue)    src/core/instance/render.js **************************************************\nVue.prototype.$nextTick = function (fn: Function) {}\nVue.prototype._render = function (): VNode {}\nVue.prototype._s = _toString\nVue.prototype._v = createTextVNode\nVue.prototype._n = toNumber\nVue.prototype._e = createEmptyVNode\nVue.prototype._q = looseEqual\nVue.prototype._i = looseIndexOf\nVue.prototype._m = function(){}\nVue.prototype._o = function(){}\nVue.prototype._f = function resolveFilter (id) {}\nVue.prototype._l = function(){}\nVue.prototype._t = function(){}\nVue.prototype._b = function(){}\nVue.prototype._k = function(){}\n\n// eventsMixin(Vue)    src/core/instance/events.js **************************************************\nVue.prototype.$on = function (event: string, fn: Function): Component {}\nVue.prototype.$once = function (event: string, fn: Function): Component {}\nVue.prototype.$off = function (event?: string, fn?: Function): Component {}\nVue.prototype.$emit = function (event: string): Component {}\n\n// lifecycleMixin(Vue)    src/core/instance/lifecycle.js **************************************************\nVue.prototype._mount = function(){}\nVue.prototype._update = function (vnode: VNode, hydrating?: boolean) {}\nVue.prototype._updateFromParent = function(){}\nVue.prototype.$forceUpdate = function () {}\nVue.prototype.$destroy = function () {}\n</code></pre>\n<p>这样就结束了吗？并没有，根据我们之前寻找 Vue 的路线，这只是刚刚开始，我们追溯路线往回走，那么下一个处理 Vue 构造函数的应该是 <code>src/core/index.js</code> 文件，我们打开它：</p>\n<pre><code class=\"js\">import Vue from &#39;./instance/index&#39;\nimport { initGlobalAPI } from &#39;./global-api/index&#39;\nimport { isServerRendering } from &#39;core/util/env&#39;\n\ninitGlobalAPI(Vue)\n\nObject.defineProperty(Vue.prototype, &#39;$isServer&#39;, {\n  get: isServerRendering\n})\n\nVue.version = &#39;__VERSION__&#39;\n\nexport default Vue\n</code></pre>\n<p>这个文件也很简单，从 instance/index 中导入已经在原型上挂载了方法和属性后的 Vue，然后导入 <code>initGlobalAPI</code> 和 <code>isServerRendering</code>，之后将Vue作为参数传给  <code>initGlobalAPI</code> ，最后又在 <code>Vue.prototype</code> 上挂载了 <code>$isServer</code> ，在 <code>Vue</code> 上挂载了 <code>version</code> 属性。</p>\n<p><code>initGlobalAPI</code> 的作用是在 <code>Vue</code> 构造函数上挂载静态属性和方法，<code>Vue</code> 在经过 <code>initGlobalAPI</code> 之后，会变成这样：</p>\n<pre><code class=\"js\">// src/core/index.js / src/core/global-api/index.js\nVue.config\nVue.util = util\nVue.set = set\nVue.delete = del\nVue.nextTick = util.nextTick\nVue.options = {\n    components: {\n        KeepAlive\n    },\n    directives: {},\n    filters: {},\n    _base: Vue\n}\nVue.use\nVue.mixin\nVue.cid = 0\nVue.extend\nVue.component = function(){}\nVue.directive = function(){}\nVue.filter = function(){}\n\nVue.prototype.$isServer\nVue.version = &#39;__VERSION__&#39;\n</code></pre>\n<p>其中，稍微复杂一点的就是 <code>Vue.options</code>，大家稍微分析分析就会知道他的确长成那个样子。下一个就是 <code>web-runtime.js</code> 文件了，<code>web-runtime.js</code> 文件主要做了三件事儿：</p>\n<blockquote>\n<p>1、覆盖 <code>Vue.config</code> 的属性，将其设置为平台特有的一些方法<br>2、<code>Vue.options.directives</code> 和 <code>Vue.options.components</code> 安装平台特有的指令和组件<br>3、在 <code>Vue.prototype</code> 上定义 <code>__patch__</code> 和 <code>$mount</code></p>\n</blockquote>\n<p>经过 <code>web-runtime.js</code> 文件之后，<code>Vue</code> 变成下面这个样子：</p>\n<pre><code class=\"js\">// 安装平台特定的utils\nVue.config.isUnknownElement = isUnknownElement\nVue.config.isReservedTag = isReservedTag\nVue.config.getTagNamespace = getTagNamespace\nVue.config.mustUseProp = mustUseProp\n// 安装平台特定的 指令 和 组件\nVue.options = {\n    components: {\n        KeepAlive,\n        Transition,\n        TransitionGroup\n    },\n    directives: {\n        model,\n        show\n    },\n    filters: {},\n    _base: Vue\n}\nVue.prototype.__patch__\nVue.prototype.$mount\n</code></pre>\n<p>这里大家要注意的是 <code>Vue.options</code> 的变化。另外这里的 <code>$mount</code> 方法很简单：</p>\n<pre><code class=\"js\">Vue.prototype.$mount = function (\n  el?: string | Element,\n  hydrating?: boolean\n): Component {\n  el = el &amp;&amp; inBrowser ? query(el) : undefined\n  return this._mount(el, hydrating)\n}\n</code></pre>\n<p>首先根据是否是浏览器环境决定要不要 <code>query(el)</code> 获取元素，然后将 <code>el</code> 作为参数传递给 <code>this._mount()</code>。</p>\n<p>最后一个处理 Vue 的文件就是入口文件 <code>web-runtime-with-compiler.js</code> 了，该文件做了两件事：</p>\n<p>1、缓存来自 <code>web-runtime.js</code> 文件的 <code>$mount</code> 函数</p>\n<pre><code class=\"js\">const mount = Vue.prototype.$mount\n</code></pre>\n<p>然后覆盖覆盖了 <code>Vue.prototype.$mount</code></p>\n<p>2、在 Vue 上挂载 <code>compile</code></p>\n<pre><code class=\"js\">Vue.compile = compileToFunctions\n</code></pre>\n<p>compileToFunctions 函数的作用，就是将模板 <code>template</code> 编译为render函数。</p>\n<p>至此，我们算是还原了 Vue 构造函数，总结一下：</p>\n<blockquote>\n<p>1、<code>Vue.prototype</code> 下的属性和方法的挂载主要是在 <code>src/core/instance</code> 目录中的代码处理的</p>\n<p>2、<code>Vue</code> 下的静态属性和方法的挂载主要是在 <code>src/core/global-api</code> 目录下的代码处理的</p>\n<p>3、<code>web-runtime.js</code> 主要是添加web平台特有的配置、组件和指令，<code>web-runtime-with-compiler.js</code> 给Vue的 <code>$mount</code> 方法添加 <code>compiler</code> 编译器，支持 <code>template</code>。</p>\n</blockquote>\n<h2 id=\"四、一个贯穿始终的例子\"><a href=\"#四、一个贯穿始终的例子\" class=\"headerlink\" title=\"四、一个贯穿始终的例子\"></a><span style=\"color: #ff6600;\">四、一个贯穿始终的例子</span></h2><p>在了解了 <code>Vue</code> 构造函数的设计之后，接下来，我们一个贯穿始终的例子就要登场了，掌声有请：</p>\n<pre><code class=\"js\">let v = new Vue({\n    el: &#39;#app&#39;,\n    data: {\n        a: 1,\n        b: [1, 2, 3]\n    }\n})\n</code></pre>\n<p>好吧，我承认这段代码你家没满月的孩子都会写了。这段代码就是我们贯穿始终的例子，它就是这篇文章的主线，在后续的讲解中，都会以这段代码为例，当讲到必要的地方，会为其添加选项，比如讲计算属性的时候当然要加上一个 <code>computed</code> 属性了。不过在最开始，我只传递了两个选项 <code>el</code> 以及 <code>data</code>，“我们看看接下来会发生什么，让我们拭目以待“ —- NBA球星在接受采访时最喜欢说这句话。</p>\n<p><em>当我们按照例子那样编码使用Vue的时候，Vue都做了什么？</em></p>\n<p>想要知道Vue都干了什么，我们就要找到 Vue 初始化程序，查看 Vue 构造函数：</p>\n<pre><code class=\"js\">function Vue (options) {\n  if (process.env.NODE_ENV !== &#39;production&#39; &amp;&amp;\n    !(this instanceof Vue)) {\n    warn(&#39;Vue is a constructor and should be called with the `new` keyword&#39;)\n  }\n  this._init(options)\n}\n</code></pre>\n<p>我们发现，<code>_init()</code> 方法就是Vue调用的第一个方法，然后将我们的参数 <code>options</code> 透传了过去。在调用 <code>_init()</code> 之前，还做了一个安全模式的处理，告诉开发者必须使用 <code>new</code> 操作符调用 Vue。根据之前我们的整理，<code>_init()</code> 方法应该是在 <code>src/core/instance/init.js</code> 文件中定义的，我们打开这个文件查看 <code>_init()</code> 方法：</p>\n<pre><code class=\"js\">  Vue.prototype._init = function (options?: Object) {\n    const vm: Component = this\n    // a uid\n    vm._uid = uid++\n    // a flag to avoid this being observed\n    vm._isVue = true\n    // merge options\n    if (options &amp;&amp; options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options)\n    } else {\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      )\n    }\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== &#39;production&#39;) {\n      initProxy(vm)\n    } else {\n      vm._renderProxy = vm\n    }\n\n    // expose real self\n    vm._self = vm\n    initLifecycle(vm)\n    initEvents(vm)\n    callHook(vm, &#39;beforeCreate&#39;)\n    initState(vm)\n    callHook(vm, &#39;created&#39;)\n    initRender(vm)\n  }\n</code></pre>\n<p><code>_init()</code> 方法在一开始的时候，在 <code>this</code> 对象上定义了两个属性：<code>_uid</code> 和 <code>_isVue</code>，然后判断有没有定义 <code>options._isComponent</code>，在使用 Vue 开发项目的时候，我们是不会使用 <code>_isComponent</code> 选项的，这个选项是 Vue 内部使用的，按照本节开头的例子，这里会走 <code>else</code> 分支，也就是这段代码：</p>\n<pre><code class=\"js\">  vm.$options = mergeOptions(\n    resolveConstructorOptions(vm.constructor),\n    options || {},\n    vm\n  )\n</code></pre>\n<p>这样 <code>Vue</code> 第一步所做的事情就来了：<span style=\"color: red;\"><em>使用策略对象合并参数选项</em></span></p>\n<p>可以发现，Vue使用 <code>mergeOptions</code> 来处理我们调用Vue时传入的参数选项(options)，然后将返回值赋值给 <code>this.$options</code> (vm === this)，传给 <code>mergeOptions</code> 方法三个参数，我们分别来看一看，首先是：<code>resolveConstructorOptions(vm.constructor)</code>，我们查看一下这个方法：</p>\n<pre><code class=\"js\">export function resolveConstructorOptions (Ctor: Class&lt;Component&gt;) {\n  let options = Ctor.options\n  if (Ctor.super) {\n    const superOptions = Ctor.super.options\n    const cachedSuperOptions = Ctor.superOptions\n    const extendOptions = Ctor.extendOptions\n    if (superOptions !== cachedSuperOptions) {\n      // super option changed\n      Ctor.superOptions = superOptions\n      extendOptions.render = options.render\n      extendOptions.staticRenderFns = options.staticRenderFns\n      extendOptions._scopeId = options._scopeId\n      options = Ctor.options = mergeOptions(superOptions, extendOptions)\n      if (options.name) {\n        options.components[options.name] = Ctor\n      }\n    }\n  }\n  return options\n}\n</code></pre>\n<p>这个方法接收一个参数 <code>Ctor</code>，通过传入的 <code>vm.constructor</code> 我们可以知道，其实就是 <code>Vue</code> 构造函数本身。所以下面这句代码：</p>\n<pre><code class=\"js\">let options = Ctor.options\n</code></pre>\n<p>相当于：</p>\n<pre><code class=\"js\">let options = Vue.options\n</code></pre>\n<p>大家还记得 <code>Vue.options</code> 吗？在寻找Vue构造函数一节里，我们整理了 <code>Vue.options</code> 应该长成下面这个样子：</p>\n<pre><code class=\"js\">Vue.options = {\n    components: {\n        KeepAlive,\n        Transition,\n        TransitionGroup\n    },\n    directives: {\n        model,\n        show\n    },\n    filters: {},\n    _base: Vue\n}\n</code></pre>\n<p>之后判断是否定义了 <code>Vue.super</code> ，这个是用来处理继承的，我们后续再讲，在本例中，<code>resolveConstructorOptions</code> 方法直接返回了 <code>Vue.options</code>。也就是说，传递给 <code>mergeOptions</code> 方法的第一个参数就是 <code>Vue.options</code>。</p>\n<p>传给 <code>mergeOptions</code> 方法的第二个参数是我们调用Vue构造函数时的参数选项，第三个参数是 <code>vm</code> 也就是 <code>this</code> 对象，按照本节开头的例子那样使用 Vue，最终运行的代码应该如下：</p>\n<pre><code class=\"js\">  vm.$options = mergeOptions(\n      // Vue.options\n    {\n        components: {\n            KeepAlive,\n            Transition,\n            TransitionGroup\n        },\n        directives: {\n            model,\n            show\n        },\n        filters: {},\n        _base: Vue\n    },\n    // 调用Vue构造函数时传入的参数选项 options\n    {\n        el: &#39;#app&#39;,\n        data: {\n            a: 1,\n            b: [1, 2, 3]\n        }\n    },\n    // this\n    vm\n  )\n</code></pre>\n<p>了解了这些，我们就可以看看 <code>mergeOptions</code> 到底做了些什么了，根据引用寻找到 <code>mergeOptions</code> 应该是在 <code>src/core/util/options.js</code> 文件中定义的。这个文件第一次看可能会头大，下面是我处理后的简略展示，大家看上去应该更容易理解了：</p>\n<pre><code class=\"js\">// 1、引用依赖\nimport Vue from &#39;../instance/index&#39;\n其他引用...\n\n// 2、合并父子选项值为最终值的策略对象，此时 strats 是一个空对象，因为 config.optionMergeStrategies = Object.create(null)\nconst strats = config.optionMergeStrategies\n// 3、在 strats 对象上定义与参数选项名称相同的方法\nstrats.el = \nstrats.propsData = function (parent, child, vm, key){}\nstrats.data = function (parentVal, childVal, vm)\n\nconfig._lifecycleHooks.forEach(hook =&gt; {\n  strats[hook] = mergeHook\n})\n\nconfig._assetTypes.forEach(function (type) {\n  strats[type + &#39;s&#39;] = mergeAssets\n})\n\nstrats.watch = function (parentVal, childVal)\n\nstrats.props =\nstrats.methods =\nstrats.computed = function (parentVal: ?Object, childVal: ?Object)\n// 默认的合并策略，如果有 `childVal` 则返回 `childVal` 没有则返回 `parentVal`\nconst defaultStrat = function (parentVal: any, childVal: any): any {\n  return childVal === undefined\n    ? parentVal\n    : childVal\n}\n\n// 4、mergeOptions 中根据参数选项调用同名的策略方法进行合并处理\nexport function mergeOptions (\n  parent: Object,\n  child: Object,\n  vm?: Component\n): Object {\n\n  // 其他代码\n  ...\n\n  const options = {}\n  let key\n  for (key in parent) {\n    mergeField(key)\n  }\n  for (key in child) {\n    if (!hasOwn(parent, key)) {\n      mergeField(key)\n    }\n  }\n  function mergeField (key) {\n    const strat = strats[key] || defaultStrat\n    options[key] = strat(parent[key], child[key], vm, key)\n  }\n  return options\n\n}\n</code></pre>\n<p>上面的代码中，我省略了一些工具函数，例如 <code>mergeHook</code> 和 <code>mergeAssets</code> 等等，唯一需要注意的是这段代码：</p>\n<pre><code class=\"js\">config._lifecycleHooks.forEach(hook =&gt; {\n  strats[hook] = mergeHook\n})\n\nconfig._assetTypes.forEach(function (type) {\n  strats[type + &#39;s&#39;] = mergeAssets\n})\n</code></pre>\n<p><code>config</code> 对象引用自 <code>src/core/config.js</code> 文件，最终的结果就是在 <code>strats</code> 下添加了相应的生命周期选项的合并策略函数为 <code>mergeHook</code>，添加指令(directives)、组件(components)、过滤器(filters)等选项的合并策略函数为 <code>mergeAssets</code>。</p>\n<p>这样看来就清晰多了，拿我们贯穿本文的例子来说：</p>\n<pre><code class=\"js\">let v = new Vue({\n    el: &#39;#app&#39;,\n    data: {\n        a: 1,\n        b: [1, 2, 3]\n    }\n})\n</code></pre>\n<p>其中 <code>el</code> 选项会使用 <code>defaultStrat</code> 默认策略函数处理，<code>data</code> 选项则会使用 <code>strats.data</code> 策略函数处理，并且根据 <code>strats.data</code> 中的逻辑，<code>strats.data</code> 方法最终会返回一个函数：<code>mergedInstanceDataFn</code>。</p>\n<p>这里就不详细的讲解每一个策略函数的内容了，后续都会讲到，这里我们还是抓住主线理清思路为主，只需要知道Vue在处理选项的时候，使用了一个策略对象对父子选项进行合并。并将最终的值赋值给实例下的 <code>$options</code> 属性即：<code>this.$options</code>，那么我们继续查看 <code>_init()</code> 方法在合并完选项之后，又做了什么：</p>\n<p>合并完选项之后，Vue 第二部做的事情就来了：<span style=\"color: red;\"><em>初始化工作与Vue实例对象的设计</em></span></p>\n<p>前面讲了 Vue 构造函数的设计，并且整理了 <em>Vue原型属性与方法</em> 和 <em>Vue静态属性与方法</em>，而 Vue 实例对象就是通过构造函数创造出来的，让我们来看一看 Vue 实例对象是如何设计的，下面的代码是 <code>_init()</code> 方法合并完选项之后的代码：</p>\n<pre><code class=\"js\">    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== &#39;production&#39;) {\n      initProxy(vm)\n    } else {\n      vm._renderProxy = vm\n    }\n\n    // expose real self\n    vm._self = vm\n    initLifecycle(vm)\n    initEvents(vm)\n    callHook(vm, &#39;beforeCreate&#39;)\n    initState(vm)\n    callHook(vm, &#39;created&#39;)\n    initRender(vm)\n</code></pre>\n<p>根据上面的代码，在生产环境下会为实例添加两个属性，并且属性值都为实例本身：</p>\n<pre><code class=\"js\">vm._renderProxy = vm\nvm._self = vm\n</code></pre>\n<p>然后，调用了四个 <code>init*</code> 方法分别为：<code>initLifecycle</code>、<code>initEvents</code>、<code>initState</code>、<code>initRender</code>，且在 <code>initState</code> 前后分别回调了生命周期钩子 <code>beforeCreate</code> 和 <code>created</code>，而 <code>initRender</code> 是在 <code>created</code> 钩子执行之后执行的，看到这里，也就明白了为什么 created 的时候不能操作DOM了。因为这个时候还没有渲染真正的DOM元素到文档中。<code>created</code> 仅仅代表数据状态的初始化完成。</p>\n<p>根据四个 <code>init*</code> 方法的引用关系打开对应的文件查看对应的方法，我们发现，这些方法是在处理Vue实例对象，以及做一些初始化的工作，类似整理Vue构造函数一样，我同样针对Vue实例做了属性和方法的整理，如下：</p>\n<pre><code class=\"js\">// 在 Vue.prototype._init 中添加的属性         **********************************************************\nthis._uid = uid++\nthis._isVue = true\nthis.$options = {\n    components,\n    directives,\n    filters,\n    _base,\n    el,\n    data: mergedInstanceDataFn()\n}\nthis._renderProxy = this\nthis._self = this\n\n// 在 initLifecycle 中添加的属性        **********************************************************\nthis.$parent = parent\nthis.$root = parent ? parent.$root : this\n\nthis.$children = []\nthis.$refs = {}\n\nthis._watcher = null\nthis._inactive = false\nthis._isMounted = false\nthis._isDestroyed = false\nthis._isBeingDestroyed = false\n\n// 在 initEvents     中添加的属性         **********************************************************\nthis._events = {}\nthis._updateListeners = function(){}\n\n// 在 initState 中添加的属性        **********************************************************\nthis._watchers = []\n    // initData\n    this._data\n\n// 在 initRender     中添加的属性     **********************************************************\nthis.$vnode = null // the placeholder node in parent tree\nthis._vnode = null // the root of the child tree\nthis._staticTrees = null\nthis.$slots\nthis.$scopedSlots\nthis._c\nthis.$createElement\n</code></pre>\n<p>以上就是一个Vue实例所包含的属性和方法，除此之外要注意的是，在 <code>initEvents</code> 中除了添加属性之外，如果有 <code>vm.$options._parentListeners</code> 还要调用 <code>vm._updateListeners()</code> 方法，在 <code>initState</code> 中又调用了一些其他init方法，如下：</p>\n<pre><code class=\"js\">export function initState (vm: Component) {\n  vm._watchers = []\n  initProps(vm)\n  initMethods(vm)\n  initData(vm)\n  initComputed(vm)\n  initWatch(vm)\n}\n</code></pre>\n<p>最后在 <code>initRender</code> 中如果有 <code>vm.$options.el</code> 还要调用 <code>vm.$mount(vm.$options.el)</code>，如下：</p>\n<pre><code class=\"js\">  if (vm.$options.el) {\n    vm.$mount(vm.$options.el)\n  }\n</code></pre>\n<p>这就是为什么如果不传递 <code>el</code> 选项就需要手动 mount 的原因了。</p>\n<p>那么我们依照我们本节开头的的例子，以及初始化的先后顺序来逐一看一看都发生了什么。我们将 <code>initState</code> 中的 <code>init*</code> 方法展开来看，执行顺序应该是这样的（从上到下的顺序执行）：</p>\n<pre><code>initLifecycle(vm)\ninitEvents(vm)\ncallHook(vm, &#39;beforeCreate&#39;)\ninitProps(vm)\ninitMethods(vm)\ninitData(vm)\ninitComputed(vm)\ninitWatch(vm)\ncallHook(vm, &#39;created&#39;)\ninitRender(vm)\n</code></pre><p>首先是 <code>initLifecycle</code>，这个函数的作用就是在实例上添加一些属性，然后是 <code>initEvents</code>，由于 <code>vm.$options._parentListeners</code> 的值为 <code>undefined</code> 所以也仅仅是在实例上添加属性， <code>vm._updateListeners(listeners)</code> 并不会执行，由于我们只传递了 <code>el</code> 和 <code>data</code>，所以 <code>initProps</code>、<code>initMethods</code>、<code>initComputed</code>、<code>initWatch</code> 这四个方法什么都不会做，只有 <code>initData</code> 会执行。最后是 <code>initRender</code>，除了在实例上添加一些属性外，由于我们传递了 <code>el</code> 选项，所以会执行 <code>vm.$mount(vm.$options.el)</code>。</p>\n<p>综上所述：按照我们的例子那样写，初始化工作只包含两个主要内容即：<code>initData</code> 和 <code>initRender</code>。</p>\n<h2 id=\"五、通过initData看Vue的数据响应系统\"><a href=\"#五、通过initData看Vue的数据响应系统\" class=\"headerlink\" title=\"五、通过initData看Vue的数据响应系统\"></a><span style=\"color: #ff6600;\">五、通过<code>initData</code>看Vue的数据响应系统</span></h2><p>Vue的数据响应系统包含三个部分：<code>Observer</code>、<code>Dep</code>、<code>Watcher</code>。关于数据响应系统的内容真的已经被文章讲烂了，所以我就简单的说一下，力求大家能理解就ok，我们还是先看一下 <code>initData</code> 中的代码：</p>\n<pre><code>function initData (vm: Component) {\n  let data = vm.$options.data\n  data = vm._data = typeof data === &#39;function&#39;\n    ? data.call(vm)\n    : data || {}\n  if (!isPlainObject(data)) {\n    data = {}\n    process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; warn(\n      &#39;data functions should return an object:\\n&#39; +\n      &#39;https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function&#39;,\n      vm\n    )\n  }\n  // proxy data on instance\n  const keys = Object.keys(data)\n  const props = vm.$options.props\n  let i = keys.length\n  while (i--) {\n    if (props &amp;&amp; hasOwn(props, keys[i])) {\n      process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; warn(\n        `The data property &quot;${keys[i]}&quot; is already declared as a prop. ` +\n        `Use prop default value instead.`,\n        vm\n      )\n    } else {\n      proxy(vm, keys[i])\n    }\n  }\n  // observe data\n  observe(data)\n  data.__ob__ &amp;&amp; data.__ob__.vmCount++\n}\n</code></pre><p>首先，先拿到 data 数据：<code>let data = vm.$options.data</code>，大家还记得此时 <code>vm.$options.data</code> 的值应该是通过 <code>mergeOptions</code> 合并处理后的 <code>mergedInstanceDataFn</code> 函数吗？所以在得到 data 后，它又判断了 data 的数据类型是不是 ‘function’，最终的结果是：data 还是我们传入的数据选项的 data，即：</p>\n<pre><code>data: {\n    a: 1,\n    b: [1, 2, 3]\n}\n</code></pre><p>然后在实例对象上定义 <code>_data</code> 属性，该属性与 <code>data</code> 是相同的引用。</p>\n<p>然后是一个 <code>while</code> 循环，循环的目的是在实例对象上对数据进行代理，这样我们就能通过 <code>this.a</code> 来访问 <code>data.a</code> 了，代码的处理是在 <code>proxy</code> 函数中，该函数非常简单，仅仅是在实例对象上设置与 <code>data</code> 属性同名的访问器属性，然后使用 <code>_data</code> 做数据劫持，如下：</p>\n<pre><code>function proxy (vm: Component, key: string) {\n  if (!isReserved(key)) {\n    Object.defineProperty(vm, key, {\n      configurable: true,\n      enumerable: true,\n      get: function proxyGetter () {\n        return vm._data[key]\n      },\n      set: function proxySetter (val) {\n        vm._data[key] = val\n      }\n    })\n  }\n}\n</code></pre><p>做完数据的代理，就正式进入响应系统，</p>\n<pre><code>observe(data)\n</code></pre><p>我们说过，数据响应系统主要包含三部分：<code>Observer</code>、<code>Dep</code>、<code>Watcher</code>，代码分别存放在：<code>observer/index.js</code>、<code>observer/dep.js</code> 以及 <code>observer/watcher.js</code> 文件中，这回我们换一种方式，我们先不看其源码，大家先跟着我的思路来思考，最后回头再去看代码，你会有一种：”奥，不过如此“的感觉。</p>\n<p>假如，我们有如下代码：</p>\n<pre><code class=\"js\">var data = {\n    a: 1,\n    b: {\n        c: 2\n    }\n}\n\nobserver(data)\n\nnew Watch(&#39;a&#39;, () =&gt; {\n    alert(9)\n})\nnew Watch(&#39;a&#39;, () =&gt; {\n    alert(90)\n})\nnew Watch(&#39;b.c&#39;, () =&gt; {\n    alert(80)\n})\n</code></pre>\n<p>这段代码目的是，首先定义一个数据对象 <code>data</code>，然后通过 observer 对其进行观测，之后定义了三个观察者，当数据有变化时，执行相应的方法，这个功能使用Vue的实现原来要如何去实现？其实就是在问 <code>observer</code> 怎么写？<code>Watch</code> 构造函数又怎么写？接下来我们逐一实现。</p>\n<p>首先，observer 的作用是：将数据对象data的属性转换为访问器属性：</p>\n<pre><code>class Observer {\n    constructor (data) {\n        this.walk(data)\n    }\n    walk (data) {\n        // 遍历 data 对象属性，调用 defineReactive 方法\n        let keys = Object.keys(data)\n        for(let i = 0; i &lt; keys.length; i++){\n            defineReactive(data, keys[i], data[keys[i]])\n        }\n    }\n}\n\n// defineReactive方法仅仅将data的属性转换为访问器属性\nfunction defineReactive (data, key, val) {\n    // 递归观测子属性\n    observer(val)\n\n    Object.defineProperty(data, key, {\n        enumerable: true,\n        configurable: true,\n        get: function () {\n            return val\n        },\n        set: function (newVal) {\n            if(val === newVal){\n                return\n            }\n            // 对新值进行观测\n            observer(newVal)\n        }\n    })\n}\n\n// observer 方法首先判断data是不是纯JavaScript对象，如果是，调用 Observer 类进行观测\nfunction observer (data) {\n    if(Object.prototype.toString.call(data) !== &#39;[object Object]&#39;) {\n        return\n    }\n    new Observer(data)\n}\n</code></pre><p>上面的代码中，我们定义了 observer 方法，该方法检测了数据data是不是纯JavaScript对象，如果是就调用 <code>Observer</code> 类，并将 <code>data</code> 作为参数透传。在 <code>Observer</code> 类中，我们使用 <code>walk</code> 方法对数据data的属性循环调用 <code>defineReactive</code> 方法，<code>defineReactive</code> 方法很简单，仅仅是将数据data的属性转为访问器属性，并对数据进行递归观测，否则只能观测数据data的直属子属性。这样我们的第一步工作就完成了，当我们修改或者获取data属性值的时候，通过 <code>get</code> 和 <code>set</code> 即能获取到通知。</p>\n<p>我们继续往下看，来看一下 <code>Watch</code>：</p>\n<pre><code>new Watch(&#39;a&#39;, () =&gt; {\n    alert(9)\n})\n</code></pre><p>现在的问题是，<code>Watch</code> 要怎么和 <code>observer</code> 关联？？？？？？？我们看看 <code>Watch</code> 它知道些什么，通过上面调用 <code>Watch</code> 的方式，传递给 <code>Watch</code> 两个参数，一个是 ‘a’ 我们可以称其为表达式，另外一个是回调函数。所以我们目前只能写出这样的代码：</p>\n<pre><code>class Watch {\n    constructor (exp, fn) {\n        this.exp = exp\n        this.fn = fn\n    }\n}\n</code></pre><p>那么要怎么关联呢，大家看下面的代码会发生什么：</p>\n<pre><code>class Watch {\n    constructor (exp, fn) {\n        this.exp = exp\n        this.fn = fn\n        data[exp]\n    }\n}\n</code></pre><p>多了一句 <code>data[exp]</code>，这句话是在干什么？是不是在获取 <code>data</code> 下某个属性的值，比如 exp 为 ‘a’ 的话，那么 <code>data[exp]</code> 就相当于在获取 <code>data.a</code> 的值，那这会放生什么？大家不要忘了，此时数据 <code>data</code> 下的属性已经是访问器属性了，所以这么做的结果会直接触发对应属性的 <code>get</code> 函数，这样我们就成功的和 <code>observer</code> 产生了关联，但这样还不够，我们还是没有达到目的，不过我们已经无限接近了，我们继续思考看一下可不可以这样：</p>\n<blockquote>\n<p>既然在 <code>Watch</code> 中对表达式求值，能够触发 <code>observer</code> 的 <code>get</code>，那么可不可以在 <code>get</code> 中收集 <code>Watch</code> 中函数呢？</p>\n</blockquote>\n<p>答案是可以的，不过这个时候我们就需要 <code>Dep</code> 出场了，它是一个依赖收集器。我们的思路是：<code>data</code> 下的每一个属性都有一个唯一的 <code>Dep</code> 对象，在 <code>get</code> 中收集仅针对该属性的依赖，然后在 <code>set</code> 方法中触发所有收集的依赖，这样就搞定了，看如下代码：</p>\n<pre><code>class Dep {\n    constructor () {\n        this.subs = []\n    }\n    addSub () {\n        this.subs.push(Dep.target)\n    }\n    notify () {\n        for(let i = 0; i &lt; this.subs.length; i++){\n            this.subs[i].fn()\n        }\n    }\n}\nDep.target = null\nfunction pushTarget(watch){\n    Dep.target = watch\n}\n\nclass Watch {\n    constructor (exp, fn) {\n        this.exp = exp\n        this.fn = fn\n        pushTarget(this)\n        data[exp]\n    }\n}\n</code></pre><p>上面的代码中，我们在 <code>Watch</code> 中增加了 <code>pushTarget(this)</code>，可以发现，这句代码的作用是将 <code>Dep.target</code> 的值设置为该Watch对象。在 <code>pushTarget</code> 之后我们才对表达式进行求值，接着，我们修改 <code>defineReactive</code> 代码如下</p>\n<pre><code>function defineReactive (data, key, val) {\n    observer(val)\n    let dep = new Dep()        // 新增\n    Object.defineProperty(data, key, {\n        enumerable: true,\n        configurable: true,\n        get: function () {\n            dep.addSub()    // 新增\n            return val\n        },\n        set: function (newVal) {\n            if(val === newVal){\n                return\n            }\n            observer(newVal)\n            dep.notify()    // 新增\n        }\n    })\n}\n</code></pre><p>如标注，新增了三句代码，我们知道，<code>Watch</code> 中对表达式求值会触发 <code>get</code> 方法，我们在 <code>get</code> 方法中调用了 <code>dep.addSub</code>，也就执行了这句代码：<code>this.subs.push(Dep.target)</code>，由于在这句代码执行之前，<code>Dep.target</code> 的值已经被设置为一个 <code>Watch</code> 对象了，所以最终结果就是收集了一个 <code>Watch</code> 对象，然后在 <code>set</code> 方法中我们调用了 <code>dep.notify</code>，所以当data属性值变化的时候，就会通过 <code>dep.notify</code> 循环调用所有收集的Watch对象中的回调函数：</p>\n<pre><code>notify () {\n    for(let i = 0; i &lt; this.subs.length; i++){\n        this.subs[i].fn()\n    }\n}\n</code></pre><p>这样 <code>observer</code>、<code>Dep</code>、<code>Watch</code> 三者就联系成为一个有机的整体，实现了我们最初的目标，完整的代码可以戳这里：<a href=\"https://github.com/HcySunYang/observer-dep-watch\" target=\"_blank\" rel=\"external\">observer-dep-watch</a>。这里还给大家挖了个坑，因为我们没有处理对数组的观测，由于比较复杂并且这又不是我们讨论的重点，如果大家想了解可以戳我的这篇文章：<a href=\"http://hcysun.me/2016/04/28/JavaScript%E5%AE%9E%E7%8E%B0MVVM%E4%B9%8B%E6%88%91%E5%B0%B1%E6%98%AF%E6%83%B3%E7%9B%91%E6%B5%8B%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8F%98%E5%8C%96/\">JavaScript实现MVVM之我就是想监测一个普通对象的变化</a>，另外，在 Watch 中对表达式求值的时候也只做了直接子属性的求值，所以如果 exp 的值为 ‘a.b’ 的时候，就不可以用了，Vue的做法是使用 <code>.</code> 分割表达式字符串为数组，然后遍历一下对其进行求值，大家可以查看其源码。如下：</p>\n<pre><code>/**\n * Parse simple path.\n */\nconst bailRE = /[^\\w.$]/\nexport function parsePath (path: string): any {\n  if (bailRE.test(path)) {\n    return\n  } else {\n    const segments = path.split(&#39;.&#39;)\n    return function (obj) {\n      for (let i = 0; i &lt; segments.length; i++) {\n        if (!obj) return\n        obj = obj[segments[i]]\n      }\n      return obj\n    }\n  }\n}\n</code></pre><p>Vue 的求值代码是在 <code>src/core/util/lang.js</code> 文件中 <code>parsePath</code> 函数中实现的。总结一下Vue的依赖收集过程应该是这样的：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/vueimgdep.png\" alt=\"Vue的依赖收集过程\"></p>\n<p>实际上，Vue并没有直接在 <code>get</code> 中调用 <code>addSub</code>，而是调用的 <code>dep.depend</code>，目的是将当前的 dep 对象收集到 watch 对象中，如果要完整的流程，应该是这样的：（大家注意数据的每一个字段都拥有自己的 <code>dep</code> 对象和 <code>get</code> 方法。）</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/all.png\" alt=\"Vue完整的收集依赖的流程\"></p>\n<p>这样 Vue 就建立了一套数据响应系统，之前我们说过，按照我们的例子那样写，初始化工作只包含两个主要内容即：<code>initData</code> 和 <code>initRender</code>。现在 <code>initData</code> 我们分析完了，接下来看一看 <code>initRender</code></p>\n<h2 id=\"六、通过initRender看Vue的-render-渲染-与-re-render-重新渲染\"><a href=\"#六、通过initRender看Vue的-render-渲染-与-re-render-重新渲染\" class=\"headerlink\" title=\"六、通过initRender看Vue的 render(渲染) 与 re-render(重新渲染)\"></a><span style=\"color: #ff6600;\">六、通过<code>initRender</code>看Vue的 render(渲染) 与 re-render(重新渲染)</span></h2><p>在 <code>initRender</code> 方法中，因为我们的例子中传递了 <code>el</code> 选项，所以下面的代码会执行：</p>\n<pre><code>  if (vm.$options.el) {\n    vm.$mount(vm.$options.el)\n  }\n</code></pre><p>这里，调用了 <code>$mount</code> 方法，在还原Vue构造函数的时候，我们整理过所有的方法，其中 <code>$mount</code> 方法在两个地方出现过：</p>\n<p>1、在 <code>web-runtime.js</code> 文件中：</p>\n<pre><code>Vue.prototype.$mount = function (\n  el?: string | Element,\n  hydrating?: boolean\n): Component {\n  el = el &amp;&amp; inBrowser ? query(el) : undefined\n  return this._mount(el, hydrating)\n}\n</code></pre><p>它的作用是通过 <code>el</code> 获取相应的DOM元素，然后调用 <code>lifecycle.js</code> 文件中的 <code>_mount</code> 方法。</p>\n<p>2、在 <code>web-runtime-with-compiler.js</code> 文件中：</p>\n<pre><code>// 缓存了来自 web-runtime.js 的 $mount 方法\nconst mount = Vue.prototype.$mount\n// 重写 $mount 方法\nVue.prototype.$mount = function (\n  el?: string | Element,\n  hydrating?: boolean\n): Component {\n  // 根据 el 获取相应的DOM元素\n  el = el &amp;&amp; query(el)\n  // 不允许你将 el 挂载到 html 标签或者 body 标签\n  if (el === document.body || el === document.documentElement) {\n    process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; warn(\n      `Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`\n    )\n    return this\n  }\n\n  const options = this.$options\n  // 如果我们没有写 render 选项，那么就尝试将 template 或者 el 转化为 render 函数\n  if (!options.render) {\n    let template = options.template\n    if (template) {\n      if (typeof template === &#39;string&#39;) {\n        if (template.charAt(0) === &#39;#&#39;) {\n          template = idToTemplate(template)\n          /* istanbul ignore if */\n          if (process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; !template) {\n            warn(\n              `Template element not found or is empty: ${options.template}`,\n              this\n            )\n          }\n        }\n      } else if (template.nodeType) {\n        template = template.innerHTML\n      } else {\n        if (process.env.NODE_ENV !== &#39;production&#39;) {\n          warn(&#39;invalid template option:&#39; + template, this)\n        }\n        return this\n      }\n    } else if (el) {\n      template = getOuterHTML(el)\n    }\n    if (template) {\n      const { render, staticRenderFns } = compileToFunctions(template, {\n        warn,\n        shouldDecodeNewlines,\n        delimiters: options.delimiters\n      }, this)\n      options.render = render\n      options.staticRenderFns = staticRenderFns\n    }\n  }\n  // 调用已经缓存下来的 web-runtime.js 文件中的 $mount 方法\n  return mount.call(this, el, hydrating)\n}\n</code></pre><p>分析一下可知 <code>web-runtime-with-compiler.js</code> 的逻辑如下：</p>\n<p>1、缓存来自 <code>web-runtime.js</code> 文件的 <code>$mount</code> 方法</p>\n<p>2、判断有没有传递 <code>render</code> 选项，如果有直接调用来自 <code>web-runtime.js</code> 文件的 $mount 方法</p>\n<p>3、如果没有传递 <code>render</code> 选项，那么查看有没有 <code>template</code> 选项，如果有就使用 <code>compileToFunctions</code> 函数根据其内容编译成 <code>render</code> 函数</p>\n<p>4、如果没有 <code>template</code> 选项，那么查看有没有 <code>el</code> 选项，如果有就使用 <code>compileToFunctions</code> 函数将其内容(template = getOuterHTML(el))编译成 <code>render</code> 函数</p>\n<p>5、将编译成的 <code>render</code> 函数挂载到 <code>this.$options</code> 属性下，并调用缓存下来的 <code>web-runtime.js</code> 文件中的 $mount 方法</p>\n<p>简单的用一张图表示 <code>mount</code> 方法的调用关系，从上至下调用：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/vueimgmount.png\" alt=\"mount调用关系\"></p>\n<p>不过不管怎样，我们发现这些步骤的最终目的是生成 <code>render</code> 函数，然后再调用 <code>lifecycle.js</code> 文件中的 <code>_mount</code> 方法，我们看看这个方法做了什么事情，查看 <code>_mount</code> 方法的代码，这是简化过得：</p>\n<pre><code>  Vue.prototype._mount = function (\n    el?: Element | void,\n    hydrating?: boolean\n  ): Component {\n    const vm: Component = this\n\n    // 在Vue实例对象上添加 $el 属性，指向挂载点元素\n    vm.$el = el\n\n    // 触发 beforeMount 生命周期钩子\n    callHook(vm, &#39;beforeMount&#39;)\n\n    vm._watcher = new Watcher(vm, () =&gt; {\n      vm._update(vm._render(), hydrating)\n    }, noop)\n\n    // 如果是第一次mount则触发 mounted 生命周期钩子\n    if (vm.$vnode == null) {\n      vm._isMounted = true\n      callHook(vm, &#39;mounted&#39;)\n    }\n    return vm\n  }\n</code></pre><p>上面的代码很简单，该注释的都注释了，唯一需要看的就是这段代码：</p>\n<pre><code>vm._watcher = new Watcher(vm, () =&gt; {\n  vm._update(vm._render(), hydrating)\n}, noop)\n</code></pre><p>看上去很眼熟有没有？我们平时使用Vue都是这样使用 watch的：</p>\n<pre><code>this.$watch(&#39;a&#39;, (newVal, oldVal) =&gt; {\n\n})\n// 或者\nthis.$watch(function(){\n    return this.a + this.b\n}, (newVal, oldVal) =&gt; {\n\n})\n</code></pre><p>第一个参数是 表达式或者函数，第二个参数是回调函数，第三个参数是可选的选项。原理是 <code>Watch</code> 内部对表达式求值或者对函数求值从而触发数据的 <code>get</code> 方法收集依赖。可是 <code>_mount</code> 方法中使用 <code>Watcher</code> 的时候第一个参数 <code>vm</code> 是什么鬼。我们不妨去看看源码中 <code>$watch</code> 函数是如何实现的，根据之前还原Vue构造函数中所整理的内容可知：<code>$warch</code> 方法是在 <code>src/core/instance/state.js</code> 文件中的 <code>stateMixin</code> 方法中定义的，源码如下：</p>\n<pre><code>  Vue.prototype.$watch = function (\n    expOrFn: string | Function,\n    cb: Function,\n    options?: Object\n  ): Function {\n    const vm: Component = this\n    options = options || {}\n    options.user = true\n    const watcher = new Watcher(vm, expOrFn, cb, options)\n    if (options.immediate) {\n      cb.call(vm, watcher.value)\n    }\n    return function unwatchFn () {\n      watcher.teardown()\n    }\n  }\n</code></pre><p>我们可以发现，<code>$warch</code> 其实是对 <code>Watcher</code> 的一个封装，内部的 <code>Watcher</code> 的第一个参数实际上也是 <code>vm</code> 即：Vue实例对象，这一点我们可以在 <code>Watcher</code> 的源码中得到验证，代开 <code>observer/watcher.js</code> 文件查看：</p>\n<pre><code class=\"js\">export default class Watcher {\n\n  constructor (\n    vm: Component,\n    expOrFn: string | Function,\n    cb: Function,\n    options?: Object = {}\n  ) {\n\n  }\n}\n</code></pre>\n<p>可以发现真正的 <code>Watcher</code> 第一个参数实际上就是 <code>vm</code>。第二个参数是表达式或者函数，然后以此类推，所以现在再来看 <code>_mount</code> 中的这段代码：</p>\n<pre><code>vm._watcher = new Watcher(vm, () =&gt; {\n  vm._update(vm._render(), hydrating)\n}, noop)\n</code></pre><p>忽略第一个参数 <code>vm</code>，也就说，<code>Watcher</code> 内部应该对第二个参数求值，也就是运行这个函数：</p>\n<pre><code>() =&gt; {\n  vm._update(vm._render(), hydrating)\n}\n</code></pre><p>所以 <code>vm._render()</code> 函数被第一个执行，该函数在 <code>src/core/instance/render.js</code> 中，该方法中的代码很多，下面是简化过的：</p>\n<pre><code>  Vue.prototype._render = function (): VNode {\n    const vm: Component = this\n    // 解构出 $options 中的 render 函数\n    const {\n      render,\n      staticRenderFns,\n      _parentVnode\n    } = vm.$options\n    ...\n\n    let vnode\n    try {\n      // 运行 render 函数\n      vnode = render.call(vm._renderProxy, vm.$createElement)\n    } catch (e) {\n      ...\n    }\n\n    // set parent\n    vnode.parent = _parentVnode\n    return vnode\n  }\n</code></pre><p><code>_render</code> 方法首先从 <code>vm.$options</code> 中解构出 <code>render</code> 函数，大家应该记得：<code>vm.$options.render</code> 方法是在 <code>web-runtime-with-compiler.js</code> 文件中通过 <code>compileToFunctions</code> 方法将 <code>template</code> 或 <code>el</code> 编译而来的。解构出 <code>render</code> 函数后，接下来便执行了该方法：</p>\n<pre><code>vnode = render.call(vm._renderProxy, vm.$createElement)\n</code></pre><p>其中使用 <code>call</code> 指定了 <code>render</code> 函数的作用域环境为 <code>vm._renderProxy</code>，这个属性在我们整理实例对象的时候知道，他是在 <code>Vue.prototype._init</code> 方法中被添加的，即：<code>vm._renderProxy = vm</code>，其实就是Vue实例对象本身，然后传递了一个参数：<code>vm.$createElement</code>。那么 <code>render</code> 函数到底是干什么的呢？让我们根据上面那句代码猜一猜，我们已经知道 <code>render</code> 函数是从 <code>template</code> 或 <code>el</code> 编译而来的，如果没错的话应该是返回一个虚拟DOM对象。我们不妨使用 <code>console.log</code> 打印一下 <code>render</code> 函数，当我们的模板这样编写时：</p>\n<pre><code>&lt;ul id=&quot;app&quot;&gt;\n  &lt;li&gt;{{a}}&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre><p>打印的 <code>render</code> 函数如下：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/vueimgr2.png\" alt=\"render函数1\"></p>\n<p>我们修改模板为：</p>\n<pre><code>&lt;ul id=&quot;app&quot;&gt;\n  &lt;li v-for=&quot;i in b&quot;&gt;{{a}}&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre><p>打印出来的 <code>render</code> 函数如下：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/vueimgr3.png\" alt=\"render函数2\"></p>\n<p>其实了解Vue2.x版本的同学都知道，Vue提供了 <code>render</code> 选项，作为 <code>template</code> 的代替方案，同时为JavaScript提供了完全编程的能力，下面两种编写模板的方式实际是等价的：</p>\n<pre><code class=\"js\">// 方案一：\nnew Vue({\n    el: &#39;#app&#39;,\n    data: {\n        a: 1\n    },\n    template: &#39;&lt;ul&gt;&lt;li&gt;{{a}}&lt;/li&gt;&lt;li&gt;{{a}}&lt;/li&gt;&lt;/ul&gt;&#39;\n})\n\n// 方案二：\nnew Vue({\n    el: &#39;#app&#39;,\n    render: function (createElement) {\n        createElement(&#39;ul&#39;, [\n            createElement(&#39;li&#39;, this.a),\n            createElement(&#39;li&#39;, this.a)\n        ])\n    }\n})\n</code></pre>\n<p>现在我们再来看我们打印的 <code>render</code> 函数：</p>\n<pre><code>function anonymous() {\n    with(this){\n        return _c(&#39;ul&#39;, { \n            attrs: {&quot;id&quot;: &quot;app&quot;}\n        },[\n            _c(&#39;li&#39;, [_v(_s(a))])\n        ])\n    }\n}\n</code></pre><p>是不是与我们自己写 <code>render</code> 函数很像？因为 render 函数的作用域被绑定到了Vue实例，即：<code>render.call(vm._renderProxy, vm.$createElement)</code>，所以上面代码中 <code>_c</code>、<code>_v</code>、<code>_s</code> 以及变量 <code>a</code>相当于Vue实例下的方法和变量。大家还记得诸如 <code>_c</code>、<code>_v</code>、<code>_s</code> 这样的方法在哪里定义的吗？我们在整理Vue构造函数的时候知道，他们在 <code>src/core/instance/render.js</code> 文件中的 <code>renderMixin</code> 方法中定义，除了这些之外还有诸如：<code>_l</code>、 <code>_m</code>、 <code>_o</code> 等等。其中 <code>_l</code> 就在我们使用 <code>v-for</code> 指令的时候出现了。所以现在大家知道为什么这些方法都被定义在 <code>render.js</code> 文件中了吧，因为他们就是为了构造出 <code>render</code> 函数而存在的。</p>\n<p>现在我们已经知道了 <code>render</code> 函数的长相，也知道了 <code>render</code> 函数的作用域是Vue实例本身即：<code>this</code>(或<code>vm</code>)。那么当我们执行 <code>render</code> 函数时，其中的变量如：<code>a</code>，就相当于：<code>this.a</code>，我们知道这是在求值，所以 <code>_mount</code> 中的这段代码：</p>\n<pre><code>vm._watcher = new Watcher(vm, () =&gt; {\n  vm._update(vm._render(), hydrating)\n}, noop)\n</code></pre><p>当 <code>vm._render</code> 执行的时候，所依赖的变量就会被求值，并被收集为依赖。按照Vue中 <code>watcher.js</code> 的逻辑，当依赖的变量有变化时不仅仅回调函数被执行，实际上还要重新求值，即还要执行一遍：</p>\n<pre><code>() =&gt; {\n  vm._update(vm._render(), hydrating)\n}\n</code></pre><p>这实际上就做到了 <code>re-render</code>，因为 <code>vm._update</code> 就是文章开头所说的虚拟DOM中的最后一步：<code>patch</code></p>\n<p><code>vm_render</code> 方法最终返回一个 <code>vnode</code> 对象，即虚拟DOM，然后作为 <code>vm_update</code> 的第一个参数传递了过去，我们看一下 <code>vm_update</code> 的逻辑，在 <code>src/core/instance/lifecycle.js</code> 文件中有这么一段代码：</p>\n<pre><code class=\"js\">    if (!prevVnode) {\n      // initial render\n      vm.$el = vm.__patch__(\n        vm.$el, vnode, hydrating, false /* removeOnly */,\n        vm.$options._parentElm,\n        vm.$options._refElm\n      )\n    } else {\n      // updates\n      vm.$el = vm.__patch__(prevVnode, vnode)\n    }\n</code></pre>\n<p>如果还没有 <code>prevVnode</code> 说明是首次渲染，直接创建真实DOM。如果已经有了 <code>prevVnode</code> 说明不是首次渲染，那么就采用 <code>patch</code> 算法进行必要的DOM操作。这就是Vue更新DOM的逻辑。只不过我们没有将 virtual DOM 内部的实现。</p>\n<p>现在我们来好好理理思路，当我们写如下代码时：</p>\n<pre><code>new Vue({\n    el: &#39;#app&#39;,\n    data: {\n        a: 1,\n        b: [1, 2, 3]\n    }\n})\n</code></pre><p>Vue 所做的事：</p>\n<blockquote>\n<p>1、构建数据响应系统，使用 <code>Observer</code> 将数据data转换为访问器属性；将 <code>el</code> 编译为 <code>render</code> 函数，<code>render</code> 函数返回值为虚拟DOM</p>\n<p>2、在 <code>_mount</code> 中对 <code>_update</code> 求值，而 <code>_update</code> 又会对 <code>render</code> 求值，<code>render</code> 内部又会对依赖的变量求值，收集为被求值的变量的依赖，当变量改变时，<code>_update</code> 又会重新执行一遍，从而做到 <code>re-render</code>。</p>\n</blockquote>\n<p>用一张详细一点的图表示就是这样的：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/vueimgdetail.png\" alt=\"详细流程\"></p>\n<p>到此，我们从大体流程，挑着重点的走了一遍Vue，但是还有很多细节我们没有提及，比如：</p>\n<p>1、将模板转为 <code>render</code> 函数的时候，实际是先生成的抽象语法树（AST），再将抽象语法树转成的 <code>render</code> 函数，而且这一整套的代码我们也没有提及，因为他在复杂了，其实这部分内容就是在完正则。</p>\n<p>2、我们也没有详细的讲 Virtual DOM 的实现原理，网上已经有文章讲了，大家可以搜一搜</p>\n<p>3、我们的例子中仅仅传递了 <code>el</code> ，<code>data</code> 选项，大家知道 Vue 支持的选项很多，比如我们都没有讲到，但都是触类旁通的，比如你搞清楚了 <code>data</code> 选项再去看 <code>computed</code> 选项或者 <code>props</code> 选项就会很容易，比如你知道了 <code>Watcher</code> 的工作机制再去看 <code>watch</code> 选项就会很容易。</p>\n<p>本篇文章作为Vue源码的启蒙文章，也许还有很多缺陷，全当抛砖引玉了。</p>\n","site":{"data":{}},"excerpt":"<p>原本文章的名字叫做《源码解析》，不过后来想想，还是用“源码学习”来的合适一点，在没有彻底掌握源码中的每一个字母之前，“解析”就有点标题党了。建议在看这篇文章之前，最好打开2.1.7的源码对照着看，这样可能更容易理解。另外本人水平有限，文中有错误或不妥的地方望大家多多指正共同成长。</p>\n<p>补充：Vue 2.2 刚刚发布，作为一个系列文章的第一篇，本篇文章主要从Vue代码的组织，Vue构造函数的还原，原型的设计，以及参数选项的处理和已经被写烂了的数据绑定与如何使用 Virtual DOM 更新视图入手。从整体的大方向观察框架，这么看来 <code>V2.1.7</code> 对于理解 <code>V2.2</code> 的代码不会有太大的影响。该系列文章的后续文章，都会从最新的源码入手，并对改动的地方做相应的提示。</p>","more":"<p>很久之前写过一篇文章：<a href=\"http://hcysun.me/2016/04/28/JavaScript%E5%AE%9E%E7%8E%B0MVVM%E4%B9%8B%E6%88%91%E5%B0%B1%E6%98%AF%E6%83%B3%E7%9B%91%E6%B5%8B%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8F%98%E5%8C%96/\">JavaScript实现MVVM之我就是想监测一个普通对象的变化</a>，文章开头提到了我写博客的风格，还是那句话，只写努力让小白，甚至是小学生都能看明白的文章。这不免会导致对于某些同学来说这篇文章有些墨迹，所以大家根据自己的喜好，可以详细的看，也可以跳跃着看。</p>\n<h2 id=\"一、从了解一个开源项目入手\"><a href=\"#一、从了解一个开源项目入手\" class=\"headerlink\" title=\"一、从了解一个开源项目入手\"></a><span style=\"color: #ff6600;\">一、从了解一个开源项目入手<span></span></span></h2><p>要看一个项目的源码，不要一上来就看，先去了解一下项目本身的元数据和依赖，除此之外最好也了解一下 PR 规则，Issue Reporting 规则等等。特别是“前端”开源项目，我们在看源码之前第一个想到的应该是：<code>package.json</code>文件。</p>\n<p>在 <code>package.json</code> 文件中，我们最应该关注的就是 <code>scripts</code> 字段和 <code>devDependencies</code> 以及 <code>dependencies</code> 字段，通过 <code>scripts</code> 字段我们可以知道项目中定义的脚本命令，通过 <code>devDependencies</code> 和 <code>dependencies</code> 字段我们可以了解项目的依赖情况。</p>\n<p>了解了这些之后，如果有依赖我们就 <code>npm install</code> 安装依赖就ok了。</p>\n<p>除了 <code>package.json</code> 之外，我们还要阅读项目的贡献规则文档，了解如何开始，一个好的开源项目肯定会包含这部分内容的，Vue也不例外：<a href=\"https://github.com/vuejs/vue/blob/dev/.github/CONTRIBUTING.md\" target=\"_blank\" rel=\"external\">https://github.com/vuejs/vue/blob/dev/.github/CONTRIBUTING.md</a>，在这个文档里说明了一些行为准则，PR指南，Issue Reporting 指南，Development Setup 以及 项目结构。通过阅读这些内容，我们可以了解项目如何开始，如何开发以及目录的说明，下面是对重要目录和文件的简单介绍，这些内容你都可以去自己阅读获取：</p>\n<pre><code>├── build --------------------------------- 构建相关的文件，一般情况下我们不需要动\n├── dist ---------------------------------- 构建后文件的输出目录\n├── examples ------------------------------ 存放一些使用Vue开发的应用案例\n├── flow ---------------------------------- 类型声明，使用开源项目 [Flow](https://flowtype.org/)\n├── package.json -------------------------- 不解释\n├── test ---------------------------------- 包含所有测试文件\n├── src ----------------------------------- 这个是我们最应该关注的目录，包含了源码\n│   ├── entries --------------------------- 包含了不同的构建或包的入口文件\n│   │   ├── web-runtime.js ---------------- 运行时构建的入口，输出 dist/vue.common.js 文件，不包含模板(template)到render函数的编译器，所以不支持 `template` 选项，我们使用vue默认导出的就是这个运行时的版本。大家使用的时候要注意\n│   │   ├── web-runtime-with-compiler.js -- 独立构建版本的入口，输出 dist/vue.js，它包含模板(template)到render函数的编译器\n│   │   ├── web-compiler.js --------------- vue-template-compiler 包的入口文件\n│   │   ├── web-server-renderer.js -------- vue-server-renderer 包的入口文件\n│   ├── compiler -------------------------- 编译器代码的存放目录，将 template 编译为 render 函数\n│   │   ├── parser ------------------------ 存放将模板字符串转换成元素抽象语法树的代码\n│   │   ├── codegen ----------------------- 存放从抽象语法树(AST)生成render函数的代码\n│   │   ├── optimizer.js ------------------ 分析静态树，优化vdom渲染\n│   ├── core ------------------------------ 存放通用的，平台无关的代码\n│   │   ├── observer ---------------------- 反应系统，包含数据观测的核心代码\n│   │   ├── vdom -------------------------- 包含虚拟DOM创建(creation)和打补丁(patching)的代码\n│   │   ├── instance ---------------------- 包含Vue构造函数设计相关的代码\n│   │   ├── global-api -------------------- 包含给Vue构造函数挂载全局方法(静态方法)或属性的代码\n│   │   ├── components -------------------- 包含抽象出来的通用组件\n│   ├── server ---------------------------- 包含服务端渲染(server-side rendering)的相关代码\n│   ├── platforms ------------------------- 包含平台特有的相关代码\n│   ├── sfc ------------------------------- 包含单文件组件(.vue文件)的解析逻辑，用于vue-template-compiler包\n│   ├── shared ---------------------------- 包含整个代码库通用的代码\n</code></pre><p>大概了解了重要目录和文件之后，我们就可以查看 <a href=\"https://github.com/vuejs/vue/blob/dev/.github/CONTRIBUTING.md#development-setup\" target=\"_blank\" rel=\"external\">Development Setup</a> 中的常用命令部分，来了解如何开始这个项目了，我们可以看到这样的介绍：</p>\n<pre><code># watch and auto re-build dist/vue.js\n$ npm run dev\n\n# watch and auto re-run unit tests in Chrome\n$ npm run dev:test\n</code></pre><p>现在，我们只需要运行 <code>npm run dev</code> 即可监测文件变化并自动重新构建输出 dist/vue.js，然后运行 <code>npm run dev:test</code> 来测试。不过为了方便，我会在 <code>examples</code> 目录新建一个例子，然后引用 dist/vue.js 这样，我们可以直接拿这个例子一边改Vue源码一边看自己写的代码想怎么玩怎么玩。</p>\n<h2 id=\"二、看源码的小提示\"><a href=\"#二、看源码的小提示\" class=\"headerlink\" title=\"二、看源码的小提示\"></a><span style=\"color: #ff6600;\">二、看源码的小提示</span></h2><p>在真正步入源码世界之前，我想简单说一说看源码的技巧：</p>\n<h3 id=\"注重大体框架，从宏观到微观\"><a href=\"#注重大体框架，从宏观到微观\" class=\"headerlink\" title=\"注重大体框架，从宏观到微观\"></a><em>注重大体框架，从宏观到微观</em></h3><p>当你看一个项目代码的时候，最好是能找到一条主线，先把大体流程结构摸清楚，再深入到细节，逐项击破，拿Vue举个栗子：假如你已经知道Vue中数据状态改变后会采用virtual DOM的方式更新DOM，这个时候，如果你不了解virtual DOM，那么听我一句“暂且不要去研究内部具体实现，因为这会是你丧失主线”，而你仅仅需要知道virtual DOM分为三个步骤：</p>\n<blockquote>\n<p>一、createElement(): 用 JavaScript对象(虚拟树) 描述 真实DOM对象(真实树)<br>二、diff(oldNode, newNode) : 对比新旧两个虚拟树的区别，收集差异<br>三、patch() : 将差异应用到真实DOM树</p>\n</blockquote>\n<p>有的时候 第二步 可能与 第三步 合并成一步(Vue 中的patch就是这样)，除此之外，还比如 <code>src/compiler/codegen</code> 内的代码，可能你不知道他写了什么，直接去看它会让你很痛苦，但是你只需要知道 codegen 是用来将抽象语法树(AST)生成render函数的就OK了，也就是生成类似下面这样的代码：</p>\n<pre><code class=\"js\">function anonymous() {\n    with(this){return _c(&#39;p&#39;,{attrs:{&quot;id&quot;:&quot;app&quot;}},[_v(&quot;\\n      &quot;+_s(a)+&quot;\\n      &quot;),_c(&#39;my-com&#39;)])}\n}\n</code></pre>\n<p>当我们知道了一个东西存在，且知道它存在的目的，那么我们就很容易抓住这条主线，这个系列的第一篇文章就是围绕大体主线展开的。了解大体之后，我们就知道了每部分内容都是做什么的，比如 codegen 是生成类似上面贴出的代码所示的函数的，那么再去看codegen下的代码时，目的性就会更强，就更容易理解。</p>\n<h2 id=\"三、Vue-的构造函数是什么样的\"><a href=\"#三、Vue-的构造函数是什么样的\" class=\"headerlink\" title=\"三、Vue 的构造函数是什么样的\"></a><span style=\"color: #ff6600;\">三、Vue 的构造函数是什么样的<span></span></span></h2><p>balabala一大堆，开始来干货吧。我们要做的第一件事就是搞清楚 Vue 构造函数到底是什么样子的。</p>\n<p>我们知道，我们要使用 <code>new</code> 操作符来调用 <code>Vue</code>，那么也就是说 <code>Vue</code> 应该是一个构造函数，所以我们第一件要做的事儿就是把构造函数先扒的一清二楚，如何寻找 <code>Vue</code> 构造函数呢？当然是从 entry 开始啦，还记的我们运行 <code>npm run dev</code> 命令后，会输出 <code>dist/vue.js</code> 吗，那么我们就去看看 <code>npm run dev</code> 干了什么：</p>\n<pre><code>&quot;dev&quot;: &quot;TARGET=web-full-dev rollup -w -c build/config.js&quot;,\n</code></pre><p>首先将 TARGET 得值设置为 ‘web-full-dev’，然后，然后，然后如果你不了解 rollup 就应该简单去看一下啦……，简单的说就是一个JavaScript模块打包器，你可以把它简单的理解为和 webpack 一样，只不过它有他的优势，比如 Tree-shaking (webpack2也有)，但同样，在某些场景它也有他的劣势。。。废话不多说，其中 <code>-w</code> 就是watch，<code>-c</code> 就是指定配置文件为 <code>build/config.js</code> ，我们打开这个配置文件看一看：</p>\n<pre><code class=\"js\">// 引入依赖，定义 banner\n...\n\n// builds 对象\nconst builds = {\n    ...\n    // Runtime+compiler development build (Browser)\n    &#39;web-full-dev&#39;: {\n        entry: path.resolve(__dirname, &#39;../src/entries/web-runtime-with-compiler.js&#39;),\n        dest: path.resolve(__dirname, &#39;../dist/vue.js&#39;),\n        format: &#39;umd&#39;,\n        env: &#39;development&#39;,\n        alias: { he: &#39;./entity-decoder&#39; },\n        banner\n    },\n    ...\n}\n\n// 生成配置的方法\nfunction genConfig(opts){\n    ...\n}\n\nif (process.env.TARGET) {\n  module.exports = genConfig(builds[process.env.TARGET])\n} else {\n  exports.getBuild = name =&gt; genConfig(builds[name])\n  exports.getAllBuilds = () =&gt; Object.keys(builds).map(name =&gt; genConfig(builds[name]))\n}\n</code></pre>\n<p>上面的代码是简化过的，当我们运行 <code>npm run dev</code> 的时候 <code>process.env.TARGET</code> 的值等于 ‘web-full-dev’，所以</p>\n<pre><code class=\"js\">module.exports = genConfig(builds[process.env.TARGET])\n</code></pre>\n<p>这句代码相当于：</p>\n<pre><code class=\"js\">module.exports = genConfig({\n    entry: path.resolve(__dirname, &#39;../src/entries/web-runtime-with-compiler.js&#39;),\n    dest: path.resolve(__dirname, &#39;../dist/vue.js&#39;),\n    format: &#39;umd&#39;,\n    env: &#39;development&#39;,\n    alias: { he: &#39;./entity-decoder&#39; },\n    banner\n})\n</code></pre>\n<p>最终，genConfig 函数返回一个 config 对象，这个config对象就是Rollup的配置对象。那么我们就不难看到，入口文件是：</p>\n<pre><code>src/entries/web-runtime-with-compiler.js\n</code></pre><p>我们打开这个文件，不要忘了我们的主题，我们在寻找Vue构造函数，所以当我们看到这个文件的第一行代码是：</p>\n<pre><code class=\"js\">import Vue from &#39;./web-runtime&#39;\n</code></pre>\n<p>这个时候，你就应该知道，这个文件暂时与你无缘，你应该打开 <code>web-runtime.js</code> 文件，不过当你打开这个文件时，你发现第一行是这样的：</p>\n<pre><code class=\"js\">import Vue from &#39;core/index&#39;\n</code></pre>\n<p>依照此思路，最终我们寻找到Vue构造函数的位置应该是在 <code>src/core/instance/index.js</code> 文件中，其实我们猜也猜得到，上面介绍目录的时候说过：instance 是存放Vue构造函数设计相关代码的目录。总结一下，我们寻找的过程是这样的：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/vueimg2BD0DCC6-D689-4809-93D3-2F979E8F8C0C.png\" alt=\"寻找 Vue 构造函数路线\"></p>\n<p>我们回头看一看 <code>src/core/instance/index.js</code> 文件，很简单：</p>\n<pre><code class=\"js\">import { initMixin } from &#39;./init&#39;\nimport { stateMixin } from &#39;./state&#39;\nimport { renderMixin } from &#39;./render&#39;\nimport { eventsMixin } from &#39;./events&#39;\nimport { lifecycleMixin } from &#39;./lifecycle&#39;\nimport { warn } from &#39;../util/index&#39;\n\nfunction Vue (options) {\n  if (process.env.NODE_ENV !== &#39;production&#39; &amp;&amp;\n    !(this instanceof Vue)) {\n    warn(&#39;Vue is a constructor and should be called with the `new` keyword&#39;)\n  }\n  this._init(options)\n}\n\ninitMixin(Vue)\nstateMixin(Vue)\neventsMixin(Vue)\nlifecycleMixin(Vue)\nrenderMixin(Vue)\n\nexport default Vue\n</code></pre>\n<p>引入依赖，定义 Vue 构造函数，然后以Vue构造函数为参数，调用了五个方法，最后导出 Vue。这五个方法分别来自五个文件：<code>init.js</code> <code>state.js</code> <code>render.js</code> <code>events.js</code> 以及 <code>lifecycle.js</code>。</p>\n<p>打开这五个文件，找到相应的方法，你会发现，这些方法的作用，就是在 Vue 的原型 prototype 上挂载方法或属性，经历了这五个方法后的Vue会变成这样：</p>\n<pre><code class=\"js\">// initMixin(Vue)    src/core/instance/init.js **************************************************\nVue.prototype._init = function (options?: Object) {}\n\n// stateMixin(Vue)    src/core/instance/state.js **************************************************\nVue.prototype.$data\nVue.prototype.$set = set\nVue.prototype.$delete = del\nVue.prototype.$watch = function(){}\n\n// renderMixin(Vue)    src/core/instance/render.js **************************************************\nVue.prototype.$nextTick = function (fn: Function) {}\nVue.prototype._render = function (): VNode {}\nVue.prototype._s = _toString\nVue.prototype._v = createTextVNode\nVue.prototype._n = toNumber\nVue.prototype._e = createEmptyVNode\nVue.prototype._q = looseEqual\nVue.prototype._i = looseIndexOf\nVue.prototype._m = function(){}\nVue.prototype._o = function(){}\nVue.prototype._f = function resolveFilter (id) {}\nVue.prototype._l = function(){}\nVue.prototype._t = function(){}\nVue.prototype._b = function(){}\nVue.prototype._k = function(){}\n\n// eventsMixin(Vue)    src/core/instance/events.js **************************************************\nVue.prototype.$on = function (event: string, fn: Function): Component {}\nVue.prototype.$once = function (event: string, fn: Function): Component {}\nVue.prototype.$off = function (event?: string, fn?: Function): Component {}\nVue.prototype.$emit = function (event: string): Component {}\n\n// lifecycleMixin(Vue)    src/core/instance/lifecycle.js **************************************************\nVue.prototype._mount = function(){}\nVue.prototype._update = function (vnode: VNode, hydrating?: boolean) {}\nVue.prototype._updateFromParent = function(){}\nVue.prototype.$forceUpdate = function () {}\nVue.prototype.$destroy = function () {}\n</code></pre>\n<p>这样就结束了吗？并没有，根据我们之前寻找 Vue 的路线，这只是刚刚开始，我们追溯路线往回走，那么下一个处理 Vue 构造函数的应该是 <code>src/core/index.js</code> 文件，我们打开它：</p>\n<pre><code class=\"js\">import Vue from &#39;./instance/index&#39;\nimport { initGlobalAPI } from &#39;./global-api/index&#39;\nimport { isServerRendering } from &#39;core/util/env&#39;\n\ninitGlobalAPI(Vue)\n\nObject.defineProperty(Vue.prototype, &#39;$isServer&#39;, {\n  get: isServerRendering\n})\n\nVue.version = &#39;__VERSION__&#39;\n\nexport default Vue\n</code></pre>\n<p>这个文件也很简单，从 instance/index 中导入已经在原型上挂载了方法和属性后的 Vue，然后导入 <code>initGlobalAPI</code> 和 <code>isServerRendering</code>，之后将Vue作为参数传给  <code>initGlobalAPI</code> ，最后又在 <code>Vue.prototype</code> 上挂载了 <code>$isServer</code> ，在 <code>Vue</code> 上挂载了 <code>version</code> 属性。</p>\n<p><code>initGlobalAPI</code> 的作用是在 <code>Vue</code> 构造函数上挂载静态属性和方法，<code>Vue</code> 在经过 <code>initGlobalAPI</code> 之后，会变成这样：</p>\n<pre><code class=\"js\">// src/core/index.js / src/core/global-api/index.js\nVue.config\nVue.util = util\nVue.set = set\nVue.delete = del\nVue.nextTick = util.nextTick\nVue.options = {\n    components: {\n        KeepAlive\n    },\n    directives: {},\n    filters: {},\n    _base: Vue\n}\nVue.use\nVue.mixin\nVue.cid = 0\nVue.extend\nVue.component = function(){}\nVue.directive = function(){}\nVue.filter = function(){}\n\nVue.prototype.$isServer\nVue.version = &#39;__VERSION__&#39;\n</code></pre>\n<p>其中，稍微复杂一点的就是 <code>Vue.options</code>，大家稍微分析分析就会知道他的确长成那个样子。下一个就是 <code>web-runtime.js</code> 文件了，<code>web-runtime.js</code> 文件主要做了三件事儿：</p>\n<blockquote>\n<p>1、覆盖 <code>Vue.config</code> 的属性，将其设置为平台特有的一些方法<br>2、<code>Vue.options.directives</code> 和 <code>Vue.options.components</code> 安装平台特有的指令和组件<br>3、在 <code>Vue.prototype</code> 上定义 <code>__patch__</code> 和 <code>$mount</code></p>\n</blockquote>\n<p>经过 <code>web-runtime.js</code> 文件之后，<code>Vue</code> 变成下面这个样子：</p>\n<pre><code class=\"js\">// 安装平台特定的utils\nVue.config.isUnknownElement = isUnknownElement\nVue.config.isReservedTag = isReservedTag\nVue.config.getTagNamespace = getTagNamespace\nVue.config.mustUseProp = mustUseProp\n// 安装平台特定的 指令 和 组件\nVue.options = {\n    components: {\n        KeepAlive,\n        Transition,\n        TransitionGroup\n    },\n    directives: {\n        model,\n        show\n    },\n    filters: {},\n    _base: Vue\n}\nVue.prototype.__patch__\nVue.prototype.$mount\n</code></pre>\n<p>这里大家要注意的是 <code>Vue.options</code> 的变化。另外这里的 <code>$mount</code> 方法很简单：</p>\n<pre><code class=\"js\">Vue.prototype.$mount = function (\n  el?: string | Element,\n  hydrating?: boolean\n): Component {\n  el = el &amp;&amp; inBrowser ? query(el) : undefined\n  return this._mount(el, hydrating)\n}\n</code></pre>\n<p>首先根据是否是浏览器环境决定要不要 <code>query(el)</code> 获取元素，然后将 <code>el</code> 作为参数传递给 <code>this._mount()</code>。</p>\n<p>最后一个处理 Vue 的文件就是入口文件 <code>web-runtime-with-compiler.js</code> 了，该文件做了两件事：</p>\n<p>1、缓存来自 <code>web-runtime.js</code> 文件的 <code>$mount</code> 函数</p>\n<pre><code class=\"js\">const mount = Vue.prototype.$mount\n</code></pre>\n<p>然后覆盖覆盖了 <code>Vue.prototype.$mount</code></p>\n<p>2、在 Vue 上挂载 <code>compile</code></p>\n<pre><code class=\"js\">Vue.compile = compileToFunctions\n</code></pre>\n<p>compileToFunctions 函数的作用，就是将模板 <code>template</code> 编译为render函数。</p>\n<p>至此，我们算是还原了 Vue 构造函数，总结一下：</p>\n<blockquote>\n<p>1、<code>Vue.prototype</code> 下的属性和方法的挂载主要是在 <code>src/core/instance</code> 目录中的代码处理的</p>\n<p>2、<code>Vue</code> 下的静态属性和方法的挂载主要是在 <code>src/core/global-api</code> 目录下的代码处理的</p>\n<p>3、<code>web-runtime.js</code> 主要是添加web平台特有的配置、组件和指令，<code>web-runtime-with-compiler.js</code> 给Vue的 <code>$mount</code> 方法添加 <code>compiler</code> 编译器，支持 <code>template</code>。</p>\n</blockquote>\n<h2 id=\"四、一个贯穿始终的例子\"><a href=\"#四、一个贯穿始终的例子\" class=\"headerlink\" title=\"四、一个贯穿始终的例子\"></a><span style=\"color: #ff6600;\">四、一个贯穿始终的例子</span></h2><p>在了解了 <code>Vue</code> 构造函数的设计之后，接下来，我们一个贯穿始终的例子就要登场了，掌声有请：</p>\n<pre><code class=\"js\">let v = new Vue({\n    el: &#39;#app&#39;,\n    data: {\n        a: 1,\n        b: [1, 2, 3]\n    }\n})\n</code></pre>\n<p>好吧，我承认这段代码你家没满月的孩子都会写了。这段代码就是我们贯穿始终的例子，它就是这篇文章的主线，在后续的讲解中，都会以这段代码为例，当讲到必要的地方，会为其添加选项，比如讲计算属性的时候当然要加上一个 <code>computed</code> 属性了。不过在最开始，我只传递了两个选项 <code>el</code> 以及 <code>data</code>，“我们看看接下来会发生什么，让我们拭目以待“ —- NBA球星在接受采访时最喜欢说这句话。</p>\n<p><em>当我们按照例子那样编码使用Vue的时候，Vue都做了什么？</em></p>\n<p>想要知道Vue都干了什么，我们就要找到 Vue 初始化程序，查看 Vue 构造函数：</p>\n<pre><code class=\"js\">function Vue (options) {\n  if (process.env.NODE_ENV !== &#39;production&#39; &amp;&amp;\n    !(this instanceof Vue)) {\n    warn(&#39;Vue is a constructor and should be called with the `new` keyword&#39;)\n  }\n  this._init(options)\n}\n</code></pre>\n<p>我们发现，<code>_init()</code> 方法就是Vue调用的第一个方法，然后将我们的参数 <code>options</code> 透传了过去。在调用 <code>_init()</code> 之前，还做了一个安全模式的处理，告诉开发者必须使用 <code>new</code> 操作符调用 Vue。根据之前我们的整理，<code>_init()</code> 方法应该是在 <code>src/core/instance/init.js</code> 文件中定义的，我们打开这个文件查看 <code>_init()</code> 方法：</p>\n<pre><code class=\"js\">  Vue.prototype._init = function (options?: Object) {\n    const vm: Component = this\n    // a uid\n    vm._uid = uid++\n    // a flag to avoid this being observed\n    vm._isVue = true\n    // merge options\n    if (options &amp;&amp; options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options)\n    } else {\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      )\n    }\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== &#39;production&#39;) {\n      initProxy(vm)\n    } else {\n      vm._renderProxy = vm\n    }\n\n    // expose real self\n    vm._self = vm\n    initLifecycle(vm)\n    initEvents(vm)\n    callHook(vm, &#39;beforeCreate&#39;)\n    initState(vm)\n    callHook(vm, &#39;created&#39;)\n    initRender(vm)\n  }\n</code></pre>\n<p><code>_init()</code> 方法在一开始的时候，在 <code>this</code> 对象上定义了两个属性：<code>_uid</code> 和 <code>_isVue</code>，然后判断有没有定义 <code>options._isComponent</code>，在使用 Vue 开发项目的时候，我们是不会使用 <code>_isComponent</code> 选项的，这个选项是 Vue 内部使用的，按照本节开头的例子，这里会走 <code>else</code> 分支，也就是这段代码：</p>\n<pre><code class=\"js\">  vm.$options = mergeOptions(\n    resolveConstructorOptions(vm.constructor),\n    options || {},\n    vm\n  )\n</code></pre>\n<p>这样 <code>Vue</code> 第一步所做的事情就来了：<span style=\"color: red;\"><em>使用策略对象合并参数选项</em></span></p>\n<p>可以发现，Vue使用 <code>mergeOptions</code> 来处理我们调用Vue时传入的参数选项(options)，然后将返回值赋值给 <code>this.$options</code> (vm === this)，传给 <code>mergeOptions</code> 方法三个参数，我们分别来看一看，首先是：<code>resolveConstructorOptions(vm.constructor)</code>，我们查看一下这个方法：</p>\n<pre><code class=\"js\">export function resolveConstructorOptions (Ctor: Class&lt;Component&gt;) {\n  let options = Ctor.options\n  if (Ctor.super) {\n    const superOptions = Ctor.super.options\n    const cachedSuperOptions = Ctor.superOptions\n    const extendOptions = Ctor.extendOptions\n    if (superOptions !== cachedSuperOptions) {\n      // super option changed\n      Ctor.superOptions = superOptions\n      extendOptions.render = options.render\n      extendOptions.staticRenderFns = options.staticRenderFns\n      extendOptions._scopeId = options._scopeId\n      options = Ctor.options = mergeOptions(superOptions, extendOptions)\n      if (options.name) {\n        options.components[options.name] = Ctor\n      }\n    }\n  }\n  return options\n}\n</code></pre>\n<p>这个方法接收一个参数 <code>Ctor</code>，通过传入的 <code>vm.constructor</code> 我们可以知道，其实就是 <code>Vue</code> 构造函数本身。所以下面这句代码：</p>\n<pre><code class=\"js\">let options = Ctor.options\n</code></pre>\n<p>相当于：</p>\n<pre><code class=\"js\">let options = Vue.options\n</code></pre>\n<p>大家还记得 <code>Vue.options</code> 吗？在寻找Vue构造函数一节里，我们整理了 <code>Vue.options</code> 应该长成下面这个样子：</p>\n<pre><code class=\"js\">Vue.options = {\n    components: {\n        KeepAlive,\n        Transition,\n        TransitionGroup\n    },\n    directives: {\n        model,\n        show\n    },\n    filters: {},\n    _base: Vue\n}\n</code></pre>\n<p>之后判断是否定义了 <code>Vue.super</code> ，这个是用来处理继承的，我们后续再讲，在本例中，<code>resolveConstructorOptions</code> 方法直接返回了 <code>Vue.options</code>。也就是说，传递给 <code>mergeOptions</code> 方法的第一个参数就是 <code>Vue.options</code>。</p>\n<p>传给 <code>mergeOptions</code> 方法的第二个参数是我们调用Vue构造函数时的参数选项，第三个参数是 <code>vm</code> 也就是 <code>this</code> 对象，按照本节开头的例子那样使用 Vue，最终运行的代码应该如下：</p>\n<pre><code class=\"js\">  vm.$options = mergeOptions(\n      // Vue.options\n    {\n        components: {\n            KeepAlive,\n            Transition,\n            TransitionGroup\n        },\n        directives: {\n            model,\n            show\n        },\n        filters: {},\n        _base: Vue\n    },\n    // 调用Vue构造函数时传入的参数选项 options\n    {\n        el: &#39;#app&#39;,\n        data: {\n            a: 1,\n            b: [1, 2, 3]\n        }\n    },\n    // this\n    vm\n  )\n</code></pre>\n<p>了解了这些，我们就可以看看 <code>mergeOptions</code> 到底做了些什么了，根据引用寻找到 <code>mergeOptions</code> 应该是在 <code>src/core/util/options.js</code> 文件中定义的。这个文件第一次看可能会头大，下面是我处理后的简略展示，大家看上去应该更容易理解了：</p>\n<pre><code class=\"js\">// 1、引用依赖\nimport Vue from &#39;../instance/index&#39;\n其他引用...\n\n// 2、合并父子选项值为最终值的策略对象，此时 strats 是一个空对象，因为 config.optionMergeStrategies = Object.create(null)\nconst strats = config.optionMergeStrategies\n// 3、在 strats 对象上定义与参数选项名称相同的方法\nstrats.el = \nstrats.propsData = function (parent, child, vm, key){}\nstrats.data = function (parentVal, childVal, vm)\n\nconfig._lifecycleHooks.forEach(hook =&gt; {\n  strats[hook] = mergeHook\n})\n\nconfig._assetTypes.forEach(function (type) {\n  strats[type + &#39;s&#39;] = mergeAssets\n})\n\nstrats.watch = function (parentVal, childVal)\n\nstrats.props =\nstrats.methods =\nstrats.computed = function (parentVal: ?Object, childVal: ?Object)\n// 默认的合并策略，如果有 `childVal` 则返回 `childVal` 没有则返回 `parentVal`\nconst defaultStrat = function (parentVal: any, childVal: any): any {\n  return childVal === undefined\n    ? parentVal\n    : childVal\n}\n\n// 4、mergeOptions 中根据参数选项调用同名的策略方法进行合并处理\nexport function mergeOptions (\n  parent: Object,\n  child: Object,\n  vm?: Component\n): Object {\n\n  // 其他代码\n  ...\n\n  const options = {}\n  let key\n  for (key in parent) {\n    mergeField(key)\n  }\n  for (key in child) {\n    if (!hasOwn(parent, key)) {\n      mergeField(key)\n    }\n  }\n  function mergeField (key) {\n    const strat = strats[key] || defaultStrat\n    options[key] = strat(parent[key], child[key], vm, key)\n  }\n  return options\n\n}\n</code></pre>\n<p>上面的代码中，我省略了一些工具函数，例如 <code>mergeHook</code> 和 <code>mergeAssets</code> 等等，唯一需要注意的是这段代码：</p>\n<pre><code class=\"js\">config._lifecycleHooks.forEach(hook =&gt; {\n  strats[hook] = mergeHook\n})\n\nconfig._assetTypes.forEach(function (type) {\n  strats[type + &#39;s&#39;] = mergeAssets\n})\n</code></pre>\n<p><code>config</code> 对象引用自 <code>src/core/config.js</code> 文件，最终的结果就是在 <code>strats</code> 下添加了相应的生命周期选项的合并策略函数为 <code>mergeHook</code>，添加指令(directives)、组件(components)、过滤器(filters)等选项的合并策略函数为 <code>mergeAssets</code>。</p>\n<p>这样看来就清晰多了，拿我们贯穿本文的例子来说：</p>\n<pre><code class=\"js\">let v = new Vue({\n    el: &#39;#app&#39;,\n    data: {\n        a: 1,\n        b: [1, 2, 3]\n    }\n})\n</code></pre>\n<p>其中 <code>el</code> 选项会使用 <code>defaultStrat</code> 默认策略函数处理，<code>data</code> 选项则会使用 <code>strats.data</code> 策略函数处理，并且根据 <code>strats.data</code> 中的逻辑，<code>strats.data</code> 方法最终会返回一个函数：<code>mergedInstanceDataFn</code>。</p>\n<p>这里就不详细的讲解每一个策略函数的内容了，后续都会讲到，这里我们还是抓住主线理清思路为主，只需要知道Vue在处理选项的时候，使用了一个策略对象对父子选项进行合并。并将最终的值赋值给实例下的 <code>$options</code> 属性即：<code>this.$options</code>，那么我们继续查看 <code>_init()</code> 方法在合并完选项之后，又做了什么：</p>\n<p>合并完选项之后，Vue 第二部做的事情就来了：<span style=\"color: red;\"><em>初始化工作与Vue实例对象的设计</em></span></p>\n<p>前面讲了 Vue 构造函数的设计，并且整理了 <em>Vue原型属性与方法</em> 和 <em>Vue静态属性与方法</em>，而 Vue 实例对象就是通过构造函数创造出来的，让我们来看一看 Vue 实例对象是如何设计的，下面的代码是 <code>_init()</code> 方法合并完选项之后的代码：</p>\n<pre><code class=\"js\">    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== &#39;production&#39;) {\n      initProxy(vm)\n    } else {\n      vm._renderProxy = vm\n    }\n\n    // expose real self\n    vm._self = vm\n    initLifecycle(vm)\n    initEvents(vm)\n    callHook(vm, &#39;beforeCreate&#39;)\n    initState(vm)\n    callHook(vm, &#39;created&#39;)\n    initRender(vm)\n</code></pre>\n<p>根据上面的代码，在生产环境下会为实例添加两个属性，并且属性值都为实例本身：</p>\n<pre><code class=\"js\">vm._renderProxy = vm\nvm._self = vm\n</code></pre>\n<p>然后，调用了四个 <code>init*</code> 方法分别为：<code>initLifecycle</code>、<code>initEvents</code>、<code>initState</code>、<code>initRender</code>，且在 <code>initState</code> 前后分别回调了生命周期钩子 <code>beforeCreate</code> 和 <code>created</code>，而 <code>initRender</code> 是在 <code>created</code> 钩子执行之后执行的，看到这里，也就明白了为什么 created 的时候不能操作DOM了。因为这个时候还没有渲染真正的DOM元素到文档中。<code>created</code> 仅仅代表数据状态的初始化完成。</p>\n<p>根据四个 <code>init*</code> 方法的引用关系打开对应的文件查看对应的方法，我们发现，这些方法是在处理Vue实例对象，以及做一些初始化的工作，类似整理Vue构造函数一样，我同样针对Vue实例做了属性和方法的整理，如下：</p>\n<pre><code class=\"js\">// 在 Vue.prototype._init 中添加的属性         **********************************************************\nthis._uid = uid++\nthis._isVue = true\nthis.$options = {\n    components,\n    directives,\n    filters,\n    _base,\n    el,\n    data: mergedInstanceDataFn()\n}\nthis._renderProxy = this\nthis._self = this\n\n// 在 initLifecycle 中添加的属性        **********************************************************\nthis.$parent = parent\nthis.$root = parent ? parent.$root : this\n\nthis.$children = []\nthis.$refs = {}\n\nthis._watcher = null\nthis._inactive = false\nthis._isMounted = false\nthis._isDestroyed = false\nthis._isBeingDestroyed = false\n\n// 在 initEvents     中添加的属性         **********************************************************\nthis._events = {}\nthis._updateListeners = function(){}\n\n// 在 initState 中添加的属性        **********************************************************\nthis._watchers = []\n    // initData\n    this._data\n\n// 在 initRender     中添加的属性     **********************************************************\nthis.$vnode = null // the placeholder node in parent tree\nthis._vnode = null // the root of the child tree\nthis._staticTrees = null\nthis.$slots\nthis.$scopedSlots\nthis._c\nthis.$createElement\n</code></pre>\n<p>以上就是一个Vue实例所包含的属性和方法，除此之外要注意的是，在 <code>initEvents</code> 中除了添加属性之外，如果有 <code>vm.$options._parentListeners</code> 还要调用 <code>vm._updateListeners()</code> 方法，在 <code>initState</code> 中又调用了一些其他init方法，如下：</p>\n<pre><code class=\"js\">export function initState (vm: Component) {\n  vm._watchers = []\n  initProps(vm)\n  initMethods(vm)\n  initData(vm)\n  initComputed(vm)\n  initWatch(vm)\n}\n</code></pre>\n<p>最后在 <code>initRender</code> 中如果有 <code>vm.$options.el</code> 还要调用 <code>vm.$mount(vm.$options.el)</code>，如下：</p>\n<pre><code class=\"js\">  if (vm.$options.el) {\n    vm.$mount(vm.$options.el)\n  }\n</code></pre>\n<p>这就是为什么如果不传递 <code>el</code> 选项就需要手动 mount 的原因了。</p>\n<p>那么我们依照我们本节开头的的例子，以及初始化的先后顺序来逐一看一看都发生了什么。我们将 <code>initState</code> 中的 <code>init*</code> 方法展开来看，执行顺序应该是这样的（从上到下的顺序执行）：</p>\n<pre><code>initLifecycle(vm)\ninitEvents(vm)\ncallHook(vm, &#39;beforeCreate&#39;)\ninitProps(vm)\ninitMethods(vm)\ninitData(vm)\ninitComputed(vm)\ninitWatch(vm)\ncallHook(vm, &#39;created&#39;)\ninitRender(vm)\n</code></pre><p>首先是 <code>initLifecycle</code>，这个函数的作用就是在实例上添加一些属性，然后是 <code>initEvents</code>，由于 <code>vm.$options._parentListeners</code> 的值为 <code>undefined</code> 所以也仅仅是在实例上添加属性， <code>vm._updateListeners(listeners)</code> 并不会执行，由于我们只传递了 <code>el</code> 和 <code>data</code>，所以 <code>initProps</code>、<code>initMethods</code>、<code>initComputed</code>、<code>initWatch</code> 这四个方法什么都不会做，只有 <code>initData</code> 会执行。最后是 <code>initRender</code>，除了在实例上添加一些属性外，由于我们传递了 <code>el</code> 选项，所以会执行 <code>vm.$mount(vm.$options.el)</code>。</p>\n<p>综上所述：按照我们的例子那样写，初始化工作只包含两个主要内容即：<code>initData</code> 和 <code>initRender</code>。</p>\n<h2 id=\"五、通过initData看Vue的数据响应系统\"><a href=\"#五、通过initData看Vue的数据响应系统\" class=\"headerlink\" title=\"五、通过initData看Vue的数据响应系统\"></a><span style=\"color: #ff6600;\">五、通过<code>initData</code>看Vue的数据响应系统</span></h2><p>Vue的数据响应系统包含三个部分：<code>Observer</code>、<code>Dep</code>、<code>Watcher</code>。关于数据响应系统的内容真的已经被文章讲烂了，所以我就简单的说一下，力求大家能理解就ok，我们还是先看一下 <code>initData</code> 中的代码：</p>\n<pre><code>function initData (vm: Component) {\n  let data = vm.$options.data\n  data = vm._data = typeof data === &#39;function&#39;\n    ? data.call(vm)\n    : data || {}\n  if (!isPlainObject(data)) {\n    data = {}\n    process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; warn(\n      &#39;data functions should return an object:\\n&#39; +\n      &#39;https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function&#39;,\n      vm\n    )\n  }\n  // proxy data on instance\n  const keys = Object.keys(data)\n  const props = vm.$options.props\n  let i = keys.length\n  while (i--) {\n    if (props &amp;&amp; hasOwn(props, keys[i])) {\n      process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; warn(\n        `The data property &quot;${keys[i]}&quot; is already declared as a prop. ` +\n        `Use prop default value instead.`,\n        vm\n      )\n    } else {\n      proxy(vm, keys[i])\n    }\n  }\n  // observe data\n  observe(data)\n  data.__ob__ &amp;&amp; data.__ob__.vmCount++\n}\n</code></pre><p>首先，先拿到 data 数据：<code>let data = vm.$options.data</code>，大家还记得此时 <code>vm.$options.data</code> 的值应该是通过 <code>mergeOptions</code> 合并处理后的 <code>mergedInstanceDataFn</code> 函数吗？所以在得到 data 后，它又判断了 data 的数据类型是不是 ‘function’，最终的结果是：data 还是我们传入的数据选项的 data，即：</p>\n<pre><code>data: {\n    a: 1,\n    b: [1, 2, 3]\n}\n</code></pre><p>然后在实例对象上定义 <code>_data</code> 属性，该属性与 <code>data</code> 是相同的引用。</p>\n<p>然后是一个 <code>while</code> 循环，循环的目的是在实例对象上对数据进行代理，这样我们就能通过 <code>this.a</code> 来访问 <code>data.a</code> 了，代码的处理是在 <code>proxy</code> 函数中，该函数非常简单，仅仅是在实例对象上设置与 <code>data</code> 属性同名的访问器属性，然后使用 <code>_data</code> 做数据劫持，如下：</p>\n<pre><code>function proxy (vm: Component, key: string) {\n  if (!isReserved(key)) {\n    Object.defineProperty(vm, key, {\n      configurable: true,\n      enumerable: true,\n      get: function proxyGetter () {\n        return vm._data[key]\n      },\n      set: function proxySetter (val) {\n        vm._data[key] = val\n      }\n    })\n  }\n}\n</code></pre><p>做完数据的代理，就正式进入响应系统，</p>\n<pre><code>observe(data)\n</code></pre><p>我们说过，数据响应系统主要包含三部分：<code>Observer</code>、<code>Dep</code>、<code>Watcher</code>，代码分别存放在：<code>observer/index.js</code>、<code>observer/dep.js</code> 以及 <code>observer/watcher.js</code> 文件中，这回我们换一种方式，我们先不看其源码，大家先跟着我的思路来思考，最后回头再去看代码，你会有一种：”奥，不过如此“的感觉。</p>\n<p>假如，我们有如下代码：</p>\n<pre><code class=\"js\">var data = {\n    a: 1,\n    b: {\n        c: 2\n    }\n}\n\nobserver(data)\n\nnew Watch(&#39;a&#39;, () =&gt; {\n    alert(9)\n})\nnew Watch(&#39;a&#39;, () =&gt; {\n    alert(90)\n})\nnew Watch(&#39;b.c&#39;, () =&gt; {\n    alert(80)\n})\n</code></pre>\n<p>这段代码目的是，首先定义一个数据对象 <code>data</code>，然后通过 observer 对其进行观测，之后定义了三个观察者，当数据有变化时，执行相应的方法，这个功能使用Vue的实现原来要如何去实现？其实就是在问 <code>observer</code> 怎么写？<code>Watch</code> 构造函数又怎么写？接下来我们逐一实现。</p>\n<p>首先，observer 的作用是：将数据对象data的属性转换为访问器属性：</p>\n<pre><code>class Observer {\n    constructor (data) {\n        this.walk(data)\n    }\n    walk (data) {\n        // 遍历 data 对象属性，调用 defineReactive 方法\n        let keys = Object.keys(data)\n        for(let i = 0; i &lt; keys.length; i++){\n            defineReactive(data, keys[i], data[keys[i]])\n        }\n    }\n}\n\n// defineReactive方法仅仅将data的属性转换为访问器属性\nfunction defineReactive (data, key, val) {\n    // 递归观测子属性\n    observer(val)\n\n    Object.defineProperty(data, key, {\n        enumerable: true,\n        configurable: true,\n        get: function () {\n            return val\n        },\n        set: function (newVal) {\n            if(val === newVal){\n                return\n            }\n            // 对新值进行观测\n            observer(newVal)\n        }\n    })\n}\n\n// observer 方法首先判断data是不是纯JavaScript对象，如果是，调用 Observer 类进行观测\nfunction observer (data) {\n    if(Object.prototype.toString.call(data) !== &#39;[object Object]&#39;) {\n        return\n    }\n    new Observer(data)\n}\n</code></pre><p>上面的代码中，我们定义了 observer 方法，该方法检测了数据data是不是纯JavaScript对象，如果是就调用 <code>Observer</code> 类，并将 <code>data</code> 作为参数透传。在 <code>Observer</code> 类中，我们使用 <code>walk</code> 方法对数据data的属性循环调用 <code>defineReactive</code> 方法，<code>defineReactive</code> 方法很简单，仅仅是将数据data的属性转为访问器属性，并对数据进行递归观测，否则只能观测数据data的直属子属性。这样我们的第一步工作就完成了，当我们修改或者获取data属性值的时候，通过 <code>get</code> 和 <code>set</code> 即能获取到通知。</p>\n<p>我们继续往下看，来看一下 <code>Watch</code>：</p>\n<pre><code>new Watch(&#39;a&#39;, () =&gt; {\n    alert(9)\n})\n</code></pre><p>现在的问题是，<code>Watch</code> 要怎么和 <code>observer</code> 关联？？？？？？？我们看看 <code>Watch</code> 它知道些什么，通过上面调用 <code>Watch</code> 的方式，传递给 <code>Watch</code> 两个参数，一个是 ‘a’ 我们可以称其为表达式，另外一个是回调函数。所以我们目前只能写出这样的代码：</p>\n<pre><code>class Watch {\n    constructor (exp, fn) {\n        this.exp = exp\n        this.fn = fn\n    }\n}\n</code></pre><p>那么要怎么关联呢，大家看下面的代码会发生什么：</p>\n<pre><code>class Watch {\n    constructor (exp, fn) {\n        this.exp = exp\n        this.fn = fn\n        data[exp]\n    }\n}\n</code></pre><p>多了一句 <code>data[exp]</code>，这句话是在干什么？是不是在获取 <code>data</code> 下某个属性的值，比如 exp 为 ‘a’ 的话，那么 <code>data[exp]</code> 就相当于在获取 <code>data.a</code> 的值，那这会放生什么？大家不要忘了，此时数据 <code>data</code> 下的属性已经是访问器属性了，所以这么做的结果会直接触发对应属性的 <code>get</code> 函数，这样我们就成功的和 <code>observer</code> 产生了关联，但这样还不够，我们还是没有达到目的，不过我们已经无限接近了，我们继续思考看一下可不可以这样：</p>\n<blockquote>\n<p>既然在 <code>Watch</code> 中对表达式求值，能够触发 <code>observer</code> 的 <code>get</code>，那么可不可以在 <code>get</code> 中收集 <code>Watch</code> 中函数呢？</p>\n</blockquote>\n<p>答案是可以的，不过这个时候我们就需要 <code>Dep</code> 出场了，它是一个依赖收集器。我们的思路是：<code>data</code> 下的每一个属性都有一个唯一的 <code>Dep</code> 对象，在 <code>get</code> 中收集仅针对该属性的依赖，然后在 <code>set</code> 方法中触发所有收集的依赖，这样就搞定了，看如下代码：</p>\n<pre><code>class Dep {\n    constructor () {\n        this.subs = []\n    }\n    addSub () {\n        this.subs.push(Dep.target)\n    }\n    notify () {\n        for(let i = 0; i &lt; this.subs.length; i++){\n            this.subs[i].fn()\n        }\n    }\n}\nDep.target = null\nfunction pushTarget(watch){\n    Dep.target = watch\n}\n\nclass Watch {\n    constructor (exp, fn) {\n        this.exp = exp\n        this.fn = fn\n        pushTarget(this)\n        data[exp]\n    }\n}\n</code></pre><p>上面的代码中，我们在 <code>Watch</code> 中增加了 <code>pushTarget(this)</code>，可以发现，这句代码的作用是将 <code>Dep.target</code> 的值设置为该Watch对象。在 <code>pushTarget</code> 之后我们才对表达式进行求值，接着，我们修改 <code>defineReactive</code> 代码如下</p>\n<pre><code>function defineReactive (data, key, val) {\n    observer(val)\n    let dep = new Dep()        // 新增\n    Object.defineProperty(data, key, {\n        enumerable: true,\n        configurable: true,\n        get: function () {\n            dep.addSub()    // 新增\n            return val\n        },\n        set: function (newVal) {\n            if(val === newVal){\n                return\n            }\n            observer(newVal)\n            dep.notify()    // 新增\n        }\n    })\n}\n</code></pre><p>如标注，新增了三句代码，我们知道，<code>Watch</code> 中对表达式求值会触发 <code>get</code> 方法，我们在 <code>get</code> 方法中调用了 <code>dep.addSub</code>，也就执行了这句代码：<code>this.subs.push(Dep.target)</code>，由于在这句代码执行之前，<code>Dep.target</code> 的值已经被设置为一个 <code>Watch</code> 对象了，所以最终结果就是收集了一个 <code>Watch</code> 对象，然后在 <code>set</code> 方法中我们调用了 <code>dep.notify</code>，所以当data属性值变化的时候，就会通过 <code>dep.notify</code> 循环调用所有收集的Watch对象中的回调函数：</p>\n<pre><code>notify () {\n    for(let i = 0; i &lt; this.subs.length; i++){\n        this.subs[i].fn()\n    }\n}\n</code></pre><p>这样 <code>observer</code>、<code>Dep</code>、<code>Watch</code> 三者就联系成为一个有机的整体，实现了我们最初的目标，完整的代码可以戳这里：<a href=\"https://github.com/HcySunYang/observer-dep-watch\" target=\"_blank\" rel=\"external\">observer-dep-watch</a>。这里还给大家挖了个坑，因为我们没有处理对数组的观测，由于比较复杂并且这又不是我们讨论的重点，如果大家想了解可以戳我的这篇文章：<a href=\"http://hcysun.me/2016/04/28/JavaScript%E5%AE%9E%E7%8E%B0MVVM%E4%B9%8B%E6%88%91%E5%B0%B1%E6%98%AF%E6%83%B3%E7%9B%91%E6%B5%8B%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8F%98%E5%8C%96/\">JavaScript实现MVVM之我就是想监测一个普通对象的变化</a>，另外，在 Watch 中对表达式求值的时候也只做了直接子属性的求值，所以如果 exp 的值为 ‘a.b’ 的时候，就不可以用了，Vue的做法是使用 <code>.</code> 分割表达式字符串为数组，然后遍历一下对其进行求值，大家可以查看其源码。如下：</p>\n<pre><code>/**\n * Parse simple path.\n */\nconst bailRE = /[^\\w.$]/\nexport function parsePath (path: string): any {\n  if (bailRE.test(path)) {\n    return\n  } else {\n    const segments = path.split(&#39;.&#39;)\n    return function (obj) {\n      for (let i = 0; i &lt; segments.length; i++) {\n        if (!obj) return\n        obj = obj[segments[i]]\n      }\n      return obj\n    }\n  }\n}\n</code></pre><p>Vue 的求值代码是在 <code>src/core/util/lang.js</code> 文件中 <code>parsePath</code> 函数中实现的。总结一下Vue的依赖收集过程应该是这样的：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/vueimgdep.png\" alt=\"Vue的依赖收集过程\"></p>\n<p>实际上，Vue并没有直接在 <code>get</code> 中调用 <code>addSub</code>，而是调用的 <code>dep.depend</code>，目的是将当前的 dep 对象收集到 watch 对象中，如果要完整的流程，应该是这样的：（大家注意数据的每一个字段都拥有自己的 <code>dep</code> 对象和 <code>get</code> 方法。）</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/all.png\" alt=\"Vue完整的收集依赖的流程\"></p>\n<p>这样 Vue 就建立了一套数据响应系统，之前我们说过，按照我们的例子那样写，初始化工作只包含两个主要内容即：<code>initData</code> 和 <code>initRender</code>。现在 <code>initData</code> 我们分析完了，接下来看一看 <code>initRender</code></p>\n<h2 id=\"六、通过initRender看Vue的-render-渲染-与-re-render-重新渲染\"><a href=\"#六、通过initRender看Vue的-render-渲染-与-re-render-重新渲染\" class=\"headerlink\" title=\"六、通过initRender看Vue的 render(渲染) 与 re-render(重新渲染)\"></a><span style=\"color: #ff6600;\">六、通过<code>initRender</code>看Vue的 render(渲染) 与 re-render(重新渲染)</span></h2><p>在 <code>initRender</code> 方法中，因为我们的例子中传递了 <code>el</code> 选项，所以下面的代码会执行：</p>\n<pre><code>  if (vm.$options.el) {\n    vm.$mount(vm.$options.el)\n  }\n</code></pre><p>这里，调用了 <code>$mount</code> 方法，在还原Vue构造函数的时候，我们整理过所有的方法，其中 <code>$mount</code> 方法在两个地方出现过：</p>\n<p>1、在 <code>web-runtime.js</code> 文件中：</p>\n<pre><code>Vue.prototype.$mount = function (\n  el?: string | Element,\n  hydrating?: boolean\n): Component {\n  el = el &amp;&amp; inBrowser ? query(el) : undefined\n  return this._mount(el, hydrating)\n}\n</code></pre><p>它的作用是通过 <code>el</code> 获取相应的DOM元素，然后调用 <code>lifecycle.js</code> 文件中的 <code>_mount</code> 方法。</p>\n<p>2、在 <code>web-runtime-with-compiler.js</code> 文件中：</p>\n<pre><code>// 缓存了来自 web-runtime.js 的 $mount 方法\nconst mount = Vue.prototype.$mount\n// 重写 $mount 方法\nVue.prototype.$mount = function (\n  el?: string | Element,\n  hydrating?: boolean\n): Component {\n  // 根据 el 获取相应的DOM元素\n  el = el &amp;&amp; query(el)\n  // 不允许你将 el 挂载到 html 标签或者 body 标签\n  if (el === document.body || el === document.documentElement) {\n    process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; warn(\n      `Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`\n    )\n    return this\n  }\n\n  const options = this.$options\n  // 如果我们没有写 render 选项，那么就尝试将 template 或者 el 转化为 render 函数\n  if (!options.render) {\n    let template = options.template\n    if (template) {\n      if (typeof template === &#39;string&#39;) {\n        if (template.charAt(0) === &#39;#&#39;) {\n          template = idToTemplate(template)\n          /* istanbul ignore if */\n          if (process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; !template) {\n            warn(\n              `Template element not found or is empty: ${options.template}`,\n              this\n            )\n          }\n        }\n      } else if (template.nodeType) {\n        template = template.innerHTML\n      } else {\n        if (process.env.NODE_ENV !== &#39;production&#39;) {\n          warn(&#39;invalid template option:&#39; + template, this)\n        }\n        return this\n      }\n    } else if (el) {\n      template = getOuterHTML(el)\n    }\n    if (template) {\n      const { render, staticRenderFns } = compileToFunctions(template, {\n        warn,\n        shouldDecodeNewlines,\n        delimiters: options.delimiters\n      }, this)\n      options.render = render\n      options.staticRenderFns = staticRenderFns\n    }\n  }\n  // 调用已经缓存下来的 web-runtime.js 文件中的 $mount 方法\n  return mount.call(this, el, hydrating)\n}\n</code></pre><p>分析一下可知 <code>web-runtime-with-compiler.js</code> 的逻辑如下：</p>\n<p>1、缓存来自 <code>web-runtime.js</code> 文件的 <code>$mount</code> 方法</p>\n<p>2、判断有没有传递 <code>render</code> 选项，如果有直接调用来自 <code>web-runtime.js</code> 文件的 $mount 方法</p>\n<p>3、如果没有传递 <code>render</code> 选项，那么查看有没有 <code>template</code> 选项，如果有就使用 <code>compileToFunctions</code> 函数根据其内容编译成 <code>render</code> 函数</p>\n<p>4、如果没有 <code>template</code> 选项，那么查看有没有 <code>el</code> 选项，如果有就使用 <code>compileToFunctions</code> 函数将其内容(template = getOuterHTML(el))编译成 <code>render</code> 函数</p>\n<p>5、将编译成的 <code>render</code> 函数挂载到 <code>this.$options</code> 属性下，并调用缓存下来的 <code>web-runtime.js</code> 文件中的 $mount 方法</p>\n<p>简单的用一张图表示 <code>mount</code> 方法的调用关系，从上至下调用：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/vueimgmount.png\" alt=\"mount调用关系\"></p>\n<p>不过不管怎样，我们发现这些步骤的最终目的是生成 <code>render</code> 函数，然后再调用 <code>lifecycle.js</code> 文件中的 <code>_mount</code> 方法，我们看看这个方法做了什么事情，查看 <code>_mount</code> 方法的代码，这是简化过得：</p>\n<pre><code>  Vue.prototype._mount = function (\n    el?: Element | void,\n    hydrating?: boolean\n  ): Component {\n    const vm: Component = this\n\n    // 在Vue实例对象上添加 $el 属性，指向挂载点元素\n    vm.$el = el\n\n    // 触发 beforeMount 生命周期钩子\n    callHook(vm, &#39;beforeMount&#39;)\n\n    vm._watcher = new Watcher(vm, () =&gt; {\n      vm._update(vm._render(), hydrating)\n    }, noop)\n\n    // 如果是第一次mount则触发 mounted 生命周期钩子\n    if (vm.$vnode == null) {\n      vm._isMounted = true\n      callHook(vm, &#39;mounted&#39;)\n    }\n    return vm\n  }\n</code></pre><p>上面的代码很简单，该注释的都注释了，唯一需要看的就是这段代码：</p>\n<pre><code>vm._watcher = new Watcher(vm, () =&gt; {\n  vm._update(vm._render(), hydrating)\n}, noop)\n</code></pre><p>看上去很眼熟有没有？我们平时使用Vue都是这样使用 watch的：</p>\n<pre><code>this.$watch(&#39;a&#39;, (newVal, oldVal) =&gt; {\n\n})\n// 或者\nthis.$watch(function(){\n    return this.a + this.b\n}, (newVal, oldVal) =&gt; {\n\n})\n</code></pre><p>第一个参数是 表达式或者函数，第二个参数是回调函数，第三个参数是可选的选项。原理是 <code>Watch</code> 内部对表达式求值或者对函数求值从而触发数据的 <code>get</code> 方法收集依赖。可是 <code>_mount</code> 方法中使用 <code>Watcher</code> 的时候第一个参数 <code>vm</code> 是什么鬼。我们不妨去看看源码中 <code>$watch</code> 函数是如何实现的，根据之前还原Vue构造函数中所整理的内容可知：<code>$warch</code> 方法是在 <code>src/core/instance/state.js</code> 文件中的 <code>stateMixin</code> 方法中定义的，源码如下：</p>\n<pre><code>  Vue.prototype.$watch = function (\n    expOrFn: string | Function,\n    cb: Function,\n    options?: Object\n  ): Function {\n    const vm: Component = this\n    options = options || {}\n    options.user = true\n    const watcher = new Watcher(vm, expOrFn, cb, options)\n    if (options.immediate) {\n      cb.call(vm, watcher.value)\n    }\n    return function unwatchFn () {\n      watcher.teardown()\n    }\n  }\n</code></pre><p>我们可以发现，<code>$warch</code> 其实是对 <code>Watcher</code> 的一个封装，内部的 <code>Watcher</code> 的第一个参数实际上也是 <code>vm</code> 即：Vue实例对象，这一点我们可以在 <code>Watcher</code> 的源码中得到验证，代开 <code>observer/watcher.js</code> 文件查看：</p>\n<pre><code class=\"js\">export default class Watcher {\n\n  constructor (\n    vm: Component,\n    expOrFn: string | Function,\n    cb: Function,\n    options?: Object = {}\n  ) {\n\n  }\n}\n</code></pre>\n<p>可以发现真正的 <code>Watcher</code> 第一个参数实际上就是 <code>vm</code>。第二个参数是表达式或者函数，然后以此类推，所以现在再来看 <code>_mount</code> 中的这段代码：</p>\n<pre><code>vm._watcher = new Watcher(vm, () =&gt; {\n  vm._update(vm._render(), hydrating)\n}, noop)\n</code></pre><p>忽略第一个参数 <code>vm</code>，也就说，<code>Watcher</code> 内部应该对第二个参数求值，也就是运行这个函数：</p>\n<pre><code>() =&gt; {\n  vm._update(vm._render(), hydrating)\n}\n</code></pre><p>所以 <code>vm._render()</code> 函数被第一个执行，该函数在 <code>src/core/instance/render.js</code> 中，该方法中的代码很多，下面是简化过的：</p>\n<pre><code>  Vue.prototype._render = function (): VNode {\n    const vm: Component = this\n    // 解构出 $options 中的 render 函数\n    const {\n      render,\n      staticRenderFns,\n      _parentVnode\n    } = vm.$options\n    ...\n\n    let vnode\n    try {\n      // 运行 render 函数\n      vnode = render.call(vm._renderProxy, vm.$createElement)\n    } catch (e) {\n      ...\n    }\n\n    // set parent\n    vnode.parent = _parentVnode\n    return vnode\n  }\n</code></pre><p><code>_render</code> 方法首先从 <code>vm.$options</code> 中解构出 <code>render</code> 函数，大家应该记得：<code>vm.$options.render</code> 方法是在 <code>web-runtime-with-compiler.js</code> 文件中通过 <code>compileToFunctions</code> 方法将 <code>template</code> 或 <code>el</code> 编译而来的。解构出 <code>render</code> 函数后，接下来便执行了该方法：</p>\n<pre><code>vnode = render.call(vm._renderProxy, vm.$createElement)\n</code></pre><p>其中使用 <code>call</code> 指定了 <code>render</code> 函数的作用域环境为 <code>vm._renderProxy</code>，这个属性在我们整理实例对象的时候知道，他是在 <code>Vue.prototype._init</code> 方法中被添加的，即：<code>vm._renderProxy = vm</code>，其实就是Vue实例对象本身，然后传递了一个参数：<code>vm.$createElement</code>。那么 <code>render</code> 函数到底是干什么的呢？让我们根据上面那句代码猜一猜，我们已经知道 <code>render</code> 函数是从 <code>template</code> 或 <code>el</code> 编译而来的，如果没错的话应该是返回一个虚拟DOM对象。我们不妨使用 <code>console.log</code> 打印一下 <code>render</code> 函数，当我们的模板这样编写时：</p>\n<pre><code>&lt;ul id=&quot;app&quot;&gt;\n  &lt;li&gt;{{a}}&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre><p>打印的 <code>render</code> 函数如下：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/vueimgr2.png\" alt=\"render函数1\"></p>\n<p>我们修改模板为：</p>\n<pre><code>&lt;ul id=&quot;app&quot;&gt;\n  &lt;li v-for=&quot;i in b&quot;&gt;{{a}}&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre><p>打印出来的 <code>render</code> 函数如下：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/vueimgr3.png\" alt=\"render函数2\"></p>\n<p>其实了解Vue2.x版本的同学都知道，Vue提供了 <code>render</code> 选项，作为 <code>template</code> 的代替方案，同时为JavaScript提供了完全编程的能力，下面两种编写模板的方式实际是等价的：</p>\n<pre><code class=\"js\">// 方案一：\nnew Vue({\n    el: &#39;#app&#39;,\n    data: {\n        a: 1\n    },\n    template: &#39;&lt;ul&gt;&lt;li&gt;{{a}}&lt;/li&gt;&lt;li&gt;{{a}}&lt;/li&gt;&lt;/ul&gt;&#39;\n})\n\n// 方案二：\nnew Vue({\n    el: &#39;#app&#39;,\n    render: function (createElement) {\n        createElement(&#39;ul&#39;, [\n            createElement(&#39;li&#39;, this.a),\n            createElement(&#39;li&#39;, this.a)\n        ])\n    }\n})\n</code></pre>\n<p>现在我们再来看我们打印的 <code>render</code> 函数：</p>\n<pre><code>function anonymous() {\n    with(this){\n        return _c(&#39;ul&#39;, { \n            attrs: {&quot;id&quot;: &quot;app&quot;}\n        },[\n            _c(&#39;li&#39;, [_v(_s(a))])\n        ])\n    }\n}\n</code></pre><p>是不是与我们自己写 <code>render</code> 函数很像？因为 render 函数的作用域被绑定到了Vue实例，即：<code>render.call(vm._renderProxy, vm.$createElement)</code>，所以上面代码中 <code>_c</code>、<code>_v</code>、<code>_s</code> 以及变量 <code>a</code>相当于Vue实例下的方法和变量。大家还记得诸如 <code>_c</code>、<code>_v</code>、<code>_s</code> 这样的方法在哪里定义的吗？我们在整理Vue构造函数的时候知道，他们在 <code>src/core/instance/render.js</code> 文件中的 <code>renderMixin</code> 方法中定义，除了这些之外还有诸如：<code>_l</code>、 <code>_m</code>、 <code>_o</code> 等等。其中 <code>_l</code> 就在我们使用 <code>v-for</code> 指令的时候出现了。所以现在大家知道为什么这些方法都被定义在 <code>render.js</code> 文件中了吧，因为他们就是为了构造出 <code>render</code> 函数而存在的。</p>\n<p>现在我们已经知道了 <code>render</code> 函数的长相，也知道了 <code>render</code> 函数的作用域是Vue实例本身即：<code>this</code>(或<code>vm</code>)。那么当我们执行 <code>render</code> 函数时，其中的变量如：<code>a</code>，就相当于：<code>this.a</code>，我们知道这是在求值，所以 <code>_mount</code> 中的这段代码：</p>\n<pre><code>vm._watcher = new Watcher(vm, () =&gt; {\n  vm._update(vm._render(), hydrating)\n}, noop)\n</code></pre><p>当 <code>vm._render</code> 执行的时候，所依赖的变量就会被求值，并被收集为依赖。按照Vue中 <code>watcher.js</code> 的逻辑，当依赖的变量有变化时不仅仅回调函数被执行，实际上还要重新求值，即还要执行一遍：</p>\n<pre><code>() =&gt; {\n  vm._update(vm._render(), hydrating)\n}\n</code></pre><p>这实际上就做到了 <code>re-render</code>，因为 <code>vm._update</code> 就是文章开头所说的虚拟DOM中的最后一步：<code>patch</code></p>\n<p><code>vm_render</code> 方法最终返回一个 <code>vnode</code> 对象，即虚拟DOM，然后作为 <code>vm_update</code> 的第一个参数传递了过去，我们看一下 <code>vm_update</code> 的逻辑，在 <code>src/core/instance/lifecycle.js</code> 文件中有这么一段代码：</p>\n<pre><code class=\"js\">    if (!prevVnode) {\n      // initial render\n      vm.$el = vm.__patch__(\n        vm.$el, vnode, hydrating, false /* removeOnly */,\n        vm.$options._parentElm,\n        vm.$options._refElm\n      )\n    } else {\n      // updates\n      vm.$el = vm.__patch__(prevVnode, vnode)\n    }\n</code></pre>\n<p>如果还没有 <code>prevVnode</code> 说明是首次渲染，直接创建真实DOM。如果已经有了 <code>prevVnode</code> 说明不是首次渲染，那么就采用 <code>patch</code> 算法进行必要的DOM操作。这就是Vue更新DOM的逻辑。只不过我们没有将 virtual DOM 内部的实现。</p>\n<p>现在我们来好好理理思路，当我们写如下代码时：</p>\n<pre><code>new Vue({\n    el: &#39;#app&#39;,\n    data: {\n        a: 1,\n        b: [1, 2, 3]\n    }\n})\n</code></pre><p>Vue 所做的事：</p>\n<blockquote>\n<p>1、构建数据响应系统，使用 <code>Observer</code> 将数据data转换为访问器属性；将 <code>el</code> 编译为 <code>render</code> 函数，<code>render</code> 函数返回值为虚拟DOM</p>\n<p>2、在 <code>_mount</code> 中对 <code>_update</code> 求值，而 <code>_update</code> 又会对 <code>render</code> 求值，<code>render</code> 内部又会对依赖的变量求值，收集为被求值的变量的依赖，当变量改变时，<code>_update</code> 又会重新执行一遍，从而做到 <code>re-render</code>。</p>\n</blockquote>\n<p>用一张详细一点的图表示就是这样的：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/vueimgdetail.png\" alt=\"详细流程\"></p>\n<p>到此，我们从大体流程，挑着重点的走了一遍Vue，但是还有很多细节我们没有提及，比如：</p>\n<p>1、将模板转为 <code>render</code> 函数的时候，实际是先生成的抽象语法树（AST），再将抽象语法树转成的 <code>render</code> 函数，而且这一整套的代码我们也没有提及，因为他在复杂了，其实这部分内容就是在完正则。</p>\n<p>2、我们也没有详细的讲 Virtual DOM 的实现原理，网上已经有文章讲了，大家可以搜一搜</p>\n<p>3、我们的例子中仅仅传递了 <code>el</code> ，<code>data</code> 选项，大家知道 Vue 支持的选项很多，比如我们都没有讲到，但都是触类旁通的，比如你搞清楚了 <code>data</code> 选项再去看 <code>computed</code> 选项或者 <code>props</code> 选项就会很容易，比如你知道了 <code>Watcher</code> 的工作机制再去看 <code>watch</code> 选项就会很容易。</p>\n<p>本篇文章作为Vue源码的启蒙文章，也许还有很多缺陷，全当抛砖引玉了。</p>"},{"title":"从矩阵与空间操作的关系理解CSS3的transform","date":"2017-05-13T02:50:27.000Z","_content":"\n前不久开源了一个插件化移动端运动效果库 [finger-mover](https://github.com/HcySunYang/finger-mover)，说到运动效果，不得不提到CSS3的 `transform`，也就是变换。这篇文章概括了在实现 [finger-mover](https://github.com/HcySunYang/finger-mover) 时对 `transform` 的理解与总结。\n\n注：文中的图片多数截取自视频：[线性代数的本质](http://www.bilibili.com/video/av6731067/index_1.html#page=1)，也强烈建议大家系统的观看这套视频。另外如果文中有误请不吝指教。\n\n<!-- more -->\n\n文章结构如下：\n\n```\n* 矩阵\n    * 概述\n* 向量\n    * 什么是向量\n    * 基向量\n* 线性变换\n* 如何用数值描述线性变换？\n* 回到 CSS 的 transform\n```\n\n我不知道大家所理解的矩阵是怎样的，但我所理解的矩阵是：该阵法免疫法术攻击且100%反伤对方随机一个单位（回合制游戏）。\n\n以上描述是在小学时代的理解，现在可能有所不同，慢慢说......\n\n## 矩阵\n\n#### 概述\n\n矩阵，是线性代数中涉及的内容，线性代数在科学领域有很多应用的场景，如下：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transformuse-the-scene.png?imageView/2/w/500)\n\n大部分同学在大学时期应该都学过一本叫做线性代数的书，如果没猜错的话，你们的老师在教学的时候大多都是概念性的灌输，比如矩阵乘法如何运算，加法如何运算，大家只要记住就ok了，但是大部分同学都不理解，*为什么矩阵的乘法要这样算？矩阵乘法的意义是什么？*，特别是我们搞计算机的，如果有做过 2D/3D 变换的同学一定听说过矩阵，比如在前端的CSS中，使用 `transform` 做 2D/3D 的变换，其中就应用到了矩阵的知识，这篇文章并不是一篇数学性质的文章，所以大家不要看了感觉一阵眩晕，这篇文章的目的在于：从矩阵与空间之间的关系讲述：为什么矩阵可以应用在空间操作(变换)。或者用一句大白话：*这玩意儿怎么就能让`div`翻过来，转过去，扭的他爹都不认识他的。*\n\n先看一段 css 代码：\n\n```css\n/* 2D */\ntransform: matrix(1, 0, 0, 1, 0, 0);\n/* 3D */\ntransform: matrix(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n```\n\n上面两行 css 代码其实什么变换都不会做，因为那是变换的默认状态，即没有变换。但是其中使用到了 `matrix`，翻译成中文叫做：矩阵。如果有深入研究过 css 的同学对这两行代码也许不陌生，但是大多数人在使用 `transform` 变换时很少直接使用 `matrix` 矩阵，除非你不想让人看懂你在做些什么鸟变换...，所以更多的时候，我们会使用类似如下语法：\n\n```css\ntransform: translateX(100px) rotateZ(30deg);\n```\n\n如上代码所示，一目了然，要做什么变换大家一看就知道了。但其实，这只是一个语法糖，其底层依然使用的是 `matrix`。\n\n如果想要理解矩阵为何可以应用到 2D/3D 变换，那么只从数值水平的角度理解是不够的，你需要从几何的角度去理解矩阵，这存在着根本性的差异。而这，也就是本篇文章的真正意义。\n\n不过，这需要我们先了解一些必要的基本概念，这些概念至关重要，首先就是向量\n\n## 向量\n\n#### 什么是向量\n\n既然矩阵是线性代数的一部分，那么就不得不提到 *向量*，因为向量是线性代数最基础、最根源的组成部分，所以我们要先搞清楚，向量是什么？我说过，这篇文章不会很“数学”，所以大家不要被吓到。用一句话描述向量是什么：\n\n> 向量：空间中的箭头\n\n这个在大家的印象里应该很好理解，这个箭头由两个因素决定：`方向` 和 `长度`，我们先把目光局限在二维空间下，如图：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transformarrow.png?imageView/2/w/500)\n\n上图中，在一个坐标系中画了四个不同长度和方向的箭头，每个箭头从原点发出，他们代表了二维空间中的四个向量，在线性代数中，向量通常以原点作为起点。\n\n如果你已经理解了“向量是空间中的箭头”这种观点，下面我们再进一步，我们重新用一句话来描述向量：\n\n> 向量：是有序的数字列表\n\n假设大家对坐标系的概念都有所了解，我们还是把目光局限在二维空间，在坐标系中任意选取单位长度，这样我们就能够使用一个一个的刻度来标刻这个坐标系，选取特定的方向为x/y轴的正方向，那么不难看出，每一个向量，都可以用唯一的一个坐标来表示，同样的，坐标系中的每一个坐标都对应着一个唯一的箭头(向量)，如下图：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transformnumber.png?imageView/2/w/500)\n\n在坐标系中，由于坐标通常用来标示一个点，如 `P(2, 8)` 表示点 P 的坐标为 `(2, 8)`，为了区分点和向量，在表示向量时，我们通常把坐标竖着写，然后用一对儿中括号来描述，如上图中的：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transformpoint.png?imageView/2/w/500)\n\n在三维空间也是一样的道理，如下图，我就不做重复的解释，唯一不同的是，每一个向量由 x/y/z 三个数字组成的坐标来表示：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transform3.png?imageView/2/w/500)\n\n对于向量，你只需要知道它是“空间中的箭头”或者“有序的数字列表”这就足够了，怎么样？不难理解吧，我们继续往下看，在坐标系中存在一种特殊的向量，我们称之为 *基向量*。\n\n#### 基向量\n\n基向量，也叫单位向量，是单位长度为1的向量，如下图中：`i帽` 和 `j帽` 就是这个二维坐标系的基向量：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transformji-xl.png?imageView/2/w/500)\n\n对于向量，我们就先介绍到这里，这已经足够了。除了向量，还有一个概念需要大家了解，即线性变换。\n\n## 线性变换\n\n“变换”本质上是“函数”的一种花哨的叫法，玩编程的都知道函数，与在数学中的概念类似，函数接收输入的内容，并输出对应的结果，如图：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transformfunction.png?imageView/2/w/500)\n\n变换也是同样的道理，只不过接收向量作为输入，并输出变换后的向量：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transformtransform.png?imageView/2/w/500)\n\n既然 “变换” 与 “函数” 本质相同，那么为什么叫变换而不叫函数呢？这实际上就暗示了我们，你可以把这个输入输出的过程，看做一个向量从初始状态到最终状态的一个变化过程，如下图：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transforminput-output.png?imageView/2/w/500)\n\n现在，我们把情况宏观一下，目前只讨论一个向量的变换，我们知道，二维空间的一整个平面，可以看做是由无数个向量组成(或者无数个点组成，因为每一个点唯一标识一个向量，所以这里说平面由无数个向量组成)，假如这无数个向量同时做相同的变换，那其实就可以看做是平面的变换，如下图：\n\n变换前：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transformbefore.png?imageView/2/w/500)\n\n变换后：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transformafter.png?imageView/2/w/500)\n\n不过，并非所有变换都叫做线性变换，线性变换必须要满足下面两个条件：\n* 1、直线在变换后仍然为直线，不能有所弯曲\n* 2、原点不能移动\n\n如下变换，就不是一个线性变换，因为直线变成了曲线：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transformwanqu.png?imageView/2/w/500)\n\n## 如何用数值描述线性变换？\n\n在上一小节中我们知道，空间的变换也可以说是向量的变换，而向量在空间中，可以用一组有序的数字列表来表示(即向量的坐标)，所以向量变换前后，必然会引起“有序数字列表的变换”，那么我们是否可以用数字去描述变换呢？\n\n之前在向量一节中，我们了解过*基向量*，单位长度为1，其实空间中的任意一个向量我们都可以看做是：*基向量变换后的和向量*，如下图：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transformhe.png?imageView/2/w/500)\n\n向量 <b>v</b> 的坐标是 ![](http://7xlolm.com1.z0.glb.clouddn.com/transformzuobiao.png?imageView/2/w/50)，如果我们把 `3` 和 `-2` 看做两个标量，也就是纯数字，那么向量  <b>v</b> 可以看做是基向量被标量缩放后相加得到的和向量： <b>v</b> = 3<b>i</b> + (-2<b>j</b>)\n\n了解了这些，我们现在就通过一个例子，来认识一个至关重要的事实，假如我们有向量 <b>v</b> = -1<b>i</b> + 2<b>j</b>，如下图：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transformqian.png?imageView/2/w/500)\n\n此时，基向量 <b>i</b> 的坐标是 `(1, 0)`【注意：为了方便，这里就用圆括号代表向量的坐标，下同】，基向量 <b>j</b> 的坐标是 `(0, 1)`，假设经过了某些变换之后，基向量 <b>i</b> 的坐标变为 `(1， -2)`，基向量 <b>j</b> 的坐标变为 `(3， 0)`，如下图：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transformhou.png?imageView/2/w/500)\n\n那么变换后的向量 <b>v</b> 依然满足 <b>v</b> = -1<b>i</b> + 2<b>j</b>，如下：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transformhou-plus.png?imageView/2/w/500)\n\n以上例子所描述的事实，实际上是线性变换的性质的推论，该性质可以从几何角度表述为：线性变换后的网格平行且等距。\n\n既然线性变换前后都满足该线性关系：<b>v</b> = -1<b>i</b> + 2<b>j</b>\n\n那么很容易根据变换后 `i帽` 和 `j帽` 的坐标推算出变换后 <b>v</b> 的坐标：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transformjisuan.png?imageView/2/w/500)\n\n也就是 `(5, 2)`，即：![](http://7xlolm.com1.z0.glb.clouddn.com/transformzuobiao2.png?imageView/2/w/50)\n\n那么我们是否可以认为，给定任意一个向量，其坐标 `(x, y)`，我们可以通过变换后的基向量的坐标推断出该向量变换后的坐标呢？答案是肯定的，假如基向量变换后的坐标 `i帽` 和 `j帽` 如下图：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transformbianhuan2.png?imageView/2/w/200)\n\n那么任意向量 `(x, y)` 在经过变换后的坐标计算如下：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transformzuobiao3.png?imageView/2/w/300)\n\n这告诉我们另外一个事实，<b>二维空间的线性变换仅由四个数字完全确定</b>，这四个数字就是基向量 <b>i</b> 变换后 <b>i帽</b> 的坐标，以及基向量 <b>j</b> 变换后 <b>j帽</b> 的坐标，如下图：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transformaaafuck.png?imageView/2/w/500)\n\n是不是很酷？只需要四个数字，我们就确定了二维空间的一个变换。通常，我们把这四个数字放到一个 `2 x 2` 的格子中，我们称之为 `2 x 2` 矩阵：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transformjuzhen.png?imageView/2/w/500)\n\n现在，当你再看到 `2 x 2` 矩阵的时候，你的第一几何直观反映应该是：它描述了一个二维空间的变换。\n\n我们把情况一般化，如下图：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transformyiban.png?imageView/2/w/500)\n\n我们有一个 `2 x 2` 的矩阵 `[a, c] [b, d]`，其中 `[a, c]` 是基向量 <b>i</b> 变换后的坐标，`[b, d]` 是基向量 <b>j</b> 变换后的坐标，那么根据这个变换，以及线性变换的性质，我们可以推断出任意向量 `[x, y]` 变换后的坐标：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transformyuanyin.png?imageView/2/w/400)\n\n<p class=\"tip\">\n实际上，这就是数学家之所以这样定义 矩阵的向量乘法 的原因。\n</p>\n\n到了这里，让我们整理一下思路，首先，对于一个 `2 x 2` 的矩阵，你的直观几何感受应该是，第一列的两个数是对基向量 <b>i</b> 的变换，第二列的两个数是对基向量 <b>j</b> 的变换，这四个数字组成的 `2 x 2` 的矩阵，描述了一个对空间的线性变换，我们可以根据这个变换推断出任意一点(或者任意向量)变换后的坐标。\n\n其实我么你还可以换一个角度考虑，我们就单纯的把 `2 x 2` 矩阵叫做变换，那么向量与矩阵的乘积，就要可以看做是该向量应用了这个变换。其实，这就是矩阵向量乘法的几何意义。\n\n## 回到 CSS 的 transform\n\n说了一大堆，是时候回到 `CSS` 的 `transform`，我们来看一下2D变换下 `transform` 属性的 `matrix` 写法：\n\n```css\ntransform: matrix(a, b, c, d, e, f);\n```\n\n在文章开始，我们知道各个参数默认值如下：\n\n```css\ntransform: matrix(1, 0, 0, 1, 0, 0);\n```\n\n有的同学可能会问：说好的 `2 x 2` 矩阵也就是四个数字就能确定一个二维空间变换，你这里明明有6个数啊，其实，`transform` 2D变换是一个 `3 * 3` 的矩阵，为什么是这样？因为：*位移(translate)*，前面我们说过，线性变换要满足其中一个特点：原点不能移动，但是位移却使原点发生了移动，所以 `2 x 2` 矩阵满足不了需求，只能再加一列，也就是 `3 x 3` 的矩阵。\n\n把 `matrix` 中的 `a b c d e f` 放到一个 `3 x 3` 的矩阵中应该是这样的：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transformmr1.png?imageView/2/w/200)\n\n其实，在没有`位移(translate)`的情况下，`[a, b] [c, d]` 四个数字组成的 `2 x 2` 矩阵是完全可以描述2D变换的，现在我们只看由 `[a, b] [c, d]` 组成的 `2 x 2` 矩阵：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transformmr2.png?imageView/2/w/100)\n\n我们把 `a b c d` 四个数字使用默认值替换一下，即：`a = 1`，`b = 0`，`c = 0`，`d = 1`，如下：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transformmr3.png?imageView/2/w/100)\n\n通过之前的介绍，我们在看到这个矩阵的时候，应该知道，第一列的坐标 `(1, 0)` 应该是基向量 <b>i</b> 变换后的坐标，但是基向量 <b>i</b> 在变换前的坐标就是 `(1, 0)`，也就是说没有任何变换，同理，基向量 <b>j</b> 也没有任何变换，所以说，这就是 `a b c d` 默认值设定为下面代码所示的值的原因：\n\n```css\ntransform: matrix(a, b, c, d, e, f);\n// a b c d 默认值为 1 0 0 1\ntransform: matrix(1, 0, 0, 1, e, f);\n```\n\n那么大家想想一下，我们把 `a` 的值从 `1` 变为 `2` 会发生什么？如果把 `a` 的值从 `1` 变为 `2` 那么矩阵如下：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transformmr4.png?imageView/2/w/100)\n\n也就是说，基向量 <b>i</b> 的坐标从 `(1, 0)` 变成了 `(2, 0)`，这是在干什么？是不是基向量 <b>i</b> 被放大为了原来的二倍？举一个通俗的例子：原本单位长度1代表20px，被放大后单位长度1则代表40px。同样的，当我们把 `a` 的值从 `1` 变为 `0.5` 则意味着把基向量 <b>i</b> 缩小为原来的一半。事实上：在 `transform: matrix()` 中，修改 `a` 的值，就是在改变 `x` 轴方向的缩放比例：\n\n```css\ntransform: matrix(2, 0, 0, 1, 0, 0);\n/* 等价于 */\ntransform: scaleX(2);\n```\n\n相信大家已经知道了，修改 `d` 的值，就是改变 `y` 轴的缩放比例：\n\n```css\ntransform: matrix(1, 0, 0, 4, 0, 0);\n/* 等价于 */\ntransform: scaleY(4);\n```\n\n那么旋转要如何修改 `matrix` 中的值呢？其实，想要知道如何修改 `a b c d` 的值，只需要知道，旋转后基向量 <b>i</b> 和 <b>j</b> 的坐标就可以了，将旋转后的坐标对号填入就可以得到变换矩阵，下面，我们就来看看如何确定旋转后基向量 <b>i</b> 和 <b>j</b> 的坐标。\n\n我们知道，在 `web` 开发中的坐标系和数学中的坐标系在正方向的选取上不太一致，在大家所熟悉的坐标系中，正方向的选取如下：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transformzbx.png?imageView/2/w/100)\n\n而在 `web` 开发中，坐标系的正方向选取是这样的：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transformzbx2.png?imageView/2/w/100)\n\n假设我们将其顺时针旋转 45 度，如下图：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transformtrans.png?imageView/2/w/300)\n\n假设，上图中我们旋转的是单位向量，那么旋转后单位向量 <b>i</b> 的坐标应该是 `(cosθ, sinθ)`，单位向量 <b>j</b> 的坐标应该是 `(-sinθ, cosθ)`，所以如果用矩阵表示的话，应该是这样的：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transformsanjiao.png?imageView/2/w/200)\n\n如果写到 `matrix` 里，自然就是下面这个样子：\n\n```css\ntransform: matrix(cosθ, sinθ, -sinθ, cosθ, 0, 0)\n```\n\n所以，如果我们要顺时针旋转 45 度，下面两种写法是等价的：\n\n```css\n/*\n * Math.cos(Math.PI / 180 * 45) = 0.707106\n * Math.sin(Math.PI / 180 * 45) = 0.707106\n */\ntransform: matrix(0.707106, 0.707106, -0.707106, 0.707106, 0, 0)\n\n/* 等价于 */\ntransform: rotate(45deg);\n```\n\n通过上面缩放和旋转的例子，我们已经知道了，`2 x 2` 的矩阵确实能够描述二维空间的变换，这也就是矩阵能够操作空间的原因。在 `transform` 中，除了缩放(`scale`)、旋转(`rotate`) 还有倾斜(`skew`)，对于倾斜，类似于我们寻找旋转后基向量的坐标一样，你只需要根据倾斜所定义的变换规则，找到基向量变换后的坐标就可以了，实际上倾斜对应如下规则：\n\n```css\ntransform: matrix(1, tan(θy), tan(θx), 1, 0, 0);\n```\n\n大家自己拿只笔在纸上画一画应该就能搞清楚倾斜在做什么样子的变换。\n\n无论 缩放(`scale`)、旋转(`rotate`) 还是倾斜(`skew`)，他们都不会是原点发生改变，所以使用 `a b c d` 四个数字组成的矩阵完全可以描述，但是不要忘了，我们还有一个 位移(`translate`)，这时，就不得不提到 `e f` 了，我想我不说大家也都知道了，`e f` 分别代表了 `x y` 方向的位移，事实也如大家所想：\n\n```css\ntransform: matrix(1, 0, 0, 1, 100, 200)\n\n/* 等价于 */\ntransform: translateX(100px) translateY(200px);\n```\n\n至此，`transform` 使用 `3 x 3` 矩阵：![](http://7xlolm.com1.z0.glb.clouddn.com/transformmr1.png?imageView/2/w/100) 来描述二维空间变换的方式，以及是如何做到的我们就算讲完了。\n\n除了2D变换，还有3D变换，在 `transform` 中，使用 `4 x 4` 的矩阵描述3D变换，但实际上，三维空间的线性变换只需要一个 `3 x 3` 的矩阵就可以描述了，那么为什么搞了一个 `4 x 4`矩阵呢？实际上这和我们在将二维空间的变换使用 `3 x 3` 矩阵的道理是一样的，那就是位移。\n\n我们来看一下3D变换的 `matrix` 默认值：\n\n```css\ntransform: matrix(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p);\ntransform: matrix(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n```\n\n这十六个数字就是 `4 x 4` 矩阵的 16 个数值：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transform3dmr.png?imageView/2/w/200)\n\n如果换成对应数字，是这样的：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transform3d.png?imageView/2/w/200)\n\n类似于我们讲解 2D 变换一样，其中由 ![](http://7xlolm.com1.z0.glb.clouddn.com/transform3d33.png?imageView/2/w/70) 组成的 `3 x 3` 矩阵用来描述空间的 3D 线性变换，如：`rotateX` `rotateY` `scaleZ` 等等，注意：`rotateZ` 是 2D 变换哦。\n\n而 `m` `n` `o` 则分别用来描述位移：`translateX` `translateY` `translateZ`。\n\n","source":"_posts/2017/05/13/从矩阵与空间操作的关系理解CSS3的transform.md","raw":"title: 从矩阵与空间操作的关系理解CSS3的transform\ndate: 2017-05-13 10:50:27\ncategories:\n- WebFrontEnd\ntags:\n- finger-mover\n- css3\n- transform\n---\n\n前不久开源了一个插件化移动端运动效果库 [finger-mover](https://github.com/HcySunYang/finger-mover)，说到运动效果，不得不提到CSS3的 `transform`，也就是变换。这篇文章概括了在实现 [finger-mover](https://github.com/HcySunYang/finger-mover) 时对 `transform` 的理解与总结。\n\n注：文中的图片多数截取自视频：[线性代数的本质](http://www.bilibili.com/video/av6731067/index_1.html#page=1)，也强烈建议大家系统的观看这套视频。另外如果文中有误请不吝指教。\n\n<!-- more -->\n\n文章结构如下：\n\n```\n* 矩阵\n    * 概述\n* 向量\n    * 什么是向量\n    * 基向量\n* 线性变换\n* 如何用数值描述线性变换？\n* 回到 CSS 的 transform\n```\n\n我不知道大家所理解的矩阵是怎样的，但我所理解的矩阵是：该阵法免疫法术攻击且100%反伤对方随机一个单位（回合制游戏）。\n\n以上描述是在小学时代的理解，现在可能有所不同，慢慢说......\n\n## 矩阵\n\n#### 概述\n\n矩阵，是线性代数中涉及的内容，线性代数在科学领域有很多应用的场景，如下：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transformuse-the-scene.png?imageView/2/w/500)\n\n大部分同学在大学时期应该都学过一本叫做线性代数的书，如果没猜错的话，你们的老师在教学的时候大多都是概念性的灌输，比如矩阵乘法如何运算，加法如何运算，大家只要记住就ok了，但是大部分同学都不理解，*为什么矩阵的乘法要这样算？矩阵乘法的意义是什么？*，特别是我们搞计算机的，如果有做过 2D/3D 变换的同学一定听说过矩阵，比如在前端的CSS中，使用 `transform` 做 2D/3D 的变换，其中就应用到了矩阵的知识，这篇文章并不是一篇数学性质的文章，所以大家不要看了感觉一阵眩晕，这篇文章的目的在于：从矩阵与空间之间的关系讲述：为什么矩阵可以应用在空间操作(变换)。或者用一句大白话：*这玩意儿怎么就能让`div`翻过来，转过去，扭的他爹都不认识他的。*\n\n先看一段 css 代码：\n\n```css\n/* 2D */\ntransform: matrix(1, 0, 0, 1, 0, 0);\n/* 3D */\ntransform: matrix(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n```\n\n上面两行 css 代码其实什么变换都不会做，因为那是变换的默认状态，即没有变换。但是其中使用到了 `matrix`，翻译成中文叫做：矩阵。如果有深入研究过 css 的同学对这两行代码也许不陌生，但是大多数人在使用 `transform` 变换时很少直接使用 `matrix` 矩阵，除非你不想让人看懂你在做些什么鸟变换...，所以更多的时候，我们会使用类似如下语法：\n\n```css\ntransform: translateX(100px) rotateZ(30deg);\n```\n\n如上代码所示，一目了然，要做什么变换大家一看就知道了。但其实，这只是一个语法糖，其底层依然使用的是 `matrix`。\n\n如果想要理解矩阵为何可以应用到 2D/3D 变换，那么只从数值水平的角度理解是不够的，你需要从几何的角度去理解矩阵，这存在着根本性的差异。而这，也就是本篇文章的真正意义。\n\n不过，这需要我们先了解一些必要的基本概念，这些概念至关重要，首先就是向量\n\n## 向量\n\n#### 什么是向量\n\n既然矩阵是线性代数的一部分，那么就不得不提到 *向量*，因为向量是线性代数最基础、最根源的组成部分，所以我们要先搞清楚，向量是什么？我说过，这篇文章不会很“数学”，所以大家不要被吓到。用一句话描述向量是什么：\n\n> 向量：空间中的箭头\n\n这个在大家的印象里应该很好理解，这个箭头由两个因素决定：`方向` 和 `长度`，我们先把目光局限在二维空间下，如图：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transformarrow.png?imageView/2/w/500)\n\n上图中，在一个坐标系中画了四个不同长度和方向的箭头，每个箭头从原点发出，他们代表了二维空间中的四个向量，在线性代数中，向量通常以原点作为起点。\n\n如果你已经理解了“向量是空间中的箭头”这种观点，下面我们再进一步，我们重新用一句话来描述向量：\n\n> 向量：是有序的数字列表\n\n假设大家对坐标系的概念都有所了解，我们还是把目光局限在二维空间，在坐标系中任意选取单位长度，这样我们就能够使用一个一个的刻度来标刻这个坐标系，选取特定的方向为x/y轴的正方向，那么不难看出，每一个向量，都可以用唯一的一个坐标来表示，同样的，坐标系中的每一个坐标都对应着一个唯一的箭头(向量)，如下图：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transformnumber.png?imageView/2/w/500)\n\n在坐标系中，由于坐标通常用来标示一个点，如 `P(2, 8)` 表示点 P 的坐标为 `(2, 8)`，为了区分点和向量，在表示向量时，我们通常把坐标竖着写，然后用一对儿中括号来描述，如上图中的：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transformpoint.png?imageView/2/w/500)\n\n在三维空间也是一样的道理，如下图，我就不做重复的解释，唯一不同的是，每一个向量由 x/y/z 三个数字组成的坐标来表示：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transform3.png?imageView/2/w/500)\n\n对于向量，你只需要知道它是“空间中的箭头”或者“有序的数字列表”这就足够了，怎么样？不难理解吧，我们继续往下看，在坐标系中存在一种特殊的向量，我们称之为 *基向量*。\n\n#### 基向量\n\n基向量，也叫单位向量，是单位长度为1的向量，如下图中：`i帽` 和 `j帽` 就是这个二维坐标系的基向量：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transformji-xl.png?imageView/2/w/500)\n\n对于向量，我们就先介绍到这里，这已经足够了。除了向量，还有一个概念需要大家了解，即线性变换。\n\n## 线性变换\n\n“变换”本质上是“函数”的一种花哨的叫法，玩编程的都知道函数，与在数学中的概念类似，函数接收输入的内容，并输出对应的结果，如图：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transformfunction.png?imageView/2/w/500)\n\n变换也是同样的道理，只不过接收向量作为输入，并输出变换后的向量：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transformtransform.png?imageView/2/w/500)\n\n既然 “变换” 与 “函数” 本质相同，那么为什么叫变换而不叫函数呢？这实际上就暗示了我们，你可以把这个输入输出的过程，看做一个向量从初始状态到最终状态的一个变化过程，如下图：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transforminput-output.png?imageView/2/w/500)\n\n现在，我们把情况宏观一下，目前只讨论一个向量的变换，我们知道，二维空间的一整个平面，可以看做是由无数个向量组成(或者无数个点组成，因为每一个点唯一标识一个向量，所以这里说平面由无数个向量组成)，假如这无数个向量同时做相同的变换，那其实就可以看做是平面的变换，如下图：\n\n变换前：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transformbefore.png?imageView/2/w/500)\n\n变换后：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transformafter.png?imageView/2/w/500)\n\n不过，并非所有变换都叫做线性变换，线性变换必须要满足下面两个条件：\n* 1、直线在变换后仍然为直线，不能有所弯曲\n* 2、原点不能移动\n\n如下变换，就不是一个线性变换，因为直线变成了曲线：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transformwanqu.png?imageView/2/w/500)\n\n## 如何用数值描述线性变换？\n\n在上一小节中我们知道，空间的变换也可以说是向量的变换，而向量在空间中，可以用一组有序的数字列表来表示(即向量的坐标)，所以向量变换前后，必然会引起“有序数字列表的变换”，那么我们是否可以用数字去描述变换呢？\n\n之前在向量一节中，我们了解过*基向量*，单位长度为1，其实空间中的任意一个向量我们都可以看做是：*基向量变换后的和向量*，如下图：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transformhe.png?imageView/2/w/500)\n\n向量 <b>v</b> 的坐标是 ![](http://7xlolm.com1.z0.glb.clouddn.com/transformzuobiao.png?imageView/2/w/50)，如果我们把 `3` 和 `-2` 看做两个标量，也就是纯数字，那么向量  <b>v</b> 可以看做是基向量被标量缩放后相加得到的和向量： <b>v</b> = 3<b>i</b> + (-2<b>j</b>)\n\n了解了这些，我们现在就通过一个例子，来认识一个至关重要的事实，假如我们有向量 <b>v</b> = -1<b>i</b> + 2<b>j</b>，如下图：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transformqian.png?imageView/2/w/500)\n\n此时，基向量 <b>i</b> 的坐标是 `(1, 0)`【注意：为了方便，这里就用圆括号代表向量的坐标，下同】，基向量 <b>j</b> 的坐标是 `(0, 1)`，假设经过了某些变换之后，基向量 <b>i</b> 的坐标变为 `(1， -2)`，基向量 <b>j</b> 的坐标变为 `(3， 0)`，如下图：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transformhou.png?imageView/2/w/500)\n\n那么变换后的向量 <b>v</b> 依然满足 <b>v</b> = -1<b>i</b> + 2<b>j</b>，如下：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transformhou-plus.png?imageView/2/w/500)\n\n以上例子所描述的事实，实际上是线性变换的性质的推论，该性质可以从几何角度表述为：线性变换后的网格平行且等距。\n\n既然线性变换前后都满足该线性关系：<b>v</b> = -1<b>i</b> + 2<b>j</b>\n\n那么很容易根据变换后 `i帽` 和 `j帽` 的坐标推算出变换后 <b>v</b> 的坐标：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transformjisuan.png?imageView/2/w/500)\n\n也就是 `(5, 2)`，即：![](http://7xlolm.com1.z0.glb.clouddn.com/transformzuobiao2.png?imageView/2/w/50)\n\n那么我们是否可以认为，给定任意一个向量，其坐标 `(x, y)`，我们可以通过变换后的基向量的坐标推断出该向量变换后的坐标呢？答案是肯定的，假如基向量变换后的坐标 `i帽` 和 `j帽` 如下图：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transformbianhuan2.png?imageView/2/w/200)\n\n那么任意向量 `(x, y)` 在经过变换后的坐标计算如下：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transformzuobiao3.png?imageView/2/w/300)\n\n这告诉我们另外一个事实，<b>二维空间的线性变换仅由四个数字完全确定</b>，这四个数字就是基向量 <b>i</b> 变换后 <b>i帽</b> 的坐标，以及基向量 <b>j</b> 变换后 <b>j帽</b> 的坐标，如下图：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transformaaafuck.png?imageView/2/w/500)\n\n是不是很酷？只需要四个数字，我们就确定了二维空间的一个变换。通常，我们把这四个数字放到一个 `2 x 2` 的格子中，我们称之为 `2 x 2` 矩阵：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transformjuzhen.png?imageView/2/w/500)\n\n现在，当你再看到 `2 x 2` 矩阵的时候，你的第一几何直观反映应该是：它描述了一个二维空间的变换。\n\n我们把情况一般化，如下图：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transformyiban.png?imageView/2/w/500)\n\n我们有一个 `2 x 2` 的矩阵 `[a, c] [b, d]`，其中 `[a, c]` 是基向量 <b>i</b> 变换后的坐标，`[b, d]` 是基向量 <b>j</b> 变换后的坐标，那么根据这个变换，以及线性变换的性质，我们可以推断出任意向量 `[x, y]` 变换后的坐标：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transformyuanyin.png?imageView/2/w/400)\n\n<p class=\"tip\">\n实际上，这就是数学家之所以这样定义 矩阵的向量乘法 的原因。\n</p>\n\n到了这里，让我们整理一下思路，首先，对于一个 `2 x 2` 的矩阵，你的直观几何感受应该是，第一列的两个数是对基向量 <b>i</b> 的变换，第二列的两个数是对基向量 <b>j</b> 的变换，这四个数字组成的 `2 x 2` 的矩阵，描述了一个对空间的线性变换，我们可以根据这个变换推断出任意一点(或者任意向量)变换后的坐标。\n\n其实我么你还可以换一个角度考虑，我们就单纯的把 `2 x 2` 矩阵叫做变换，那么向量与矩阵的乘积，就要可以看做是该向量应用了这个变换。其实，这就是矩阵向量乘法的几何意义。\n\n## 回到 CSS 的 transform\n\n说了一大堆，是时候回到 `CSS` 的 `transform`，我们来看一下2D变换下 `transform` 属性的 `matrix` 写法：\n\n```css\ntransform: matrix(a, b, c, d, e, f);\n```\n\n在文章开始，我们知道各个参数默认值如下：\n\n```css\ntransform: matrix(1, 0, 0, 1, 0, 0);\n```\n\n有的同学可能会问：说好的 `2 x 2` 矩阵也就是四个数字就能确定一个二维空间变换，你这里明明有6个数啊，其实，`transform` 2D变换是一个 `3 * 3` 的矩阵，为什么是这样？因为：*位移(translate)*，前面我们说过，线性变换要满足其中一个特点：原点不能移动，但是位移却使原点发生了移动，所以 `2 x 2` 矩阵满足不了需求，只能再加一列，也就是 `3 x 3` 的矩阵。\n\n把 `matrix` 中的 `a b c d e f` 放到一个 `3 x 3` 的矩阵中应该是这样的：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transformmr1.png?imageView/2/w/200)\n\n其实，在没有`位移(translate)`的情况下，`[a, b] [c, d]` 四个数字组成的 `2 x 2` 矩阵是完全可以描述2D变换的，现在我们只看由 `[a, b] [c, d]` 组成的 `2 x 2` 矩阵：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transformmr2.png?imageView/2/w/100)\n\n我们把 `a b c d` 四个数字使用默认值替换一下，即：`a = 1`，`b = 0`，`c = 0`，`d = 1`，如下：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transformmr3.png?imageView/2/w/100)\n\n通过之前的介绍，我们在看到这个矩阵的时候，应该知道，第一列的坐标 `(1, 0)` 应该是基向量 <b>i</b> 变换后的坐标，但是基向量 <b>i</b> 在变换前的坐标就是 `(1, 0)`，也就是说没有任何变换，同理，基向量 <b>j</b> 也没有任何变换，所以说，这就是 `a b c d` 默认值设定为下面代码所示的值的原因：\n\n```css\ntransform: matrix(a, b, c, d, e, f);\n// a b c d 默认值为 1 0 0 1\ntransform: matrix(1, 0, 0, 1, e, f);\n```\n\n那么大家想想一下，我们把 `a` 的值从 `1` 变为 `2` 会发生什么？如果把 `a` 的值从 `1` 变为 `2` 那么矩阵如下：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transformmr4.png?imageView/2/w/100)\n\n也就是说，基向量 <b>i</b> 的坐标从 `(1, 0)` 变成了 `(2, 0)`，这是在干什么？是不是基向量 <b>i</b> 被放大为了原来的二倍？举一个通俗的例子：原本单位长度1代表20px，被放大后单位长度1则代表40px。同样的，当我们把 `a` 的值从 `1` 变为 `0.5` 则意味着把基向量 <b>i</b> 缩小为原来的一半。事实上：在 `transform: matrix()` 中，修改 `a` 的值，就是在改变 `x` 轴方向的缩放比例：\n\n```css\ntransform: matrix(2, 0, 0, 1, 0, 0);\n/* 等价于 */\ntransform: scaleX(2);\n```\n\n相信大家已经知道了，修改 `d` 的值，就是改变 `y` 轴的缩放比例：\n\n```css\ntransform: matrix(1, 0, 0, 4, 0, 0);\n/* 等价于 */\ntransform: scaleY(4);\n```\n\n那么旋转要如何修改 `matrix` 中的值呢？其实，想要知道如何修改 `a b c d` 的值，只需要知道，旋转后基向量 <b>i</b> 和 <b>j</b> 的坐标就可以了，将旋转后的坐标对号填入就可以得到变换矩阵，下面，我们就来看看如何确定旋转后基向量 <b>i</b> 和 <b>j</b> 的坐标。\n\n我们知道，在 `web` 开发中的坐标系和数学中的坐标系在正方向的选取上不太一致，在大家所熟悉的坐标系中，正方向的选取如下：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transformzbx.png?imageView/2/w/100)\n\n而在 `web` 开发中，坐标系的正方向选取是这样的：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transformzbx2.png?imageView/2/w/100)\n\n假设我们将其顺时针旋转 45 度，如下图：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transformtrans.png?imageView/2/w/300)\n\n假设，上图中我们旋转的是单位向量，那么旋转后单位向量 <b>i</b> 的坐标应该是 `(cosθ, sinθ)`，单位向量 <b>j</b> 的坐标应该是 `(-sinθ, cosθ)`，所以如果用矩阵表示的话，应该是这样的：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transformsanjiao.png?imageView/2/w/200)\n\n如果写到 `matrix` 里，自然就是下面这个样子：\n\n```css\ntransform: matrix(cosθ, sinθ, -sinθ, cosθ, 0, 0)\n```\n\n所以，如果我们要顺时针旋转 45 度，下面两种写法是等价的：\n\n```css\n/*\n * Math.cos(Math.PI / 180 * 45) = 0.707106\n * Math.sin(Math.PI / 180 * 45) = 0.707106\n */\ntransform: matrix(0.707106, 0.707106, -0.707106, 0.707106, 0, 0)\n\n/* 等价于 */\ntransform: rotate(45deg);\n```\n\n通过上面缩放和旋转的例子，我们已经知道了，`2 x 2` 的矩阵确实能够描述二维空间的变换，这也就是矩阵能够操作空间的原因。在 `transform` 中，除了缩放(`scale`)、旋转(`rotate`) 还有倾斜(`skew`)，对于倾斜，类似于我们寻找旋转后基向量的坐标一样，你只需要根据倾斜所定义的变换规则，找到基向量变换后的坐标就可以了，实际上倾斜对应如下规则：\n\n```css\ntransform: matrix(1, tan(θy), tan(θx), 1, 0, 0);\n```\n\n大家自己拿只笔在纸上画一画应该就能搞清楚倾斜在做什么样子的变换。\n\n无论 缩放(`scale`)、旋转(`rotate`) 还是倾斜(`skew`)，他们都不会是原点发生改变，所以使用 `a b c d` 四个数字组成的矩阵完全可以描述，但是不要忘了，我们还有一个 位移(`translate`)，这时，就不得不提到 `e f` 了，我想我不说大家也都知道了，`e f` 分别代表了 `x y` 方向的位移，事实也如大家所想：\n\n```css\ntransform: matrix(1, 0, 0, 1, 100, 200)\n\n/* 等价于 */\ntransform: translateX(100px) translateY(200px);\n```\n\n至此，`transform` 使用 `3 x 3` 矩阵：![](http://7xlolm.com1.z0.glb.clouddn.com/transformmr1.png?imageView/2/w/100) 来描述二维空间变换的方式，以及是如何做到的我们就算讲完了。\n\n除了2D变换，还有3D变换，在 `transform` 中，使用 `4 x 4` 的矩阵描述3D变换，但实际上，三维空间的线性变换只需要一个 `3 x 3` 的矩阵就可以描述了，那么为什么搞了一个 `4 x 4`矩阵呢？实际上这和我们在将二维空间的变换使用 `3 x 3` 矩阵的道理是一样的，那就是位移。\n\n我们来看一下3D变换的 `matrix` 默认值：\n\n```css\ntransform: matrix(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p);\ntransform: matrix(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n```\n\n这十六个数字就是 `4 x 4` 矩阵的 16 个数值：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transform3dmr.png?imageView/2/w/200)\n\n如果换成对应数字，是这样的：\n\n![](http://7xlolm.com1.z0.glb.clouddn.com/transform3d.png?imageView/2/w/200)\n\n类似于我们讲解 2D 变换一样，其中由 ![](http://7xlolm.com1.z0.glb.clouddn.com/transform3d33.png?imageView/2/w/70) 组成的 `3 x 3` 矩阵用来描述空间的 3D 线性变换，如：`rotateX` `rotateY` `scaleZ` 等等，注意：`rotateZ` 是 2D 变换哦。\n\n而 `m` `n` `o` 则分别用来描述位移：`translateX` `translateY` `translateZ`。\n\n","slug":"从矩阵与空间操作的关系理解CSS3的transform","published":1,"updated":"2017-05-13T03:59:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj669fskk001yewfcpri173b8","content":"<p>前不久开源了一个插件化移动端运动效果库 <a href=\"https://github.com/HcySunYang/finger-mover\" target=\"_blank\" rel=\"external\">finger-mover</a>，说到运动效果，不得不提到CSS3的 <code>transform</code>，也就是变换。这篇文章概括了在实现 <a href=\"https://github.com/HcySunYang/finger-mover\" target=\"_blank\" rel=\"external\">finger-mover</a> 时对 <code>transform</code> 的理解与总结。</p>\n<p>注：文中的图片多数截取自视频：<a href=\"http://www.bilibili.com/video/av6731067/index_1.html#page=1\" target=\"_blank\" rel=\"external\">线性代数的本质</a>，也强烈建议大家系统的观看这套视频。另外如果文中有误请不吝指教。</p>\n<a id=\"more\"></a>\n<p>文章结构如下：</p>\n<pre><code>* 矩阵\n    * 概述\n* 向量\n    * 什么是向量\n    * 基向量\n* 线性变换\n* 如何用数值描述线性变换？\n* 回到 CSS 的 transform\n</code></pre><p>我不知道大家所理解的矩阵是怎样的，但我所理解的矩阵是：该阵法免疫法术攻击且100%反伤对方随机一个单位（回合制游戏）。</p>\n<p>以上描述是在小学时代的理解，现在可能有所不同，慢慢说……</p>\n<h2 id=\"矩阵\"><a href=\"#矩阵\" class=\"headerlink\" title=\"矩阵\"></a>矩阵</h2><h4 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h4><p>矩阵，是线性代数中涉及的内容，线性代数在科学领域有很多应用的场景，如下：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformuse-the-scene.png?imageView/2/w/500\" alt=\"\"></p>\n<p>大部分同学在大学时期应该都学过一本叫做线性代数的书，如果没猜错的话，你们的老师在教学的时候大多都是概念性的灌输，比如矩阵乘法如何运算，加法如何运算，大家只要记住就ok了，但是大部分同学都不理解，<em>为什么矩阵的乘法要这样算？矩阵乘法的意义是什么？</em>，特别是我们搞计算机的，如果有做过 2D/3D 变换的同学一定听说过矩阵，比如在前端的CSS中，使用 <code>transform</code> 做 2D/3D 的变换，其中就应用到了矩阵的知识，这篇文章并不是一篇数学性质的文章，所以大家不要看了感觉一阵眩晕，这篇文章的目的在于：从矩阵与空间之间的关系讲述：为什么矩阵可以应用在空间操作(变换)。或者用一句大白话：<em>这玩意儿怎么就能让<code>div</code>翻过来，转过去，扭的他爹都不认识他的。</em></p>\n<p>先看一段 css 代码：</p>\n<pre><code class=\"css\">/* 2D */\ntransform: matrix(1, 0, 0, 1, 0, 0);\n/* 3D */\ntransform: matrix(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n</code></pre>\n<p>上面两行 css 代码其实什么变换都不会做，因为那是变换的默认状态，即没有变换。但是其中使用到了 <code>matrix</code>，翻译成中文叫做：矩阵。如果有深入研究过 css 的同学对这两行代码也许不陌生，但是大多数人在使用 <code>transform</code> 变换时很少直接使用 <code>matrix</code> 矩阵，除非你不想让人看懂你在做些什么鸟变换…，所以更多的时候，我们会使用类似如下语法：</p>\n<pre><code class=\"css\">transform: translateX(100px) rotateZ(30deg);\n</code></pre>\n<p>如上代码所示，一目了然，要做什么变换大家一看就知道了。但其实，这只是一个语法糖，其底层依然使用的是 <code>matrix</code>。</p>\n<p>如果想要理解矩阵为何可以应用到 2D/3D 变换，那么只从数值水平的角度理解是不够的，你需要从几何的角度去理解矩阵，这存在着根本性的差异。而这，也就是本篇文章的真正意义。</p>\n<p>不过，这需要我们先了解一些必要的基本概念，这些概念至关重要，首先就是向量</p>\n<h2 id=\"向量\"><a href=\"#向量\" class=\"headerlink\" title=\"向量\"></a>向量</h2><h4 id=\"什么是向量\"><a href=\"#什么是向量\" class=\"headerlink\" title=\"什么是向量\"></a>什么是向量</h4><p>既然矩阵是线性代数的一部分，那么就不得不提到 <em>向量</em>，因为向量是线性代数最基础、最根源的组成部分，所以我们要先搞清楚，向量是什么？我说过，这篇文章不会很“数学”，所以大家不要被吓到。用一句话描述向量是什么：</p>\n<blockquote>\n<p>向量：空间中的箭头</p>\n</blockquote>\n<p>这个在大家的印象里应该很好理解，这个箭头由两个因素决定：<code>方向</code> 和 <code>长度</code>，我们先把目光局限在二维空间下，如图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformarrow.png?imageView/2/w/500\" alt=\"\"></p>\n<p>上图中，在一个坐标系中画了四个不同长度和方向的箭头，每个箭头从原点发出，他们代表了二维空间中的四个向量，在线性代数中，向量通常以原点作为起点。</p>\n<p>如果你已经理解了“向量是空间中的箭头”这种观点，下面我们再进一步，我们重新用一句话来描述向量：</p>\n<blockquote>\n<p>向量：是有序的数字列表</p>\n</blockquote>\n<p>假设大家对坐标系的概念都有所了解，我们还是把目光局限在二维空间，在坐标系中任意选取单位长度，这样我们就能够使用一个一个的刻度来标刻这个坐标系，选取特定的方向为x/y轴的正方向，那么不难看出，每一个向量，都可以用唯一的一个坐标来表示，同样的，坐标系中的每一个坐标都对应着一个唯一的箭头(向量)，如下图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformnumber.png?imageView/2/w/500\" alt=\"\"></p>\n<p>在坐标系中，由于坐标通常用来标示一个点，如 <code>P(2, 8)</code> 表示点 P 的坐标为 <code>(2, 8)</code>，为了区分点和向量，在表示向量时，我们通常把坐标竖着写，然后用一对儿中括号来描述，如上图中的：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformpoint.png?imageView/2/w/500\" alt=\"\"></p>\n<p>在三维空间也是一样的道理，如下图，我就不做重复的解释，唯一不同的是，每一个向量由 x/y/z 三个数字组成的坐标来表示：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transform3.png?imageView/2/w/500\" alt=\"\"></p>\n<p>对于向量，你只需要知道它是“空间中的箭头”或者“有序的数字列表”这就足够了，怎么样？不难理解吧，我们继续往下看，在坐标系中存在一种特殊的向量，我们称之为 <em>基向量</em>。</p>\n<h4 id=\"基向量\"><a href=\"#基向量\" class=\"headerlink\" title=\"基向量\"></a>基向量</h4><p>基向量，也叫单位向量，是单位长度为1的向量，如下图中：<code>i帽</code> 和 <code>j帽</code> 就是这个二维坐标系的基向量：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformji-xl.png?imageView/2/w/500\" alt=\"\"></p>\n<p>对于向量，我们就先介绍到这里，这已经足够了。除了向量，还有一个概念需要大家了解，即线性变换。</p>\n<h2 id=\"线性变换\"><a href=\"#线性变换\" class=\"headerlink\" title=\"线性变换\"></a>线性变换</h2><p>“变换”本质上是“函数”的一种花哨的叫法，玩编程的都知道函数，与在数学中的概念类似，函数接收输入的内容，并输出对应的结果，如图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformfunction.png?imageView/2/w/500\" alt=\"\"></p>\n<p>变换也是同样的道理，只不过接收向量作为输入，并输出变换后的向量：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformtransform.png?imageView/2/w/500\" alt=\"\"></p>\n<p>既然 “变换” 与 “函数” 本质相同，那么为什么叫变换而不叫函数呢？这实际上就暗示了我们，你可以把这个输入输出的过程，看做一个向量从初始状态到最终状态的一个变化过程，如下图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transforminput-output.png?imageView/2/w/500\" alt=\"\"></p>\n<p>现在，我们把情况宏观一下，目前只讨论一个向量的变换，我们知道，二维空间的一整个平面，可以看做是由无数个向量组成(或者无数个点组成，因为每一个点唯一标识一个向量，所以这里说平面由无数个向量组成)，假如这无数个向量同时做相同的变换，那其实就可以看做是平面的变换，如下图：</p>\n<p>变换前：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformbefore.png?imageView/2/w/500\" alt=\"\"></p>\n<p>变换后：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformafter.png?imageView/2/w/500\" alt=\"\"></p>\n<p>不过，并非所有变换都叫做线性变换，线性变换必须要满足下面两个条件：</p>\n<ul>\n<li>1、直线在变换后仍然为直线，不能有所弯曲</li>\n<li>2、原点不能移动</li>\n</ul>\n<p>如下变换，就不是一个线性变换，因为直线变成了曲线：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformwanqu.png?imageView/2/w/500\" alt=\"\"></p>\n<h2 id=\"如何用数值描述线性变换？\"><a href=\"#如何用数值描述线性变换？\" class=\"headerlink\" title=\"如何用数值描述线性变换？\"></a>如何用数值描述线性变换？</h2><p>在上一小节中我们知道，空间的变换也可以说是向量的变换，而向量在空间中，可以用一组有序的数字列表来表示(即向量的坐标)，所以向量变换前后，必然会引起“有序数字列表的变换”，那么我们是否可以用数字去描述变换呢？</p>\n<p>之前在向量一节中，我们了解过<em>基向量</em>，单位长度为1，其实空间中的任意一个向量我们都可以看做是：<em>基向量变换后的和向量</em>，如下图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformhe.png?imageView/2/w/500\" alt=\"\"></p>\n<p>向量 <b>v</b> 的坐标是 <img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformzuobiao.png?imageView/2/w/50\" alt=\"\">，如果我们把 <code>3</code> 和 <code>-2</code> 看做两个标量，也就是纯数字，那么向量  <b>v</b> 可以看做是基向量被标量缩放后相加得到的和向量： <b>v</b> = 3<b>i</b> + (-2<b>j</b>)</p>\n<p>了解了这些，我们现在就通过一个例子，来认识一个至关重要的事实，假如我们有向量 <b>v</b> = -1<b>i</b> + 2<b>j</b>，如下图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformqian.png?imageView/2/w/500\" alt=\"\"></p>\n<p>此时，基向量 <b>i</b> 的坐标是 <code>(1, 0)</code>【注意：为了方便，这里就用圆括号代表向量的坐标，下同】，基向量 <b>j</b> 的坐标是 <code>(0, 1)</code>，假设经过了某些变换之后，基向量 <b>i</b> 的坐标变为 <code>(1， -2)</code>，基向量 <b>j</b> 的坐标变为 <code>(3， 0)</code>，如下图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformhou.png?imageView/2/w/500\" alt=\"\"></p>\n<p>那么变换后的向量 <b>v</b> 依然满足 <b>v</b> = -1<b>i</b> + 2<b>j</b>，如下：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformhou-plus.png?imageView/2/w/500\" alt=\"\"></p>\n<p>以上例子所描述的事实，实际上是线性变换的性质的推论，该性质可以从几何角度表述为：线性变换后的网格平行且等距。</p>\n<p>既然线性变换前后都满足该线性关系：<b>v</b> = -1<b>i</b> + 2<b>j</b></p>\n<p>那么很容易根据变换后 <code>i帽</code> 和 <code>j帽</code> 的坐标推算出变换后 <b>v</b> 的坐标：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformjisuan.png?imageView/2/w/500\" alt=\"\"></p>\n<p>也就是 <code>(5, 2)</code>，即：<img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformzuobiao2.png?imageView/2/w/50\" alt=\"\"></p>\n<p>那么我们是否可以认为，给定任意一个向量，其坐标 <code>(x, y)</code>，我们可以通过变换后的基向量的坐标推断出该向量变换后的坐标呢？答案是肯定的，假如基向量变换后的坐标 <code>i帽</code> 和 <code>j帽</code> 如下图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformbianhuan2.png?imageView/2/w/200\" alt=\"\"></p>\n<p>那么任意向量 <code>(x, y)</code> 在经过变换后的坐标计算如下：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformzuobiao3.png?imageView/2/w/300\" alt=\"\"></p>\n<p>这告诉我们另外一个事实，<b>二维空间的线性变换仅由四个数字完全确定</b>，这四个数字就是基向量 <b>i</b> 变换后 <b>i帽</b> 的坐标，以及基向量 <b>j</b> 变换后 <b>j帽</b> 的坐标，如下图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformaaafuck.png?imageView/2/w/500\" alt=\"\"></p>\n<p>是不是很酷？只需要四个数字，我们就确定了二维空间的一个变换。通常，我们把这四个数字放到一个 <code>2 x 2</code> 的格子中，我们称之为 <code>2 x 2</code> 矩阵：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformjuzhen.png?imageView/2/w/500\" alt=\"\"></p>\n<p>现在，当你再看到 <code>2 x 2</code> 矩阵的时候，你的第一几何直观反映应该是：它描述了一个二维空间的变换。</p>\n<p>我们把情况一般化，如下图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformyiban.png?imageView/2/w/500\" alt=\"\"></p>\n<p>我们有一个 <code>2 x 2</code> 的矩阵 <code>[a, c] [b, d]</code>，其中 <code>[a, c]</code> 是基向量 <b>i</b> 变换后的坐标，<code>[b, d]</code> 是基向量 <b>j</b> 变换后的坐标，那么根据这个变换，以及线性变换的性质，我们可以推断出任意向量 <code>[x, y]</code> 变换后的坐标：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformyuanyin.png?imageView/2/w/400\" alt=\"\"></p>\n<p class=\"tip\"><br>实际上，这就是数学家之所以这样定义 矩阵的向量乘法 的原因。<br></p>\n\n<p>到了这里，让我们整理一下思路，首先，对于一个 <code>2 x 2</code> 的矩阵，你的直观几何感受应该是，第一列的两个数是对基向量 <b>i</b> 的变换，第二列的两个数是对基向量 <b>j</b> 的变换，这四个数字组成的 <code>2 x 2</code> 的矩阵，描述了一个对空间的线性变换，我们可以根据这个变换推断出任意一点(或者任意向量)变换后的坐标。</p>\n<p>其实我么你还可以换一个角度考虑，我们就单纯的把 <code>2 x 2</code> 矩阵叫做变换，那么向量与矩阵的乘积，就要可以看做是该向量应用了这个变换。其实，这就是矩阵向量乘法的几何意义。</p>\n<h2 id=\"回到-CSS-的-transform\"><a href=\"#回到-CSS-的-transform\" class=\"headerlink\" title=\"回到 CSS 的 transform\"></a>回到 CSS 的 transform</h2><p>说了一大堆，是时候回到 <code>CSS</code> 的 <code>transform</code>，我们来看一下2D变换下 <code>transform</code> 属性的 <code>matrix</code> 写法：</p>\n<pre><code class=\"css\">transform: matrix(a, b, c, d, e, f);\n</code></pre>\n<p>在文章开始，我们知道各个参数默认值如下：</p>\n<pre><code class=\"css\">transform: matrix(1, 0, 0, 1, 0, 0);\n</code></pre>\n<p>有的同学可能会问：说好的 <code>2 x 2</code> 矩阵也就是四个数字就能确定一个二维空间变换，你这里明明有6个数啊，其实，<code>transform</code> 2D变换是一个 <code>3 * 3</code> 的矩阵，为什么是这样？因为：<em>位移(translate)</em>，前面我们说过，线性变换要满足其中一个特点：原点不能移动，但是位移却使原点发生了移动，所以 <code>2 x 2</code> 矩阵满足不了需求，只能再加一列，也就是 <code>3 x 3</code> 的矩阵。</p>\n<p>把 <code>matrix</code> 中的 <code>a b c d e f</code> 放到一个 <code>3 x 3</code> 的矩阵中应该是这样的：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformmr1.png?imageView/2/w/200\" alt=\"\"></p>\n<p>其实，在没有<code>位移(translate)</code>的情况下，<code>[a, b] [c, d]</code> 四个数字组成的 <code>2 x 2</code> 矩阵是完全可以描述2D变换的，现在我们只看由 <code>[a, b] [c, d]</code> 组成的 <code>2 x 2</code> 矩阵：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformmr2.png?imageView/2/w/100\" alt=\"\"></p>\n<p>我们把 <code>a b c d</code> 四个数字使用默认值替换一下，即：<code>a = 1</code>，<code>b = 0</code>，<code>c = 0</code>，<code>d = 1</code>，如下：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformmr3.png?imageView/2/w/100\" alt=\"\"></p>\n<p>通过之前的介绍，我们在看到这个矩阵的时候，应该知道，第一列的坐标 <code>(1, 0)</code> 应该是基向量 <b>i</b> 变换后的坐标，但是基向量 <b>i</b> 在变换前的坐标就是 <code>(1, 0)</code>，也就是说没有任何变换，同理，基向量 <b>j</b> 也没有任何变换，所以说，这就是 <code>a b c d</code> 默认值设定为下面代码所示的值的原因：</p>\n<pre><code class=\"css\">transform: matrix(a, b, c, d, e, f);\n// a b c d 默认值为 1 0 0 1\ntransform: matrix(1, 0, 0, 1, e, f);\n</code></pre>\n<p>那么大家想想一下，我们把 <code>a</code> 的值从 <code>1</code> 变为 <code>2</code> 会发生什么？如果把 <code>a</code> 的值从 <code>1</code> 变为 <code>2</code> 那么矩阵如下：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformmr4.png?imageView/2/w/100\" alt=\"\"></p>\n<p>也就是说，基向量 <b>i</b> 的坐标从 <code>(1, 0)</code> 变成了 <code>(2, 0)</code>，这是在干什么？是不是基向量 <b>i</b> 被放大为了原来的二倍？举一个通俗的例子：原本单位长度1代表20px，被放大后单位长度1则代表40px。同样的，当我们把 <code>a</code> 的值从 <code>1</code> 变为 <code>0.5</code> 则意味着把基向量 <b>i</b> 缩小为原来的一半。事实上：在 <code>transform: matrix()</code> 中，修改 <code>a</code> 的值，就是在改变 <code>x</code> 轴方向的缩放比例：</p>\n<pre><code class=\"css\">transform: matrix(2, 0, 0, 1, 0, 0);\n/* 等价于 */\ntransform: scaleX(2);\n</code></pre>\n<p>相信大家已经知道了，修改 <code>d</code> 的值，就是改变 <code>y</code> 轴的缩放比例：</p>\n<pre><code class=\"css\">transform: matrix(1, 0, 0, 4, 0, 0);\n/* 等价于 */\ntransform: scaleY(4);\n</code></pre>\n<p>那么旋转要如何修改 <code>matrix</code> 中的值呢？其实，想要知道如何修改 <code>a b c d</code> 的值，只需要知道，旋转后基向量 <b>i</b> 和 <b>j</b> 的坐标就可以了，将旋转后的坐标对号填入就可以得到变换矩阵，下面，我们就来看看如何确定旋转后基向量 <b>i</b> 和 <b>j</b> 的坐标。</p>\n<p>我们知道，在 <code>web</code> 开发中的坐标系和数学中的坐标系在正方向的选取上不太一致，在大家所熟悉的坐标系中，正方向的选取如下：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformzbx.png?imageView/2/w/100\" alt=\"\"></p>\n<p>而在 <code>web</code> 开发中，坐标系的正方向选取是这样的：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformzbx2.png?imageView/2/w/100\" alt=\"\"></p>\n<p>假设我们将其顺时针旋转 45 度，如下图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformtrans.png?imageView/2/w/300\" alt=\"\"></p>\n<p>假设，上图中我们旋转的是单位向量，那么旋转后单位向量 <b>i</b> 的坐标应该是 <code>(cosθ, sinθ)</code>，单位向量 <b>j</b> 的坐标应该是 <code>(-sinθ, cosθ)</code>，所以如果用矩阵表示的话，应该是这样的：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformsanjiao.png?imageView/2/w/200\" alt=\"\"></p>\n<p>如果写到 <code>matrix</code> 里，自然就是下面这个样子：</p>\n<pre><code class=\"css\">transform: matrix(cosθ, sinθ, -sinθ, cosθ, 0, 0)\n</code></pre>\n<p>所以，如果我们要顺时针旋转 45 度，下面两种写法是等价的：</p>\n<pre><code class=\"css\">/*\n * Math.cos(Math.PI / 180 * 45) = 0.707106\n * Math.sin(Math.PI / 180 * 45) = 0.707106\n */\ntransform: matrix(0.707106, 0.707106, -0.707106, 0.707106, 0, 0)\n\n/* 等价于 */\ntransform: rotate(45deg);\n</code></pre>\n<p>通过上面缩放和旋转的例子，我们已经知道了，<code>2 x 2</code> 的矩阵确实能够描述二维空间的变换，这也就是矩阵能够操作空间的原因。在 <code>transform</code> 中，除了缩放(<code>scale</code>)、旋转(<code>rotate</code>) 还有倾斜(<code>skew</code>)，对于倾斜，类似于我们寻找旋转后基向量的坐标一样，你只需要根据倾斜所定义的变换规则，找到基向量变换后的坐标就可以了，实际上倾斜对应如下规则：</p>\n<pre><code class=\"css\">transform: matrix(1, tan(θy), tan(θx), 1, 0, 0);\n</code></pre>\n<p>大家自己拿只笔在纸上画一画应该就能搞清楚倾斜在做什么样子的变换。</p>\n<p>无论 缩放(<code>scale</code>)、旋转(<code>rotate</code>) 还是倾斜(<code>skew</code>)，他们都不会是原点发生改变，所以使用 <code>a b c d</code> 四个数字组成的矩阵完全可以描述，但是不要忘了，我们还有一个 位移(<code>translate</code>)，这时，就不得不提到 <code>e f</code> 了，我想我不说大家也都知道了，<code>e f</code> 分别代表了 <code>x y</code> 方向的位移，事实也如大家所想：</p>\n<pre><code class=\"css\">transform: matrix(1, 0, 0, 1, 100, 200)\n\n/* 等价于 */\ntransform: translateX(100px) translateY(200px);\n</code></pre>\n<p>至此，<code>transform</code> 使用 <code>3 x 3</code> 矩阵：<img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformmr1.png?imageView/2/w/100\" alt=\"\"> 来描述二维空间变换的方式，以及是如何做到的我们就算讲完了。</p>\n<p>除了2D变换，还有3D变换，在 <code>transform</code> 中，使用 <code>4 x 4</code> 的矩阵描述3D变换，但实际上，三维空间的线性变换只需要一个 <code>3 x 3</code> 的矩阵就可以描述了，那么为什么搞了一个 <code>4 x 4</code>矩阵呢？实际上这和我们在将二维空间的变换使用 <code>3 x 3</code> 矩阵的道理是一样的，那就是位移。</p>\n<p>我们来看一下3D变换的 <code>matrix</code> 默认值：</p>\n<pre><code class=\"css\">transform: matrix(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p);\ntransform: matrix(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n</code></pre>\n<p>这十六个数字就是 <code>4 x 4</code> 矩阵的 16 个数值：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transform3dmr.png?imageView/2/w/200\" alt=\"\"></p>\n<p>如果换成对应数字，是这样的：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transform3d.png?imageView/2/w/200\" alt=\"\"></p>\n<p>类似于我们讲解 2D 变换一样，其中由 <img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transform3d33.png?imageView/2/w/70\" alt=\"\"> 组成的 <code>3 x 3</code> 矩阵用来描述空间的 3D 线性变换，如：<code>rotateX</code> <code>rotateY</code> <code>scaleZ</code> 等等，注意：<code>rotateZ</code> 是 2D 变换哦。</p>\n<p>而 <code>m</code> <code>n</code> <code>o</code> 则分别用来描述位移：<code>translateX</code> <code>translateY</code> <code>translateZ</code>。</p>\n","site":{"data":{}},"excerpt":"<p>前不久开源了一个插件化移动端运动效果库 <a href=\"https://github.com/HcySunYang/finger-mover\" target=\"_blank\" rel=\"external\">finger-mover</a>，说到运动效果，不得不提到CSS3的 <code>transform</code>，也就是变换。这篇文章概括了在实现 <a href=\"https://github.com/HcySunYang/finger-mover\" target=\"_blank\" rel=\"external\">finger-mover</a> 时对 <code>transform</code> 的理解与总结。</p>\n<p>注：文中的图片多数截取自视频：<a href=\"http://www.bilibili.com/video/av6731067/index_1.html#page=1\" target=\"_blank\" rel=\"external\">线性代数的本质</a>，也强烈建议大家系统的观看这套视频。另外如果文中有误请不吝指教。</p>","more":"<p>文章结构如下：</p>\n<pre><code>* 矩阵\n    * 概述\n* 向量\n    * 什么是向量\n    * 基向量\n* 线性变换\n* 如何用数值描述线性变换？\n* 回到 CSS 的 transform\n</code></pre><p>我不知道大家所理解的矩阵是怎样的，但我所理解的矩阵是：该阵法免疫法术攻击且100%反伤对方随机一个单位（回合制游戏）。</p>\n<p>以上描述是在小学时代的理解，现在可能有所不同，慢慢说……</p>\n<h2 id=\"矩阵\"><a href=\"#矩阵\" class=\"headerlink\" title=\"矩阵\"></a>矩阵</h2><h4 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h4><p>矩阵，是线性代数中涉及的内容，线性代数在科学领域有很多应用的场景，如下：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformuse-the-scene.png?imageView/2/w/500\" alt=\"\"></p>\n<p>大部分同学在大学时期应该都学过一本叫做线性代数的书，如果没猜错的话，你们的老师在教学的时候大多都是概念性的灌输，比如矩阵乘法如何运算，加法如何运算，大家只要记住就ok了，但是大部分同学都不理解，<em>为什么矩阵的乘法要这样算？矩阵乘法的意义是什么？</em>，特别是我们搞计算机的，如果有做过 2D/3D 变换的同学一定听说过矩阵，比如在前端的CSS中，使用 <code>transform</code> 做 2D/3D 的变换，其中就应用到了矩阵的知识，这篇文章并不是一篇数学性质的文章，所以大家不要看了感觉一阵眩晕，这篇文章的目的在于：从矩阵与空间之间的关系讲述：为什么矩阵可以应用在空间操作(变换)。或者用一句大白话：<em>这玩意儿怎么就能让<code>div</code>翻过来，转过去，扭的他爹都不认识他的。</em></p>\n<p>先看一段 css 代码：</p>\n<pre><code class=\"css\">/* 2D */\ntransform: matrix(1, 0, 0, 1, 0, 0);\n/* 3D */\ntransform: matrix(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n</code></pre>\n<p>上面两行 css 代码其实什么变换都不会做，因为那是变换的默认状态，即没有变换。但是其中使用到了 <code>matrix</code>，翻译成中文叫做：矩阵。如果有深入研究过 css 的同学对这两行代码也许不陌生，但是大多数人在使用 <code>transform</code> 变换时很少直接使用 <code>matrix</code> 矩阵，除非你不想让人看懂你在做些什么鸟变换…，所以更多的时候，我们会使用类似如下语法：</p>\n<pre><code class=\"css\">transform: translateX(100px) rotateZ(30deg);\n</code></pre>\n<p>如上代码所示，一目了然，要做什么变换大家一看就知道了。但其实，这只是一个语法糖，其底层依然使用的是 <code>matrix</code>。</p>\n<p>如果想要理解矩阵为何可以应用到 2D/3D 变换，那么只从数值水平的角度理解是不够的，你需要从几何的角度去理解矩阵，这存在着根本性的差异。而这，也就是本篇文章的真正意义。</p>\n<p>不过，这需要我们先了解一些必要的基本概念，这些概念至关重要，首先就是向量</p>\n<h2 id=\"向量\"><a href=\"#向量\" class=\"headerlink\" title=\"向量\"></a>向量</h2><h4 id=\"什么是向量\"><a href=\"#什么是向量\" class=\"headerlink\" title=\"什么是向量\"></a>什么是向量</h4><p>既然矩阵是线性代数的一部分，那么就不得不提到 <em>向量</em>，因为向量是线性代数最基础、最根源的组成部分，所以我们要先搞清楚，向量是什么？我说过，这篇文章不会很“数学”，所以大家不要被吓到。用一句话描述向量是什么：</p>\n<blockquote>\n<p>向量：空间中的箭头</p>\n</blockquote>\n<p>这个在大家的印象里应该很好理解，这个箭头由两个因素决定：<code>方向</code> 和 <code>长度</code>，我们先把目光局限在二维空间下，如图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformarrow.png?imageView/2/w/500\" alt=\"\"></p>\n<p>上图中，在一个坐标系中画了四个不同长度和方向的箭头，每个箭头从原点发出，他们代表了二维空间中的四个向量，在线性代数中，向量通常以原点作为起点。</p>\n<p>如果你已经理解了“向量是空间中的箭头”这种观点，下面我们再进一步，我们重新用一句话来描述向量：</p>\n<blockquote>\n<p>向量：是有序的数字列表</p>\n</blockquote>\n<p>假设大家对坐标系的概念都有所了解，我们还是把目光局限在二维空间，在坐标系中任意选取单位长度，这样我们就能够使用一个一个的刻度来标刻这个坐标系，选取特定的方向为x/y轴的正方向，那么不难看出，每一个向量，都可以用唯一的一个坐标来表示，同样的，坐标系中的每一个坐标都对应着一个唯一的箭头(向量)，如下图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformnumber.png?imageView/2/w/500\" alt=\"\"></p>\n<p>在坐标系中，由于坐标通常用来标示一个点，如 <code>P(2, 8)</code> 表示点 P 的坐标为 <code>(2, 8)</code>，为了区分点和向量，在表示向量时，我们通常把坐标竖着写，然后用一对儿中括号来描述，如上图中的：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformpoint.png?imageView/2/w/500\" alt=\"\"></p>\n<p>在三维空间也是一样的道理，如下图，我就不做重复的解释，唯一不同的是，每一个向量由 x/y/z 三个数字组成的坐标来表示：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transform3.png?imageView/2/w/500\" alt=\"\"></p>\n<p>对于向量，你只需要知道它是“空间中的箭头”或者“有序的数字列表”这就足够了，怎么样？不难理解吧，我们继续往下看，在坐标系中存在一种特殊的向量，我们称之为 <em>基向量</em>。</p>\n<h4 id=\"基向量\"><a href=\"#基向量\" class=\"headerlink\" title=\"基向量\"></a>基向量</h4><p>基向量，也叫单位向量，是单位长度为1的向量，如下图中：<code>i帽</code> 和 <code>j帽</code> 就是这个二维坐标系的基向量：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformji-xl.png?imageView/2/w/500\" alt=\"\"></p>\n<p>对于向量，我们就先介绍到这里，这已经足够了。除了向量，还有一个概念需要大家了解，即线性变换。</p>\n<h2 id=\"线性变换\"><a href=\"#线性变换\" class=\"headerlink\" title=\"线性变换\"></a>线性变换</h2><p>“变换”本质上是“函数”的一种花哨的叫法，玩编程的都知道函数，与在数学中的概念类似，函数接收输入的内容，并输出对应的结果，如图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformfunction.png?imageView/2/w/500\" alt=\"\"></p>\n<p>变换也是同样的道理，只不过接收向量作为输入，并输出变换后的向量：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformtransform.png?imageView/2/w/500\" alt=\"\"></p>\n<p>既然 “变换” 与 “函数” 本质相同，那么为什么叫变换而不叫函数呢？这实际上就暗示了我们，你可以把这个输入输出的过程，看做一个向量从初始状态到最终状态的一个变化过程，如下图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transforminput-output.png?imageView/2/w/500\" alt=\"\"></p>\n<p>现在，我们把情况宏观一下，目前只讨论一个向量的变换，我们知道，二维空间的一整个平面，可以看做是由无数个向量组成(或者无数个点组成，因为每一个点唯一标识一个向量，所以这里说平面由无数个向量组成)，假如这无数个向量同时做相同的变换，那其实就可以看做是平面的变换，如下图：</p>\n<p>变换前：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformbefore.png?imageView/2/w/500\" alt=\"\"></p>\n<p>变换后：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformafter.png?imageView/2/w/500\" alt=\"\"></p>\n<p>不过，并非所有变换都叫做线性变换，线性变换必须要满足下面两个条件：</p>\n<ul>\n<li>1、直线在变换后仍然为直线，不能有所弯曲</li>\n<li>2、原点不能移动</li>\n</ul>\n<p>如下变换，就不是一个线性变换，因为直线变成了曲线：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformwanqu.png?imageView/2/w/500\" alt=\"\"></p>\n<h2 id=\"如何用数值描述线性变换？\"><a href=\"#如何用数值描述线性变换？\" class=\"headerlink\" title=\"如何用数值描述线性变换？\"></a>如何用数值描述线性变换？</h2><p>在上一小节中我们知道，空间的变换也可以说是向量的变换，而向量在空间中，可以用一组有序的数字列表来表示(即向量的坐标)，所以向量变换前后，必然会引起“有序数字列表的变换”，那么我们是否可以用数字去描述变换呢？</p>\n<p>之前在向量一节中，我们了解过<em>基向量</em>，单位长度为1，其实空间中的任意一个向量我们都可以看做是：<em>基向量变换后的和向量</em>，如下图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformhe.png?imageView/2/w/500\" alt=\"\"></p>\n<p>向量 <b>v</b> 的坐标是 <img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformzuobiao.png?imageView/2/w/50\" alt=\"\">，如果我们把 <code>3</code> 和 <code>-2</code> 看做两个标量，也就是纯数字，那么向量  <b>v</b> 可以看做是基向量被标量缩放后相加得到的和向量： <b>v</b> = 3<b>i</b> + (-2<b>j</b>)</p>\n<p>了解了这些，我们现在就通过一个例子，来认识一个至关重要的事实，假如我们有向量 <b>v</b> = -1<b>i</b> + 2<b>j</b>，如下图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformqian.png?imageView/2/w/500\" alt=\"\"></p>\n<p>此时，基向量 <b>i</b> 的坐标是 <code>(1, 0)</code>【注意：为了方便，这里就用圆括号代表向量的坐标，下同】，基向量 <b>j</b> 的坐标是 <code>(0, 1)</code>，假设经过了某些变换之后，基向量 <b>i</b> 的坐标变为 <code>(1， -2)</code>，基向量 <b>j</b> 的坐标变为 <code>(3， 0)</code>，如下图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformhou.png?imageView/2/w/500\" alt=\"\"></p>\n<p>那么变换后的向量 <b>v</b> 依然满足 <b>v</b> = -1<b>i</b> + 2<b>j</b>，如下：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformhou-plus.png?imageView/2/w/500\" alt=\"\"></p>\n<p>以上例子所描述的事实，实际上是线性变换的性质的推论，该性质可以从几何角度表述为：线性变换后的网格平行且等距。</p>\n<p>既然线性变换前后都满足该线性关系：<b>v</b> = -1<b>i</b> + 2<b>j</b></p>\n<p>那么很容易根据变换后 <code>i帽</code> 和 <code>j帽</code> 的坐标推算出变换后 <b>v</b> 的坐标：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformjisuan.png?imageView/2/w/500\" alt=\"\"></p>\n<p>也就是 <code>(5, 2)</code>，即：<img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformzuobiao2.png?imageView/2/w/50\" alt=\"\"></p>\n<p>那么我们是否可以认为，给定任意一个向量，其坐标 <code>(x, y)</code>，我们可以通过变换后的基向量的坐标推断出该向量变换后的坐标呢？答案是肯定的，假如基向量变换后的坐标 <code>i帽</code> 和 <code>j帽</code> 如下图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformbianhuan2.png?imageView/2/w/200\" alt=\"\"></p>\n<p>那么任意向量 <code>(x, y)</code> 在经过变换后的坐标计算如下：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformzuobiao3.png?imageView/2/w/300\" alt=\"\"></p>\n<p>这告诉我们另外一个事实，<b>二维空间的线性变换仅由四个数字完全确定</b>，这四个数字就是基向量 <b>i</b> 变换后 <b>i帽</b> 的坐标，以及基向量 <b>j</b> 变换后 <b>j帽</b> 的坐标，如下图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformaaafuck.png?imageView/2/w/500\" alt=\"\"></p>\n<p>是不是很酷？只需要四个数字，我们就确定了二维空间的一个变换。通常，我们把这四个数字放到一个 <code>2 x 2</code> 的格子中，我们称之为 <code>2 x 2</code> 矩阵：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformjuzhen.png?imageView/2/w/500\" alt=\"\"></p>\n<p>现在，当你再看到 <code>2 x 2</code> 矩阵的时候，你的第一几何直观反映应该是：它描述了一个二维空间的变换。</p>\n<p>我们把情况一般化，如下图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformyiban.png?imageView/2/w/500\" alt=\"\"></p>\n<p>我们有一个 <code>2 x 2</code> 的矩阵 <code>[a, c] [b, d]</code>，其中 <code>[a, c]</code> 是基向量 <b>i</b> 变换后的坐标，<code>[b, d]</code> 是基向量 <b>j</b> 变换后的坐标，那么根据这个变换，以及线性变换的性质，我们可以推断出任意向量 <code>[x, y]</code> 变换后的坐标：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformyuanyin.png?imageView/2/w/400\" alt=\"\"></p>\n<p class=\"tip\"><br>实际上，这就是数学家之所以这样定义 矩阵的向量乘法 的原因。<br></p>\n\n<p>到了这里，让我们整理一下思路，首先，对于一个 <code>2 x 2</code> 的矩阵，你的直观几何感受应该是，第一列的两个数是对基向量 <b>i</b> 的变换，第二列的两个数是对基向量 <b>j</b> 的变换，这四个数字组成的 <code>2 x 2</code> 的矩阵，描述了一个对空间的线性变换，我们可以根据这个变换推断出任意一点(或者任意向量)变换后的坐标。</p>\n<p>其实我么你还可以换一个角度考虑，我们就单纯的把 <code>2 x 2</code> 矩阵叫做变换，那么向量与矩阵的乘积，就要可以看做是该向量应用了这个变换。其实，这就是矩阵向量乘法的几何意义。</p>\n<h2 id=\"回到-CSS-的-transform\"><a href=\"#回到-CSS-的-transform\" class=\"headerlink\" title=\"回到 CSS 的 transform\"></a>回到 CSS 的 transform</h2><p>说了一大堆，是时候回到 <code>CSS</code> 的 <code>transform</code>，我们来看一下2D变换下 <code>transform</code> 属性的 <code>matrix</code> 写法：</p>\n<pre><code class=\"css\">transform: matrix(a, b, c, d, e, f);\n</code></pre>\n<p>在文章开始，我们知道各个参数默认值如下：</p>\n<pre><code class=\"css\">transform: matrix(1, 0, 0, 1, 0, 0);\n</code></pre>\n<p>有的同学可能会问：说好的 <code>2 x 2</code> 矩阵也就是四个数字就能确定一个二维空间变换，你这里明明有6个数啊，其实，<code>transform</code> 2D变换是一个 <code>3 * 3</code> 的矩阵，为什么是这样？因为：<em>位移(translate)</em>，前面我们说过，线性变换要满足其中一个特点：原点不能移动，但是位移却使原点发生了移动，所以 <code>2 x 2</code> 矩阵满足不了需求，只能再加一列，也就是 <code>3 x 3</code> 的矩阵。</p>\n<p>把 <code>matrix</code> 中的 <code>a b c d e f</code> 放到一个 <code>3 x 3</code> 的矩阵中应该是这样的：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformmr1.png?imageView/2/w/200\" alt=\"\"></p>\n<p>其实，在没有<code>位移(translate)</code>的情况下，<code>[a, b] [c, d]</code> 四个数字组成的 <code>2 x 2</code> 矩阵是完全可以描述2D变换的，现在我们只看由 <code>[a, b] [c, d]</code> 组成的 <code>2 x 2</code> 矩阵：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformmr2.png?imageView/2/w/100\" alt=\"\"></p>\n<p>我们把 <code>a b c d</code> 四个数字使用默认值替换一下，即：<code>a = 1</code>，<code>b = 0</code>，<code>c = 0</code>，<code>d = 1</code>，如下：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformmr3.png?imageView/2/w/100\" alt=\"\"></p>\n<p>通过之前的介绍，我们在看到这个矩阵的时候，应该知道，第一列的坐标 <code>(1, 0)</code> 应该是基向量 <b>i</b> 变换后的坐标，但是基向量 <b>i</b> 在变换前的坐标就是 <code>(1, 0)</code>，也就是说没有任何变换，同理，基向量 <b>j</b> 也没有任何变换，所以说，这就是 <code>a b c d</code> 默认值设定为下面代码所示的值的原因：</p>\n<pre><code class=\"css\">transform: matrix(a, b, c, d, e, f);\n// a b c d 默认值为 1 0 0 1\ntransform: matrix(1, 0, 0, 1, e, f);\n</code></pre>\n<p>那么大家想想一下，我们把 <code>a</code> 的值从 <code>1</code> 变为 <code>2</code> 会发生什么？如果把 <code>a</code> 的值从 <code>1</code> 变为 <code>2</code> 那么矩阵如下：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformmr4.png?imageView/2/w/100\" alt=\"\"></p>\n<p>也就是说，基向量 <b>i</b> 的坐标从 <code>(1, 0)</code> 变成了 <code>(2, 0)</code>，这是在干什么？是不是基向量 <b>i</b> 被放大为了原来的二倍？举一个通俗的例子：原本单位长度1代表20px，被放大后单位长度1则代表40px。同样的，当我们把 <code>a</code> 的值从 <code>1</code> 变为 <code>0.5</code> 则意味着把基向量 <b>i</b> 缩小为原来的一半。事实上：在 <code>transform: matrix()</code> 中，修改 <code>a</code> 的值，就是在改变 <code>x</code> 轴方向的缩放比例：</p>\n<pre><code class=\"css\">transform: matrix(2, 0, 0, 1, 0, 0);\n/* 等价于 */\ntransform: scaleX(2);\n</code></pre>\n<p>相信大家已经知道了，修改 <code>d</code> 的值，就是改变 <code>y</code> 轴的缩放比例：</p>\n<pre><code class=\"css\">transform: matrix(1, 0, 0, 4, 0, 0);\n/* 等价于 */\ntransform: scaleY(4);\n</code></pre>\n<p>那么旋转要如何修改 <code>matrix</code> 中的值呢？其实，想要知道如何修改 <code>a b c d</code> 的值，只需要知道，旋转后基向量 <b>i</b> 和 <b>j</b> 的坐标就可以了，将旋转后的坐标对号填入就可以得到变换矩阵，下面，我们就来看看如何确定旋转后基向量 <b>i</b> 和 <b>j</b> 的坐标。</p>\n<p>我们知道，在 <code>web</code> 开发中的坐标系和数学中的坐标系在正方向的选取上不太一致，在大家所熟悉的坐标系中，正方向的选取如下：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformzbx.png?imageView/2/w/100\" alt=\"\"></p>\n<p>而在 <code>web</code> 开发中，坐标系的正方向选取是这样的：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformzbx2.png?imageView/2/w/100\" alt=\"\"></p>\n<p>假设我们将其顺时针旋转 45 度，如下图：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformtrans.png?imageView/2/w/300\" alt=\"\"></p>\n<p>假设，上图中我们旋转的是单位向量，那么旋转后单位向量 <b>i</b> 的坐标应该是 <code>(cosθ, sinθ)</code>，单位向量 <b>j</b> 的坐标应该是 <code>(-sinθ, cosθ)</code>，所以如果用矩阵表示的话，应该是这样的：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformsanjiao.png?imageView/2/w/200\" alt=\"\"></p>\n<p>如果写到 <code>matrix</code> 里，自然就是下面这个样子：</p>\n<pre><code class=\"css\">transform: matrix(cosθ, sinθ, -sinθ, cosθ, 0, 0)\n</code></pre>\n<p>所以，如果我们要顺时针旋转 45 度，下面两种写法是等价的：</p>\n<pre><code class=\"css\">/*\n * Math.cos(Math.PI / 180 * 45) = 0.707106\n * Math.sin(Math.PI / 180 * 45) = 0.707106\n */\ntransform: matrix(0.707106, 0.707106, -0.707106, 0.707106, 0, 0)\n\n/* 等价于 */\ntransform: rotate(45deg);\n</code></pre>\n<p>通过上面缩放和旋转的例子，我们已经知道了，<code>2 x 2</code> 的矩阵确实能够描述二维空间的变换，这也就是矩阵能够操作空间的原因。在 <code>transform</code> 中，除了缩放(<code>scale</code>)、旋转(<code>rotate</code>) 还有倾斜(<code>skew</code>)，对于倾斜，类似于我们寻找旋转后基向量的坐标一样，你只需要根据倾斜所定义的变换规则，找到基向量变换后的坐标就可以了，实际上倾斜对应如下规则：</p>\n<pre><code class=\"css\">transform: matrix(1, tan(θy), tan(θx), 1, 0, 0);\n</code></pre>\n<p>大家自己拿只笔在纸上画一画应该就能搞清楚倾斜在做什么样子的变换。</p>\n<p>无论 缩放(<code>scale</code>)、旋转(<code>rotate</code>) 还是倾斜(<code>skew</code>)，他们都不会是原点发生改变，所以使用 <code>a b c d</code> 四个数字组成的矩阵完全可以描述，但是不要忘了，我们还有一个 位移(<code>translate</code>)，这时，就不得不提到 <code>e f</code> 了，我想我不说大家也都知道了，<code>e f</code> 分别代表了 <code>x y</code> 方向的位移，事实也如大家所想：</p>\n<pre><code class=\"css\">transform: matrix(1, 0, 0, 1, 100, 200)\n\n/* 等价于 */\ntransform: translateX(100px) translateY(200px);\n</code></pre>\n<p>至此，<code>transform</code> 使用 <code>3 x 3</code> 矩阵：<img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transformmr1.png?imageView/2/w/100\" alt=\"\"> 来描述二维空间变换的方式，以及是如何做到的我们就算讲完了。</p>\n<p>除了2D变换，还有3D变换，在 <code>transform</code> 中，使用 <code>4 x 4</code> 的矩阵描述3D变换，但实际上，三维空间的线性变换只需要一个 <code>3 x 3</code> 的矩阵就可以描述了，那么为什么搞了一个 <code>4 x 4</code>矩阵呢？实际上这和我们在将二维空间的变换使用 <code>3 x 3</code> 矩阵的道理是一样的，那就是位移。</p>\n<p>我们来看一下3D变换的 <code>matrix</code> 默认值：</p>\n<pre><code class=\"css\">transform: matrix(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p);\ntransform: matrix(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n</code></pre>\n<p>这十六个数字就是 <code>4 x 4</code> 矩阵的 16 个数值：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transform3dmr.png?imageView/2/w/200\" alt=\"\"></p>\n<p>如果换成对应数字，是这样的：</p>\n<p><img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transform3d.png?imageView/2/w/200\" alt=\"\"></p>\n<p>类似于我们讲解 2D 变换一样，其中由 <img src=\"http://7xlolm.com1.z0.glb.clouddn.com/transform3d33.png?imageView/2/w/70\" alt=\"\"> 组成的 <code>3 x 3</code> 矩阵用来描述空间的 3D 线性变换，如：<code>rotateX</code> <code>rotateY</code> <code>scaleZ</code> 等等，注意：<code>rotateZ</code> 是 2D 变换哦。</p>\n<p>而 <code>m</code> <code>n</code> <code>o</code> 则分别用来描述位移：<code>translateX</code> <code>translateY</code> <code>translateZ</code>。</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cj669fsjb000aewfcuahcvsdx","category_id":"cj6680ssh0004uffcc1tnqx0v","_id":"cj669fsjk000eewfc3ei5ihb7"},{"post_id":"cj669fsjg000cewfcloqpns9y","category_id":"cj6680ssh0004uffcc1tnqx0v","_id":"cj669fsjm000iewfcrssmd44y"},{"post_id":"cj669fsjk000fewfcsk545e0m","category_id":"cj6680ssh0004uffcc1tnqx0v","_id":"cj669fsjo000pewfczfir7mzj"},{"post_id":"cj669fsjm000jewfcjvvao0u1","category_id":"cj6680ssh0004uffcc1tnqx0v","_id":"cj669fsjs000rewfc1ppvv2ce"},{"post_id":"cj669fsjn000mewfcno4zqmca","category_id":"cj6680ssh0004uffcc1tnqx0v","_id":"cj669fsju000uewfc4n96pnyu"},{"post_id":"cj669fsjo000qewfcilwg9kgk","category_id":"cj6680ssh0004uffcc1tnqx0v","_id":"cj669fsjv000xewfcrec8rkto"},{"post_id":"cj669fsjs000sewfc39bpkfz3","category_id":"cj6680ssh0004uffcc1tnqx0v","_id":"cj669fsjv0010ewfc0z9v2tdf"},{"post_id":"cj669fsjv000yewfch8dqtnk1","category_id":"cj6680ssh0004uffcc1tnqx0v","_id":"cj669fsk00017ewfcptte799i"},{"post_id":"cj669fsjw0012ewfc9g70auhx","category_id":"cj6680ssh0004uffcc1tnqx0v","_id":"cj669fsk3001aewfcpq0cnzdq"},{"post_id":"cj669fsjy0015ewfcap7bbz9x","category_id":"cj6680ssh0004uffcc1tnqx0v","_id":"cj669fsk4001cewfcerzb6fzj"},{"post_id":"cj669fsk00018ewfc864avg3o","category_id":"cj6680ssh0004uffcc1tnqx0v","_id":"cj669fsk8001fewfc01spbvca"},{"post_id":"cj669fsk3001bewfcarq2x2un","category_id":"cj6680ssh0004uffcc1tnqx0v","_id":"cj669fskb001iewfciww911vr"},{"post_id":"cj669fsk4001dewfcznewfwfl","category_id":"cj6680ssh0004uffcc1tnqx0v","_id":"cj669fskd001mewfc6gi0b8lx"},{"post_id":"cj669fsk9001gewfclwd6i6am","category_id":"cj6680ssh0004uffcc1tnqx0v","_id":"cj669fske001pewfcc51d8vzw"},{"post_id":"cj669fskb001jewfcqw6da0a8","category_id":"cj6680ssh0004uffcc1tnqx0v","_id":"cj669fskh001sewfcqqecfu0n"},{"post_id":"cj669fskd001newfct4icfw84","category_id":"cj6680ssh0004uffcc1tnqx0v","_id":"cj669fski001uewfcrovuw5by"},{"post_id":"cj669fskf001qewfc7ody61y6","category_id":"cj6680ssh0004uffcc1tnqx0v","_id":"cj669fskk001xewfcgofgc19x"},{"post_id":"cj669fskh001tewfcvc5imurp","category_id":"cj6680ssh0004uffcc1tnqx0v","_id":"cj669fsks0020ewfc3nf49ab9"},{"post_id":"cj669fskj001vewfc2eldvdp7","category_id":"cj6680ssh0004uffcc1tnqx0v","_id":"cj669fskt0023ewfcewpssae2"},{"post_id":"cj669fskk001yewfcpri173b8","category_id":"cj6680ssh0004uffcc1tnqx0v","_id":"cj669fskt0025ewfc7vzom8fa"}],"PostTag":[{"post_id":"cj669fsjb000aewfcuahcvsdx","tag_id":"cj669fsjl000gewfc7c8mho6u","_id":"cj669fsjv000wewfcsksa9dxm"},{"post_id":"cj669fsjb000aewfcuahcvsdx","tag_id":"cj669fsjo000newfc8wpzrz2q","_id":"cj669fsjv000zewfcz2ld29y5"},{"post_id":"cj669fsjv000yewfch8dqtnk1","tag_id":"cj669fsjt000tewfc2fsl1hoy","_id":"cj669fsjy0013ewfcbff39kqp"},{"post_id":"cj669fsjv000yewfch8dqtnk1","tag_id":"cj669fsi10002ewfc0435ivcc","_id":"cj669fsk00016ewfcq4sjpd33"},{"post_id":"cj669fsjg000cewfcloqpns9y","tag_id":"cj669fsjt000tewfc2fsl1hoy","_id":"cj669fsk9001hewfcjyqjc7el"},{"post_id":"cj669fsjg000cewfcloqpns9y","tag_id":"cj669fsjw0011ewfcgdwa9eh5","_id":"cj669fskc001kewfcx6jamyix"},{"post_id":"cj669fsjg000cewfcloqpns9y","tag_id":"cj669fsk10019ewfchudqcobr","_id":"cj669fske001oewfco4okq3c1"},{"post_id":"cj669fsjk000fewfcsk545e0m","tag_id":"cj669fsjw0011ewfcgdwa9eh5","_id":"cj669fsks001zewfc3etytlab"},{"post_id":"cj669fsjk000fewfcsk545e0m","tag_id":"cj669fsjt000tewfc2fsl1hoy","_id":"cj669fsks0021ewfcnn9iphdr"},{"post_id":"cj669fsjk000fewfcsk545e0m","tag_id":"cj669fsk10019ewfchudqcobr","_id":"cj669fskt0024ewfcer66d5hu"},{"post_id":"cj669fskj001vewfc2eldvdp7","tag_id":"cj6680ssm0005uffcbxpnxbyw","_id":"cj669fsku0026ewfcvj9f8yp9"},{"post_id":"cj669fskj001vewfc2eldvdp7","tag_id":"cj6680ssv0009uffceijabm6y","_id":"cj669fsku0028ewfc8vfbg2mh"},{"post_id":"cj669fsjm000jewfcjvvao0u1","tag_id":"cj669fsjw0011ewfcgdwa9eh5","_id":"cj669fskw002aewfce827e7i7"},{"post_id":"cj669fsjm000jewfcjvvao0u1","tag_id":"cj669fsjt000tewfc2fsl1hoy","_id":"cj669fskw002bewfczhow6dgr"},{"post_id":"cj669fsjm000jewfcjvvao0u1","tag_id":"cj669fsk10019ewfchudqcobr","_id":"cj669fskw002dewfcuq7hlbf3"},{"post_id":"cj669fsjn000mewfcno4zqmca","tag_id":"cj669fsi10002ewfc0435ivcc","_id":"cj669fsky002iewfcylo4jla6"},{"post_id":"cj669fsjn000mewfcno4zqmca","tag_id":"cj669fskv0029ewfccf8hdwr7","_id":"cj669fsky002jewfcmtrocm5a"},{"post_id":"cj669fsjn000mewfcno4zqmca","tag_id":"cj669fskw002cewfc3rppzmbp","_id":"cj669fsl2002lewfco2ivpunb"},{"post_id":"cj669fsjn000mewfcno4zqmca","tag_id":"cj669fskw002eewfcl0jxhm41","_id":"cj669fsl2002mewfcnrlbjx9n"},{"post_id":"cj669fsjn000mewfcno4zqmca","tag_id":"cj669fskw002fewfceqthrdqf","_id":"cj669fsl3002oewfc1357jvpx"},{"post_id":"cj669fsjn000mewfcno4zqmca","tag_id":"cj669fskx002gewfc8pj6tcqt","_id":"cj669fsl3002pewfcstkie7jy"},{"post_id":"cj669fsjo000qewfcilwg9kgk","tag_id":"cj669fsi10002ewfc0435ivcc","_id":"cj669fsl4002tewfcoa4fbtjc"},{"post_id":"cj669fsjo000qewfcilwg9kgk","tag_id":"cj669fskv0029ewfccf8hdwr7","_id":"cj669fsl4002uewfcbt73wjpc"},{"post_id":"cj669fsjo000qewfcilwg9kgk","tag_id":"cj669fskw002cewfc3rppzmbp","_id":"cj669fsl5002wewfcybwnyjf1"},{"post_id":"cj669fsjo000qewfcilwg9kgk","tag_id":"cj669fskw002eewfcl0jxhm41","_id":"cj669fsl5002xewfcnfoy7vs4"},{"post_id":"cj669fsjo000qewfcilwg9kgk","tag_id":"cj669fskw002fewfceqthrdqf","_id":"cj669fsl6002zewfcg6b30fcc"},{"post_id":"cj669fsjo000qewfcilwg9kgk","tag_id":"cj669fskx002gewfc8pj6tcqt","_id":"cj669fsl60030ewfc541f4a6f"},{"post_id":"cj669fsjs000sewfc39bpkfz3","tag_id":"cj669fsl4002sewfcc7tvj5e1","_id":"cj669fsl70032ewfca77jgrgq"},{"post_id":"cj669fsjs000sewfc39bpkfz3","tag_id":"cj669fsl4002vewfctwlwquyn","_id":"cj669fsl70033ewfcziziti0a"},{"post_id":"cj669fsjs000sewfc39bpkfz3","tag_id":"cj669fsl5002yewfcopmav7wi","_id":"cj669fsl70035ewfc73v03ahg"},{"post_id":"cj669fsjw0012ewfc9g70auhx","tag_id":"cj669fsl4002sewfcc7tvj5e1","_id":"cj669fsl9003aewfcxao2s4tk"},{"post_id":"cj669fsjw0012ewfc9g70auhx","tag_id":"cj669fsjo000newfc8wpzrz2q","_id":"cj669fsl9003bewfcku0w1erh"},{"post_id":"cj669fsjy0015ewfcap7bbz9x","tag_id":"cj669fsl80039ewfctwiavzw5","_id":"cj669fsla003eewfcd28k29as"},{"post_id":"cj669fsjy0015ewfcap7bbz9x","tag_id":"cj669fsl9003cewfcdc7lfjoa","_id":"cj669fsla003fewfcf5e3j6rp"},{"post_id":"cj669fsjy0015ewfcap7bbz9x","tag_id":"cj669fsjo000newfc8wpzrz2q","_id":"cj669fslc003hewfcnvd6inu0"},{"post_id":"cj669fsk00018ewfc864avg3o","tag_id":"cj669fsl80039ewfctwiavzw5","_id":"cj669fsld003kewfczitbllb4"},{"post_id":"cj669fsk00018ewfc864avg3o","tag_id":"cj669fsla003gewfcgz7byzsu","_id":"cj669fsld003lewfcslajcupa"},{"post_id":"cj669fsk00018ewfc864avg3o","tag_id":"cj669fslc003iewfcqitzflqk","_id":"cj669fsle003newfcxq2acwko"},{"post_id":"cj669fsk3001bewfcarq2x2un","tag_id":"cj669fskw002cewfc3rppzmbp","_id":"cj669fslf003qewfcgaow8jmr"},{"post_id":"cj669fsk3001bewfcarq2x2un","tag_id":"cj669fsjo000newfc8wpzrz2q","_id":"cj669fslf003rewfco739t6xn"},{"post_id":"cj669fsk3001bewfcarq2x2un","tag_id":"cj669fskv0029ewfccf8hdwr7","_id":"cj669fslf003tewfcf9k7ndpt"},{"post_id":"cj669fsk3001bewfcarq2x2un","tag_id":"cj669fsle003oewfcw8o6qpxc","_id":"cj669fslg003uewfc6qn7xddj"},{"post_id":"cj669fsk4001dewfcznewfwfl","tag_id":"cj669fslf003pewfcza4leeg5","_id":"cj669fslg003xewfclghst2ao"},{"post_id":"cj669fsk4001dewfcznewfwfl","tag_id":"cj669fslf003sewfcbyucbix8","_id":"cj669fslg003yewfcdnndwh0s"},{"post_id":"cj669fsk4001dewfcznewfwfl","tag_id":"cj669fslg003vewfcn5wta0ba","_id":"cj669fslg0040ewfcir0nbo71"},{"post_id":"cj669fsk9001gewfclwd6i6am","tag_id":"cj669fslg003wewfciolek91a","_id":"cj669fslh0042ewfcokqogk7d"},{"post_id":"cj669fsk9001gewfclwd6i6am","tag_id":"cj669fslg003zewfc74e5pebn","_id":"cj669fslh0043ewfcjb101ayp"},{"post_id":"cj669fskb001jewfcqw6da0a8","tag_id":"cj669fsl70034ewfcjl5my05u","_id":"cj669fsli0048ewfc5q9s99o8"},{"post_id":"cj669fskb001jewfcqw6da0a8","tag_id":"cj669fslh0044ewfcsdsg5dw3","_id":"cj669fsli0049ewfc7qvcoiyg"},{"post_id":"cj669fskb001jewfcqw6da0a8","tag_id":"cj669fslh0045ewfctlixwjrh","_id":"cj669fsli004bewfcsjsera9r"},{"post_id":"cj669fskb001jewfcqw6da0a8","tag_id":"cj669fsli0046ewfc27vzuk7i","_id":"cj669fslj004cewfcj4md5lbv"},{"post_id":"cj669fskd001newfct4icfw84","tag_id":"cj669fsl70034ewfcjl5my05u","_id":"cj669fslj004fewfctovulek1"},{"post_id":"cj669fskd001newfct4icfw84","tag_id":"cj669fsli004aewfcxyobd61p","_id":"cj669fslj004gewfcl26kc4m4"},{"post_id":"cj669fskd001newfct4icfw84","tag_id":"cj669fslj004dewfc3o5b54zg","_id":"cj669fslj004iewfck436e2vi"},{"post_id":"cj669fskf001qewfc7ody61y6","tag_id":"cj669fslj004eewfcryhnonti","_id":"cj669fslj004jewfc0wxylu3t"},{"post_id":"cj669fskh001tewfcvc5imurp","tag_id":"cj669fslj004hewfcaex91e6c","_id":"cj669fslk004mewfcluvial37"},{"post_id":"cj669fskh001tewfcvc5imurp","tag_id":"cj669fslk004kewfcn1s7a35g","_id":"cj669fslk004newfcep4hxfk8"},{"post_id":"cj669fskk001yewfcpri173b8","tag_id":"cj669fslk004lewfc6mdqi10u","_id":"cj669fsll004qewfc32o1m4v4"},{"post_id":"cj669fskk001yewfcpri173b8","tag_id":"cj669fslk004oewfcv47hfskw","_id":"cj669fsll004rewfcxv25453n"},{"post_id":"cj669fskk001yewfcpri173b8","tag_id":"cj669fslk004pewfc0x7rxvjv","_id":"cj669fsll004sewfcp0sii8e6"}],"Tag":[{"name":"源码","_id":"cj6680ssm0005uffcbxpnxbyw"},{"name":"Vue","_id":"cj6680ssv0009uffceijabm6y"},{"name":"notes","_id":"cj669fshn0000ewfc83wxpo9q"},{"name":"js","_id":"cj669fsi10002ewfc0435ivcc"},{"name":"php","_id":"cj669fsi10003ewfc121uwhrz"},{"name":"jquery","_id":"cj669fsi10004ewfc46vg7byz"},{"name":"hexo","_id":"cj669fsje000bewfcb7o79t7s"},{"name":"express","_id":"cj669fsjl000gewfc7c8mho6u"},{"name":"nodejs","_id":"cj669fsjo000newfc8wpzrz2q"},{"name":"html","_id":"cj669fsjt000tewfc2fsl1hoy"},{"name":"css","_id":"cj669fsjw0011ewfcgdwa9eh5"},{"name":"移动页面","_id":"cj669fsk10019ewfchudqcobr"},{"name":"自动化","_id":"cj669fskv0029ewfccf8hdwr7"},{"name":"gulp","_id":"cj669fskw002cewfc3rppzmbp"},{"name":"requirejs","_id":"cj669fskw002eewfcl0jxhm41"},{"name":"rjs","_id":"cj669fskw002fewfceqthrdqf"},{"name":"构建","_id":"cj669fskx002gewfc8pj6tcqt"},{"name":"mongodb","_id":"cj669fsl4002sewfcc7tvj5e1"},{"name":"数据库","_id":"cj669fsl4002vewfctwlwquyn"},{"name":"brew","_id":"cj669fsl5002yewfcopmav7wi"},{"name":"kerkee","_id":"cj669fsl60031ewfc9wirhszx"},{"name":"框架","_id":"cj669fsl70034ewfcjl5my05u"},{"name":"Ubuntu","_id":"cj669fsl80039ewfctwiavzw5"},{"name":"git","_id":"cj669fsl9003cewfcdc7lfjoa"},{"name":"python","_id":"cj669fsla003gewfcgz7byzsu"},{"name":"pycurl","_id":"cj669fslc003iewfcqitzflqk"},{"name":"插件","_id":"cj669fsle003oewfcw8o6qpxc"},{"name":"node","_id":"cj669fslf003pewfcza4leeg5"},{"name":"npm","_id":"cj669fslf003sewfcbyucbix8"},{"name":"命令行工具","_id":"cj669fslg003vewfcn5wta0ba"},{"name":"设计模式","_id":"cj669fslg003wewfciolek91a"},{"name":"表单验证","_id":"cj669fslg003zewfc74e5pebn"},{"name":"架构","_id":"cj669fslh0044ewfcsdsg5dw3"},{"name":"vue","_id":"cj669fslh0045ewfctlixwjrh"},{"name":"webpack","_id":"cj669fsli0046ewfc27vzuk7i"},{"name":"MVVM","_id":"cj669fsli004aewfcxyobd61p"},{"name":"observe","_id":"cj669fslj004dewfc3o5b54zg"},{"name":"Worker","_id":"cj669fslj004eewfcryhnonti"},{"name":"debug","_id":"cj669fslj004hewfcaex91e6c"},{"name":"移动调试","_id":"cj669fslk004kewfcn1s7a35g"},{"name":"finger-mover","_id":"cj669fslk004lewfc6mdqi10u"},{"name":"css3","_id":"cj669fslk004oewfcv47hfskw"},{"name":"transform","_id":"cj669fslk004pewfc0x7rxvjv"}]}}